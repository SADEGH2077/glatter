/*
Copyright 2017 Ioannis Makris

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// This file was generated by glatter.py script.



#ifdef GLATTER_GLU
#if defined(__glu_h__)
#if defined(__GLU_H__)
#ifndef gluBeginCurve
#define gluBeginCurve(nobj) glatter_gluBeginCurve((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluBeginCurve, (GLUnurbs *nobj))
#ifndef gluBeginPolygon
#define gluBeginPolygon(tess) glatter_gluBeginPolygon((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluBeginPolygon, (GLUtesselator *tess))
#ifndef gluBeginSurface
#define gluBeginSurface(nobj) glatter_gluBeginSurface((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluBeginSurface, (GLUnurbs *nobj))
#ifndef gluBeginTrim
#define gluBeginTrim(nobj) glatter_gluBeginTrim((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluBeginTrim, (GLUnurbs *nobj))
#ifndef gluBuild1DMipmaps
#define gluBuild1DMipmaps(target, components, width, format, type, data) glatter_gluBuild1DMipmaps((target), (components), (width), (format), (type), (data))
#endif
GLATTER_UBLOCK(int, APIENTRY, gluBuild1DMipmaps, (GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data))
#ifndef gluBuild2DMipmaps
#define gluBuild2DMipmaps(target, components, width, height, format, type, data) glatter_gluBuild2DMipmaps((target), (components), (width), (height), (format), (type), (data))
#endif
GLATTER_UBLOCK(int, APIENTRY, gluBuild2DMipmaps, (GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data))
#ifndef gluCylinder
#define gluCylinder(qobj, baseRadius, topRadius, height, slices, stacks) glatter_gluCylinder((qobj), (baseRadius), (topRadius), (height), (slices), (stacks))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluCylinder, (GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks))
#ifndef gluDeleteNurbsRenderer
#define gluDeleteNurbsRenderer(nobj) glatter_gluDeleteNurbsRenderer((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluDeleteNurbsRenderer, (GLUnurbs *nobj))
#ifndef gluDeleteQuadric
#define gluDeleteQuadric(state) glatter_gluDeleteQuadric((state))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluDeleteQuadric, (GLUquadric *state))
#ifndef gluDeleteTess
#define gluDeleteTess(tess) glatter_gluDeleteTess((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluDeleteTess, (GLUtesselator *tess))
#ifndef gluDisk
#define gluDisk(qobj, innerRadius, outerRadius, slices, loops) glatter_gluDisk((qobj), (innerRadius), (outerRadius), (slices), (loops))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluDisk, (GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops))
#ifndef gluEndCurve
#define gluEndCurve(nobj) glatter_gluEndCurve((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluEndCurve, (GLUnurbs *nobj))
#ifndef gluEndPolygon
#define gluEndPolygon(tess) glatter_gluEndPolygon((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluEndPolygon, (GLUtesselator *tess))
#ifndef gluEndSurface
#define gluEndSurface(nobj) glatter_gluEndSurface((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluEndSurface, (GLUnurbs *nobj))
#ifndef gluEndTrim
#define gluEndTrim(nobj) glatter_gluEndTrim((nobj))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluEndTrim, (GLUnurbs *nobj))
#ifndef gluErrorString
#define gluErrorString(errCode) glatter_gluErrorString((errCode))
#endif
GLATTER_UBLOCK(const GLubyte*, APIENTRY, gluErrorString, (GLenum errCode))
#ifndef gluErrorUnicodeStringEXT
#define gluErrorUnicodeStringEXT(errCode) glatter_gluErrorUnicodeStringEXT((errCode))
#endif
GLATTER_UBLOCK(const wchar_t*, APIENTRY, gluErrorUnicodeStringEXT, (GLenum errCode))
#ifndef gluGetString
#define gluGetString(name) glatter_gluGetString((name))
#endif
GLATTER_UBLOCK(const GLubyte*, APIENTRY, gluGetString, (GLenum name))
#ifndef gluGetTessProperty
#define gluGetTessProperty(tess, which, value) glatter_gluGetTessProperty((tess), (which), (value))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluGetTessProperty, (GLUtesselator *tess, GLenum which, GLdouble *value))
#ifndef gluLookAt
#define gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz) glatter_gluLookAt((eyex), (eyey), (eyez), (centerx), (centery), (centerz), (upx), (upy), (upz))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluLookAt, (GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz))
#ifndef gluNewNurbsRenderer
#define gluNewNurbsRenderer() glatter_gluNewNurbsRenderer()
#endif
GLATTER_UBLOCK(GLUnurbs*, APIENTRY, gluNewNurbsRenderer, (void))
#ifndef gluNewQuadric
#define gluNewQuadric() glatter_gluNewQuadric()
#endif
GLATTER_UBLOCK(GLUquadric*, APIENTRY, gluNewQuadric, (void))
#ifndef gluNewTess
#define gluNewTess() glatter_gluNewTess()
#endif
GLATTER_UBLOCK(GLUtesselator*, APIENTRY, gluNewTess, (void))
#ifndef gluNextContour
#define gluNextContour(tess, type) glatter_gluNextContour((tess), (type))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluNextContour, (GLUtesselator *tess, GLenum type))
#ifndef gluNurbsCurve
#define gluNurbsCurve(nobj, nknots, knot, stride, ctlarray, order, type) glatter_gluNurbsCurve((nobj), (nknots), (knot), (stride), (ctlarray), (order), (type))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluNurbsCurve, (GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type))
#ifndef gluOrtho2D
#define gluOrtho2D(left, right, bottom, top) glatter_gluOrtho2D((left), (right), (bottom), (top))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluOrtho2D, (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top))
#ifndef gluPartialDisk
#define gluPartialDisk(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle) glatter_gluPartialDisk((qobj), (innerRadius), (outerRadius), (slices), (loops), (startAngle), (sweepAngle))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluPartialDisk, (GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle))
#ifndef gluPerspective
#define gluPerspective(fovy, aspect, zNear, zFar) glatter_gluPerspective((fovy), (aspect), (zNear), (zFar))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluPerspective, (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar))
#ifndef gluPickMatrix
#define gluPickMatrix(x, y, width, height, viewport) glatter_gluPickMatrix((x), (y), (width), (height), (viewport))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluPickMatrix, (GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4]))
#ifndef gluProject
#define gluProject(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz) glatter_gluProject((objx), (objy), (objz), (modelMatrix), (projMatrix), (viewport), (winx), (winy), (winz))
#endif
GLATTER_UBLOCK(int, APIENTRY, gluProject, (GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz))
#ifndef gluPwlCurve
#define gluPwlCurve(nobj, count, array, stride, type) glatter_gluPwlCurve((nobj), (count), (array), (stride), (type))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluPwlCurve, (GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type))
#ifndef gluQuadricCallback
#define gluQuadricCallback(qobj, which, fn) glatter_gluQuadricCallback((qobj), (which), (fn))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluQuadricCallback, (GLUquadric *qobj, GLenum which, void (CALLBACK* fn)()))
#ifndef gluQuadricDrawStyle
#define gluQuadricDrawStyle(quadObject, drawStyle) glatter_gluQuadricDrawStyle((quadObject), (drawStyle))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluQuadricDrawStyle, (GLUquadric *quadObject, GLenum drawStyle))
#ifndef gluQuadricNormals
#define gluQuadricNormals(quadObject, normals) glatter_gluQuadricNormals((quadObject), (normals))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluQuadricNormals, (GLUquadric *quadObject, GLenum normals))
#ifndef gluQuadricOrientation
#define gluQuadricOrientation(quadObject, orientation) glatter_gluQuadricOrientation((quadObject), (orientation))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluQuadricOrientation, (GLUquadric *quadObject, GLenum orientation))
#ifndef gluQuadricTexture
#define gluQuadricTexture(quadObject, textureCoords) glatter_gluQuadricTexture((quadObject), (textureCoords))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluQuadricTexture, (GLUquadric *quadObject, GLboolean textureCoords))
#ifndef gluScaleImage
#define gluScaleImage(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout) glatter_gluScaleImage((format), (widthin), (heightin), (typein), (datain), (widthout), (heightout), (typeout), (dataout))
#endif
GLATTER_UBLOCK(int, APIENTRY, gluScaleImage, (GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout))
#ifndef gluSphere
#define gluSphere(qobj, radius, slices, stacks) glatter_gluSphere((qobj), (radius), (slices), (stacks))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluSphere, (GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks))
#ifndef gluTessBeginContour
#define gluTessBeginContour(tess) glatter_gluTessBeginContour((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessBeginContour, (GLUtesselator *tess))
#ifndef gluTessBeginPolygon
#define gluTessBeginPolygon(tess, polygon_data) glatter_gluTessBeginPolygon((tess), (polygon_data))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessBeginPolygon, (GLUtesselator *tess, void *polygon_data))
#ifndef gluTessCallback
#define gluTessCallback(tess, which, fn) glatter_gluTessCallback((tess), (which), (fn))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessCallback, (GLUtesselator *tess, GLenum which, void (CALLBACK *fn)()))
#ifndef gluTessEndContour
#define gluTessEndContour(tess) glatter_gluTessEndContour((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessEndContour, (GLUtesselator *tess))
#ifndef gluTessEndPolygon
#define gluTessEndPolygon(tess) glatter_gluTessEndPolygon((tess))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessEndPolygon, (GLUtesselator *tess))
#ifndef gluTessNormal
#define gluTessNormal(tess, x, y, z) glatter_gluTessNormal((tess), (x), (y), (z))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessNormal, (GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z))
#ifndef gluTessProperty
#define gluTessProperty(tess, which, value) glatter_gluTessProperty((tess), (which), (value))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessProperty, (GLUtesselator *tess, GLenum which, GLdouble value))
#ifndef gluTessVertex
#define gluTessVertex(tess, coords, data) glatter_gluTessVertex((tess), (coords), (data))
#endif
GLATTER_UBLOCK(void, APIENTRY, gluTessVertex, (GLUtesselator *tess, GLdouble coords[3], void *data))
#ifndef gluUnProject
#define gluUnProject(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz) glatter_gluUnProject((winx), (winy), (winz), (modelMatrix), (projMatrix), (viewport), (objx), (objy), (objz))
#endif
GLATTER_UBLOCK(int, APIENTRY, gluUnProject, (GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz))
#endif // defined(__GLU_H__)
#if !defined(__GLU_H__)
#ifndef gluBeginCurve
#define gluBeginCurve(nurb) glatter_gluBeginCurve((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluBeginCurve, (GLUnurbs* nurb))
#ifndef gluBeginPolygon
#define gluBeginPolygon(tess) glatter_gluBeginPolygon((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluBeginPolygon, (GLUtesselator* tess))
#ifndef gluBeginSurface
#define gluBeginSurface(nurb) glatter_gluBeginSurface((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluBeginSurface, (GLUnurbs* nurb))
#ifndef gluBeginTrim
#define gluBeginTrim(nurb) glatter_gluBeginTrim((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluBeginTrim, (GLUnurbs* nurb))
#endif // !defined(__GLU_H__)
#ifndef gluBuild1DMipmapLevels
#define gluBuild1DMipmapLevels(target, internalFormat, width, format, type, level, base, max, data) glatter_gluBuild1DMipmapLevels((target), (internalFormat), (width), (format), (type), (level), (base), (max), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild1DMipmapLevels, (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data))
#if !defined(__GLU_H__)
#ifndef gluBuild1DMipmaps
#define gluBuild1DMipmaps(target, internalFormat, width, format, type, data) glatter_gluBuild1DMipmaps((target), (internalFormat), (width), (format), (type), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild1DMipmaps, (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data))
#endif // !defined(__GLU_H__)
#ifndef gluBuild2DMipmapLevels
#define gluBuild2DMipmapLevels(target, internalFormat, width, height, format, type, level, base, max, data) glatter_gluBuild2DMipmapLevels((target), (internalFormat), (width), (height), (format), (type), (level), (base), (max), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild2DMipmapLevels, (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data))
#if !defined(__GLU_H__)
#ifndef gluBuild2DMipmaps
#define gluBuild2DMipmaps(target, internalFormat, width, height, format, type, data) glatter_gluBuild2DMipmaps((target), (internalFormat), (width), (height), (format), (type), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild2DMipmaps, (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data))
#endif // !defined(__GLU_H__)
#ifndef gluBuild3DMipmapLevels
#define gluBuild3DMipmapLevels(target, internalFormat, width, height, depth, format, type, level, base, max, data) glatter_gluBuild3DMipmapLevels((target), (internalFormat), (width), (height), (depth), (format), (type), (level), (base), (max), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild3DMipmapLevels, (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data))
#ifndef gluBuild3DMipmaps
#define gluBuild3DMipmaps(target, internalFormat, width, height, depth, format, type, data) glatter_gluBuild3DMipmaps((target), (internalFormat), (width), (height), (depth), (format), (type), (data))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluBuild3DMipmaps, (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data))
#ifndef gluCheckExtension
#define gluCheckExtension(extName, extString) glatter_gluCheckExtension((extName), (extString))
#endif
GLATTER_UBLOCK(GLboolean, GLAPIENTRY, gluCheckExtension, (const GLubyte *extName, const GLubyte *extString))
#if !defined(__GLU_H__)
#ifndef gluCylinder
#define gluCylinder(quad, base, top, height, slices, stacks) glatter_gluCylinder((quad), (base), (top), (height), (slices), (stacks))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluCylinder, (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks))
#ifndef gluDeleteNurbsRenderer
#define gluDeleteNurbsRenderer(nurb) glatter_gluDeleteNurbsRenderer((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluDeleteNurbsRenderer, (GLUnurbs* nurb))
#ifndef gluDeleteQuadric
#define gluDeleteQuadric(quad) glatter_gluDeleteQuadric((quad))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluDeleteQuadric, (GLUquadric* quad))
#ifndef gluDeleteTess
#define gluDeleteTess(tess) glatter_gluDeleteTess((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluDeleteTess, (GLUtesselator* tess))
#ifndef gluDisk
#define gluDisk(quad, inner, outer, slices, loops) glatter_gluDisk((quad), (inner), (outer), (slices), (loops))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluDisk, (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops))
#ifndef gluEndCurve
#define gluEndCurve(nurb) glatter_gluEndCurve((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluEndCurve, (GLUnurbs* nurb))
#ifndef gluEndPolygon
#define gluEndPolygon(tess) glatter_gluEndPolygon((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluEndPolygon, (GLUtesselator* tess))
#ifndef gluEndSurface
#define gluEndSurface(nurb) glatter_gluEndSurface((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluEndSurface, (GLUnurbs* nurb))
#ifndef gluEndTrim
#define gluEndTrim(nurb) glatter_gluEndTrim((nurb))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluEndTrim, (GLUnurbs* nurb))
#ifndef gluErrorString
#define gluErrorString(error) glatter_gluErrorString((error))
#endif
GLATTER_UBLOCK(const GLubyte *, GLAPIENTRY, gluErrorString, (GLenum error))
#endif // !defined(__GLU_H__)
#ifndef gluGetNurbsProperty
#define gluGetNurbsProperty(nurb, property, data) glatter_gluGetNurbsProperty((nurb), (property), (data))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluGetNurbsProperty, (GLUnurbs* nurb, GLenum property, GLfloat* data))
#if !defined(__GLU_H__)
#ifndef gluGetString
#define gluGetString(name) glatter_gluGetString((name))
#endif
GLATTER_UBLOCK(const GLubyte *, GLAPIENTRY, gluGetString, (GLenum name))
#ifndef gluGetTessProperty
#define gluGetTessProperty(tess, which, data) glatter_gluGetTessProperty((tess), (which), (data))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluGetTessProperty, (GLUtesselator* tess, GLenum which, GLdouble* data))
#endif // !defined(__GLU_H__)
#ifndef gluLoadSamplingMatrices
#define gluLoadSamplingMatrices(nurb, model, perspective, view) glatter_gluLoadSamplingMatrices((nurb), (model), (perspective), (view))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluLoadSamplingMatrices, (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view))
#if !defined(__GLU_H__)
#ifndef gluLookAt
#define gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) glatter_gluLookAt((eyeX), (eyeY), (eyeZ), (centerX), (centerY), (centerZ), (upX), (upY), (upZ))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluLookAt, (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ))
#ifndef gluNewNurbsRenderer
#define gluNewNurbsRenderer() glatter_gluNewNurbsRenderer()
#endif
GLATTER_UBLOCK(GLUnurbs*, GLAPIENTRY, gluNewNurbsRenderer, (void))
#ifndef gluNewQuadric
#define gluNewQuadric() glatter_gluNewQuadric()
#endif
GLATTER_UBLOCK(GLUquadric*, GLAPIENTRY, gluNewQuadric, (void))
#ifndef gluNewTess
#define gluNewTess() glatter_gluNewTess()
#endif
GLATTER_UBLOCK(GLUtesselator*, GLAPIENTRY, gluNewTess, (void))
#ifndef gluNextContour
#define gluNextContour(tess, type) glatter_gluNextContour((tess), (type))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNextContour, (GLUtesselator* tess, GLenum type))
#endif // !defined(__GLU_H__)
#ifndef gluNurbsCallback
#define gluNurbsCallback(nurb, which, CallBackFunc) glatter_gluNurbsCallback((nurb), (which), (CallBackFunc))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsCallback, (GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc))
#ifndef gluNurbsCallbackData
#define gluNurbsCallbackData(nurb, userData) glatter_gluNurbsCallbackData((nurb), (userData))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsCallbackData, (GLUnurbs* nurb, GLvoid* userData))
#ifndef gluNurbsCallbackDataEXT
#define gluNurbsCallbackDataEXT(nurb, userData) glatter_gluNurbsCallbackDataEXT((nurb), (userData))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsCallbackDataEXT, (GLUnurbs* nurb, GLvoid* userData))
#if !defined(__GLU_H__)
#ifndef gluNurbsCurve
#define gluNurbsCurve(nurb, knotCount, knots, stride, control, order, type) glatter_gluNurbsCurve((nurb), (knotCount), (knots), (stride), (control), (order), (type))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsCurve, (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type))
#endif // !defined(__GLU_H__)
#ifndef gluNurbsProperty
#define gluNurbsProperty(nurb, property, value) glatter_gluNurbsProperty((nurb), (property), (value))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsProperty, (GLUnurbs* nurb, GLenum property, GLfloat value))
#ifndef gluNurbsSurface
#define gluNurbsSurface(nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride, control, sOrder, tOrder, type) glatter_gluNurbsSurface((nurb), (sKnotCount), (sKnots), (tKnotCount), (tKnots), (sStride), (tStride), (control), (sOrder), (tOrder), (type))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluNurbsSurface, (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type))
#if !defined(__GLU_H__)
#ifndef gluOrtho2D
#define gluOrtho2D(left, right, bottom, top) glatter_gluOrtho2D((left), (right), (bottom), (top))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluOrtho2D, (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top))
#ifndef gluPartialDisk
#define gluPartialDisk(quad, inner, outer, slices, loops, start, sweep) glatter_gluPartialDisk((quad), (inner), (outer), (slices), (loops), (start), (sweep))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluPartialDisk, (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep))
#ifndef gluPerspective
#define gluPerspective(fovy, aspect, zNear, zFar) glatter_gluPerspective((fovy), (aspect), (zNear), (zFar))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluPerspective, (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar))
#ifndef gluPickMatrix
#define gluPickMatrix(x, y, delX, delY, viewport) glatter_gluPickMatrix((x), (y), (delX), (delY), (viewport))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluPickMatrix, (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport))
#ifndef gluProject
#define gluProject(objX, objY, objZ, model, proj, view, winX, winY, winZ) glatter_gluProject((objX), (objY), (objZ), (model), (proj), (view), (winX), (winY), (winZ))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluProject, (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ))
#ifndef gluPwlCurve
#define gluPwlCurve(nurb, count, data, stride, type) glatter_gluPwlCurve((nurb), (count), (data), (stride), (type))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluPwlCurve, (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type))
#ifndef gluQuadricCallback
#define gluQuadricCallback(quad, which, CallBackFunc) glatter_gluQuadricCallback((quad), (which), (CallBackFunc))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluQuadricCallback, (GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc))
#ifndef gluQuadricDrawStyle
#define gluQuadricDrawStyle(quad, draw) glatter_gluQuadricDrawStyle((quad), (draw))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluQuadricDrawStyle, (GLUquadric* quad, GLenum draw))
#ifndef gluQuadricNormals
#define gluQuadricNormals(quad, normal) glatter_gluQuadricNormals((quad), (normal))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluQuadricNormals, (GLUquadric* quad, GLenum normal))
#ifndef gluQuadricOrientation
#define gluQuadricOrientation(quad, orientation) glatter_gluQuadricOrientation((quad), (orientation))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluQuadricOrientation, (GLUquadric* quad, GLenum orientation))
#ifndef gluQuadricTexture
#define gluQuadricTexture(quad, texture) glatter_gluQuadricTexture((quad), (texture))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluQuadricTexture, (GLUquadric* quad, GLboolean texture))
#ifndef gluScaleImage
#define gluScaleImage(format, wIn, hIn, typeIn, dataIn, wOut, hOut, typeOut, dataOut) glatter_gluScaleImage((format), (wIn), (hIn), (typeIn), (dataIn), (wOut), (hOut), (typeOut), (dataOut))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluScaleImage, (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut))
#ifndef gluSphere
#define gluSphere(quad, radius, slices, stacks) glatter_gluSphere((quad), (radius), (slices), (stacks))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluSphere, (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks))
#ifndef gluTessBeginContour
#define gluTessBeginContour(tess) glatter_gluTessBeginContour((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessBeginContour, (GLUtesselator* tess))
#ifndef gluTessBeginPolygon
#define gluTessBeginPolygon(tess, data) glatter_gluTessBeginPolygon((tess), (data))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessBeginPolygon, (GLUtesselator* tess, GLvoid* data))
#ifndef gluTessCallback
#define gluTessCallback(tess, which, CallBackFunc) glatter_gluTessCallback((tess), (which), (CallBackFunc))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessCallback, (GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc))
#ifndef gluTessEndContour
#define gluTessEndContour(tess) glatter_gluTessEndContour((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessEndContour, (GLUtesselator* tess))
#ifndef gluTessEndPolygon
#define gluTessEndPolygon(tess) glatter_gluTessEndPolygon((tess))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessEndPolygon, (GLUtesselator* tess))
#ifndef gluTessNormal
#define gluTessNormal(tess, valueX, valueY, valueZ) glatter_gluTessNormal((tess), (valueX), (valueY), (valueZ))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessNormal, (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ))
#ifndef gluTessProperty
#define gluTessProperty(tess, which, data) glatter_gluTessProperty((tess), (which), (data))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessProperty, (GLUtesselator* tess, GLenum which, GLdouble data))
#ifndef gluTessVertex
#define gluTessVertex(tess, location, data) glatter_gluTessVertex((tess), (location), (data))
#endif
GLATTER_UBLOCK(void, GLAPIENTRY, gluTessVertex, (GLUtesselator* tess, GLdouble *location, GLvoid* data))
#ifndef gluUnProject
#define gluUnProject(winX, winY, winZ, model, proj, view, objX, objY, objZ) glatter_gluUnProject((winX), (winY), (winZ), (model), (proj), (view), (objX), (objY), (objZ))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluUnProject, (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ))
#endif // !defined(__GLU_H__)
#ifndef gluUnProject4
#define gluUnProject4(winX, winY, winZ, clipW, model, proj, view, nearVal, farVal, objX, objY, objZ, objW) glatter_gluUnProject4((winX), (winY), (winZ), (clipW), (model), (proj), (view), (nearVal), (farVal), (objX), (objY), (objZ), (objW))
#endif
GLATTER_UBLOCK(GLint, GLAPIENTRY, gluUnProject4, (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW))
#endif // defined(__glu_h__)
#endif // GLATTER_GLU

