Glatter
=======

Overview
--------

Glatter is an OpenGL loading library, with support for GL, GLES, GLU, EGL, GLX, WGL.
In addition to extension loading, it facilitates logging and error checking.


Usage
-----

Glatter requires that the main header ``glatter.h`` is included, wherever its functionality is meant to be used.
As ``glatter.h`` pulls its own API headers, the system's API headers should not be included at all.

In C++ code, glatter may be used as a header-only library, by specifying ``GLATTER_HEADER_ONLY`` in ``glatter_config.h``.
Alternatively, src/glatter.c may be compiled into the project.

There are two Glatter headers used for configuration:

- ``glatter_config.h``:
  It contains a set of macro declarations, that mostly enable or disable parts of the library or functionality.
- ``glatter_platform_headers.h``: 
  This is where OpenGL platforms are defined and their corresponding headers included. Changing this file will require that the headers are re-generated, by running glatter.py.

Glatter does not require explicit loading or initialization calls, and its startup cost is minimal.


Checking for extensions
-----------------------

Support for extensions in the current context can be queried as follows:

  .. code-block:: c

        if (glatter_GL_ARB_framebuffer_object) {
            // do stuff...
        }

The first extension support query in the program, triggers an initialization call, with negligible overhead.
As extension strings are pre-hashed during header generation, its complexity is O(n), where n is the length of the extension strings. There are no string comparisons involved.


Tracing calls, checking errors
------------------------------

Although there are the extensions ``ARB_debug_output`` and ``KHR_debug``, which serve a similar purpose, at least with regards to error checking, the asynchronous nature of OpenGL, makes their usage less convenient. The main issue with these extensions is that, depending on the implementation, the errors may only show when the OpenGL server reaches the erroneous calls in the command buffer, without providing a clear indication of where the problem in the source code really is.

Glatter performs this task by wrapping all library calls inside debug versions of each call.
There are two modes of debug operation, which can be switched on and off independently:

1. Logging (tracing) every OpenGL call, which can be enabled by defining ``GLATTER_LOG_CALLS`` in the configuration header
2. Logging only the errors produced by API calls, which may be enabled by defining ``GLATTER_LOG_ERRORS``. This is enabled by default, when ``NDEBUG`` is not defined.

Traces of calls with GLenum arguments, are shown with their arguments converted to readable strings.

Here is a pseudo-example, of legacy OpenGL code drawing something, traced with ``GLATTER_LOG_CALLS``:

  .. code-block:: c

	GLboolean r = glIsEnabled(GL_COLOR_MATERIAL);
	glBegin(GL_QUAD_STRIP);
	// ...
	glEnd();

For the above, Glatter could produce:

  .. code::

	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: glIsEnabled(GL_COLOR_MATERIAL)
	GLATTER: returned 0
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(134):
	GLATTER: glBegin(GL_QUAD_STRIP)
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(145):
	GLATTER: glEnd()

Let's now introduce an error, by passing an invalid enumerator in the glIsEnabled call:

  .. code-block:: c

	GLboolean r = glIsEnabled(GL_FRAMEBUFFER_RENDERABLE);


In this case, Glatter could produce:

  .. code::

	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: glIsEnabled(GL_FRAMEBUFFER_RENDERABLE)
	GLATTER: returned 0
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: OpenGL call produced GL_INVALID_ENUM error.


Header generation
-----------------

Glatter's headers work supplementary to the API headers they operate on. They are generated by a python script, which directly parses the API's headers, to produce its own.
A standard set of pre-generated headers is supplied, which can be used on a fairly broad set of platforms.
If needed, new custom headers for additional platforms can be generated by the python script (``include/glatter/glatter.py``).
To do this, the API's headers must placed under ``include/glatter/headers``, and the corresponding platform header set should be defined in ``glatter_platform_headers.h``.
Then the script should only be invoked, and its generated output headers will be written under ``include/glatter/platforms``
	
	
License
-------
The source code of the library is licensed under the Simplified BSD License.
