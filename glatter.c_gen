/*
Copyright 2017 Ioannis Makris

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// This file was generated by glatter.py script.



const char* enum_to_string_GL(GLenum e)
{
    switch (e) {
#if defined(__gl_h_)
        case 0x100: return "GL_ACCUM";
        case 0x101: return "GL_LOAD";
        case 0x102: return "GL_RETURN";
        case 0x103: return "GL_MULT";
        case 0x104: return "GL_ADD";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x200: return "GL_NEVER";
        case 0x201: return "GL_LESS";
        case 0x202: return "GL_EQUAL";
        case 0x203: return "GL_LEQUAL";
        case 0x204: return "GL_GREATER";
        case 0x205: return "GL_NOTEQUAL";
        case 0x206: return "GL_GEQUAL";
        case 0x207: return "GL_ALWAYS";
        case 0x300: return "GL_SRC_COLOR";
        case 0x301: return "GL_ONE_MINUS_SRC_COLOR";
        case 0x302: return "GL_SRC_ALPHA";
        case 0x303: return "GL_ONE_MINUS_SRC_ALPHA";
        case 0x304: return "GL_DST_ALPHA";
        case 0x305: return "GL_ONE_MINUS_DST_ALPHA";
        case 0x306: return "GL_DST_COLOR";
        case 0x307: return "GL_ONE_MINUS_DST_COLOR";
#endif
        case 0x308:
#if defined(GL_VERSION_1_0) || defined(__gl_h_) || defined(GL_ES_VERSION_2_0)
                     return "GL_SRC_ALPHA_SATURATE";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_SRC_ALPHA_SATURATE_EXT";
#endif
            break;
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x400: return "GL_FRONT_LEFT";
        case 0x401: return "GL_FRONT_RIGHT";
        case 0x402: return "GL_BACK_LEFT";
        case 0x403: return "GL_BACK_RIGHT";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x404: return "GL_FRONT";
        case 0x405: return "GL_BACK";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x406: return "GL_LEFT";
        case 0x407: return "GL_RIGHT";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x408: return "GL_FRONT_AND_BACK";
#endif
#if defined(__gl_h_)
        case 0x409: return "GL_AUX0";
        case 0x40a: return "GL_AUX1";
        case 0x40b: return "GL_AUX2";
        case 0x40c: return "GL_AUX3";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x500: return "GL_INVALID_ENUM";
        case 0x501: return "GL_INVALID_VALUE";
        case 0x502: return "GL_INVALID_OPERATION";
#endif
        case 0x503:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_STACK_OVERFLOW";
#endif
#if defined(GL_KHR_debug)
                     return "GL_STACK_OVERFLOW_KHR";
#endif
            break;
        case 0x504:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_STACK_UNDERFLOW";
#endif
#if defined(GL_KHR_debug)
                     return "GL_STACK_UNDERFLOW_KHR";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x505: return "GL_OUT_OF_MEMORY";
#endif
        case 0x506:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_INVALID_FRAMEBUFFER_OPERATION";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_INVALID_FRAMEBUFFER_OPERATION_EXT";
#endif
            break;
        case 0x507:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_CONTEXT_LOST";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_CONTEXT_LOST_KHR";
#endif
            break;
#if defined(__gl_h_)
        case 0x600: return "GL_2D";
        case 0x601: return "GL_3D";
        case 0x602: return "GL_3D_COLOR";
        case 0x603: return "GL_3D_COLOR_TEXTURE";
        case 0x604: return "GL_4D_COLOR_TEXTURE";
        case 0x700: return "GL_PASS_THROUGH_TOKEN";
        case 0x701: return "GL_POINT_TOKEN";
        case 0x702: return "GL_LINE_TOKEN";
        case 0x703: return "GL_POLYGON_TOKEN";
        case 0x704: return "GL_BITMAP_TOKEN";
        case 0x705: return "GL_DRAW_PIXEL_TOKEN";
        case 0x706: return "GL_COPY_PIXEL_TOKEN";
        case 0x707: return "GL_LINE_RESET_TOKEN";
        case 0x800: return "GL_EXP";
        case 0x801: return "GL_EXP2";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x900: return "GL_CW";
        case 0x901: return "GL_CCW";
#endif
#if defined(__gl_h_)
        case 0xa00: return "GL_COEFF";
        case 0xa01: return "GL_ORDER";
        case 0xa02: return "GL_DOMAIN";
        case 0xb00: return "GL_CURRENT_COLOR";
        case 0xb01: return "GL_CURRENT_INDEX";
        case 0xb02: return "GL_CURRENT_NORMAL";
        case 0xb03: return "GL_CURRENT_TEXTURE_COORDS";
        case 0xb04: return "GL_CURRENT_RASTER_COLOR";
        case 0xb05: return "GL_CURRENT_RASTER_INDEX";
        case 0xb06: return "GL_CURRENT_RASTER_TEXTURE_COORDS";
        case 0xb07: return "GL_CURRENT_RASTER_POSITION";
        case 0xb08: return "GL_CURRENT_RASTER_POSITION_VALID";
        case 0xb09: return "GL_CURRENT_RASTER_DISTANCE";
        case 0xb10: return "GL_POINT_SMOOTH";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb11: return "GL_POINT_SIZE";
#endif
        case 0xb12:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_POINT_SIZE_RANGE";
#endif
#if defined(GL_VERSION_1_2)
                     return "GL_SMOOTH_POINT_SIZE_RANGE";
#endif
            break;
        case 0xb13:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_POINT_SIZE_GRANULARITY";
#endif
#if defined(GL_VERSION_1_2)
                     return "GL_SMOOTH_POINT_SIZE_GRANULARITY";
#endif
            break;
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb20: return "GL_LINE_SMOOTH";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb21: return "GL_LINE_WIDTH";
#endif
        case 0xb22:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_LINE_WIDTH_RANGE";
#endif
#if defined(GL_VERSION_1_2)
                     return "GL_SMOOTH_LINE_WIDTH_RANGE";
#endif
            break;
        case 0xb23:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_LINE_WIDTH_GRANULARITY";
#endif
#if defined(GL_VERSION_1_2)
                     return "GL_SMOOTH_LINE_WIDTH_GRANULARITY";
#endif
            break;
#if defined(__gl_h_)
        case 0xb24: return "GL_LINE_STIPPLE";
        case 0xb25: return "GL_LINE_STIPPLE_PATTERN";
        case 0xb26: return "GL_LINE_STIPPLE_REPEAT";
        case 0xb30: return "GL_LIST_MODE";
        case 0xb31: return "GL_MAX_LIST_NESTING";
        case 0xb32: return "GL_LIST_BASE";
        case 0xb33: return "GL_LIST_INDEX";
#endif
        case 0xb40:
#if defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_POLYGON_MODE";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_POLYGON_MODE_NV";
#endif
            break;
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb41: return "GL_POLYGON_SMOOTH";
#endif
#if defined(__gl_h_)
        case 0xb42: return "GL_POLYGON_STIPPLE";
        case 0xb43: return "GL_EDGE_FLAG";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb44: return "GL_CULL_FACE";
        case 0xb45: return "GL_CULL_FACE_MODE";
        case 0xb46: return "GL_FRONT_FACE";
#endif
#if defined(__gl_h_)
        case 0xb50: return "GL_LIGHTING";
        case 0xb51: return "GL_LIGHT_MODEL_LOCAL_VIEWER";
        case 0xb52: return "GL_LIGHT_MODEL_TWO_SIDE";
        case 0xb53: return "GL_LIGHT_MODEL_AMBIENT";
        case 0xb54: return "GL_SHADE_MODEL";
        case 0xb55: return "GL_COLOR_MATERIAL_FACE";
        case 0xb56: return "GL_COLOR_MATERIAL_PARAMETER";
        case 0xb57: return "GL_COLOR_MATERIAL";
        case 0xb60: return "GL_FOG";
        case 0xb61: return "GL_FOG_INDEX";
        case 0xb62: return "GL_FOG_DENSITY";
        case 0xb63: return "GL_FOG_START";
        case 0xb64: return "GL_FOG_END";
        case 0xb65: return "GL_FOG_MODE";
        case 0xb66: return "GL_FOG_COLOR";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb70: return "GL_DEPTH_RANGE";
        case 0xb71: return "GL_DEPTH_TEST";
        case 0xb72: return "GL_DEPTH_WRITEMASK";
        case 0xb73: return "GL_DEPTH_CLEAR_VALUE";
        case 0xb74: return "GL_DEPTH_FUNC";
#endif
#if defined(__gl_h_)
        case 0xb80: return "GL_ACCUM_CLEAR_VALUE";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xb90: return "GL_STENCIL_TEST";
        case 0xb91: return "GL_STENCIL_CLEAR_VALUE";
        case 0xb92: return "GL_STENCIL_FUNC";
        case 0xb93: return "GL_STENCIL_VALUE_MASK";
        case 0xb94: return "GL_STENCIL_FAIL";
        case 0xb95: return "GL_STENCIL_PASS_DEPTH_FAIL";
        case 0xb96: return "GL_STENCIL_PASS_DEPTH_PASS";
        case 0xb97: return "GL_STENCIL_REF";
        case 0xb98: return "GL_STENCIL_WRITEMASK";
#endif
#if defined(__gl_h_)
        case 0xba0: return "GL_MATRIX_MODE";
        case 0xba1: return "GL_NORMALIZE";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xba2: return "GL_VIEWPORT";
#endif
        case 0xba3:
#if defined(GL_EXT_vertex_weighting)
                     return "GL_MODELVIEW0_STACK_DEPTH_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_MODELVIEW_STACK_DEPTH";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_MODELVIEW_STACK_DEPTH_NV";
#endif
            break;
        case 0xba4:
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_PROJECTION_STACK_DEPTH_NV";
#endif
#if defined(__gl_h_)
                     return "GL_PROJECTION_STACK_DEPTH";
#endif
            break;
#if defined(__gl_h_)
        case 0xba5: return "GL_TEXTURE_STACK_DEPTH";
#endif
        case 0xba6:
#if defined(GL_EXT_vertex_weighting)
                     return "GL_MODELVIEW0_MATRIX_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_MODELVIEW_MATRIX";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_MODELVIEW_MATRIX_NV";
#endif
            break;
        case 0xba7:
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_PROJECTION_MATRIX_NV";
#endif
#if defined(__gl_h_)
                     return "GL_PROJECTION_MATRIX";
#endif
            break;
#if defined(__gl_h_)
        case 0xba8: return "GL_TEXTURE_MATRIX";
        case 0xbb0: return "GL_ATTRIB_STACK_DEPTH";
        case 0xbb1: return "GL_CLIENT_ATTRIB_STACK_DEPTH";
#endif
        case 0xbc0:
#if defined(__gl_h_)
                     return "GL_ALPHA_TEST";
#endif
#if defined(GL_QCOM_alpha_test)
                     return "GL_ALPHA_TEST_QCOM";
#endif
            break;
        case 0xbc1:
#if defined(__gl_h_)
                     return "GL_ALPHA_TEST_FUNC";
#endif
#if defined(GL_QCOM_alpha_test)
                     return "GL_ALPHA_TEST_FUNC_QCOM";
#endif
            break;
        case 0xbc2:
#if defined(__gl_h_)
                     return "GL_ALPHA_TEST_REF";
#endif
#if defined(GL_QCOM_alpha_test)
                     return "GL_ALPHA_TEST_REF_QCOM";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xbd0: return "GL_DITHER";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xbe0: return "GL_BLEND_DST";
        case 0xbe1: return "GL_BLEND_SRC";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xbe2: return "GL_BLEND";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xbf0: return "GL_LOGIC_OP_MODE";
#endif
#if defined(__gl_h_)
        case 0xbf1: return "GL_INDEX_LOGIC_OP";
#endif
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
        case 0xbf2: return "GL_COLOR_LOGIC_OP";
#endif
#if defined(__gl_h_)
        case 0xc00: return "GL_AUX_BUFFERS";
#endif
        case 0xc01:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_DRAW_BUFFER";
#endif
#if defined(GL_EXT_multiview_draw_buffers)
                     return "GL_DRAW_BUFFER_EXT";
#endif
            break;
        case 0xc02:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_READ_BUFFER";
#endif
#if defined(GL_EXT_multiview_draw_buffers)
                     return "GL_READ_BUFFER_EXT";
#endif
#if defined(GL_NV_read_buffer)
                     return "GL_READ_BUFFER_NV";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xc10: return "GL_SCISSOR_BOX";
        case 0xc11: return "GL_SCISSOR_TEST";
#endif
#if defined(__gl_h_)
        case 0xc20: return "GL_INDEX_CLEAR_VALUE";
        case 0xc21: return "GL_INDEX_WRITEMASK";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xc22: return "GL_COLOR_CLEAR_VALUE";
        case 0xc23: return "GL_COLOR_WRITEMASK";
#endif
#if defined(__gl_h_)
        case 0xc30: return "GL_INDEX_MODE";
        case 0xc31: return "GL_RGBA_MODE";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xc32: return "GL_DOUBLEBUFFER";
        case 0xc33: return "GL_STEREO";
#endif
#if defined(__gl_h_)
        case 0xc40: return "GL_RENDER_MODE";
        case 0xc50: return "GL_PERSPECTIVE_CORRECTION_HINT";
        case 0xc51: return "GL_POINT_SMOOTH_HINT";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xc52: return "GL_LINE_SMOOTH_HINT";
        case 0xc53: return "GL_POLYGON_SMOOTH_HINT";
#endif
#if defined(__gl_h_)
        case 0xc54: return "GL_FOG_HINT";
        case 0xc60: return "GL_TEXTURE_GEN_S";
        case 0xc61: return "GL_TEXTURE_GEN_T";
        case 0xc62: return "GL_TEXTURE_GEN_R";
        case 0xc63: return "GL_TEXTURE_GEN_Q";
        case 0xc70: return "GL_PIXEL_MAP_I_TO_I";
        case 0xc71: return "GL_PIXEL_MAP_S_TO_S";
        case 0xc72: return "GL_PIXEL_MAP_I_TO_R";
        case 0xc73: return "GL_PIXEL_MAP_I_TO_G";
        case 0xc74: return "GL_PIXEL_MAP_I_TO_B";
        case 0xc75: return "GL_PIXEL_MAP_I_TO_A";
        case 0xc76: return "GL_PIXEL_MAP_R_TO_R";
        case 0xc77: return "GL_PIXEL_MAP_G_TO_G";
        case 0xc78: return "GL_PIXEL_MAP_B_TO_B";
        case 0xc79: return "GL_PIXEL_MAP_A_TO_A";
        case 0xcb0: return "GL_PIXEL_MAP_I_TO_I_SIZE";
        case 0xcb1: return "GL_PIXEL_MAP_S_TO_S_SIZE";
        case 0xcb2: return "GL_PIXEL_MAP_I_TO_R_SIZE";
        case 0xcb3: return "GL_PIXEL_MAP_I_TO_G_SIZE";
        case 0xcb4: return "GL_PIXEL_MAP_I_TO_B_SIZE";
        case 0xcb5: return "GL_PIXEL_MAP_I_TO_A_SIZE";
        case 0xcb6: return "GL_PIXEL_MAP_R_TO_R_SIZE";
        case 0xcb7: return "GL_PIXEL_MAP_G_TO_G_SIZE";
        case 0xcb8: return "GL_PIXEL_MAP_B_TO_B_SIZE";
        case 0xcb9: return "GL_PIXEL_MAP_A_TO_A_SIZE";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xcf0: return "GL_UNPACK_SWAP_BYTES";
        case 0xcf1: return "GL_UNPACK_LSB_FIRST";
#endif
        case 0xcf2:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_UNPACK_ROW_LENGTH";
#endif
#if defined(GL_EXT_unpack_subimage)
                     return "GL_UNPACK_ROW_LENGTH_EXT";
#endif
            break;
        case 0xcf3:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_UNPACK_SKIP_ROWS";
#endif
#if defined(GL_EXT_unpack_subimage)
                     return "GL_UNPACK_SKIP_ROWS_EXT";
#endif
            break;
        case 0xcf4:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_UNPACK_SKIP_PIXELS";
#endif
#if defined(GL_EXT_unpack_subimage)
                     return "GL_UNPACK_SKIP_PIXELS_EXT";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xcf5: return "GL_UNPACK_ALIGNMENT";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xd00: return "GL_PACK_SWAP_BYTES";
        case 0xd01: return "GL_PACK_LSB_FIRST";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
        case 0xd02: return "GL_PACK_ROW_LENGTH";
        case 0xd03: return "GL_PACK_SKIP_ROWS";
        case 0xd04: return "GL_PACK_SKIP_PIXELS";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xd05: return "GL_PACK_ALIGNMENT";
#endif
#if defined(__gl_h_)
        case 0xd10: return "GL_MAP_COLOR";
        case 0xd11: return "GL_MAP_STENCIL";
        case 0xd12: return "GL_INDEX_SHIFT";
        case 0xd13: return "GL_INDEX_OFFSET";
        case 0xd14: return "GL_RED_SCALE";
        case 0xd15: return "GL_RED_BIAS";
        case 0xd16: return "GL_ZOOM_X";
        case 0xd17: return "GL_ZOOM_Y";
        case 0xd18: return "GL_GREEN_SCALE";
        case 0xd19: return "GL_GREEN_BIAS";
        case 0xd1a: return "GL_BLUE_SCALE";
        case 0xd1b: return "GL_BLUE_BIAS";
        case 0xd1c: return "GL_ALPHA_SCALE";
        case 0xd1d: return "GL_ALPHA_BIAS";
        case 0xd1e: return "GL_DEPTH_SCALE";
        case 0xd1f: return "GL_DEPTH_BIAS";
        case 0xd30: return "GL_MAX_EVAL_ORDER";
        case 0xd31: return "GL_MAX_LIGHTS";
#endif
        case 0xd32:
#if defined(GL_VERSION_3_0)
                     return "GL_MAX_CLIP_DISTANCES";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_MAX_CLIP_DISTANCES_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_MAX_CLIP_DISTANCES_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_MAX_CLIP_PLANES";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xd33: return "GL_MAX_TEXTURE_SIZE";
#endif
#if defined(__gl_h_)
        case 0xd34: return "GL_MAX_PIXEL_MAP_TABLE";
        case 0xd35: return "GL_MAX_ATTRIB_STACK_DEPTH";
#endif
        case 0xd36:
#if defined(__gl_h_)
                     return "GL_MAX_MODELVIEW_STACK_DEPTH";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV";
#endif
            break;
#if defined(__gl_h_)
        case 0xd37: return "GL_MAX_NAME_STACK_DEPTH";
#endif
        case 0xd38:
#if defined(__gl_h_)
                     return "GL_MAX_PROJECTION_STACK_DEPTH";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV";
#endif
            break;
#if defined(__gl_h_)
        case 0xd39: return "GL_MAX_TEXTURE_STACK_DEPTH";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xd3a: return "GL_MAX_VIEWPORT_DIMS";
#endif
#if defined(__gl_h_)
        case 0xd3b: return "GL_MAX_CLIENT_ATTRIB_STACK_DEPTH";
        case 0xd70: return "GL_NAME_STACK_DEPTH";
        case 0xd80: return "GL_AUTO_NORMAL";
        case 0xd90: return "GL_MAP1_COLOR_4";
        case 0xd91: return "GL_MAP1_INDEX";
        case 0xd92: return "GL_MAP1_NORMAL";
        case 0xd93: return "GL_MAP1_TEXTURE_COORD_1";
        case 0xd94: return "GL_MAP1_TEXTURE_COORD_2";
        case 0xd95: return "GL_MAP1_TEXTURE_COORD_3";
        case 0xd96: return "GL_MAP1_TEXTURE_COORD_4";
        case 0xd97: return "GL_MAP1_VERTEX_3";
        case 0xd98: return "GL_MAP1_VERTEX_4";
        case 0xdb0: return "GL_MAP2_COLOR_4";
        case 0xdb1: return "GL_MAP2_INDEX";
        case 0xdb2: return "GL_MAP2_NORMAL";
        case 0xdb3: return "GL_MAP2_TEXTURE_COORD_1";
        case 0xdb4: return "GL_MAP2_TEXTURE_COORD_2";
        case 0xdb5: return "GL_MAP2_TEXTURE_COORD_3";
        case 0xdb6: return "GL_MAP2_TEXTURE_COORD_4";
        case 0xdb7: return "GL_MAP2_VERTEX_3";
        case 0xdb8: return "GL_MAP2_VERTEX_4";
        case 0xdd0: return "GL_MAP1_GRID_DOMAIN";
        case 0xdd1: return "GL_MAP1_GRID_SEGMENTS";
        case 0xdd2: return "GL_MAP2_GRID_DOMAIN";
        case 0xdd3: return "GL_MAP2_GRID_SEGMENTS";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xde0: return "GL_TEXTURE_1D";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0xde1: return "GL_TEXTURE_2D";
#endif
#if defined(__gl_h_)
        case 0xdf0: return "GL_FEEDBACK_BUFFER_POINTER";
        case 0xdf1: return "GL_FEEDBACK_BUFFER_SIZE";
        case 0xdf2: return "GL_FEEDBACK_BUFFER_TYPE";
        case 0xdf3: return "GL_SELECTION_BUFFER_POINTER";
        case 0xdf4: return "GL_SELECTION_BUFFER_SIZE";
#endif
#if defined(GL_ES_VERSION_3_1) || defined(__gl_h_) || defined(GL_VERSION_1_0)
        case 0x1000: return "GL_TEXTURE_WIDTH";
        case 0x1001: return "GL_TEXTURE_HEIGHT";
#endif
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_1) || defined(__gl_h_)
        case 0x1003: return "GL_TEXTURE_INTERNAL_FORMAT";
#endif
        case 0x1004:
#if defined(GL_VERSION_1_0) || defined(__gl_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BORDER_COLOR";
#endif
#if defined(GL_EXT_texture_border_clamp)
                     return "GL_TEXTURE_BORDER_COLOR_EXT";
#endif
#if defined(GL_NV_texture_border_clamp)
                     return "GL_TEXTURE_BORDER_COLOR_NV";
#endif
#if defined(GL_OES_texture_border_clamp)
                     return "GL_TEXTURE_BORDER_COLOR_OES";
#endif
            break;
#if defined(__gl_h_)
        case 0x1005: return "GL_TEXTURE_BORDER";
#endif
#if defined(GL_VERSION_4_5)
        case 0x1006: return "GL_TEXTURE_TARGET";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1100: return "GL_DONT_CARE";
        case 0x1101: return "GL_FASTEST";
        case 0x1102: return "GL_NICEST";
#endif
#if defined(__gl_h_)
        case 0x1200: return "GL_AMBIENT";
        case 0x1201: return "GL_DIFFUSE";
        case 0x1202: return "GL_SPECULAR";
        case 0x1203: return "GL_POSITION";
        case 0x1204: return "GL_SPOT_DIRECTION";
        case 0x1205: return "GL_SPOT_EXPONENT";
        case 0x1206: return "GL_SPOT_CUTOFF";
        case 0x1207: return "GL_CONSTANT_ATTENUATION";
        case 0x1208: return "GL_LINEAR_ATTENUATION";
        case 0x1209: return "GL_QUADRATIC_ATTENUATION";
        case 0x1300: return "GL_COMPILE";
        case 0x1301: return "GL_COMPILE_AND_EXECUTE";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1400: return "GL_BYTE";
        case 0x1401: return "GL_UNSIGNED_BYTE";
        case 0x1402: return "GL_SHORT";
        case 0x1403: return "GL_UNSIGNED_SHORT";
        case 0x1404: return "GL_INT";
        case 0x1405: return "GL_UNSIGNED_INT";
        case 0x1406: return "GL_FLOAT";
#endif
        case 0x1407:
#if defined(__gl_h_)
                     return "GL_2_BYTES";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_2_BYTES_NV";
#endif
            break;
        case 0x1408:
#if defined(__gl_h_)
                     return "GL_3_BYTES";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_3_BYTES_NV";
#endif
            break;
        case 0x1409:
#if defined(__gl_h_)
                     return "GL_4_BYTES";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_4_BYTES_NV";
#endif
            break;
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
        case 0x140a: return "GL_DOUBLE";
#endif
        case 0x140b:
#if defined(GL_APPLE_float_pixels)
                     return "GL_HALF_APPLE";
#endif
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_HALF_FLOAT";
#endif
#if defined(GL_ARB_half_float_pixel)
                     return "GL_HALF_FLOAT_ARB";
#endif
#if defined(GL_NV_half_float)
                     return "GL_HALF_FLOAT_NV";
#endif
            break;
        case 0x140c:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
                     return "GL_FIXED";
#endif
#if defined(GL_OES_fixed_point)
                     return "GL_FIXED_OES";
#endif
            break;
        case 0x140e:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_INT64_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_INT64_NV";
#endif
            break;
        case 0x140f:
#if defined(GL_ARB_bindless_texture)
                     return "GL_UNSIGNED_INT64_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_UNSIGNED_INT64_NV";
#endif
            break;
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1500: return "GL_CLEAR";
        case 0x1501: return "GL_AND";
        case 0x1502: return "GL_AND_REVERSE";
        case 0x1503: return "GL_COPY";
        case 0x1504: return "GL_AND_INVERTED";
        case 0x1505: return "GL_NOOP";
#endif
        case 0x1506:
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
                     return "GL_XOR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_XOR_NV";
#endif
            break;
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1507: return "GL_OR";
        case 0x1508: return "GL_NOR";
        case 0x1509: return "GL_EQUIV";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x150a: return "GL_INVERT";
#endif
#if defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x150b: return "GL_OR_REVERSE";
        case 0x150c: return "GL_COPY_INVERTED";
        case 0x150d: return "GL_OR_INVERTED";
        case 0x150e: return "GL_NAND";
        case 0x150f: return "GL_SET";
#endif
#if defined(__gl_h_)
        case 0x1600: return "GL_EMISSION";
        case 0x1601: return "GL_SHININESS";
        case 0x1602: return "GL_AMBIENT_AND_DIFFUSE";
        case 0x1603: return "GL_COLOR_INDEXES";
#endif
        case 0x1700:
#if defined(__gl_h_)
                     return "GL_MODELVIEW";
#endif
#if defined(GL_ARB_vertex_blend)
                     return "GL_MODELVIEW0_ARB";
#endif
#if defined(GL_EXT_vertex_weighting)
                     return "GL_MODELVIEW0_EXT";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_MODELVIEW_NV";
#endif
            break;
        case 0x1701:
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_PROJECTION_NV";
#endif
#if defined(__gl_h_)
                     return "GL_PROJECTION";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1702: return "GL_TEXTURE";
#endif
        case 0x1800:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_COLOR";
#endif
#if defined(GL_EXT_discard_framebuffer)
                     return "GL_COLOR_EXT";
#endif
            break;
        case 0x1801:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_DEPTH";
#endif
#if defined(GL_EXT_discard_framebuffer)
                     return "GL_DEPTH_EXT";
#endif
            break;
        case 0x1802:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_STENCIL";
#endif
#if defined(GL_EXT_discard_framebuffer)
                     return "GL_STENCIL_EXT";
#endif
            break;
#if defined(__gl_h_)
        case 0x1900: return "GL_COLOR_INDEX";
#endif
        case 0x1901:
#if defined(GL_ES_VERSION_3_1) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_STENCIL_INDEX";
#endif
#if defined(GL_OES_texture_stencil8)
                     return "GL_STENCIL_INDEX_OES";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1902: return "GL_DEPTH_COMPONENT";
#endif
        case 0x1903:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_RED";
#endif
#if defined(GL_EXT_texture_rg)
                     return "GL_RED_EXT";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_RED_NV";
#endif
            break;
        case 0x1904:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_GREEN";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_GREEN_NV";
#endif
            break;
        case 0x1905:
#if defined(GL_ES_VERSION_3_0) || defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_BLUE";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_BLUE_NV";
#endif
            break;
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1906: return "GL_ALPHA";
        case 0x1907: return "GL_RGB";
        case 0x1908: return "GL_RGBA";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
        case 0x1909: return "GL_LUMINANCE";
        case 0x190a: return "GL_LUMINANCE_ALPHA";
#endif
#if defined(__gl_h_)
        case 0x1a00: return "GL_BITMAP";
#endif
        case 0x1b00:
#if defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_POINT";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_POINT_NV";
#endif
            break;
        case 0x1b01:
#if defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_LINE";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_LINE_NV";
#endif
            break;
        case 0x1b02:
#if defined(__gl_h_) || defined(GL_VERSION_1_0)
                     return "GL_FILL";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_FILL_NV";
#endif
            break;
#if defined(__gl_h_)
        case 0x1c00: return "GL_RENDER";
        case 0x1c01: return "GL_FEEDBACK";
        case 0x1c02: return "GL_SELECT";
        case 0x1d00: return "GL_FLAT";
        case 0x1d01: return "GL_SMOOTH";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x1e00: return "GL_KEEP";
        case 0x1e01: return "GL_REPLACE";
        case 0x1e02: return "GL_INCR";
        case 0x1e03: return "GL_DECR";
        case 0x1f00: return "GL_VENDOR";
        case 0x1f01: return "GL_RENDERER";
        case 0x1f02: return "GL_VERSION";
        case 0x1f03: return "GL_EXTENSIONS";
#endif
#if defined(__gl_h_)
        case 0x2000: return "GL_S";
        case 0x2001: return "GL_T";
        case 0x2002: return "GL_R";
        case 0x2003: return "GL_Q";
        case 0x2100: return "GL_MODULATE";
        case 0x2101: return "GL_DECAL";
        case 0x2200: return "GL_TEXTURE_ENV_MODE";
        case 0x2201: return "GL_TEXTURE_ENV_COLOR";
        case 0x2300: return "GL_TEXTURE_ENV";
#endif
        case 0x2400:
#if defined(__gl_h_)
                     return "GL_EYE_LINEAR";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_EYE_LINEAR_NV";
#endif
            break;
        case 0x2401:
#if defined(__gl_h_)
                     return "GL_OBJECT_LINEAR";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_OBJECT_LINEAR_NV";
#endif
            break;
#if defined(__gl_h_)
        case 0x2402: return "GL_SPHERE_MAP";
        case 0x2500: return "GL_TEXTURE_GEN_MODE";
        case 0x2501: return "GL_OBJECT_PLANE";
        case 0x2502: return "GL_EYE_PLANE";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x2600: return "GL_NEAREST";
        case 0x2601: return "GL_LINEAR";
        case 0x2700: return "GL_NEAREST_MIPMAP_NEAREST";
        case 0x2701: return "GL_LINEAR_MIPMAP_NEAREST";
        case 0x2702: return "GL_NEAREST_MIPMAP_LINEAR";
        case 0x2703: return "GL_LINEAR_MIPMAP_LINEAR";
        case 0x2800: return "GL_TEXTURE_MAG_FILTER";
        case 0x2801: return "GL_TEXTURE_MIN_FILTER";
        case 0x2802: return "GL_TEXTURE_WRAP_S";
        case 0x2803: return "GL_TEXTURE_WRAP_T";
#endif
#if defined(__gl_h_)
        case 0x2900: return "GL_CLAMP";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_0) || defined(__gl_h_)
        case 0x2901: return "GL_REPEAT";
#endif
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
        case 0x2a00: return "GL_POLYGON_OFFSET_UNITS";
#endif
        case 0x2a01:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_POLYGON_OFFSET_POINT";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_POLYGON_OFFSET_POINT_NV";
#endif
            break;
        case 0x2a02:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_POLYGON_OFFSET_LINE";
#endif
#if defined(GL_NV_polygon_mode)
                     return "GL_POLYGON_OFFSET_LINE_NV";
#endif
            break;
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
        case 0x2a10: return "GL_R3_G3_B2";
#endif
#if defined(__gl_h_)
        case 0x2a20: return "GL_V2F";
        case 0x2a21: return "GL_V3F";
        case 0x2a22: return "GL_C4UB_V2F";
        case 0x2a23: return "GL_C4UB_V3F";
        case 0x2a24: return "GL_C3F_V3F";
        case 0x2a25: return "GL_N3F_V3F";
        case 0x2a26: return "GL_C4F_N3F_V3F";
        case 0x2a27: return "GL_T2F_V3F";
        case 0x2a28: return "GL_T4F_V4F";
        case 0x2a29: return "GL_T2F_C4UB_V3F";
        case 0x2a2a: return "GL_T2F_C3F_V3F";
        case 0x2a2b: return "GL_T2F_N3F_V3F";
        case 0x2a2c: return "GL_T2F_C4F_N3F_V3F";
        case 0x2a2d: return "GL_T4F_C4F_N3F_V4F";
#endif
        case 0x3000:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE0";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE0_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE0_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE0";
#endif
            break;
        case 0x3001:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE1";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE1_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE1_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE1";
#endif
            break;
        case 0x3002:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE2";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE2_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE2_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE2";
#endif
            break;
        case 0x3003:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE3";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE3_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE3_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE3";
#endif
            break;
        case 0x3004:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE4";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE4_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE4_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE4";
#endif
            break;
        case 0x3005:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE5";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE5_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE5_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_CLIP_PLANE5";
#endif
            break;
        case 0x3006:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE6";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE6_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE6_EXT";
#endif
            break;
        case 0x3007:
#if defined(GL_VERSION_3_0)
                     return "GL_CLIP_DISTANCE7";
#endif
#if defined(GL_APPLE_clip_distance)
                     return "GL_CLIP_DISTANCE7_APPLE";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_CLIP_DISTANCE7_EXT";
#endif
            break;
#if defined(__gl_h_)
        case 0x4000: return "GL_LIGHT0";
        case 0x4001: return "GL_LIGHT1";
        case 0x4002: return "GL_LIGHT2";
        case 0x4003: return "GL_LIGHT3";
        case 0x4004: return "GL_LIGHT4";
        case 0x4005: return "GL_LIGHT5";
        case 0x4006: return "GL_LIGHT6";
        case 0x4007: return "GL_LIGHT7";
#endif
#if defined(GL_EXT_abgr)
        case 0x8000: return "GL_ABGR_EXT";
#endif
        case 0x8001:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_CONSTANT_COLOR";
#endif
#if defined(GL_EXT_blend_color)
                     return "GL_CONSTANT_COLOR_EXT";
#endif
            break;
        case 0x8002:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_ONE_MINUS_CONSTANT_COLOR";
#endif
#if defined(GL_EXT_blend_color)
                     return "GL_ONE_MINUS_CONSTANT_COLOR_EXT";
#endif
            break;
        case 0x8003:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_CONSTANT_ALPHA";
#endif
#if defined(GL_EXT_blend_color)
                     return "GL_CONSTANT_ALPHA_EXT";
#endif
            break;
        case 0x8004:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_ONE_MINUS_CONSTANT_ALPHA";
#endif
#if defined(GL_EXT_blend_color)
                     return "GL_ONE_MINUS_CONSTANT_ALPHA_EXT";
#endif
            break;
        case 0x8005:
#if defined(GL_ARB_imaging) || defined(GL_ES_VERSION_2_0)
                     return "GL_BLEND_COLOR";
#endif
#if defined(GL_EXT_blend_color)
                     return "GL_BLEND_COLOR_EXT";
#endif
            break;
        case 0x8006:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_FUNC_ADD";
#endif
#if defined(GL_EXT_blend_minmax)
                     return "GL_FUNC_ADD_EXT";
#endif
            break;
        case 0x8007:
#if defined(GL_ES_VERSION_3_0) || defined(GL_OES_draw_buffers_indexed) || defined(GL_VERSION_1_4)
                     return "GL_MIN";
#endif
#if defined(GL_EXT_blend_minmax)
                     return "GL_MIN_EXT";
#endif
            break;
        case 0x8008:
#if defined(GL_ES_VERSION_3_0) || defined(GL_OES_draw_buffers_indexed) || defined(GL_VERSION_1_4)
                     return "GL_MAX";
#endif
#if defined(GL_EXT_blend_minmax)
                     return "GL_MAX_EXT";
#endif
            break;
        case 0x8009:
#if defined(GL_ARB_imaging) || defined(GL_ES_VERSION_2_0)
                     return "GL_BLEND_EQUATION";
#endif
#if defined(GL_EXT_blend_minmax)
                     return "GL_BLEND_EQUATION_EXT";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BLEND_EQUATION_RGB";
#endif
#if defined(GL_EXT_blend_equation_separate)
                     return "GL_BLEND_EQUATION_RGB_EXT";
#endif
            break;
        case 0x800a:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_FUNC_SUBTRACT";
#endif
#if defined(GL_EXT_blend_subtract)
                     return "GL_FUNC_SUBTRACT_EXT";
#endif
            break;
        case 0x800b:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_FUNC_REVERSE_SUBTRACT";
#endif
#if defined(GL_EXT_blend_subtract)
                     return "GL_FUNC_REVERSE_SUBTRACT_EXT";
#endif
            break;
#if defined(GL_EXT_cmyka)
        case 0x800c: return "GL_CMYK_EXT";
        case 0x800d: return "GL_CMYKA_EXT";
        case 0x800e: return "GL_PACK_CMYK_HINT_EXT";
        case 0x800f: return "GL_UNPACK_CMYK_HINT_EXT";
#endif
        case 0x8010:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_1D";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_1D_EXT";
#endif
            break;
        case 0x8011:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_2D";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_2D_EXT";
#endif
            break;
        case 0x8012:
#if defined(GL_ARB_imaging)
                     return "GL_SEPARABLE_2D";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_SEPARABLE_2D_EXT";
#endif
            break;
        case 0x8013:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_BORDER_MODE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_BORDER_MODE_EXT";
#endif
            break;
        case 0x8014:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_FILTER_SCALE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_FILTER_SCALE_EXT";
#endif
            break;
        case 0x8015:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_FILTER_BIAS";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_FILTER_BIAS_EXT";
#endif
            break;
        case 0x8016:
#if defined(GL_ARB_imaging)
                     return "GL_REDUCE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_REDUCE_EXT";
#endif
            break;
        case 0x8017:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_FORMAT";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_FORMAT_EXT";
#endif
            break;
        case 0x8018:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_WIDTH";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_WIDTH_EXT";
#endif
            break;
        case 0x8019:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_HEIGHT";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_CONVOLUTION_HEIGHT_EXT";
#endif
            break;
        case 0x801a:
#if defined(GL_ARB_imaging)
                     return "GL_MAX_CONVOLUTION_WIDTH";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_MAX_CONVOLUTION_WIDTH_EXT";
#endif
            break;
        case 0x801b:
#if defined(GL_ARB_imaging)
                     return "GL_MAX_CONVOLUTION_HEIGHT";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_MAX_CONVOLUTION_HEIGHT_EXT";
#endif
            break;
        case 0x801c:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_RED_SCALE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_RED_SCALE_EXT";
#endif
            break;
        case 0x801d:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_GREEN_SCALE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_GREEN_SCALE_EXT";
#endif
            break;
        case 0x801e:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_BLUE_SCALE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_BLUE_SCALE_EXT";
#endif
            break;
        case 0x801f:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_ALPHA_SCALE";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_ALPHA_SCALE_EXT";
#endif
            break;
        case 0x8020:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_RED_BIAS";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_RED_BIAS_EXT";
#endif
            break;
        case 0x8021:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_GREEN_BIAS";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_GREEN_BIAS_EXT";
#endif
            break;
        case 0x8022:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_BLUE_BIAS";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_BLUE_BIAS_EXT";
#endif
            break;
        case 0x8023:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_ALPHA_BIAS";
#endif
#if defined(GL_EXT_convolution)
                     return "GL_POST_CONVOLUTION_ALPHA_BIAS_EXT";
#endif
            break;
        case 0x8024:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_EXT";
#endif
            break;
        case 0x8025:
#if defined(GL_ARB_imaging)
                     return "GL_PROXY_HISTOGRAM";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_PROXY_HISTOGRAM_EXT";
#endif
            break;
        case 0x8026:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_WIDTH";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_WIDTH_EXT";
#endif
            break;
        case 0x8027:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_FORMAT";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_FORMAT_EXT";
#endif
            break;
        case 0x8028:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_RED_SIZE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_RED_SIZE_EXT";
#endif
            break;
        case 0x8029:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_GREEN_SIZE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_GREEN_SIZE_EXT";
#endif
            break;
        case 0x802a:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_BLUE_SIZE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_BLUE_SIZE_EXT";
#endif
            break;
        case 0x802b:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_ALPHA_SIZE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_ALPHA_SIZE_EXT";
#endif
            break;
        case 0x802c:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_LUMINANCE_SIZE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_LUMINANCE_SIZE_EXT";
#endif
            break;
        case 0x802d:
#if defined(GL_ARB_imaging)
                     return "GL_HISTOGRAM_SINK";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_HISTOGRAM_SINK_EXT";
#endif
            break;
        case 0x802e:
#if defined(GL_ARB_imaging)
                     return "GL_MINMAX";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_MINMAX_EXT";
#endif
            break;
        case 0x802f:
#if defined(GL_ARB_imaging)
                     return "GL_MINMAX_FORMAT";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_MINMAX_FORMAT_EXT";
#endif
            break;
        case 0x8030:
#if defined(GL_ARB_imaging)
                     return "GL_MINMAX_SINK";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_MINMAX_SINK_EXT";
#endif
            break;
        case 0x8031:
#if defined(GL_ARB_imaging)
                     return "GL_TABLE_TOO_LARGE";
#endif
#if defined(GL_EXT_histogram)
                     return "GL_TABLE_TOO_LARGE_EXT";
#endif
            break;
        case 0x8032:
#if defined(GL_VERSION_1_2)
                     return "GL_UNSIGNED_BYTE_3_3_2";
#endif
#if defined(GL_EXT_packed_pixels)
                     return "GL_UNSIGNED_BYTE_3_3_2_EXT";
#endif
            break;
        case 0x8033:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_2_0)
                     return "GL_UNSIGNED_SHORT_4_4_4_4";
#endif
#if defined(GL_EXT_packed_pixels)
                     return "GL_UNSIGNED_SHORT_4_4_4_4_EXT";
#endif
            break;
        case 0x8034:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_2_0)
                     return "GL_UNSIGNED_SHORT_5_5_5_1";
#endif
#if defined(GL_EXT_packed_pixels)
                     return "GL_UNSIGNED_SHORT_5_5_5_1_EXT";
#endif
            break;
        case 0x8035:
#if defined(GL_VERSION_1_2)
                     return "GL_UNSIGNED_INT_8_8_8_8";
#endif
#if defined(GL_EXT_packed_pixels)
                     return "GL_UNSIGNED_INT_8_8_8_8_EXT";
#endif
            break;
        case 0x8036:
#if defined(GL_VERSION_1_2)
                     return "GL_UNSIGNED_INT_10_10_10_2";
#endif
#if defined(GL_EXT_packed_pixels)
                     return "GL_UNSIGNED_INT_10_10_10_2_EXT";
#endif
            break;
        case 0x8037:
#if defined(GL_EXT_polygon_offset)
                     return "GL_POLYGON_OFFSET_EXT";
#endif
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
                     return "GL_POLYGON_OFFSET_FILL";
#endif
            break;
        case 0x8038:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
                     return "GL_POLYGON_OFFSET_FACTOR";
#endif
#if defined(GL_EXT_polygon_offset)
                     return "GL_POLYGON_OFFSET_FACTOR_EXT";
#endif
            break;
#if defined(GL_EXT_polygon_offset)
        case 0x8039: return "GL_POLYGON_OFFSET_BIAS_EXT";
#endif
        case 0x803a:
#if defined(GL_VERSION_1_2)
                     return "GL_RESCALE_NORMAL";
#endif
#if defined(GL_EXT_rescale_normal)
                     return "GL_RESCALE_NORMAL_EXT";
#endif
            break;
        case 0x803b:
#if defined(__gl_h_)
                     return "GL_ALPHA4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_ALPHA4_EXT";
#endif
            break;
        case 0x803c:
#if defined(__gl_h_)
                     return "GL_ALPHA8";
#endif
#if defined(GL_EXT_texture_storage) || defined(GL_EXT_texture)
                     return "GL_ALPHA8_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_ALPHA8_OES";
#endif
            break;
        case 0x803d:
#if defined(__gl_h_)
                     return "GL_ALPHA12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_ALPHA12_EXT";
#endif
            break;
        case 0x803e:
#if defined(__gl_h_)
                     return "GL_ALPHA16";
#endif
#if defined(GL_EXT_texture)
                     return "GL_ALPHA16_EXT";
#endif
            break;
        case 0x803f:
#if defined(__gl_h_)
                     return "GL_LUMINANCE4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE4_EXT";
#endif
            break;
        case 0x8040:
#if defined(__gl_h_)
                     return "GL_LUMINANCE8";
#endif
#if defined(GL_EXT_texture_storage) || defined(GL_EXT_texture)
                     return "GL_LUMINANCE8_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_LUMINANCE8_OES";
#endif
            break;
        case 0x8041:
#if defined(__gl_h_)
                     return "GL_LUMINANCE12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE12_EXT";
#endif
            break;
        case 0x8042:
#if defined(__gl_h_)
                     return "GL_LUMINANCE16";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE16_EXT";
#endif
            break;
        case 0x8043:
#if defined(__gl_h_)
                     return "GL_LUMINANCE4_ALPHA4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE4_ALPHA4_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_LUMINANCE4_ALPHA4_OES";
#endif
            break;
        case 0x8044:
#if defined(__gl_h_)
                     return "GL_LUMINANCE6_ALPHA2";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE6_ALPHA2_EXT";
#endif
            break;
        case 0x8045:
#if defined(__gl_h_)
                     return "GL_LUMINANCE8_ALPHA8";
#endif
#if defined(GL_EXT_texture_storage) || defined(GL_EXT_texture)
                     return "GL_LUMINANCE8_ALPHA8_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_LUMINANCE8_ALPHA8_OES";
#endif
            break;
        case 0x8046:
#if defined(__gl_h_)
                     return "GL_LUMINANCE12_ALPHA4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE12_ALPHA4_EXT";
#endif
            break;
        case 0x8047:
#if defined(__gl_h_)
                     return "GL_LUMINANCE12_ALPHA12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE12_ALPHA12_EXT";
#endif
            break;
        case 0x8048:
#if defined(__gl_h_)
                     return "GL_LUMINANCE16_ALPHA16";
#endif
#if defined(GL_EXT_texture)
                     return "GL_LUMINANCE16_ALPHA16_EXT";
#endif
            break;
        case 0x8049:
#if defined(__gl_h_)
                     return "GL_INTENSITY";
#endif
#if defined(GL_EXT_texture)
                     return "GL_INTENSITY_EXT";
#endif
            break;
        case 0x804a:
#if defined(__gl_h_)
                     return "GL_INTENSITY4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_INTENSITY4_EXT";
#endif
            break;
        case 0x804b:
#if defined(__gl_h_)
                     return "GL_INTENSITY8";
#endif
#if defined(GL_EXT_texture)
                     return "GL_INTENSITY8_EXT";
#endif
            break;
        case 0x804c:
#if defined(__gl_h_)
                     return "GL_INTENSITY12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_INTENSITY12_EXT";
#endif
            break;
        case 0x804d:
#if defined(__gl_h_)
                     return "GL_INTENSITY16";
#endif
#if defined(GL_EXT_texture)
                     return "GL_INTENSITY16_EXT";
#endif
            break;
#if defined(GL_EXT_texture)
        case 0x804e: return "GL_RGB2_EXT";
#endif
        case 0x804f:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGB4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGB4_EXT";
#endif
            break;
        case 0x8050:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGB5";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGB5_EXT";
#endif
            break;
        case 0x8051:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_0) || defined(__gl_h_)
                     return "GL_RGB8";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGB8_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_RGB8_OES";
#endif
            break;
        case 0x8052:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGB10";
#endif
#if defined(GL_OES_required_internalformat) || defined(GL_EXT_texture)
                     return "GL_RGB10_EXT";
#endif
            break;
        case 0x8053:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGB12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGB12_EXT";
#endif
            break;
        case 0x8054:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGB16";
#endif
#if defined(GL_EXT_texture_norm16) || defined(GL_EXT_texture)
                     return "GL_RGB16_EXT";
#endif
            break;
        case 0x8055:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGBA2";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGBA2_EXT";
#endif
            break;
        case 0x8056:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
                     return "GL_RGBA4";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGBA4_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_RGBA4_OES";
#endif
            break;
        case 0x8057:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
                     return "GL_RGB5_A1";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGB5_A1_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_RGB5_A1_OES";
#endif
            break;
        case 0x8058:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_0) || defined(__gl_h_)
                     return "GL_RGBA8";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGBA8_EXT";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_RGBA8_OES";
#endif
            break;
        case 0x8059:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_0) || defined(__gl_h_)
                     return "GL_RGB10_A2";
#endif
#if defined(GL_OES_required_internalformat) || defined(GL_EXT_texture)
                     return "GL_RGB10_A2_EXT";
#endif
            break;
        case 0x805a:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGBA12";
#endif
#if defined(GL_EXT_texture)
                     return "GL_RGBA12_EXT";
#endif
            break;
        case 0x805b:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_RGBA16";
#endif
#if defined(GL_EXT_texture_norm16) || defined(GL_EXT_texture)
                     return "GL_RGBA16_EXT";
#endif
            break;
        case 0x805c:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_1) || defined(__gl_h_)
                     return "GL_TEXTURE_RED_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_RED_SIZE_EXT";
#endif
            break;
        case 0x805d:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_1) || defined(__gl_h_)
                     return "GL_TEXTURE_GREEN_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_GREEN_SIZE_EXT";
#endif
            break;
        case 0x805e:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_1) || defined(__gl_h_)
                     return "GL_TEXTURE_BLUE_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_BLUE_SIZE_EXT";
#endif
            break;
        case 0x805f:
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_3_1) || defined(__gl_h_)
                     return "GL_TEXTURE_ALPHA_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_ALPHA_SIZE_EXT";
#endif
            break;
        case 0x8060:
#if defined(__gl_h_)
                     return "GL_TEXTURE_LUMINANCE_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_LUMINANCE_SIZE_EXT";
#endif
            break;
        case 0x8061:
#if defined(__gl_h_)
                     return "GL_TEXTURE_INTENSITY_SIZE";
#endif
#if defined(GL_EXT_texture)
                     return "GL_TEXTURE_INTENSITY_SIZE_EXT";
#endif
            break;
#if defined(GL_EXT_texture)
        case 0x8062: return "GL_REPLACE_EXT";
#endif
        case 0x8063:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_PROXY_TEXTURE_1D";
#endif
#if defined(GL_EXT_texture)
                     return "GL_PROXY_TEXTURE_1D_EXT";
#endif
            break;
        case 0x8064:
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_PROXY_TEXTURE_2D";
#endif
#if defined(GL_EXT_texture)
                     return "GL_PROXY_TEXTURE_2D_EXT";
#endif
            break;
#if defined(GL_EXT_texture)
        case 0x8065: return "GL_TEXTURE_TOO_LARGE_EXT";
#endif
        case 0x8066:
#if defined(__gl_h_)
                     return "GL_TEXTURE_PRIORITY";
#endif
#if defined(GL_EXT_texture_object)
                     return "GL_TEXTURE_PRIORITY_EXT";
#endif
            break;
        case 0x8067:
#if defined(__gl_h_)
                     return "GL_TEXTURE_RESIDENT";
#endif
#if defined(GL_EXT_texture_object)
                     return "GL_TEXTURE_RESIDENT_EXT";
#endif
            break;
        case 0x8068:
#if defined(GL_EXT_texture_object)
                     return "GL_TEXTURE_1D_BINDING_EXT";
#endif
#if defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_TEXTURE_BINDING_1D";
#endif
            break;
        case 0x8069:
#if defined(GL_EXT_texture_object)
                     return "GL_TEXTURE_2D_BINDING_EXT";
#endif
#if defined(GL_VERSION_1_1) || defined(GL_ES_VERSION_2_0) || defined(__gl_h_)
                     return "GL_TEXTURE_BINDING_2D";
#endif
            break;
        case 0x806a:
#if defined(GL_EXT_texture_object)
                     return "GL_TEXTURE_3D_BINDING_EXT";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_2)
                     return "GL_TEXTURE_BINDING_3D";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_TEXTURE_BINDING_3D_OES";
#endif
            break;
        case 0x806b:
#if defined(GL_VERSION_1_2)
                     return "GL_PACK_SKIP_IMAGES";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_PACK_SKIP_IMAGES_EXT";
#endif
            break;
        case 0x806c:
#if defined(GL_VERSION_1_2)
                     return "GL_PACK_IMAGE_HEIGHT";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_PACK_IMAGE_HEIGHT_EXT";
#endif
            break;
        case 0x806d:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNPACK_SKIP_IMAGES";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_UNPACK_SKIP_IMAGES_EXT";
#endif
            break;
        case 0x806e:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNPACK_IMAGE_HEIGHT";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_UNPACK_IMAGE_HEIGHT_EXT";
#endif
            break;
        case 0x806f:
#if defined(GL_ES_VERSION_3_0) || defined(GL_EXT_sparse_texture) || defined(GL_VERSION_1_2)
                     return "GL_TEXTURE_3D";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_TEXTURE_3D_EXT";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_TEXTURE_3D_OES";
#endif
            break;
        case 0x8070:
#if defined(GL_VERSION_1_2)
                     return "GL_PROXY_TEXTURE_3D";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_PROXY_TEXTURE_3D_EXT";
#endif
            break;
        case 0x8071:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_DEPTH";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_TEXTURE_DEPTH_EXT";
#endif
            break;
        case 0x8072:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_2)
                     return "GL_TEXTURE_WRAP_R";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_TEXTURE_WRAP_R_EXT";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_TEXTURE_WRAP_R_OES";
#endif
            break;
        case 0x8073:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_2)
                     return "GL_MAX_3D_TEXTURE_SIZE";
#endif
#if defined(GL_EXT_texture3D)
                     return "GL_MAX_3D_TEXTURE_SIZE_EXT";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_MAX_3D_TEXTURE_SIZE_OES";
#endif
            break;
        case 0x8074:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_1_1) || defined(__gl_h_)
                     return "GL_VERTEX_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_VERTEX_ARRAY_EXT";
#endif
#if defined(GL_KHR_debug)
                     return "GL_VERTEX_ARRAY_KHR";
#endif
            break;
        case 0x8075:
#if defined(__gl_h_)
                     return "GL_NORMAL_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_NORMAL_ARRAY_EXT";
#endif
            break;
        case 0x8076:
#if defined(__gl_h_)
                     return "GL_COLOR_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_COLOR_ARRAY_EXT";
#endif
            break;
        case 0x8077:
#if defined(__gl_h_)
                     return "GL_INDEX_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_INDEX_ARRAY_EXT";
#endif
            break;
        case 0x8078:
#if defined(__gl_h_)
                     return "GL_TEXTURE_COORD_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_TEXTURE_COORD_ARRAY_EXT";
#endif
            break;
        case 0x8079:
#if defined(__gl_h_)
                     return "GL_EDGE_FLAG_ARRAY";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_EDGE_FLAG_ARRAY_EXT";
#endif
            break;
        case 0x807a:
#if defined(__gl_h_)
                     return "GL_VERTEX_ARRAY_SIZE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_VERTEX_ARRAY_SIZE_EXT";
#endif
            break;
        case 0x807b:
#if defined(__gl_h_)
                     return "GL_VERTEX_ARRAY_TYPE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_VERTEX_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x807c:
#if defined(__gl_h_)
                     return "GL_VERTEX_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_VERTEX_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x807d: return "GL_VERTEX_ARRAY_COUNT_EXT";
#endif
        case 0x807e:
#if defined(__gl_h_)
                     return "GL_NORMAL_ARRAY_TYPE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_NORMAL_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x807f:
#if defined(__gl_h_)
                     return "GL_NORMAL_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_NORMAL_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x8080: return "GL_NORMAL_ARRAY_COUNT_EXT";
#endif
        case 0x8081:
#if defined(__gl_h_)
                     return "GL_COLOR_ARRAY_SIZE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_COLOR_ARRAY_SIZE_EXT";
#endif
            break;
        case 0x8082:
#if defined(__gl_h_)
                     return "GL_COLOR_ARRAY_TYPE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_COLOR_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x8083:
#if defined(__gl_h_)
                     return "GL_COLOR_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_COLOR_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x8084: return "GL_COLOR_ARRAY_COUNT_EXT";
#endif
        case 0x8085:
#if defined(__gl_h_)
                     return "GL_INDEX_ARRAY_TYPE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_INDEX_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x8086:
#if defined(__gl_h_)
                     return "GL_INDEX_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_INDEX_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x8087: return "GL_INDEX_ARRAY_COUNT_EXT";
#endif
        case 0x8088:
#if defined(__gl_h_)
                     return "GL_TEXTURE_COORD_ARRAY_SIZE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_TEXTURE_COORD_ARRAY_SIZE_EXT";
#endif
            break;
        case 0x8089:
#if defined(__gl_h_)
                     return "GL_TEXTURE_COORD_ARRAY_TYPE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_TEXTURE_COORD_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x808a:
#if defined(__gl_h_)
                     return "GL_TEXTURE_COORD_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_TEXTURE_COORD_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x808b: return "GL_TEXTURE_COORD_ARRAY_COUNT_EXT";
#endif
        case 0x808c:
#if defined(__gl_h_)
                     return "GL_EDGE_FLAG_ARRAY_STRIDE";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_EDGE_FLAG_ARRAY_STRIDE_EXT";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
        case 0x808d: return "GL_EDGE_FLAG_ARRAY_COUNT_EXT";
#endif
        case 0x808e:
#if defined(__gl_h_)
                     return "GL_VERTEX_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_VERTEX_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x808f:
#if defined(__gl_h_)
                     return "GL_NORMAL_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_NORMAL_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x8090:
#if defined(__gl_h_)
                     return "GL_COLOR_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_COLOR_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x8091:
#if defined(__gl_h_)
                     return "GL_INDEX_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_INDEX_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x8092:
#if defined(__gl_h_)
                     return "GL_TEXTURE_COORD_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_TEXTURE_COORD_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x8093:
#if defined(__gl_h_)
                     return "GL_EDGE_FLAG_ARRAY_POINTER";
#endif
#if defined(__gl_h_) || defined(GL_EXT_vertex_array)
                     return "GL_EDGE_FLAG_ARRAY_POINTER_EXT";
#endif
            break;
#if defined(GL_SGIX_interlace)
        case 0x8094: return "GL_INTERLACE_SGIX";
#endif
#if defined(GL_SGIS_detail_texture)
        case 0x8095: return "GL_DETAIL_TEXTURE_2D_SGIS";
        case 0x8096: return "GL_DETAIL_TEXTURE_2D_BINDING_SGIS";
        case 0x8097: return "GL_LINEAR_DETAIL_SGIS";
        case 0x8098: return "GL_LINEAR_DETAIL_ALPHA_SGIS";
        case 0x8099: return "GL_LINEAR_DETAIL_COLOR_SGIS";
        case 0x809a: return "GL_DETAIL_TEXTURE_LEVEL_SGIS";
        case 0x809b: return "GL_DETAIL_TEXTURE_MODE_SGIS";
        case 0x809c: return "GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS";
#endif
        case 0x809d:
#if defined(GL_VERSION_1_3)
                     return "GL_MULTISAMPLE";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_MULTISAMPLE_ARB";
#endif
#if defined(GL_EXT_multisampled_compatibility) || defined(GL_EXT_multisample)
                     return "GL_MULTISAMPLE_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_MULTISAMPLE_SGIS";
#endif
            break;
        case 0x809e:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLE_ALPHA_TO_COVERAGE";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_ALPHA_TO_COVERAGE_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_ALPHA_TO_MASK_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_ALPHA_TO_MASK_SGIS";
#endif
            break;
        case 0x809f:
#if defined(GL_VERSION_1_3)
                     return "GL_SAMPLE_ALPHA_TO_ONE";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_ALPHA_TO_ONE_ARB";
#endif
#if defined(GL_EXT_multisampled_compatibility) || defined(GL_EXT_multisample)
                     return "GL_SAMPLE_ALPHA_TO_ONE_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_ALPHA_TO_ONE_SGIS";
#endif
            break;
        case 0x80a0:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLE_COVERAGE";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_COVERAGE_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_MASK_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_MASK_SGIS";
#endif
            break;
        case 0x80a1:
#if defined(GL_EXT_multisample)
                     return "GL_1PASS_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_1PASS_SGIS";
#endif
            break;
        case 0x80a2:
#if defined(GL_EXT_multisample)
                     return "GL_2PASS_0_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_2PASS_0_SGIS";
#endif
            break;
        case 0x80a3:
#if defined(GL_EXT_multisample)
                     return "GL_2PASS_1_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_2PASS_1_SGIS";
#endif
            break;
        case 0x80a4:
#if defined(GL_EXT_multisample)
                     return "GL_4PASS_0_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_4PASS_0_SGIS";
#endif
            break;
        case 0x80a5:
#if defined(GL_EXT_multisample)
                     return "GL_4PASS_1_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_4PASS_1_SGIS";
#endif
            break;
        case 0x80a6:
#if defined(GL_EXT_multisample)
                     return "GL_4PASS_2_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_4PASS_2_SGIS";
#endif
            break;
        case 0x80a7:
#if defined(GL_EXT_multisample)
                     return "GL_4PASS_3_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_4PASS_3_SGIS";
#endif
            break;
        case 0x80a8:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLE_BUFFERS";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_BUFFERS_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_BUFFERS_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_BUFFERS_SGIS";
#endif
            break;
        case 0x80a9:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLES";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLES_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLES_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLES_SGIS";
#endif
            break;
        case 0x80aa:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLE_COVERAGE_VALUE";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_COVERAGE_VALUE_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_MASK_VALUE_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_MASK_VALUE_SGIS";
#endif
            break;
        case 0x80ab:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLE_COVERAGE_INVERT";
#endif
#if defined(GL_ARB_multisample)
                     return "GL_SAMPLE_COVERAGE_INVERT_ARB";
#endif
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_MASK_INVERT_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_MASK_INVERT_SGIS";
#endif
            break;
        case 0x80ac:
#if defined(GL_EXT_multisample)
                     return "GL_SAMPLE_PATTERN_EXT";
#endif
#if defined(GL_SGIS_multisample)
                     return "GL_SAMPLE_PATTERN_SGIS";
#endif
            break;
#if defined(GL_SGIS_sharpen_texture)
        case 0x80ad: return "GL_LINEAR_SHARPEN_SGIS";
        case 0x80ae: return "GL_LINEAR_SHARPEN_ALPHA_SGIS";
        case 0x80af: return "GL_LINEAR_SHARPEN_COLOR_SGIS";
        case 0x80b0: return "GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS";
#endif
        case 0x80b1:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_MATRIX";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_COLOR_MATRIX_SGI";
#endif
            break;
        case 0x80b2:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_MATRIX_STACK_DEPTH";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_COLOR_MATRIX_STACK_DEPTH_SGI";
#endif
            break;
        case 0x80b3:
#if defined(GL_ARB_imaging)
                     return "GL_MAX_COLOR_MATRIX_STACK_DEPTH";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI";
#endif
            break;
        case 0x80b4:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_RED_SCALE";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_RED_SCALE_SGI";
#endif
            break;
        case 0x80b5:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_GREEN_SCALE";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI";
#endif
            break;
        case 0x80b6:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_BLUE_SCALE";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI";
#endif
            break;
        case 0x80b7:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_ALPHA_SCALE";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI";
#endif
            break;
        case 0x80b8:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_RED_BIAS";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_RED_BIAS_SGI";
#endif
            break;
        case 0x80b9:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_GREEN_BIAS";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI";
#endif
            break;
        case 0x80ba:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_BLUE_BIAS";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI";
#endif
            break;
        case 0x80bb:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_ALPHA_BIAS";
#endif
#if defined(GL_SGI_color_matrix)
                     return "GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI";
#endif
            break;
#if defined(GL_SGI_texture_color_table)
        case 0x80bc: return "GL_TEXTURE_COLOR_TABLE_SGI";
        case 0x80bd: return "GL_PROXY_TEXTURE_COLOR_TABLE_SGI";
#endif
#if defined(GL_SGIX_texture_add_env)
        case 0x80be: return "GL_TEXTURE_ENV_BIAS_SGIX";
#endif
        case 0x80bf:
#if defined(GL_SGIX_shadow_ambient)
                     return "GL_SHADOW_AMBIENT_SGIX";
#endif
#if defined(GL_ARB_shadow_ambient)
                     return "GL_TEXTURE_COMPARE_FAIL_VALUE_ARB";
#endif
            break;
        case 0x80c8:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_BLEND_DST_RGB";
#endif
#if defined(GL_EXT_blend_func_separate)
                     return "GL_BLEND_DST_RGB_EXT";
#endif
            break;
        case 0x80c9:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_BLEND_SRC_RGB";
#endif
#if defined(GL_EXT_blend_func_separate)
                     return "GL_BLEND_SRC_RGB_EXT";
#endif
            break;
        case 0x80ca:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_BLEND_DST_ALPHA";
#endif
#if defined(GL_EXT_blend_func_separate)
                     return "GL_BLEND_DST_ALPHA_EXT";
#endif
            break;
        case 0x80cb:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_BLEND_SRC_ALPHA";
#endif
#if defined(GL_EXT_blend_func_separate)
                     return "GL_BLEND_SRC_ALPHA_EXT";
#endif
            break;
#if defined(GL_EXT_422_pixels)
        case 0x80cc: return "GL_422_EXT";
        case 0x80cd: return "GL_422_REV_EXT";
        case 0x80ce: return "GL_422_AVERAGE_EXT";
        case 0x80cf: return "GL_422_REV_AVERAGE_EXT";
#endif
        case 0x80d0:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d1:
#if defined(GL_ARB_imaging)
                     return "GL_POST_CONVOLUTION_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_POST_CONVOLUTION_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d2:
#if defined(GL_ARB_imaging)
                     return "GL_POST_COLOR_MATRIX_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d3:
#if defined(GL_ARB_imaging)
                     return "GL_PROXY_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_PROXY_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d4:
#if defined(GL_ARB_imaging)
                     return "GL_PROXY_POST_CONVOLUTION_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d5:
#if defined(GL_ARB_imaging)
                     return "GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI";
#endif
            break;
        case 0x80d6:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_SCALE";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_SCALE_SGI";
#endif
            break;
        case 0x80d7:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_BIAS";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_BIAS_SGI";
#endif
            break;
        case 0x80d8:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_FORMAT";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_FORMAT_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_FORMAT_SGI";
#endif
            break;
        case 0x80d9:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_WIDTH";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_WIDTH_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_WIDTH_SGI";
#endif
            break;
        case 0x80da:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_RED_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_RED_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_RED_SIZE_SGI";
#endif
            break;
        case 0x80db:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_GREEN_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_GREEN_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_GREEN_SIZE_SGI";
#endif
            break;
        case 0x80dc:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_BLUE_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_BLUE_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_BLUE_SIZE_SGI";
#endif
            break;
        case 0x80dd:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_ALPHA_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_ALPHA_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_ALPHA_SIZE_SGI";
#endif
            break;
        case 0x80de:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_LUMINANCE_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_LUMINANCE_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_LUMINANCE_SIZE_SGI";
#endif
            break;
        case 0x80df:
#if defined(GL_ARB_imaging)
                     return "GL_COLOR_TABLE_INTENSITY_SIZE";
#endif
#if defined(__gl_h_)
                     return "GL_COLOR_TABLE_INTENSITY_SIZE_EXT";
#endif
#if defined(GL_SGI_color_table)
                     return "GL_COLOR_TABLE_INTENSITY_SIZE_SGI";
#endif
            break;
        case 0x80e0:
#if defined(GL_VERSION_1_2)
                     return "GL_BGR";
#endif
#if defined(GL_EXT_bgra) || defined(__gl_h_)
                     return "GL_BGR_EXT";
#endif
            break;
        case 0x80e1:
#if defined(GL_VERSION_1_2)
                     return "GL_BGRA";
#endif
#if defined(GL_APPLE_texture_format_BGRA8888) || defined(GL_EXT_bgra) || defined(__gl_h_)
                     return "GL_BGRA_EXT";
#endif
#if defined(GL_IMG_read_format)
                     return "GL_BGRA_IMG";
#endif
            break;
#if defined(__gl_h_) || defined(GL_EXT_paletted_texture)
        case 0x80e2: return "GL_COLOR_INDEX1_EXT";
        case 0x80e3: return "GL_COLOR_INDEX2_EXT";
        case 0x80e4: return "GL_COLOR_INDEX4_EXT";
        case 0x80e5: return "GL_COLOR_INDEX8_EXT";
        case 0x80e6: return "GL_COLOR_INDEX12_EXT";
        case 0x80e7: return "GL_COLOR_INDEX16_EXT";
#endif
        case 0x80e8:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_ELEMENTS_VERTICES";
#endif
#if defined(GL_EXT_draw_range_elements)
                     return "GL_MAX_ELEMENTS_VERTICES_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_MAX_ELEMENTS_VERTICES_WIN";
#endif
            break;
        case 0x80e9:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_ELEMENTS_INDICES";
#endif
#if defined(GL_EXT_draw_range_elements)
                     return "GL_MAX_ELEMENTS_INDICES_EXT";
#endif
#if defined(__gl_h_)
                     return "GL_MAX_ELEMENTS_INDICES_WIN";
#endif
            break;
#if defined(GL_WIN_phong_shading) || defined(__gl_h_)
        case 0x80ea: return "GL_PHONG_WIN";
        case 0x80eb: return "GL_PHONG_HINT_WIN";
#endif
#if defined(GL_WIN_specular_fog) || defined(__gl_h_)
        case 0x80ec: return "GL_FOG_SPECULAR_TEXTURE_WIN";
#endif
#if defined(GL_EXT_paletted_texture)
        case 0x80ed: return "GL_TEXTURE_INDEX_SIZE_EXT";
#endif
#if defined(GL_ARB_indirect_parameters)
        case 0x80ee: return "GL_PARAMETER_BUFFER_ARB";
        case 0x80ef: return "GL_PARAMETER_BUFFER_BINDING_ARB";
#endif
#if defined(GL_EXT_clip_volume_hint)
        case 0x80f0: return "GL_CLIP_VOLUME_CLIPPING_HINT_EXT";
#endif
#if defined(GL_SGIS_texture_select)
        case 0x8110: return "GL_DUAL_ALPHA4_SGIS";
        case 0x8111: return "GL_DUAL_ALPHA8_SGIS";
        case 0x8112: return "GL_DUAL_ALPHA12_SGIS";
        case 0x8113: return "GL_DUAL_ALPHA16_SGIS";
        case 0x8114: return "GL_DUAL_LUMINANCE4_SGIS";
        case 0x8115: return "GL_DUAL_LUMINANCE8_SGIS";
        case 0x8116: return "GL_DUAL_LUMINANCE12_SGIS";
        case 0x8117: return "GL_DUAL_LUMINANCE16_SGIS";
        case 0x8118: return "GL_DUAL_INTENSITY4_SGIS";
        case 0x8119: return "GL_DUAL_INTENSITY8_SGIS";
        case 0x811a: return "GL_DUAL_INTENSITY12_SGIS";
        case 0x811b: return "GL_DUAL_INTENSITY16_SGIS";
        case 0x811c: return "GL_DUAL_LUMINANCE_ALPHA4_SGIS";
        case 0x811d: return "GL_DUAL_LUMINANCE_ALPHA8_SGIS";
        case 0x811e: return "GL_QUAD_ALPHA4_SGIS";
        case 0x811f: return "GL_QUAD_ALPHA8_SGIS";
        case 0x8120: return "GL_QUAD_LUMINANCE4_SGIS";
        case 0x8121: return "GL_QUAD_LUMINANCE8_SGIS";
        case 0x8122: return "GL_QUAD_INTENSITY4_SGIS";
        case 0x8123: return "GL_QUAD_INTENSITY8_SGIS";
        case 0x8124: return "GL_DUAL_TEXTURE_SELECT_SGIS";
        case 0x8125: return "GL_QUAD_TEXTURE_SELECT_SGIS";
#endif
        case 0x8126:
#if defined(GL_VERSION_1_4)
                     return "GL_POINT_SIZE_MIN";
#endif
#if defined(GL_ARB_point_parameters)
                     return "GL_POINT_SIZE_MIN_ARB";
#endif
#if defined(GL_EXT_point_parameters)
                     return "GL_POINT_SIZE_MIN_EXT";
#endif
#if defined(GL_SGIS_point_parameters)
                     return "GL_POINT_SIZE_MIN_SGIS";
#endif
            break;
        case 0x8127:
#if defined(GL_VERSION_1_4)
                     return "GL_POINT_SIZE_MAX";
#endif
#if defined(GL_ARB_point_parameters)
                     return "GL_POINT_SIZE_MAX_ARB";
#endif
#if defined(GL_EXT_point_parameters)
                     return "GL_POINT_SIZE_MAX_EXT";
#endif
#if defined(GL_SGIS_point_parameters)
                     return "GL_POINT_SIZE_MAX_SGIS";
#endif
            break;
        case 0x8128:
#if defined(GL_VERSION_1_4)
                     return "GL_POINT_FADE_THRESHOLD_SIZE";
#endif
#if defined(GL_ARB_point_parameters)
                     return "GL_POINT_FADE_THRESHOLD_SIZE_ARB";
#endif
#if defined(GL_EXT_point_parameters)
                     return "GL_POINT_FADE_THRESHOLD_SIZE_EXT";
#endif
#if defined(GL_SGIS_point_parameters)
                     return "GL_POINT_FADE_THRESHOLD_SIZE_SGIS";
#endif
            break;
        case 0x8129:
#if defined(GL_EXT_point_parameters)
                     return "GL_DISTANCE_ATTENUATION_EXT";
#endif
#if defined(GL_SGIS_point_parameters)
                     return "GL_DISTANCE_ATTENUATION_SGIS";
#endif
#if defined(GL_VERSION_1_4)
                     return "GL_POINT_DISTANCE_ATTENUATION";
#endif
#if defined(GL_ARB_point_parameters)
                     return "GL_POINT_DISTANCE_ATTENUATION_ARB";
#endif
            break;
#if defined(GL_SGIS_fog_function)
        case 0x812a: return "GL_FOG_FUNC_SGIS";
        case 0x812b: return "GL_FOG_FUNC_POINTS_SGIS";
        case 0x812c: return "GL_MAX_FOG_FUNC_POINTS_SGIS";
#endif
        case 0x812d:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_CLAMP_TO_BORDER";
#endif
#if defined(GL_ARB_texture_border_clamp)
                     return "GL_CLAMP_TO_BORDER_ARB";
#endif
#if defined(GL_EXT_texture_border_clamp)
                     return "GL_CLAMP_TO_BORDER_EXT";
#endif
#if defined(GL_NV_texture_border_clamp)
                     return "GL_CLAMP_TO_BORDER_NV";
#endif
#if defined(GL_OES_texture_border_clamp)
                     return "GL_CLAMP_TO_BORDER_OES";
#endif
#if defined(GL_SGIS_texture_border_clamp)
                     return "GL_CLAMP_TO_BORDER_SGIS";
#endif
            break;
#if defined(GL_SGIX_texture_multi_buffer)
        case 0x812e: return "GL_TEXTURE_MULTI_BUFFER_HINT_SGIX";
#endif
        case 0x812f:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_2_0)
                     return "GL_CLAMP_TO_EDGE";
#endif
#if defined(GL_SGIS_texture_edge_clamp)
                     return "GL_CLAMP_TO_EDGE_SGIS";
#endif
            break;
#if defined(GL_SGIS_texture4D)
        case 0x8130: return "GL_PACK_SKIP_VOLUMES_SGIS";
        case 0x8131: return "GL_PACK_IMAGE_DEPTH_SGIS";
        case 0x8132: return "GL_UNPACK_SKIP_VOLUMES_SGIS";
        case 0x8133: return "GL_UNPACK_IMAGE_DEPTH_SGIS";
        case 0x8134: return "GL_TEXTURE_4D_SGIS";
        case 0x8135: return "GL_PROXY_TEXTURE_4D_SGIS";
        case 0x8136: return "GL_TEXTURE_4DSIZE_SGIS";
        case 0x8137: return "GL_TEXTURE_WRAP_Q_SGIS";
        case 0x8138: return "GL_MAX_4D_TEXTURE_SIZE_SGIS";
#endif
#if defined(GL_SGIX_pixel_texture)
        case 0x8139: return "GL_PIXEL_TEX_GEN_SGIX";
#endif
        case 0x813a:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_TEXTURE_MIN_LOD";
#endif
#if defined(GL_SGIS_texture_lod)
                     return "GL_TEXTURE_MIN_LOD_SGIS";
#endif
            break;
        case 0x813b:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_TEXTURE_MAX_LOD";
#endif
#if defined(GL_SGIS_texture_lod)
                     return "GL_TEXTURE_MAX_LOD_SGIS";
#endif
            break;
        case 0x813c:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_TEXTURE_BASE_LEVEL";
#endif
#if defined(GL_SGIS_texture_lod)
                     return "GL_TEXTURE_BASE_LEVEL_SGIS";
#endif
            break;
        case 0x813d:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_TEXTURE_MAX_LEVEL";
#endif
#if defined(GL_APPLE_texture_max_level)
                     return "GL_TEXTURE_MAX_LEVEL_APPLE";
#endif
#if defined(GL_SGIS_texture_lod)
                     return "GL_TEXTURE_MAX_LEVEL_SGIS";
#endif
            break;
#if defined(GL_SGIX_pixel_tiles)
        case 0x813e: return "GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX";
        case 0x813f: return "GL_PIXEL_TILE_CACHE_INCREMENT_SGIX";
        case 0x8140: return "GL_PIXEL_TILE_WIDTH_SGIX";
        case 0x8141: return "GL_PIXEL_TILE_HEIGHT_SGIX";
        case 0x8142: return "GL_PIXEL_TILE_GRID_WIDTH_SGIX";
        case 0x8143: return "GL_PIXEL_TILE_GRID_HEIGHT_SGIX";
        case 0x8144: return "GL_PIXEL_TILE_GRID_DEPTH_SGIX";
        case 0x8145: return "GL_PIXEL_TILE_CACHE_SIZE_SGIX";
#endif
#if defined(GL_SGIS_texture_filter4)
        case 0x8146: return "GL_FILTER4_SGIS";
        case 0x8147: return "GL_TEXTURE_FILTER4_SIZE_SGIS";
#endif
#if defined(GL_SGIX_sprite)
        case 0x8148: return "GL_SPRITE_SGIX";
        case 0x8149: return "GL_SPRITE_MODE_SGIX";
        case 0x814a: return "GL_SPRITE_AXIS_SGIX";
        case 0x814b: return "GL_SPRITE_TRANSLATION_SGIX";
        case 0x814c: return "GL_SPRITE_AXIAL_SGIX";
        case 0x814d: return "GL_SPRITE_OBJECT_ALIGNED_SGIX";
        case 0x814e: return "GL_SPRITE_EYE_ALIGNED_SGIX";
#endif
#if defined(GL_SGIS_texture4D)
        case 0x814f: return "GL_TEXTURE_4D_BINDING_SGIS";
#endif
#if defined(GL_HP_convolution_border_modes)
        case 0x8150: return "GL_IGNORE_BORDER_HP";
#endif
        case 0x8151:
#if defined(GL_ARB_imaging)
                     return "GL_CONSTANT_BORDER";
#endif
#if defined(GL_HP_convolution_border_modes)
                     return "GL_CONSTANT_BORDER_HP";
#endif
            break;
        case 0x8153:
#if defined(GL_ARB_imaging)
                     return "GL_REPLICATE_BORDER";
#endif
#if defined(GL_HP_convolution_border_modes)
                     return "GL_REPLICATE_BORDER_HP";
#endif
            break;
        case 0x8154:
#if defined(GL_ARB_imaging)
                     return "GL_CONVOLUTION_BORDER_COLOR";
#endif
#if defined(GL_HP_convolution_border_modes)
                     return "GL_CONVOLUTION_BORDER_COLOR_HP";
#endif
            break;
#if defined(GL_HP_image_transform)
        case 0x8155: return "GL_IMAGE_SCALE_X_HP";
        case 0x8156: return "GL_IMAGE_SCALE_Y_HP";
        case 0x8157: return "GL_IMAGE_TRANSLATE_X_HP";
        case 0x8158: return "GL_IMAGE_TRANSLATE_Y_HP";
        case 0x8159: return "GL_IMAGE_ROTATE_ANGLE_HP";
        case 0x815a: return "GL_IMAGE_ROTATE_ORIGIN_X_HP";
        case 0x815b: return "GL_IMAGE_ROTATE_ORIGIN_Y_HP";
        case 0x815c: return "GL_IMAGE_MAG_FILTER_HP";
        case 0x815d: return "GL_IMAGE_MIN_FILTER_HP";
        case 0x815e: return "GL_IMAGE_CUBIC_WEIGHT_HP";
        case 0x815f: return "GL_CUBIC_HP";
        case 0x8160: return "GL_AVERAGE_HP";
        case 0x8161: return "GL_IMAGE_TRANSFORM_2D_HP";
        case 0x8162: return "GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP";
        case 0x8163: return "GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP";
#endif
#if defined(GL_HP_occlusion_test)
        case 0x8165: return "GL_OCCLUSION_TEST_HP";
        case 0x8166: return "GL_OCCLUSION_TEST_RESULT_HP";
#endif
#if defined(GL_HP_texture_lighting)
        case 0x8167: return "GL_TEXTURE_LIGHTING_MODE_HP";
        case 0x8168: return "GL_TEXTURE_POST_SPECULAR_HP";
        case 0x8169: return "GL_TEXTURE_PRE_SPECULAR_HP";
#endif
#if defined(GL_SGIX_clipmap)
        case 0x8170: return "GL_LINEAR_CLIPMAP_LINEAR_SGIX";
        case 0x8171: return "GL_TEXTURE_CLIPMAP_CENTER_SGIX";
        case 0x8172: return "GL_TEXTURE_CLIPMAP_FRAME_SGIX";
        case 0x8173: return "GL_TEXTURE_CLIPMAP_OFFSET_SGIX";
        case 0x8174: return "GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX";
        case 0x8175: return "GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX";
        case 0x8176: return "GL_TEXTURE_CLIPMAP_DEPTH_SGIX";
        case 0x8177: return "GL_MAX_CLIPMAP_DEPTH_SGIX";
        case 0x8178: return "GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX";
#endif
#if defined(GL_SGIX_texture_scale_bias)
        case 0x8179: return "GL_POST_TEXTURE_FILTER_BIAS_SGIX";
        case 0x817a: return "GL_POST_TEXTURE_FILTER_SCALE_SGIX";
        case 0x817b: return "GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX";
        case 0x817c: return "GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX";
#endif
#if defined(GL_SGIX_reference_plane)
        case 0x817d: return "GL_REFERENCE_PLANE_SGIX";
        case 0x817e: return "GL_REFERENCE_PLANE_EQUATION_SGIX";
#endif
#if defined(GL_SGIX_ir_instrument1)
        case 0x817f: return "GL_IR_INSTRUMENT1_SGIX";
#endif
#if defined(GL_SGIX_instruments)
        case 0x8180: return "GL_INSTRUMENT_BUFFER_POINTER_SGIX";
        case 0x8181: return "GL_INSTRUMENT_MEASUREMENTS_SGIX";
#endif
#if defined(GL_SGIX_list_priority)
        case 0x8182: return "GL_LIST_PRIORITY_SGIX";
#endif
#if defined(GL_SGIX_calligraphic_fragment)
        case 0x8183: return "GL_CALLIGRAPHIC_FRAGMENT_SGIX";
#endif
#if defined(GL_SGIX_framezoom)
        case 0x818b: return "GL_FRAMEZOOM_SGIX";
        case 0x818c: return "GL_FRAMEZOOM_FACTOR_SGIX";
        case 0x818d: return "GL_MAX_FRAMEZOOM_FACTOR_SGIX";
#endif
#if defined(GL_SGIX_texture_lod_bias)
        case 0x818e: return "GL_TEXTURE_LOD_BIAS_S_SGIX";
        case 0x818f: return "GL_TEXTURE_LOD_BIAS_T_SGIX";
        case 0x8190: return "GL_TEXTURE_LOD_BIAS_R_SGIX";
#endif
        case 0x8191:
#if defined(GL_VERSION_1_4)
                     return "GL_GENERATE_MIPMAP";
#endif
#if defined(GL_SGIS_generate_mipmap)
                     return "GL_GENERATE_MIPMAP_SGIS";
#endif
            break;
        case 0x8192:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_GENERATE_MIPMAP_HINT";
#endif
#if defined(GL_SGIS_generate_mipmap)
                     return "GL_GENERATE_MIPMAP_HINT_SGIS";
#endif
            break;
#if defined(GL_SGIX_polynomial_ffd)
        case 0x8194: return "GL_GEOMETRY_DEFORMATION_SGIX";
        case 0x8195: return "GL_TEXTURE_DEFORMATION_SGIX";
        case 0x8196: return "GL_DEFORMATIONS_MASK_SGIX";
        case 0x8197: return "GL_MAX_DEFORMATION_ORDER_SGIX";
#endif
#if defined(GL_SGIX_fog_offset)
        case 0x8198: return "GL_FOG_OFFSET_SGIX";
        case 0x8199: return "GL_FOG_OFFSET_VALUE_SGIX";
#endif
#if defined(GL_SGIX_shadow)
        case 0x819a: return "GL_TEXTURE_COMPARE_SGIX";
        case 0x819b: return "GL_TEXTURE_COMPARE_OPERATOR_SGIX";
        case 0x819c: return "GL_TEXTURE_LEQUAL_R_SGIX";
        case 0x819d: return "GL_TEXTURE_GEQUAL_R_SGIX";
#endif
        case 0x81a5:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_DEPTH_COMPONENT16";
#endif
#if defined(GL_ARB_depth_texture)
                     return "GL_DEPTH_COMPONENT16_ARB";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_DEPTH_COMPONENT16_OES";
#endif
#if defined(GL_SGIX_depth_texture)
                     return "GL_DEPTH_COMPONENT16_SGIX";
#endif
            break;
        case 0x81a6:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_4)
                     return "GL_DEPTH_COMPONENT24";
#endif
#if defined(GL_ARB_depth_texture)
                     return "GL_DEPTH_COMPONENT24_ARB";
#endif
#if defined(GL_OES_depth24)
                     return "GL_DEPTH_COMPONENT24_OES";
#endif
#if defined(GL_SGIX_depth_texture)
                     return "GL_DEPTH_COMPONENT24_SGIX";
#endif
            break;
        case 0x81a7:
#if defined(GL_VERSION_1_4)
                     return "GL_DEPTH_COMPONENT32";
#endif
#if defined(GL_ARB_depth_texture)
                     return "GL_DEPTH_COMPONENT32_ARB";
#endif
#if defined(GL_OES_depth32)
                     return "GL_DEPTH_COMPONENT32_OES";
#endif
#if defined(GL_SGIX_depth_texture)
                     return "GL_DEPTH_COMPONENT32_SGIX";
#endif
            break;
#if defined(GL_EXT_compiled_vertex_array)
        case 0x81a8: return "GL_ARRAY_ELEMENT_LOCK_FIRST_EXT";
        case 0x81a9: return "GL_ARRAY_ELEMENT_LOCK_COUNT_EXT";
#endif
#if defined(GL_EXT_cull_vertex)
        case 0x81aa: return "GL_CULL_VERTEX_EXT";
        case 0x81ab: return "GL_CULL_VERTEX_EYE_POSITION_EXT";
        case 0x81ac: return "GL_CULL_VERTEX_OBJECT_POSITION_EXT";
#endif
#if defined(GL_EXT_index_array_formats)
        case 0x81ad: return "GL_IUI_V2F_EXT";
        case 0x81ae: return "GL_IUI_V3F_EXT";
        case 0x81af: return "GL_IUI_N3F_V2F_EXT";
        case 0x81b0: return "GL_IUI_N3F_V3F_EXT";
        case 0x81b1: return "GL_T2F_IUI_V2F_EXT";
        case 0x81b2: return "GL_T2F_IUI_V3F_EXT";
        case 0x81b3: return "GL_T2F_IUI_N3F_V2F_EXT";
        case 0x81b4: return "GL_T2F_IUI_N3F_V3F_EXT";
#endif
#if defined(GL_EXT_index_func)
        case 0x81b5: return "GL_INDEX_TEST_EXT";
        case 0x81b6: return "GL_INDEX_TEST_FUNC_EXT";
        case 0x81b7: return "GL_INDEX_TEST_REF_EXT";
#endif
#if defined(GL_EXT_index_material)
        case 0x81b8: return "GL_INDEX_MATERIAL_EXT";
        case 0x81b9: return "GL_INDEX_MATERIAL_PARAMETER_EXT";
        case 0x81ba: return "GL_INDEX_MATERIAL_FACE_EXT";
#endif
#if defined(GL_SGIX_ycrcb)
        case 0x81bb: return "GL_YCRCB_422_SGIX";
        case 0x81bc: return "GL_YCRCB_444_SGIX";
#endif
#if defined(GL_SUN_convolution_border_modes)
        case 0x81d4: return "GL_WRAP_BORDER_SUN";
#endif
#if defined(GL_SUNX_constant_data)
        case 0x81d5: return "GL_UNPACK_CONSTANT_DATA_SUNX";
        case 0x81d6: return "GL_TEXTURE_CONSTANT_DATA_SUNX";
#endif
#if defined(GL_SUN_triangle_list)
        case 0x81d7: return "GL_TRIANGLE_LIST_SUN";
        case 0x81d8: return "GL_REPLACEMENT_CODE_SUN";
#endif
#if defined(GL_SUN_global_alpha)
        case 0x81d9: return "GL_GLOBAL_ALPHA_SUN";
        case 0x81da: return "GL_GLOBAL_ALPHA_FACTOR_SUN";
#endif
#if defined(GL_SGIS_texture_color_mask)
        case 0x81ef: return "GL_TEXTURE_COLOR_WRITEMASK_SGIS";
#endif
#if defined(GL_SGIS_point_line_texgen)
        case 0x81f0: return "GL_EYE_DISTANCE_TO_POINT_SGIS";
        case 0x81f1: return "GL_OBJECT_DISTANCE_TO_POINT_SGIS";
        case 0x81f2: return "GL_EYE_DISTANCE_TO_LINE_SGIS";
        case 0x81f3: return "GL_OBJECT_DISTANCE_TO_LINE_SGIS";
        case 0x81f4: return "GL_EYE_POINT_SGIS";
        case 0x81f5: return "GL_OBJECT_POINT_SGIS";
        case 0x81f6: return "GL_EYE_LINE_SGIS";
        case 0x81f7: return "GL_OBJECT_LINE_SGIS";
#endif
        case 0x81f8:
#if defined(GL_VERSION_1_2)
                     return "GL_LIGHT_MODEL_COLOR_CONTROL";
#endif
#if defined(GL_EXT_separate_specular_color)
                     return "GL_LIGHT_MODEL_COLOR_CONTROL_EXT";
#endif
            break;
        case 0x81f9:
#if defined(GL_VERSION_1_2)
                     return "GL_SINGLE_COLOR";
#endif
#if defined(GL_EXT_separate_specular_color)
                     return "GL_SINGLE_COLOR_EXT";
#endif
            break;
        case 0x81fa:
#if defined(GL_VERSION_1_2)
                     return "GL_SEPARATE_SPECULAR_COLOR";
#endif
#if defined(GL_EXT_separate_specular_color)
                     return "GL_SEPARATE_SPECULAR_COLOR_EXT";
#endif
            break;
#if defined(GL_EXT_shared_texture_palette)
        case 0x81fb: return "GL_SHARED_TEXTURE_PALETTE_EXT";
#endif
#if defined(GL_ATI_text_fragment_shader)
        case 0x8200: return "GL_TEXT_FRAGMENT_SHADER_ATI";
#endif
        case 0x8210:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
#endif
#if defined(GL_EXT_sRGB)
                     return "GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT";
#endif
            break;
        case 0x8211:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x8212: return "GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE";
        case 0x8213: return "GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
        case 0x8214: return "GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
        case 0x8215: return "GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
        case 0x8216: return "GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
        case 0x8217: return "GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
        case 0x8218: return "GL_FRAMEBUFFER_DEFAULT";
#endif
        case 0x8219:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_FRAMEBUFFER_UNDEFINED";
#endif
#if defined(GL_OES_surfaceless_context)
                     return "GL_FRAMEBUFFER_UNDEFINED_OES";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x821a: return "GL_DEPTH_STENCIL_ATTACHMENT";
        case 0x821b: return "GL_MAJOR_VERSION";
        case 0x821c: return "GL_MINOR_VERSION";
        case 0x821d: return "GL_NUM_EXTENSIONS";
#endif
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_2)
        case 0x821e: return "GL_CONTEXT_FLAGS";
#endif
        case 0x821f:
#if defined(GL_VERSION_4_4)
                     return "GL_BUFFER_IMMUTABLE_STORAGE";
#endif
#if defined(GL_EXT_buffer_storage)
                     return "GL_BUFFER_IMMUTABLE_STORAGE_EXT";
#endif
            break;
        case 0x8220:
#if defined(GL_VERSION_4_4)
                     return "GL_BUFFER_STORAGE_FLAGS";
#endif
#if defined(GL_EXT_buffer_storage)
                     return "GL_BUFFER_STORAGE_FLAGS_EXT";
#endif
            break;
        case 0x8221:
#if defined(GL_VERSION_4_4) || defined(GL_ES_VERSION_3_2) || defined(GL_EXT_tessellation_shader)
                     return "GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES";
#endif
            break;
#if defined(GL_VERSION_3_0)
        case 0x8222: return "GL_INDEX";
        case 0x8225: return "GL_COMPRESSED_RED";
        case 0x8226: return "GL_COMPRESSED_RG";
#endif
        case 0x8227:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RG";
#endif
#if defined(GL_EXT_texture_rg)
                     return "GL_RG_EXT";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x8228: return "GL_RG_INTEGER";
#endif
        case 0x8229:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_R8";
#endif
#if defined(GL_EXT_texture_rg)
                     return "GL_R8_EXT";
#endif
            break;
        case 0x822a:
#if defined(GL_VERSION_3_0)
                     return "GL_R16";
#endif
#if defined(GL_EXT_texture_norm16)
                     return "GL_R16_EXT";
#endif
            break;
        case 0x822b:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RG8";
#endif
#if defined(GL_EXT_texture_rg)
                     return "GL_RG8_EXT";
#endif
            break;
        case 0x822c:
#if defined(GL_VERSION_3_0)
                     return "GL_RG16";
#endif
#if defined(GL_EXT_texture_norm16)
                     return "GL_RG16_EXT";
#endif
            break;
        case 0x822d:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_R16F";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_R16F_EXT";
#endif
            break;
        case 0x822e:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_R32F";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_R32F_EXT";
#endif
            break;
        case 0x822f:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RG16F";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_RG16F_EXT";
#endif
            break;
        case 0x8230:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RG32F";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_RG32F_EXT";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x8231: return "GL_R8I";
        case 0x8232: return "GL_R8UI";
        case 0x8233: return "GL_R16I";
        case 0x8234: return "GL_R16UI";
        case 0x8235: return "GL_R32I";
        case 0x8236: return "GL_R32UI";
        case 0x8237: return "GL_RG8I";
        case 0x8238: return "GL_RG8UI";
        case 0x8239: return "GL_RG16I";
        case 0x823a: return "GL_RG16UI";
        case 0x823b: return "GL_RG32I";
        case 0x823c: return "GL_RG32UI";
#endif
#if defined(GL_ARB_cl_event)
        case 0x8240: return "GL_SYNC_CL_EVENT_ARB";
        case 0x8241: return "GL_SYNC_CL_EVENT_COMPLETE_ARB";
#endif
        case 0x8242:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_OUTPUT_SYNCHRONOUS";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR";
#endif
            break;
        case 0x8243:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR";
#endif
            break;
        case 0x8244:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_CALLBACK_FUNCTION";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_CALLBACK_FUNCTION_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_CALLBACK_FUNCTION_KHR";
#endif
            break;
        case 0x8245:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_CALLBACK_USER_PARAM";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_CALLBACK_USER_PARAM_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_CALLBACK_USER_PARAM_KHR";
#endif
            break;
        case 0x8246:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_API";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_API_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_API_KHR";
#endif
            break;
        case 0x8247:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_WINDOW_SYSTEM";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR";
#endif
            break;
        case 0x8248:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_SHADER_COMPILER";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_SHADER_COMPILER_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_SHADER_COMPILER_KHR";
#endif
            break;
        case 0x8249:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_THIRD_PARTY";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_THIRD_PARTY_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_THIRD_PARTY_KHR";
#endif
            break;
        case 0x824a:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_APPLICATION";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_APPLICATION_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_APPLICATION_KHR";
#endif
            break;
        case 0x824b:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SOURCE_OTHER";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SOURCE_OTHER_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SOURCE_OTHER_KHR";
#endif
            break;
        case 0x824c:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_ERROR";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_ERROR_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_ERROR_KHR";
#endif
            break;
        case 0x824d:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR";
#endif
            break;
        case 0x824e:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR";
#endif
            break;
        case 0x824f:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_PORTABILITY";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_PORTABILITY_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_PORTABILITY_KHR";
#endif
            break;
        case 0x8250:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_PERFORMANCE";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_PERFORMANCE_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_PERFORMANCE_KHR";
#endif
            break;
        case 0x8251:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_OTHER";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_TYPE_OTHER_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_OTHER_KHR";
#endif
            break;
        case 0x8252:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_LOSE_CONTEXT_ON_RESET";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_LOSE_CONTEXT_ON_RESET_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_LOSE_CONTEXT_ON_RESET_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_LOSE_CONTEXT_ON_RESET_KHR";
#endif
            break;
        case 0x8253:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_GUILTY_CONTEXT_RESET";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_GUILTY_CONTEXT_RESET_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_GUILTY_CONTEXT_RESET_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_GUILTY_CONTEXT_RESET_KHR";
#endif
            break;
        case 0x8254:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_INNOCENT_CONTEXT_RESET";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_INNOCENT_CONTEXT_RESET_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_INNOCENT_CONTEXT_RESET_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_INNOCENT_CONTEXT_RESET_KHR";
#endif
            break;
        case 0x8255:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_UNKNOWN_CONTEXT_RESET";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_UNKNOWN_CONTEXT_RESET_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_UNKNOWN_CONTEXT_RESET_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_UNKNOWN_CONTEXT_RESET_KHR";
#endif
            break;
        case 0x8256:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_RESET_NOTIFICATION_STRATEGY";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_RESET_NOTIFICATION_STRATEGY_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_RESET_NOTIFICATION_STRATEGY_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_RESET_NOTIFICATION_STRATEGY_KHR";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_1)
        case 0x8257: return "GL_PROGRAM_BINARY_RETRIEVABLE_HINT";
#endif
        case 0x8258:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_1)
                     return "GL_PROGRAM_SEPARABLE";
#endif
#if defined(GL_EXT_separate_shader_objects)
                     return "GL_PROGRAM_SEPARABLE_EXT";
#endif
            break;
        case 0x8259:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_1)
                     return "GL_ACTIVE_PROGRAM";
#endif
#if defined(GL_EXT_separate_shader_objects)
                     return "GL_ACTIVE_PROGRAM_EXT";
#endif
            break;
        case 0x825a:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_1)
                     return "GL_PROGRAM_PIPELINE_BINDING";
#endif
#if defined(GL_EXT_separate_shader_objects)
                     return "GL_PROGRAM_PIPELINE_BINDING_EXT";
#endif
            break;
        case 0x825b:
#if defined(GL_VERSION_4_1)
                     return "GL_MAX_VIEWPORTS";
#endif
#if defined(GL_NV_viewport_array)
                     return "GL_MAX_VIEWPORTS_NV";
#endif
#if defined(GL_OES_viewport_array)
                     return "GL_MAX_VIEWPORTS_OES";
#endif
            break;
        case 0x825d:
#if defined(GL_VERSION_4_1)
                     return "GL_VIEWPORT_BOUNDS_RANGE";
#endif
#if defined(GL_NV_viewport_array)
                     return "GL_VIEWPORT_BOUNDS_RANGE_NV";
#endif
#if defined(GL_OES_viewport_array)
                     return "GL_VIEWPORT_BOUNDS_RANGE_OES";
#endif
            break;
        case 0x825e:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_LAYER_PROVOKING_VERTEX";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_LAYER_PROVOKING_VERTEX_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_LAYER_PROVOKING_VERTEX_OES";
#endif
            break;
        case 0x825f:
#if defined(GL_VERSION_4_1)
                     return "GL_VIEWPORT_INDEX_PROVOKING_VERTEX";
#endif
#if defined(GL_NV_viewport_array)
                     return "GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV";
#endif
#if defined(GL_OES_viewport_array)
                     return "GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES";
#endif
            break;
        case 0x8260:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_UNDEFINED_VERTEX";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_UNDEFINED_VERTEX_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_UNDEFINED_VERTEX_OES";
#endif
            break;
        case 0x8261:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_5)
                     return "GL_NO_RESET_NOTIFICATION";
#endif
#if defined(GL_ARB_robustness)
                     return "GL_NO_RESET_NOTIFICATION_ARB";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_NO_RESET_NOTIFICATION_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_NO_RESET_NOTIFICATION_KHR";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x8262: return "GL_MAX_COMPUTE_SHARED_MEMORY_SIZE";
        case 0x8263: return "GL_MAX_COMPUTE_UNIFORM_COMPONENTS";
        case 0x8264: return "GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS";
        case 0x8265: return "GL_MAX_COMPUTE_ATOMIC_COUNTERS";
        case 0x8266: return "GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS";
        case 0x8267: return "GL_COMPUTE_WORK_GROUP_SIZE";
#endif
        case 0x8268:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_MARKER";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_MARKER_KHR";
#endif
            break;
        case 0x8269:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_PUSH_GROUP";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_PUSH_GROUP_KHR";
#endif
            break;
        case 0x826a:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_TYPE_POP_GROUP";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_TYPE_POP_GROUP_KHR";
#endif
            break;
        case 0x826b:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SEVERITY_NOTIFICATION";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SEVERITY_NOTIFICATION_KHR";
#endif
            break;
        case 0x826c:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_DEBUG_GROUP_STACK_DEPTH";
#endif
#if defined(GL_KHR_debug)
                     return "GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR";
#endif
            break;
        case 0x826d:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_GROUP_STACK_DEPTH";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_GROUP_STACK_DEPTH_KHR";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x826e: return "GL_MAX_UNIFORM_LOCATIONS";
#endif
#if defined(GL_VERSION_4_3)
        case 0x826f: return "GL_INTERNALFORMAT_SUPPORTED";
        case 0x8270: return "GL_INTERNALFORMAT_PREFERRED";
        case 0x8271: return "GL_INTERNALFORMAT_RED_SIZE";
        case 0x8272: return "GL_INTERNALFORMAT_GREEN_SIZE";
        case 0x8273: return "GL_INTERNALFORMAT_BLUE_SIZE";
        case 0x8274: return "GL_INTERNALFORMAT_ALPHA_SIZE";
        case 0x8275: return "GL_INTERNALFORMAT_DEPTH_SIZE";
        case 0x8276: return "GL_INTERNALFORMAT_STENCIL_SIZE";
        case 0x8277: return "GL_INTERNALFORMAT_SHARED_SIZE";
        case 0x8278: return "GL_INTERNALFORMAT_RED_TYPE";
        case 0x8279: return "GL_INTERNALFORMAT_GREEN_TYPE";
        case 0x827a: return "GL_INTERNALFORMAT_BLUE_TYPE";
        case 0x827b: return "GL_INTERNALFORMAT_ALPHA_TYPE";
        case 0x827c: return "GL_INTERNALFORMAT_DEPTH_TYPE";
        case 0x827d: return "GL_INTERNALFORMAT_STENCIL_TYPE";
        case 0x827e: return "GL_MAX_WIDTH";
        case 0x827f: return "GL_MAX_HEIGHT";
        case 0x8280: return "GL_MAX_DEPTH";
        case 0x8281: return "GL_MAX_LAYERS";
        case 0x8282: return "GL_MAX_COMBINED_DIMENSIONS";
        case 0x8283: return "GL_COLOR_COMPONENTS";
        case 0x8284: return "GL_DEPTH_COMPONENTS";
        case 0x8285: return "GL_STENCIL_COMPONENTS";
        case 0x8286: return "GL_COLOR_RENDERABLE";
        case 0x8287: return "GL_DEPTH_RENDERABLE";
        case 0x8288: return "GL_STENCIL_RENDERABLE";
        case 0x8289: return "GL_FRAMEBUFFER_RENDERABLE";
        case 0x828a: return "GL_FRAMEBUFFER_RENDERABLE_LAYERED";
        case 0x828b: return "GL_FRAMEBUFFER_BLEND";
        case 0x828c: return "GL_READ_PIXELS";
        case 0x828d: return "GL_READ_PIXELS_FORMAT";
        case 0x828e: return "GL_READ_PIXELS_TYPE";
        case 0x828f: return "GL_TEXTURE_IMAGE_FORMAT";
        case 0x8290: return "GL_TEXTURE_IMAGE_TYPE";
        case 0x8291: return "GL_GET_TEXTURE_IMAGE_FORMAT";
        case 0x8292: return "GL_GET_TEXTURE_IMAGE_TYPE";
        case 0x8293: return "GL_MIPMAP";
        case 0x8294: return "GL_MANUAL_GENERATE_MIPMAP";
        case 0x8295: return "GL_AUTO_GENERATE_MIPMAP";
        case 0x8296: return "GL_COLOR_ENCODING";
        case 0x8297: return "GL_SRGB_READ";
        case 0x8298: return "GL_SRGB_WRITE";
#endif
#if defined(GL_ARB_internalformat_query2)
        case 0x8299: return "GL_SRGB_DECODE_ARB";
#endif
#if defined(GL_VERSION_4_3)
        case 0x829a: return "GL_FILTER";
        case 0x829b: return "GL_VERTEX_TEXTURE";
        case 0x829c: return "GL_TESS_CONTROL_TEXTURE";
        case 0x829d: return "GL_TESS_EVALUATION_TEXTURE";
        case 0x829e: return "GL_GEOMETRY_TEXTURE";
        case 0x829f: return "GL_FRAGMENT_TEXTURE";
        case 0x82a0: return "GL_COMPUTE_TEXTURE";
        case 0x82a1: return "GL_TEXTURE_SHADOW";
        case 0x82a2: return "GL_TEXTURE_GATHER";
        case 0x82a3: return "GL_TEXTURE_GATHER_SHADOW";
        case 0x82a4: return "GL_SHADER_IMAGE_LOAD";
        case 0x82a5: return "GL_SHADER_IMAGE_STORE";
        case 0x82a6: return "GL_SHADER_IMAGE_ATOMIC";
        case 0x82a7: return "GL_IMAGE_TEXEL_SIZE";
        case 0x82a8: return "GL_IMAGE_COMPATIBILITY_CLASS";
        case 0x82a9: return "GL_IMAGE_PIXEL_FORMAT";
        case 0x82aa: return "GL_IMAGE_PIXEL_TYPE";
        case 0x82ac: return "GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST";
        case 0x82ad: return "GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST";
        case 0x82ae: return "GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE";
        case 0x82af: return "GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE";
        case 0x82b1: return "GL_TEXTURE_COMPRESSED_BLOCK_WIDTH";
        case 0x82b2: return "GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT";
        case 0x82b3: return "GL_TEXTURE_COMPRESSED_BLOCK_SIZE";
        case 0x82b4: return "GL_CLEAR_BUFFER";
        case 0x82b5: return "GL_TEXTURE_VIEW";
        case 0x82b6: return "GL_VIEW_COMPATIBILITY_CLASS";
        case 0x82b7: return "GL_FULL_SUPPORT";
        case 0x82b8: return "GL_CAVEAT_SUPPORT";
        case 0x82b9: return "GL_IMAGE_CLASS_4_X_32";
        case 0x82ba: return "GL_IMAGE_CLASS_2_X_32";
        case 0x82bb: return "GL_IMAGE_CLASS_1_X_32";
        case 0x82bc: return "GL_IMAGE_CLASS_4_X_16";
        case 0x82bd: return "GL_IMAGE_CLASS_2_X_16";
        case 0x82be: return "GL_IMAGE_CLASS_1_X_16";
        case 0x82bf: return "GL_IMAGE_CLASS_4_X_8";
        case 0x82c0: return "GL_IMAGE_CLASS_2_X_8";
        case 0x82c1: return "GL_IMAGE_CLASS_1_X_8";
        case 0x82c2: return "GL_IMAGE_CLASS_11_11_10";
        case 0x82c3: return "GL_IMAGE_CLASS_10_10_10_2";
        case 0x82cc: return "GL_VIEW_CLASS_S3TC_DXT1_RGB";
        case 0x82cd: return "GL_VIEW_CLASS_S3TC_DXT1_RGBA";
        case 0x82ce: return "GL_VIEW_CLASS_S3TC_DXT3_RGBA";
        case 0x82cf: return "GL_VIEW_CLASS_S3TC_DXT5_RGBA";
        case 0x82d0: return "GL_VIEW_CLASS_RGTC1_RED";
        case 0x82d1: return "GL_VIEW_CLASS_RGTC2_RG";
        case 0x82d2: return "GL_VIEW_CLASS_BPTC_UNORM";
        case 0x82d3: return "GL_VIEW_CLASS_BPTC_FLOAT";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x82d4: return "GL_VERTEX_ATTRIB_BINDING";
        case 0x82d5: return "GL_VERTEX_ATTRIB_RELATIVE_OFFSET";
        case 0x82d6: return "GL_VERTEX_BINDING_DIVISOR";
        case 0x82d7: return "GL_VERTEX_BINDING_OFFSET";
        case 0x82d8: return "GL_VERTEX_BINDING_STRIDE";
        case 0x82d9: return "GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET";
        case 0x82da: return "GL_MAX_VERTEX_ATTRIB_BINDINGS";
#endif
        case 0x82db:
#if defined(GL_VERSION_4_3)
                     return "GL_TEXTURE_VIEW_MIN_LEVEL";
#endif
#if defined(GL_EXT_texture_view)
                     return "GL_TEXTURE_VIEW_MIN_LEVEL_EXT";
#endif
#if defined(GL_OES_texture_view)
                     return "GL_TEXTURE_VIEW_MIN_LEVEL_OES";
#endif
            break;
        case 0x82dc:
#if defined(GL_VERSION_4_3)
                     return "GL_TEXTURE_VIEW_NUM_LEVELS";
#endif
#if defined(GL_EXT_texture_view)
                     return "GL_TEXTURE_VIEW_NUM_LEVELS_EXT";
#endif
#if defined(GL_OES_texture_view)
                     return "GL_TEXTURE_VIEW_NUM_LEVELS_OES";
#endif
            break;
        case 0x82dd:
#if defined(GL_VERSION_4_3)
                     return "GL_TEXTURE_VIEW_MIN_LAYER";
#endif
#if defined(GL_EXT_texture_view)
                     return "GL_TEXTURE_VIEW_MIN_LAYER_EXT";
#endif
#if defined(GL_OES_texture_view)
                     return "GL_TEXTURE_VIEW_MIN_LAYER_OES";
#endif
            break;
        case 0x82de:
#if defined(GL_VERSION_4_3)
                     return "GL_TEXTURE_VIEW_NUM_LAYERS";
#endif
#if defined(GL_EXT_texture_view)
                     return "GL_TEXTURE_VIEW_NUM_LAYERS_EXT";
#endif
#if defined(GL_OES_texture_view)
                     return "GL_TEXTURE_VIEW_NUM_LAYERS_OES";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_0) || defined(GL_OES_texture_view)
        case 0x82df: return "GL_TEXTURE_IMMUTABLE_LEVELS";
#endif
        case 0x82e0:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_BUFFER";
#endif
#if defined(GL_KHR_debug)
                     return "GL_BUFFER_KHR";
#endif
            break;
        case 0x82e1:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_SHADER";
#endif
#if defined(GL_KHR_debug)
                     return "GL_SHADER_KHR";
#endif
            break;
        case 0x82e2:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_PROGRAM";
#endif
#if defined(GL_KHR_debug)
                     return "GL_PROGRAM_KHR";
#endif
            break;
        case 0x82e3:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_QUERY";
#endif
#if defined(GL_KHR_debug)
                     return "GL_QUERY_KHR";
#endif
            break;
        case 0x82e4:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_PROGRAM_PIPELINE";
#endif
#if defined(GL_KHR_debug)
                     return "GL_PROGRAM_PIPELINE_KHR";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_4)
        case 0x82e5: return "GL_MAX_VERTEX_ATTRIB_STRIDE";
#endif
        case 0x82e6:
#if defined(GL_KHR_debug) || defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_SAMPLER";
#endif
#if defined(GL_KHR_debug)
                     return "GL_SAMPLER_KHR";
#endif
            break;
#if defined(GL_VERSION_4_3)
        case 0x82e7: return "GL_DISPLAY_LIST";
#endif
        case 0x82e8:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_LABEL_LENGTH";
#endif
#if defined(GL_KHR_debug)
                     return "GL_MAX_LABEL_LENGTH_KHR";
#endif
            break;
#if defined(GL_VERSION_4_3)
        case 0x82e9: return "GL_NUM_SHADING_LANGUAGE_VERSIONS";
#endif
#if defined(GL_VERSION_4_5)
        case 0x82ea: return "GL_QUERY_TARGET";
#endif
#if defined(GL_ARB_transform_feedback_overflow_query)
        case 0x82ec: return "GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB";
        case 0x82ed: return "GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB";
#endif
#if defined(GL_ARB_pipeline_statistics_query)
        case 0x82ee: return "GL_VERTICES_SUBMITTED_ARB";
        case 0x82ef: return "GL_PRIMITIVES_SUBMITTED_ARB";
        case 0x82f0: return "GL_VERTEX_SHADER_INVOCATIONS_ARB";
        case 0x82f1: return "GL_TESS_CONTROL_SHADER_PATCHES_ARB";
        case 0x82f2: return "GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB";
        case 0x82f3: return "GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB";
        case 0x82f4: return "GL_FRAGMENT_SHADER_INVOCATIONS_ARB";
        case 0x82f5: return "GL_COMPUTE_SHADER_INVOCATIONS_ARB";
        case 0x82f6: return "GL_CLIPPING_INPUT_PRIMITIVES_ARB";
        case 0x82f7: return "GL_CLIPPING_OUTPUT_PRIMITIVES_ARB";
#endif
#if defined(GL_ARB_sparse_buffer)
        case 0x82f8: return "GL_SPARSE_BUFFER_PAGE_SIZE_ARB";
#endif
        case 0x82f9:
#if defined(GL_VERSION_4_5)
                     return "GL_MAX_CULL_DISTANCES";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_MAX_CULL_DISTANCES_EXT";
#endif
            break;
        case 0x82fa:
#if defined(GL_VERSION_4_5)
                     return "GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES";
#endif
#if defined(GL_EXT_clip_cull_distance)
                     return "GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT";
#endif
            break;
        case 0x82fb:
#if defined(GL_VERSION_4_5)
                     return "GL_CONTEXT_RELEASE_BEHAVIOR";
#endif
#if defined(GL_KHR_context_flush_control)
                     return "GL_CONTEXT_RELEASE_BEHAVIOR_KHR";
#endif
            break;
        case 0x82fc:
#if defined(GL_VERSION_4_5)
                     return "GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH";
#endif
#if defined(GL_KHR_context_flush_control)
                     return "GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR";
#endif
            break;
#if defined(GL_SGIX_convolution_accuracy)
        case 0x8316: return "GL_CONVOLUTION_HINT_SGIX";
#endif
#if defined(GL_SGIX_ycrcba)
        case 0x8318: return "GL_YCRCB_SGIX";
        case 0x8319: return "GL_YCRCBA_SGIX";
#endif
#if defined(GL_SGIX_blend_alpha_minmax)
        case 0x8320: return "GL_ALPHA_MIN_SGIX";
        case 0x8321: return "GL_ALPHA_MAX_SGIX";
#endif
#if defined(GL_SGIX_scalebias_hint)
        case 0x8322: return "GL_SCALEBIAS_HINT_SGIX";
#endif
#if defined(GL_SGIX_async)
        case 0x8329: return "GL_ASYNC_MARKER_SGIX";
#endif
#if defined(GL_SGIX_pixel_texture)
        case 0x832b: return "GL_PIXEL_TEX_GEN_MODE_SGIX";
#endif
#if defined(GL_SGIX_async_histogram)
        case 0x832c: return "GL_ASYNC_HISTOGRAM_SGIX";
        case 0x832d: return "GL_MAX_ASYNC_HISTOGRAM_SGIX";
#endif
#if defined(GL_EXT_pixel_transform)
        case 0x8330: return "GL_PIXEL_TRANSFORM_2D_EXT";
        case 0x8331: return "GL_PIXEL_MAG_FILTER_EXT";
        case 0x8332: return "GL_PIXEL_MIN_FILTER_EXT";
        case 0x8333: return "GL_PIXEL_CUBIC_WEIGHT_EXT";
        case 0x8334: return "GL_CUBIC_EXT";
        case 0x8335: return "GL_AVERAGE_EXT";
        case 0x8336: return "GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT";
        case 0x8337: return "GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT";
        case 0x8338: return "GL_PIXEL_TRANSFORM_2D_MATRIX_EXT";
#endif
#if defined(GL_EXT_light_texture)
        case 0x8349: return "GL_FRAGMENT_MATERIAL_EXT";
        case 0x834a: return "GL_FRAGMENT_NORMAL_EXT";
        case 0x834c: return "GL_FRAGMENT_COLOR_EXT";
        case 0x834d: return "GL_ATTENUATION_EXT";
        case 0x834e: return "GL_SHADOW_ATTENUATION_EXT";
        case 0x834f: return "GL_TEXTURE_APPLICATION_MODE_EXT";
        case 0x8350: return "GL_TEXTURE_LIGHT_EXT";
        case 0x8351: return "GL_TEXTURE_MATERIAL_FACE_EXT";
        case 0x8352: return "GL_TEXTURE_MATERIAL_PARAMETER_EXT";
#endif
#if defined(GL_SGIS_pixel_texture)
        case 0x8353: return "GL_PIXEL_TEXTURE_SGIS";
        case 0x8354: return "GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS";
        case 0x8355: return "GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS";
        case 0x8356: return "GL_PIXEL_GROUP_COLOR_SGIS";
#endif
#if defined(GL_SGIX_async_pixel)
        case 0x835c: return "GL_ASYNC_TEX_IMAGE_SGIX";
        case 0x835d: return "GL_ASYNC_DRAW_PIXELS_SGIX";
        case 0x835e: return "GL_ASYNC_READ_PIXELS_SGIX";
        case 0x835f: return "GL_MAX_ASYNC_TEX_IMAGE_SGIX";
        case 0x8360: return "GL_MAX_ASYNC_DRAW_PIXELS_SGIX";
        case 0x8361: return "GL_MAX_ASYNC_READ_PIXELS_SGIX";
#endif
#if defined(GL_VERSION_1_2)
        case 0x8362: return "GL_UNSIGNED_BYTE_2_3_3_REV";
#endif
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_2_0)
        case 0x8363: return "GL_UNSIGNED_SHORT_5_6_5";
#endif
#if defined(GL_VERSION_1_2)
        case 0x8364: return "GL_UNSIGNED_SHORT_5_6_5_REV";
#endif
        case 0x8365:
#if defined(GL_VERSION_1_2)
                     return "GL_UNSIGNED_SHORT_4_4_4_4_REV";
#endif
#if defined(GL_EXT_read_format_bgra)
                     return "GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT";
#endif
#if defined(GL_IMG_read_format)
                     return "GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG";
#endif
            break;
        case 0x8366:
#if defined(GL_VERSION_1_2)
                     return "GL_UNSIGNED_SHORT_1_5_5_5_REV";
#endif
#if defined(GL_EXT_read_format_bgra)
                     return "GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT";
#endif
            break;
#if defined(GL_VERSION_1_2)
        case 0x8367: return "GL_UNSIGNED_INT_8_8_8_8_REV";
#endif
        case 0x8368:
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_2_10_10_10_REV";
#endif
#if defined(GL_EXT_texture_type_2_10_10_10_REV)
                     return "GL_UNSIGNED_INT_2_10_10_10_REV_EXT";
#endif
            break;
#if defined(GL_SGIX_texture_coordinate_clamp)
        case 0x8369: return "GL_TEXTURE_MAX_CLAMP_S_SGIX";
        case 0x836a: return "GL_TEXTURE_MAX_CLAMP_T_SGIX";
        case 0x836b: return "GL_TEXTURE_MAX_CLAMP_R_SGIX";
#endif
        case 0x8370:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_MIRRORED_REPEAT";
#endif
#if defined(GL_ARB_texture_mirrored_repeat)
                     return "GL_MIRRORED_REPEAT_ARB";
#endif
#if defined(GL_IBM_texture_mirrored_repeat)
                     return "GL_MIRRORED_REPEAT_IBM";
#endif
            break;
#if defined(GL_S3_s3tc)
        case 0x83a0: return "GL_RGB_S3TC";
        case 0x83a1: return "GL_RGB4_S3TC";
        case 0x83a2: return "GL_RGBA_S3TC";
        case 0x83a3: return "GL_RGBA4_S3TC";
        case 0x83a4: return "GL_RGBA_DXT5_S3TC";
        case 0x83a5: return "GL_RGBA4_DXT5_S3TC";
#endif
#if defined(GL_SGIX_vertex_preclip)
        case 0x83ee: return "GL_VERTEX_PRECLIP_SGIX";
        case 0x83ef: return "GL_VERTEX_PRECLIP_HINT_SGIX";
#endif
#if defined(GL_EXT_texture_compression_dxt1) || defined(GL_EXT_texture_compression_s3tc)
        case 0x83f0: return "GL_COMPRESSED_RGB_S3TC_DXT1_EXT";
        case 0x83f1: return "GL_COMPRESSED_RGBA_S3TC_DXT1_EXT";
#endif
        case 0x83f2:
#if defined(GL_ANGLE_texture_compression_dxt3)
                     return "GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE";
#endif
#if defined(GL_EXT_texture_compression_s3tc)
                     return "GL_COMPRESSED_RGBA_S3TC_DXT3_EXT";
#endif
            break;
        case 0x83f3:
#if defined(GL_ANGLE_texture_compression_dxt5)
                     return "GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE";
#endif
#if defined(GL_EXT_texture_compression_s3tc)
                     return "GL_COMPRESSED_RGBA_S3TC_DXT5_EXT";
#endif
            break;
#if defined(GL_INTEL_parallel_arrays)
        case 0x83f4: return "GL_PARALLEL_ARRAYS_INTEL";
        case 0x83f5: return "GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL";
        case 0x83f6: return "GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL";
        case 0x83f7: return "GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL";
        case 0x83f8: return "GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL";
#endif
#if defined(GL_INTEL_performance_query)
        case 0x83f9: return "GL_PERFQUERY_DONOT_FLUSH_INTEL";
        case 0x83fa: return "GL_PERFQUERY_FLUSH_INTEL";
        case 0x83fb: return "GL_PERFQUERY_WAIT_INTEL";
#endif
#if defined(GL_INTEL_conservative_rasterization)
        case 0x83fe: return "GL_CONSERVATIVE_RASTERIZATION_INTEL";
#endif
#if defined(GL_INTEL_map_texture)
        case 0x83ff: return "GL_TEXTURE_MEMORY_LAYOUT_INTEL";
#endif
#if defined(GL_SGIX_fragment_lighting)
        case 0x8400: return "GL_FRAGMENT_LIGHTING_SGIX";
        case 0x8401: return "GL_FRAGMENT_COLOR_MATERIAL_SGIX";
        case 0x8402: return "GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX";
        case 0x8403: return "GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX";
        case 0x8404: return "GL_MAX_FRAGMENT_LIGHTS_SGIX";
        case 0x8405: return "GL_MAX_ACTIVE_LIGHTS_SGIX";
        case 0x8406: return "GL_CURRENT_RASTER_NORMAL_SGIX";
        case 0x8407: return "GL_LIGHT_ENV_MODE_SGIX";
        case 0x8408: return "GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX";
        case 0x8409: return "GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX";
        case 0x840a: return "GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX";
        case 0x840b: return "GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX";
        case 0x840c: return "GL_FRAGMENT_LIGHT0_SGIX";
        case 0x840d: return "GL_FRAGMENT_LIGHT1_SGIX";
        case 0x840e: return "GL_FRAGMENT_LIGHT2_SGIX";
        case 0x840f: return "GL_FRAGMENT_LIGHT3_SGIX";
        case 0x8410: return "GL_FRAGMENT_LIGHT4_SGIX";
        case 0x8411: return "GL_FRAGMENT_LIGHT5_SGIX";
        case 0x8412: return "GL_FRAGMENT_LIGHT6_SGIX";
        case 0x8413: return "GL_FRAGMENT_LIGHT7_SGIX";
#endif
#if defined(GL_SGIX_resample)
        case 0x842e: return "GL_PACK_RESAMPLE_SGIX";
        case 0x842f: return "GL_UNPACK_RESAMPLE_SGIX";
        case 0x8430: return "GL_RESAMPLE_DECIMATE_SGIX";
        case 0x8433: return "GL_RESAMPLE_REPLICATE_SGIX";
        case 0x8434: return "GL_RESAMPLE_ZERO_FILL_SGIX";
#endif
#if defined(GL_EXT_coordinate_frame)
        case 0x8439: return "GL_TANGENT_ARRAY_EXT";
        case 0x843a: return "GL_BINORMAL_ARRAY_EXT";
        case 0x843b: return "GL_CURRENT_TANGENT_EXT";
        case 0x843c: return "GL_CURRENT_BINORMAL_EXT";
        case 0x843e: return "GL_TANGENT_ARRAY_TYPE_EXT";
        case 0x843f: return "GL_TANGENT_ARRAY_STRIDE_EXT";
        case 0x8440: return "GL_BINORMAL_ARRAY_TYPE_EXT";
        case 0x8441: return "GL_BINORMAL_ARRAY_STRIDE_EXT";
        case 0x8442: return "GL_TANGENT_ARRAY_POINTER_EXT";
        case 0x8443: return "GL_BINORMAL_ARRAY_POINTER_EXT";
        case 0x8444: return "GL_MAP1_TANGENT_EXT";
        case 0x8445: return "GL_MAP2_TANGENT_EXT";
        case 0x8446: return "GL_MAP1_BINORMAL_EXT";
        case 0x8447: return "GL_MAP2_BINORMAL_EXT";
#endif
#if defined(GL_SGIX_clipmap)
        case 0x844d: return "GL_NEAREST_CLIPMAP_NEAREST_SGIX";
        case 0x844e: return "GL_NEAREST_CLIPMAP_LINEAR_SGIX";
        case 0x844f: return "GL_LINEAR_CLIPMAP_NEAREST_SGIX";
#endif
        case 0x8450:
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE_SOURCE";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_SOURCE_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_SRC";
#endif
            break;
        case 0x8451:
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD";
#endif
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_EXT";
#endif
            break;
        case 0x8452:
#if defined(GL_VERSION_1_4)
                     return "GL_FRAGMENT_DEPTH";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FRAGMENT_DEPTH_EXT";
#endif
            break;
        case 0x8453:
#if defined(GL_VERSION_1_5)
                     return "GL_CURRENT_FOG_COORD";
#endif
#if defined(GL_VERSION_1_4)
                     return "GL_CURRENT_FOG_COORDINATE";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_CURRENT_FOG_COORDINATE_EXT";
#endif
            break;
        case 0x8454:
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE_ARRAY_TYPE";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_ARRAY_TYPE_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_ARRAY_TYPE";
#endif
            break;
        case 0x8455:
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE_ARRAY_STRIDE";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_ARRAY_STRIDE_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_ARRAY_STRIDE";
#endif
            break;
        case 0x8456:
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE_ARRAY_POINTER";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_ARRAY_POINTER_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_ARRAY_POINTER";
#endif
            break;
        case 0x8457:
#if defined(GL_VERSION_1_4)
                     return "GL_FOG_COORDINATE_ARRAY";
#endif
#if defined(GL_EXT_fog_coord)
                     return "GL_FOG_COORDINATE_ARRAY_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_ARRAY";
#endif
            break;
        case 0x8458:
#if defined(GL_VERSION_1_4)
                     return "GL_COLOR_SUM";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_COLOR_SUM_ARB";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_COLOR_SUM_EXT";
#endif
            break;
        case 0x8459:
#if defined(GL_VERSION_1_4)
                     return "GL_CURRENT_SECONDARY_COLOR";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_CURRENT_SECONDARY_COLOR_EXT";
#endif
            break;
        case 0x845a:
#if defined(GL_VERSION_1_4)
                     return "GL_SECONDARY_COLOR_ARRAY_SIZE";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_SECONDARY_COLOR_ARRAY_SIZE_EXT";
#endif
            break;
        case 0x845b:
#if defined(GL_VERSION_1_4)
                     return "GL_SECONDARY_COLOR_ARRAY_TYPE";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_SECONDARY_COLOR_ARRAY_TYPE_EXT";
#endif
            break;
        case 0x845c:
#if defined(GL_VERSION_1_4)
                     return "GL_SECONDARY_COLOR_ARRAY_STRIDE";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT";
#endif
            break;
        case 0x845d:
#if defined(GL_VERSION_1_4)
                     return "GL_SECONDARY_COLOR_ARRAY_POINTER";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_SECONDARY_COLOR_ARRAY_POINTER_EXT";
#endif
            break;
        case 0x845e:
#if defined(GL_VERSION_1_4)
                     return "GL_SECONDARY_COLOR_ARRAY";
#endif
#if defined(GL_EXT_secondary_color)
                     return "GL_SECONDARY_COLOR_ARRAY_EXT";
#endif
            break;
#if defined(GL_VERSION_2_1)
        case 0x845f: return "GL_CURRENT_RASTER_SECONDARY_COLOR";
#endif
#if defined(GL_VERSION_1_2) || defined(GL_ES_VERSION_2_0)
        case 0x846d: return "GL_ALIASED_POINT_SIZE_RANGE";
        case 0x846e: return "GL_ALIASED_LINE_WIDTH_RANGE";
#endif
#if defined(GL_REND_screen_coordinates)
        case 0x8490: return "GL_SCREEN_COORDINATES_REND";
        case 0x8491: return "GL_INVERTED_SCREEN_W_REND";
#endif
        case 0x84c0:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE0";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE0_ARB";
#endif
            break;
        case 0x84c1:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE1";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE1_ARB";
#endif
            break;
        case 0x84c2:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE2";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE2_ARB";
#endif
            break;
        case 0x84c3:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE3";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE3_ARB";
#endif
            break;
        case 0x84c4:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE4";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE4_ARB";
#endif
            break;
        case 0x84c5:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE5";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE5_ARB";
#endif
            break;
        case 0x84c6:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE6";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE6_ARB";
#endif
            break;
        case 0x84c7:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE7";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE7_ARB";
#endif
            break;
        case 0x84c8:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE8";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE8_ARB";
#endif
            break;
        case 0x84c9:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE9";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE9_ARB";
#endif
            break;
        case 0x84ca:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE10";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE10_ARB";
#endif
            break;
        case 0x84cb:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE11";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE11_ARB";
#endif
            break;
        case 0x84cc:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE12";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE12_ARB";
#endif
            break;
        case 0x84cd:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE13";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE13_ARB";
#endif
            break;
        case 0x84ce:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE14";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE14_ARB";
#endif
            break;
        case 0x84cf:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE15";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE15_ARB";
#endif
            break;
        case 0x84d0:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE16";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE16_ARB";
#endif
            break;
        case 0x84d1:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE17";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE17_ARB";
#endif
            break;
        case 0x84d2:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE18";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE18_ARB";
#endif
            break;
        case 0x84d3:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE19";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE19_ARB";
#endif
            break;
        case 0x84d4:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE20";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE20_ARB";
#endif
            break;
        case 0x84d5:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE21";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE21_ARB";
#endif
            break;
        case 0x84d6:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE22";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE22_ARB";
#endif
            break;
        case 0x84d7:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE23";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE23_ARB";
#endif
            break;
        case 0x84d8:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE24";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE24_ARB";
#endif
            break;
        case 0x84d9:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE25";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE25_ARB";
#endif
            break;
        case 0x84da:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE26";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE26_ARB";
#endif
            break;
        case 0x84db:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE27";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE27_ARB";
#endif
            break;
        case 0x84dc:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE28";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE28_ARB";
#endif
            break;
        case 0x84dd:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE29";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE29_ARB";
#endif
            break;
        case 0x84de:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE30";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE30_ARB";
#endif
            break;
        case 0x84df:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE31";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_TEXTURE31_ARB";
#endif
            break;
        case 0x84e0:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_ACTIVE_TEXTURE";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_ACTIVE_TEXTURE_ARB";
#endif
            break;
        case 0x84e1:
#if defined(GL_VERSION_1_3)
                     return "GL_CLIENT_ACTIVE_TEXTURE";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_CLIENT_ACTIVE_TEXTURE_ARB";
#endif
            break;
        case 0x84e2:
#if defined(GL_VERSION_1_3)
                     return "GL_MAX_TEXTURE_UNITS";
#endif
#if defined(GL_ARB_multitexture)
                     return "GL_MAX_TEXTURE_UNITS_ARB";
#endif
            break;
        case 0x84e3:
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV";
#endif
#if defined(GL_VERSION_1_3)
                     return "GL_TRANSPOSE_MODELVIEW_MATRIX";
#endif
#if defined(GL_ARB_transpose_matrix)
                     return "GL_TRANSPOSE_MODELVIEW_MATRIX_ARB";
#endif
            break;
        case 0x84e4:
#if defined(GL_NV_path_rendering)
                     return "GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV";
#endif
#if defined(GL_VERSION_1_3)
                     return "GL_TRANSPOSE_PROJECTION_MATRIX";
#endif
#if defined(GL_ARB_transpose_matrix)
                     return "GL_TRANSPOSE_PROJECTION_MATRIX_ARB";
#endif
            break;
        case 0x84e5:
#if defined(GL_VERSION_1_3)
                     return "GL_TRANSPOSE_TEXTURE_MATRIX";
#endif
#if defined(GL_ARB_transpose_matrix)
                     return "GL_TRANSPOSE_TEXTURE_MATRIX_ARB";
#endif
            break;
        case 0x84e6:
#if defined(GL_VERSION_1_3)
                     return "GL_TRANSPOSE_COLOR_MATRIX";
#endif
#if defined(GL_ARB_transpose_matrix)
                     return "GL_TRANSPOSE_COLOR_MATRIX_ARB";
#endif
            break;
        case 0x84e7:
#if defined(GL_VERSION_1_3)
                     return "GL_SUBTRACT";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SUBTRACT_ARB";
#endif
            break;
        case 0x84e8:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_RENDERBUFFER_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_MAX_RENDERBUFFER_SIZE_EXT";
#endif
            break;
        case 0x84e9:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_ALPHA";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_ALPHA_ARB";
#endif
            break;
        case 0x84ea:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_LUMINANCE";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_LUMINANCE_ARB";
#endif
            break;
        case 0x84eb:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_LUMINANCE_ALPHA";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_LUMINANCE_ALPHA_ARB";
#endif
            break;
        case 0x84ec:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_INTENSITY";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_INTENSITY_ARB";
#endif
            break;
        case 0x84ed:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_RGB";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_RGB_ARB";
#endif
            break;
        case 0x84ee:
#if defined(GL_VERSION_1_3)
                     return "GL_COMPRESSED_RGBA";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_RGBA_ARB";
#endif
            break;
        case 0x84ef:
#if defined(GL_VERSION_1_3)
                     return "GL_TEXTURE_COMPRESSION_HINT";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_TEXTURE_COMPRESSION_HINT_ARB";
#endif
            break;
#if defined(GL_VERSION_4_0)
        case 0x84f0: return "GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER";
        case 0x84f1: return "GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER";
#endif
#if defined(GL_NV_fence)
        case 0x84f2: return "GL_ALL_COMPLETED_NV";
        case 0x84f3: return "GL_FENCE_STATUS_NV";
        case 0x84f4: return "GL_FENCE_CONDITION_NV";
#endif
        case 0x84f5:
#if defined(GL_VERSION_3_1)
                     return "GL_TEXTURE_RECTANGLE";
#endif
#if defined(GL_ARB_texture_rectangle)
                     return "GL_TEXTURE_RECTANGLE_ARB";
#endif
#if defined(GL_NV_texture_rectangle)
                     return "GL_TEXTURE_RECTANGLE_NV";
#endif
            break;
        case 0x84f6:
#if defined(GL_VERSION_3_1)
                     return "GL_TEXTURE_BINDING_RECTANGLE";
#endif
#if defined(GL_ARB_texture_rectangle)
                     return "GL_TEXTURE_BINDING_RECTANGLE_ARB";
#endif
#if defined(GL_NV_texture_rectangle)
                     return "GL_TEXTURE_BINDING_RECTANGLE_NV";
#endif
            break;
        case 0x84f7:
#if defined(GL_VERSION_3_1)
                     return "GL_PROXY_TEXTURE_RECTANGLE";
#endif
#if defined(GL_ARB_texture_rectangle)
                     return "GL_PROXY_TEXTURE_RECTANGLE_ARB";
#endif
#if defined(GL_NV_texture_rectangle)
                     return "GL_PROXY_TEXTURE_RECTANGLE_NV";
#endif
            break;
        case 0x84f8:
#if defined(GL_VERSION_3_1)
                     return "GL_MAX_RECTANGLE_TEXTURE_SIZE";
#endif
#if defined(GL_ARB_texture_rectangle)
                     return "GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB";
#endif
#if defined(GL_NV_texture_rectangle)
                     return "GL_MAX_RECTANGLE_TEXTURE_SIZE_NV";
#endif
            break;
        case 0x84f9:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_DEPTH_STENCIL";
#endif
#if defined(GL_EXT_packed_depth_stencil)
                     return "GL_DEPTH_STENCIL_EXT";
#endif
#if defined(GL_NV_packed_depth_stencil)
                     return "GL_DEPTH_STENCIL_NV";
#endif
#if defined(GL_OES_packed_depth_stencil)
                     return "GL_DEPTH_STENCIL_OES";
#endif
            break;
        case 0x84fa:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_24_8";
#endif
#if defined(GL_EXT_packed_depth_stencil)
                     return "GL_UNSIGNED_INT_24_8_EXT";
#endif
#if defined(GL_NV_packed_depth_stencil)
                     return "GL_UNSIGNED_INT_24_8_NV";
#endif
#if defined(GL_OES_packed_depth_stencil)
                     return "GL_UNSIGNED_INT_24_8_OES";
#endif
            break;
        case 0x84fd:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_4)
                     return "GL_MAX_TEXTURE_LOD_BIAS";
#endif
#if defined(GL_EXT_texture_lod_bias)
                     return "GL_MAX_TEXTURE_LOD_BIAS_EXT";
#endif
            break;
#if defined(GL_EXT_texture_filter_anisotropic)
        case 0x84fe: return "GL_TEXTURE_MAX_ANISOTROPY_EXT";
        case 0x84ff: return "GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT";
#endif
        case 0x8500:
#if defined(GL_VERSION_1_4)
                     return "GL_TEXTURE_FILTER_CONTROL";
#endif
#if defined(GL_EXT_texture_lod_bias)
                     return "GL_TEXTURE_FILTER_CONTROL_EXT";
#endif
            break;
        case 0x8501:
#if defined(GL_VERSION_1_4)
                     return "GL_TEXTURE_LOD_BIAS";
#endif
#if defined(GL_EXT_texture_lod_bias)
                     return "GL_TEXTURE_LOD_BIAS_EXT";
#endif
            break;
#if defined(GL_EXT_vertex_weighting)
        case 0x8502: return "GL_MODELVIEW1_STACK_DEPTH_EXT";
#endif
#if defined(GL_NV_texture_env_combine4)
        case 0x8503: return "GL_COMBINE4_NV";
#endif
#if defined(GL_NV_light_max_exponent)
        case 0x8504: return "GL_MAX_SHININESS_NV";
        case 0x8505: return "GL_MAX_SPOT_EXPONENT_NV";
#endif
#if defined(GL_EXT_vertex_weighting)
        case 0x8506: return "GL_MODELVIEW1_MATRIX_EXT";
#endif
        case 0x8507:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_INCR_WRAP";
#endif
#if defined(GL_EXT_stencil_wrap)
                     return "GL_INCR_WRAP_EXT";
#endif
            break;
        case 0x8508:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_4)
                     return "GL_DECR_WRAP";
#endif
#if defined(GL_EXT_stencil_wrap)
                     return "GL_DECR_WRAP_EXT";
#endif
            break;
#if defined(GL_EXT_vertex_weighting)
        case 0x8509: return "GL_VERTEX_WEIGHTING_EXT";
#endif
        case 0x850a:
#if defined(GL_ARB_vertex_blend)
                     return "GL_MODELVIEW1_ARB";
#endif
#if defined(GL_EXT_vertex_weighting)
                     return "GL_MODELVIEW1_EXT";
#endif
            break;
#if defined(GL_EXT_vertex_weighting)
        case 0x850b: return "GL_CURRENT_VERTEX_WEIGHT_EXT";
        case 0x850c: return "GL_VERTEX_WEIGHT_ARRAY_EXT";
        case 0x850d: return "GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT";
        case 0x850e: return "GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT";
        case 0x850f: return "GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT";
        case 0x8510: return "GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT";
#endif
        case 0x8511:
#if defined(GL_VERSION_1_3)
                     return "GL_NORMAL_MAP";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_NORMAL_MAP_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_NORMAL_MAP_EXT";
#endif
#if defined(GL_NV_texgen_reflection)
                     return "GL_NORMAL_MAP_NV";
#endif
            break;
        case 0x8512:
#if defined(GL_VERSION_1_3)
                     return "GL_REFLECTION_MAP";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_REFLECTION_MAP_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_REFLECTION_MAP_EXT";
#endif
#if defined(GL_NV_texgen_reflection)
                     return "GL_REFLECTION_MAP_NV";
#endif
            break;
        case 0x8513:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_EXT";
#endif
            break;
        case 0x8514:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_BINDING_CUBE_MAP";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_EXT";
#endif
            break;
        case 0x8515:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_X";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT";
#endif
            break;
        case 0x8516:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_X";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT";
#endif
            break;
        case 0x8517:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Y";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT";
#endif
            break;
        case 0x8518:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Y";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT";
#endif
            break;
        case 0x8519:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Z";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT";
#endif
            break;
        case 0x851a:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Z";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT";
#endif
            break;
        case 0x851b:
#if defined(GL_VERSION_1_3)
                     return "GL_PROXY_TEXTURE_CUBE_MAP";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_PROXY_TEXTURE_CUBE_MAP_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_PROXY_TEXTURE_CUBE_MAP_EXT";
#endif
            break;
        case 0x851c:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_CUBE_MAP_TEXTURE_SIZE";
#endif
#if defined(GL_ARB_texture_cube_map)
                     return "GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB";
#endif
#if defined(GL_EXT_texture_cube_map)
                     return "GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT";
#endif
            break;
        case 0x851d:
#if defined(GL_APPLE_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_APPLE";
#endif
#if defined(GL_NV_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_NV";
#endif
            break;
        case 0x851e:
#if defined(GL_APPLE_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE";
#endif
#if defined(GL_NV_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_LENGTH_NV";
#endif
            break;
        case 0x851f:
#if defined(GL_NV_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_VALID_NV";
#endif
#if defined(GL_APPLE_vertex_array_range)
                     return "GL_VERTEX_ARRAY_STORAGE_HINT_APPLE";
#endif
            break;
#if defined(GL_NV_vertex_array_range)
        case 0x8520: return "GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV";
#endif
        case 0x8521:
#if defined(GL_APPLE_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_POINTER_APPLE";
#endif
#if defined(GL_NV_vertex_array_range)
                     return "GL_VERTEX_ARRAY_RANGE_POINTER_NV";
#endif
            break;
#if defined(GL_NV_register_combiners)
        case 0x8522: return "GL_REGISTER_COMBINERS_NV";
        case 0x8523: return "GL_VARIABLE_A_NV";
        case 0x8524: return "GL_VARIABLE_B_NV";
        case 0x8525: return "GL_VARIABLE_C_NV";
        case 0x8526: return "GL_VARIABLE_D_NV";
        case 0x8527: return "GL_VARIABLE_E_NV";
        case 0x8528: return "GL_VARIABLE_F_NV";
        case 0x8529: return "GL_VARIABLE_G_NV";
        case 0x852a: return "GL_CONSTANT_COLOR0_NV";
        case 0x852b: return "GL_CONSTANT_COLOR1_NV";
#endif
#if defined(GL_NV_path_rendering)
        case 0x852c: return "GL_PRIMARY_COLOR_NV";
        case 0x852d: return "GL_SECONDARY_COLOR_NV";
#endif
#if defined(GL_NV_register_combiners)
        case 0x852e: return "GL_SPARE0_NV";
        case 0x852f: return "GL_SPARE1_NV";
        case 0x8530: return "GL_DISCARD_NV";
        case 0x8531: return "GL_E_TIMES_F_NV";
        case 0x8532: return "GL_SPARE0_PLUS_SECONDARY_COLOR_NV";
#endif
#if defined(GL_NV_vertex_array_range2)
        case 0x8533: return "GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV";
#endif
#if defined(GL_NV_multisample_filter_hint)
        case 0x8534: return "GL_MULTISAMPLE_FILTER_HINT_NV";
#endif
#if defined(GL_NV_register_combiners2)
        case 0x8535: return "GL_PER_STAGE_CONSTANTS_NV";
#endif
#if defined(GL_NV_register_combiners)
        case 0x8536: return "GL_UNSIGNED_IDENTITY_NV";
        case 0x8537: return "GL_UNSIGNED_INVERT_NV";
        case 0x8538: return "GL_EXPAND_NORMAL_NV";
        case 0x8539: return "GL_EXPAND_NEGATE_NV";
        case 0x853a: return "GL_HALF_BIAS_NORMAL_NV";
        case 0x853b: return "GL_HALF_BIAS_NEGATE_NV";
        case 0x853c: return "GL_SIGNED_IDENTITY_NV";
        case 0x853d: return "GL_SIGNED_NEGATE_NV";
        case 0x853e: return "GL_SCALE_BY_TWO_NV";
        case 0x853f: return "GL_SCALE_BY_FOUR_NV";
        case 0x8540: return "GL_SCALE_BY_ONE_HALF_NV";
        case 0x8541: return "GL_BIAS_BY_NEGATIVE_ONE_HALF_NV";
        case 0x8542: return "GL_COMBINER_INPUT_NV";
        case 0x8543: return "GL_COMBINER_MAPPING_NV";
        case 0x8544: return "GL_COMBINER_COMPONENT_USAGE_NV";
        case 0x8545: return "GL_COMBINER_AB_DOT_PRODUCT_NV";
        case 0x8546: return "GL_COMBINER_CD_DOT_PRODUCT_NV";
        case 0x8547: return "GL_COMBINER_MUX_SUM_NV";
        case 0x8548: return "GL_COMBINER_SCALE_NV";
        case 0x8549: return "GL_COMBINER_BIAS_NV";
        case 0x854a: return "GL_COMBINER_AB_OUTPUT_NV";
        case 0x854b: return "GL_COMBINER_CD_OUTPUT_NV";
        case 0x854c: return "GL_COMBINER_SUM_OUTPUT_NV";
        case 0x854d: return "GL_MAX_GENERAL_COMBINERS_NV";
        case 0x854e: return "GL_NUM_GENERAL_COMBINERS_NV";
        case 0x854f: return "GL_COLOR_SUM_CLAMP_NV";
        case 0x8550: return "GL_COMBINER0_NV";
        case 0x8551: return "GL_COMBINER1_NV";
        case 0x8552: return "GL_COMBINER2_NV";
        case 0x8553: return "GL_COMBINER3_NV";
        case 0x8554: return "GL_COMBINER4_NV";
        case 0x8555: return "GL_COMBINER5_NV";
        case 0x8556: return "GL_COMBINER6_NV";
        case 0x8557: return "GL_COMBINER7_NV";
#endif
#if defined(GL_NV_primitive_restart)
        case 0x8558: return "GL_PRIMITIVE_RESTART_NV";
        case 0x8559: return "GL_PRIMITIVE_RESTART_INDEX_NV";
#endif
#if defined(GL_NV_fog_distance)
        case 0x855a: return "GL_FOG_DISTANCE_MODE_NV";
        case 0x855b: return "GL_EYE_RADIAL_NV";
        case 0x855c: return "GL_EYE_PLANE_ABSOLUTE_NV";
#endif
#if defined(GL_NV_texgen_emboss)
        case 0x855d: return "GL_EMBOSS_LIGHT_NV";
        case 0x855e: return "GL_EMBOSS_CONSTANT_NV";
        case 0x855f: return "GL_EMBOSS_MAP_NV";
#endif
#if defined(GL_INGR_color_clamp)
        case 0x8560: return "GL_RED_MIN_CLAMP_INGR";
        case 0x8561: return "GL_GREEN_MIN_CLAMP_INGR";
        case 0x8562: return "GL_BLUE_MIN_CLAMP_INGR";
        case 0x8563: return "GL_ALPHA_MIN_CLAMP_INGR";
        case 0x8564: return "GL_RED_MAX_CLAMP_INGR";
        case 0x8565: return "GL_GREEN_MAX_CLAMP_INGR";
        case 0x8566: return "GL_BLUE_MAX_CLAMP_INGR";
        case 0x8567: return "GL_ALPHA_MAX_CLAMP_INGR";
#endif
#if defined(GL_INGR_interlace_read)
        case 0x8568: return "GL_INTERLACE_READ_INGR";
#endif
        case 0x8570:
#if defined(GL_VERSION_1_3)
                     return "GL_COMBINE";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_COMBINE_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_COMBINE_EXT";
#endif
            break;
        case 0x8571:
#if defined(GL_VERSION_1_3)
                     return "GL_COMBINE_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_COMBINE_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_COMBINE_RGB_EXT";
#endif
            break;
        case 0x8572:
#if defined(GL_VERSION_1_3)
                     return "GL_COMBINE_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_COMBINE_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_COMBINE_ALPHA_EXT";
#endif
            break;
        case 0x8573:
#if defined(GL_VERSION_1_3)
                     return "GL_RGB_SCALE";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_RGB_SCALE_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_RGB_SCALE_EXT";
#endif
            break;
        case 0x8574:
#if defined(GL_VERSION_1_3)
                     return "GL_ADD_SIGNED";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_ADD_SIGNED_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_ADD_SIGNED_EXT";
#endif
            break;
        case 0x8575:
#if defined(GL_VERSION_1_3)
                     return "GL_INTERPOLATE";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_INTERPOLATE_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_INTERPOLATE_EXT";
#endif
            break;
        case 0x8576:
#if defined(GL_VERSION_1_3)
                     return "GL_CONSTANT";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_CONSTANT_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_CONSTANT_EXT";
#endif
#if defined(GL_NV_path_rendering)
                     return "GL_CONSTANT_NV";
#endif
            break;
        case 0x8577:
#if defined(GL_VERSION_1_3)
                     return "GL_PRIMARY_COLOR";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_PRIMARY_COLOR_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_PRIMARY_COLOR_EXT";
#endif
            break;
        case 0x8578:
#if defined(GL_VERSION_1_3)
                     return "GL_PREVIOUS";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_PREVIOUS_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_PREVIOUS_EXT";
#endif
            break;
        case 0x8580:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE0_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE0_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE0_RGB_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC0_RGB";
#endif
            break;
        case 0x8581:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE1_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE1_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE1_RGB_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC1_RGB";
#endif
            break;
        case 0x8582:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE2_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE2_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE2_RGB_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC2_RGB";
#endif
            break;
#if defined(GL_NV_texture_env_combine4)
        case 0x8583: return "GL_SOURCE3_RGB_NV";
#endif
        case 0x8588:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE0_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE0_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE0_ALPHA_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC0_ALPHA";
#endif
            break;
        case 0x8589:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE1_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE1_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE1_ALPHA_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC1_ALPHA";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_SRC1_ALPHA_EXT";
#endif
            break;
        case 0x858a:
#if defined(GL_VERSION_1_3)
                     return "GL_SOURCE2_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_SOURCE2_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_SOURCE2_ALPHA_EXT";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_SRC2_ALPHA";
#endif
            break;
#if defined(GL_NV_texture_env_combine4)
        case 0x858b: return "GL_SOURCE3_ALPHA_NV";
#endif
        case 0x8590:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND0_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND0_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND0_RGB_EXT";
#endif
            break;
        case 0x8591:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND1_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND1_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND1_RGB_EXT";
#endif
            break;
        case 0x8592:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND2_RGB";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND2_RGB_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND2_RGB_EXT";
#endif
            break;
#if defined(GL_NV_texture_env_combine4)
        case 0x8593: return "GL_OPERAND3_RGB_NV";
#endif
        case 0x8598:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND0_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND0_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND0_ALPHA_EXT";
#endif
            break;
        case 0x8599:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND1_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND1_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND1_ALPHA_EXT";
#endif
            break;
        case 0x859a:
#if defined(GL_VERSION_1_3)
                     return "GL_OPERAND2_ALPHA";
#endif
#if defined(GL_ARB_texture_env_combine)
                     return "GL_OPERAND2_ALPHA_ARB";
#endif
#if defined(GL_EXT_texture_env_combine)
                     return "GL_OPERAND2_ALPHA_EXT";
#endif
            break;
#if defined(GL_NV_texture_env_combine4)
        case 0x859b: return "GL_OPERAND3_ALPHA_NV";
#endif
#if defined(GL_SGIX_subsample)
        case 0x85a0: return "GL_PACK_SUBSAMPLE_RATE_SGIX";
        case 0x85a1: return "GL_UNPACK_SUBSAMPLE_RATE_SGIX";
        case 0x85a2: return "GL_PIXEL_SUBSAMPLE_4444_SGIX";
        case 0x85a3: return "GL_PIXEL_SUBSAMPLE_2424_SGIX";
        case 0x85a4: return "GL_PIXEL_SUBSAMPLE_4242_SGIX";
#endif
#if defined(GL_EXT_texture_perturb_normal)
        case 0x85ae: return "GL_PERTURB_EXT";
        case 0x85af: return "GL_TEXTURE_NORMAL_EXT";
#endif
#if defined(GL_APPLE_specular_vector)
        case 0x85b0: return "GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE";
#endif
#if defined(GL_APPLE_transform_hint)
        case 0x85b1: return "GL_TRANSFORM_HINT_APPLE";
#endif
#if defined(GL_APPLE_client_storage)
        case 0x85b2: return "GL_UNPACK_CLIENT_STORAGE_APPLE";
#endif
#if defined(GL_APPLE_object_purgeable)
        case 0x85b3: return "GL_BUFFER_OBJECT_APPLE";
#endif
#if defined(GL_APPLE_vertex_array_range)
        case 0x85b4: return "GL_STORAGE_CLIENT_APPLE";
#endif
        case 0x85b5:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_VERTEX_ARRAY_BINDING";
#endif
#if defined(GL_APPLE_vertex_array_object)
                     return "GL_VERTEX_ARRAY_BINDING_APPLE";
#endif
#if defined(GL_OES_vertex_array_object)
                     return "GL_VERTEX_ARRAY_BINDING_OES";
#endif
            break;
#if defined(GL_APPLE_texture_range)
        case 0x85b7: return "GL_TEXTURE_RANGE_LENGTH_APPLE";
        case 0x85b8: return "GL_TEXTURE_RANGE_POINTER_APPLE";
#endif
#if defined(GL_APPLE_ycbcr_422)
        case 0x85b9: return "GL_YCBCR_422_APPLE";
#endif
        case 0x85ba:
#if defined(GL_APPLE_rgb_422)
                     return "GL_UNSIGNED_SHORT_8_8_APPLE";
#endif
#if defined(GL_MESA_ycbcr_texture)
                     return "GL_UNSIGNED_SHORT_8_8_MESA";
#endif
            break;
        case 0x85bb:
#if defined(GL_APPLE_rgb_422)
                     return "GL_UNSIGNED_SHORT_8_8_REV_APPLE";
#endif
#if defined(GL_MESA_ycbcr_texture)
                     return "GL_UNSIGNED_SHORT_8_8_REV_MESA";
#endif
            break;
#if defined(GL_APPLE_texture_range)
        case 0x85bc: return "GL_TEXTURE_STORAGE_HINT_APPLE";
        case 0x85bd: return "GL_STORAGE_PRIVATE_APPLE";
        case 0x85be: return "GL_STORAGE_CACHED_APPLE";
        case 0x85bf: return "GL_STORAGE_SHARED_APPLE";
#endif
#if defined(GL_SUN_triangle_list)
        case 0x85c0: return "GL_REPLACEMENT_CODE_ARRAY_SUN";
        case 0x85c1: return "GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN";
        case 0x85c2: return "GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN";
        case 0x85c3: return "GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN";
        case 0x85c4: return "GL_R1UI_V3F_SUN";
        case 0x85c5: return "GL_R1UI_C4UB_V3F_SUN";
        case 0x85c6: return "GL_R1UI_C3F_V3F_SUN";
        case 0x85c7: return "GL_R1UI_N3F_V3F_SUN";
        case 0x85c8: return "GL_R1UI_C4F_N3F_V3F_SUN";
        case 0x85c9: return "GL_R1UI_T2F_V3F_SUN";
        case 0x85ca: return "GL_R1UI_T2F_N3F_V3F_SUN";
        case 0x85cb: return "GL_R1UI_T2F_C4F_N3F_V3F_SUN";
#endif
#if defined(GL_SUN_slice_accum)
        case 0x85cc: return "GL_SLICE_ACCUM_SUN";
#endif
#if defined(GL_SUN_mesh_array)
        case 0x8614: return "GL_QUAD_MESH_SUN";
        case 0x8615: return "GL_TRIANGLE_MESH_SUN";
#endif
        case 0x8620:
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_PROGRAM_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_VERTEX_PROGRAM_NV";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8621: return "GL_VERTEX_STATE_PROGRAM_NV";
#endif
        case 0x8622:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_ENABLED";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB";
#endif
            break;
        case 0x8623:
#if defined(GL_NV_vertex_program)
                     return "GL_ATTRIB_ARRAY_SIZE_NV";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_SIZE";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB";
#endif
            break;
        case 0x8624:
#if defined(GL_NV_vertex_program)
                     return "GL_ATTRIB_ARRAY_STRIDE_NV";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_STRIDE";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB";
#endif
            break;
        case 0x8625:
#if defined(GL_NV_vertex_program)
                     return "GL_ATTRIB_ARRAY_TYPE_NV";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_TYPE";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB";
#endif
            break;
        case 0x8626:
#if defined(GL_NV_vertex_program)
                     return "GL_CURRENT_ATTRIB_NV";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_CURRENT_VERTEX_ATTRIB";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_CURRENT_VERTEX_ATTRIB_ARB";
#endif
            break;
        case 0x8627:
#if defined(GL_ARB_fragment_program)
                     return "GL_PROGRAM_LENGTH_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_PROGRAM_LENGTH_NV";
#endif
            break;
        case 0x8628:
#if defined(GL_ARB_fragment_program)
                     return "GL_PROGRAM_STRING_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_PROGRAM_STRING_NV";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8629: return "GL_MODELVIEW_PROJECTION_NV";
        case 0x862a: return "GL_IDENTITY_NV";
        case 0x862b: return "GL_INVERSE_NV";
        case 0x862c: return "GL_TRANSPOSE_NV";
        case 0x862d: return "GL_INVERSE_TRANSPOSE_NV";
#endif
        case 0x862e:
#if defined(GL_ARB_fragment_program)
                     return "GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV";
#endif
            break;
        case 0x862f:
#if defined(GL_ARB_fragment_program)
                     return "GL_MAX_PROGRAM_MATRICES_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_MAX_TRACK_MATRICES_NV";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8630: return "GL_MATRIX0_NV";
        case 0x8631: return "GL_MATRIX1_NV";
        case 0x8632: return "GL_MATRIX2_NV";
        case 0x8633: return "GL_MATRIX3_NV";
        case 0x8634: return "GL_MATRIX4_NV";
        case 0x8635: return "GL_MATRIX5_NV";
        case 0x8636: return "GL_MATRIX6_NV";
        case 0x8637: return "GL_MATRIX7_NV";
#endif
        case 0x8640:
#if defined(GL_ARB_fragment_program)
                     return "GL_CURRENT_MATRIX_STACK_DEPTH_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_CURRENT_MATRIX_STACK_DEPTH_NV";
#endif
            break;
        case 0x8641:
#if defined(GL_ARB_fragment_program)
                     return "GL_CURRENT_MATRIX_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_CURRENT_MATRIX_NV";
#endif
            break;
        case 0x8642:
#if defined(__glcorearb_h_) || defined(__glext_h_)
                     return "GL_PROGRAM_POINT_SIZE";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_PROGRAM_POINT_SIZE_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_PROGRAM_POINT_SIZE_EXT";
#endif
#if defined(GL_VERSION_2_0)
                     return "GL_VERTEX_PROGRAM_POINT_SIZE";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_PROGRAM_POINT_SIZE_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_VERTEX_PROGRAM_POINT_SIZE_NV";
#endif
            break;
        case 0x8643:
#if defined(GL_VERSION_2_0)
                     return "GL_VERTEX_PROGRAM_TWO_SIDE";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_PROGRAM_TWO_SIDE_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_VERTEX_PROGRAM_TWO_SIDE_NV";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8644: return "GL_PROGRAM_PARAMETER_NV";
#endif
        case 0x8645:
#if defined(GL_NV_vertex_program)
                     return "GL_ATTRIB_ARRAY_POINTER_NV";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_POINTER";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8646: return "GL_PROGRAM_TARGET_NV";
        case 0x8647: return "GL_PROGRAM_RESIDENT_NV";
        case 0x8648: return "GL_TRACK_MATRIX_NV";
        case 0x8649: return "GL_TRACK_MATRIX_TRANSFORM_NV";
        case 0x864a: return "GL_VERTEX_PROGRAM_BINDING_NV";
#endif
        case 0x864b:
#if defined(GL_ARB_fragment_program)
                     return "GL_PROGRAM_ERROR_POSITION_ARB";
#endif
#if defined(GL_NV_vertex_program)
                     return "GL_PROGRAM_ERROR_POSITION_NV";
#endif
            break;
#if defined(GL_NV_texture_shader)
        case 0x864c: return "GL_OFFSET_TEXTURE_RECTANGLE_NV";
        case 0x864d: return "GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV";
        case 0x864e: return "GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV";
#endif
        case 0x864f:
#if defined(__glcorearb_h_) || defined(__glext_h_)
                     return "GL_DEPTH_CLAMP";
#endif
#if defined(GL_NV_depth_clamp)
                     return "GL_DEPTH_CLAMP_NV";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8650: return "GL_VERTEX_ATTRIB_ARRAY0_NV";
        case 0x8651: return "GL_VERTEX_ATTRIB_ARRAY1_NV";
        case 0x8652: return "GL_VERTEX_ATTRIB_ARRAY2_NV";
        case 0x8653: return "GL_VERTEX_ATTRIB_ARRAY3_NV";
        case 0x8654: return "GL_VERTEX_ATTRIB_ARRAY4_NV";
        case 0x8655: return "GL_VERTEX_ATTRIB_ARRAY5_NV";
        case 0x8656: return "GL_VERTEX_ATTRIB_ARRAY6_NV";
        case 0x8657: return "GL_VERTEX_ATTRIB_ARRAY7_NV";
        case 0x8658: return "GL_VERTEX_ATTRIB_ARRAY8_NV";
        case 0x8659: return "GL_VERTEX_ATTRIB_ARRAY9_NV";
        case 0x865a: return "GL_VERTEX_ATTRIB_ARRAY10_NV";
        case 0x865b: return "GL_VERTEX_ATTRIB_ARRAY11_NV";
        case 0x865c: return "GL_VERTEX_ATTRIB_ARRAY12_NV";
        case 0x865d: return "GL_VERTEX_ATTRIB_ARRAY13_NV";
        case 0x865e: return "GL_VERTEX_ATTRIB_ARRAY14_NV";
        case 0x865f: return "GL_VERTEX_ATTRIB_ARRAY15_NV";
        case 0x8660: return "GL_MAP1_VERTEX_ATTRIB0_4_NV";
        case 0x8661: return "GL_MAP1_VERTEX_ATTRIB1_4_NV";
        case 0x8662: return "GL_MAP1_VERTEX_ATTRIB2_4_NV";
        case 0x8663: return "GL_MAP1_VERTEX_ATTRIB3_4_NV";
        case 0x8664: return "GL_MAP1_VERTEX_ATTRIB4_4_NV";
        case 0x8665: return "GL_MAP1_VERTEX_ATTRIB5_4_NV";
        case 0x8666: return "GL_MAP1_VERTEX_ATTRIB6_4_NV";
        case 0x8667: return "GL_MAP1_VERTEX_ATTRIB7_4_NV";
        case 0x8668: return "GL_MAP1_VERTEX_ATTRIB8_4_NV";
        case 0x8669: return "GL_MAP1_VERTEX_ATTRIB9_4_NV";
        case 0x866a: return "GL_MAP1_VERTEX_ATTRIB10_4_NV";
        case 0x866b: return "GL_MAP1_VERTEX_ATTRIB11_4_NV";
        case 0x866c: return "GL_MAP1_VERTEX_ATTRIB12_4_NV";
        case 0x866d: return "GL_MAP1_VERTEX_ATTRIB13_4_NV";
        case 0x866e: return "GL_MAP1_VERTEX_ATTRIB14_4_NV";
        case 0x866f: return "GL_MAP1_VERTEX_ATTRIB15_4_NV";
        case 0x8670: return "GL_MAP2_VERTEX_ATTRIB0_4_NV";
        case 0x8671: return "GL_MAP2_VERTEX_ATTRIB1_4_NV";
        case 0x8672: return "GL_MAP2_VERTEX_ATTRIB2_4_NV";
        case 0x8673: return "GL_MAP2_VERTEX_ATTRIB3_4_NV";
        case 0x8674: return "GL_MAP2_VERTEX_ATTRIB4_4_NV";
        case 0x8675: return "GL_MAP2_VERTEX_ATTRIB5_4_NV";
        case 0x8676: return "GL_MAP2_VERTEX_ATTRIB6_4_NV";
#endif
        case 0x8677:
#if defined(GL_NV_vertex_program)
                     return "GL_MAP2_VERTEX_ATTRIB7_4_NV";
#endif
#if defined(GL_ARB_fragment_program)
                     return "GL_PROGRAM_BINDING_ARB";
#endif
            break;
#if defined(GL_NV_vertex_program)
        case 0x8678: return "GL_MAP2_VERTEX_ATTRIB8_4_NV";
        case 0x8679: return "GL_MAP2_VERTEX_ATTRIB9_4_NV";
        case 0x867a: return "GL_MAP2_VERTEX_ATTRIB10_4_NV";
        case 0x867b: return "GL_MAP2_VERTEX_ATTRIB11_4_NV";
        case 0x867c: return "GL_MAP2_VERTEX_ATTRIB12_4_NV";
        case 0x867d: return "GL_MAP2_VERTEX_ATTRIB13_4_NV";
        case 0x867e: return "GL_MAP2_VERTEX_ATTRIB14_4_NV";
        case 0x867f: return "GL_MAP2_VERTEX_ATTRIB15_4_NV";
#endif
        case 0x86a0:
#if defined(GL_VERSION_1_3)
                     return "GL_TEXTURE_COMPRESSED_IMAGE_SIZE";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB";
#endif
            break;
        case 0x86a1:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_COMPRESSED";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_TEXTURE_COMPRESSED_ARB";
#endif
            break;
        case 0x86a2:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_NUM_COMPRESSED_TEXTURE_FORMATS";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB";
#endif
            break;
        case 0x86a3:
#if defined(GL_VERSION_1_3) || defined(GL_ES_VERSION_2_0)
                     return "GL_COMPRESSED_TEXTURE_FORMATS";
#endif
#if defined(GL_ARB_texture_compression)
                     return "GL_COMPRESSED_TEXTURE_FORMATS_ARB";
#endif
            break;
#if defined(GL_ARB_vertex_blend)
        case 0x86a4: return "GL_MAX_VERTEX_UNITS_ARB";
        case 0x86a5: return "GL_ACTIVE_VERTEX_UNITS_ARB";
        case 0x86a6: return "GL_WEIGHT_SUM_UNITY_ARB";
        case 0x86a7: return "GL_VERTEX_BLEND_ARB";
        case 0x86a8: return "GL_CURRENT_WEIGHT_ARB";
        case 0x86a9: return "GL_WEIGHT_ARRAY_TYPE_ARB";
        case 0x86aa: return "GL_WEIGHT_ARRAY_STRIDE_ARB";
        case 0x86ab: return "GL_WEIGHT_ARRAY_SIZE_ARB";
        case 0x86ac: return "GL_WEIGHT_ARRAY_POINTER_ARB";
        case 0x86ad: return "GL_WEIGHT_ARRAY_ARB";
#endif
        case 0x86ae:
#if defined(GL_VERSION_1_3)
                     return "GL_DOT3_RGB";
#endif
#if defined(GL_ARB_texture_env_dot3)
                     return "GL_DOT3_RGB_ARB";
#endif
            break;
        case 0x86af:
#if defined(GL_VERSION_1_3)
                     return "GL_DOT3_RGBA";
#endif
#if defined(GL_ARB_texture_env_dot3)
                     return "GL_DOT3_RGBA_ARB";
#endif
            break;
#if defined(GL_3DFX_texture_compression_FXT1)
        case 0x86b0: return "GL_COMPRESSED_RGB_FXT1_3DFX";
        case 0x86b1: return "GL_COMPRESSED_RGBA_FXT1_3DFX";
#endif
#if defined(GL_3DFX_multisample)
        case 0x86b2: return "GL_MULTISAMPLE_3DFX";
        case 0x86b3: return "GL_SAMPLE_BUFFERS_3DFX";
        case 0x86b4: return "GL_SAMPLES_3DFX";
#endif
#if defined(GL_NV_evaluators)
        case 0x86c0: return "GL_EVAL_2D_NV";
        case 0x86c1: return "GL_EVAL_TRIANGULAR_2D_NV";
        case 0x86c2: return "GL_MAP_TESSELLATION_NV";
        case 0x86c3: return "GL_MAP_ATTRIB_U_ORDER_NV";
        case 0x86c4: return "GL_MAP_ATTRIB_V_ORDER_NV";
        case 0x86c5: return "GL_EVAL_FRACTIONAL_TESSELLATION_NV";
        case 0x86c6: return "GL_EVAL_VERTEX_ATTRIB0_NV";
        case 0x86c7: return "GL_EVAL_VERTEX_ATTRIB1_NV";
        case 0x86c8: return "GL_EVAL_VERTEX_ATTRIB2_NV";
        case 0x86c9: return "GL_EVAL_VERTEX_ATTRIB3_NV";
        case 0x86ca: return "GL_EVAL_VERTEX_ATTRIB4_NV";
        case 0x86cb: return "GL_EVAL_VERTEX_ATTRIB5_NV";
        case 0x86cc: return "GL_EVAL_VERTEX_ATTRIB6_NV";
        case 0x86cd: return "GL_EVAL_VERTEX_ATTRIB7_NV";
        case 0x86ce: return "GL_EVAL_VERTEX_ATTRIB8_NV";
        case 0x86cf: return "GL_EVAL_VERTEX_ATTRIB9_NV";
        case 0x86d0: return "GL_EVAL_VERTEX_ATTRIB10_NV";
        case 0x86d1: return "GL_EVAL_VERTEX_ATTRIB11_NV";
        case 0x86d2: return "GL_EVAL_VERTEX_ATTRIB12_NV";
        case 0x86d3: return "GL_EVAL_VERTEX_ATTRIB13_NV";
        case 0x86d4: return "GL_EVAL_VERTEX_ATTRIB14_NV";
        case 0x86d5: return "GL_EVAL_VERTEX_ATTRIB15_NV";
        case 0x86d6: return "GL_MAX_MAP_TESSELLATION_NV";
        case 0x86d7: return "GL_MAX_RATIONAL_EVAL_ORDER_NV";
#endif
#if defined(GL_NV_tessellation_program5)
        case 0x86d8: return "GL_MAX_PROGRAM_PATCH_ATTRIBS_NV";
#endif
#if defined(GL_NV_texture_shader)
        case 0x86d9: return "GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV";
        case 0x86da: return "GL_UNSIGNED_INT_S8_S8_8_8_NV";
        case 0x86db: return "GL_UNSIGNED_INT_8_8_S8_S8_REV_NV";
        case 0x86dc: return "GL_DSDT_MAG_INTENSITY_NV";
        case 0x86dd: return "GL_SHADER_CONSISTENT_NV";
        case 0x86de: return "GL_TEXTURE_SHADER_NV";
        case 0x86df: return "GL_SHADER_OPERATION_NV";
        case 0x86e0: return "GL_CULL_MODES_NV";
#endif
        case 0x86e1:
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_2D_MATRIX_NV";
#endif
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_MATRIX_NV";
#endif
            break;
        case 0x86e2:
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_2D_SCALE_NV";
#endif
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_SCALE_NV";
#endif
            break;
        case 0x86e3:
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_2D_BIAS_NV";
#endif
#if defined(GL_NV_texture_shader)
                     return "GL_OFFSET_TEXTURE_BIAS_NV";
#endif
            break;
#if defined(GL_NV_texture_shader)
        case 0x86e4: return "GL_PREVIOUS_TEXTURE_INPUT_NV";
        case 0x86e5: return "GL_CONST_EYE_NV";
        case 0x86e6: return "GL_PASS_THROUGH_NV";
        case 0x86e7: return "GL_CULL_FRAGMENT_NV";
        case 0x86e8: return "GL_OFFSET_TEXTURE_2D_NV";
        case 0x86e9: return "GL_DEPENDENT_AR_TEXTURE_2D_NV";
        case 0x86ea: return "GL_DEPENDENT_GB_TEXTURE_2D_NV";
#endif
#if defined(GL_NV_vdpau_interop)
        case 0x86eb: return "GL_SURFACE_STATE_NV";
#endif
#if defined(GL_NV_texture_shader)
        case 0x86ec: return "GL_DOT_PRODUCT_NV";
        case 0x86ed: return "GL_DOT_PRODUCT_DEPTH_REPLACE_NV";
        case 0x86ee: return "GL_DOT_PRODUCT_TEXTURE_2D_NV";
#endif
#if defined(GL_NV_texture_shader2)
        case 0x86ef: return "GL_DOT_PRODUCT_TEXTURE_3D_NV";
#endif
#if defined(GL_NV_texture_shader)
        case 0x86f0: return "GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV";
        case 0x86f1: return "GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV";
        case 0x86f2: return "GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV";
        case 0x86f3: return "GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV";
        case 0x86f4: return "GL_HILO_NV";
        case 0x86f5: return "GL_DSDT_NV";
        case 0x86f6: return "GL_DSDT_MAG_NV";
        case 0x86f7: return "GL_DSDT_MAG_VIB_NV";
        case 0x86f8: return "GL_HILO16_NV";
        case 0x86f9: return "GL_SIGNED_HILO_NV";
        case 0x86fa: return "GL_SIGNED_HILO16_NV";
        case 0x86fb: return "GL_SIGNED_RGBA_NV";
        case 0x86fc: return "GL_SIGNED_RGBA8_NV";
#endif
#if defined(GL_NV_vdpau_interop)
        case 0x86fd: return "GL_SURFACE_REGISTERED_NV";
#endif
#if defined(GL_NV_texture_shader)
        case 0x86fe: return "GL_SIGNED_RGB_NV";
        case 0x86ff: return "GL_SIGNED_RGB8_NV";
#endif
#if defined(GL_NV_vdpau_interop)
        case 0x8700: return "GL_SURFACE_MAPPED_NV";
#endif
#if defined(GL_NV_texture_shader)
        case 0x8701: return "GL_SIGNED_LUMINANCE_NV";
        case 0x8702: return "GL_SIGNED_LUMINANCE8_NV";
        case 0x8703: return "GL_SIGNED_LUMINANCE_ALPHA_NV";
        case 0x8704: return "GL_SIGNED_LUMINANCE8_ALPHA8_NV";
        case 0x8705: return "GL_SIGNED_ALPHA_NV";
        case 0x8706: return "GL_SIGNED_ALPHA8_NV";
        case 0x8707: return "GL_SIGNED_INTENSITY_NV";
        case 0x8708: return "GL_SIGNED_INTENSITY8_NV";
        case 0x8709: return "GL_DSDT8_NV";
        case 0x870a: return "GL_DSDT8_MAG8_NV";
        case 0x870b: return "GL_DSDT8_MAG8_INTENSITY8_NV";
        case 0x870c: return "GL_SIGNED_RGB_UNSIGNED_ALPHA_NV";
        case 0x870d: return "GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV";
        case 0x870e: return "GL_HI_SCALE_NV";
        case 0x870f: return "GL_LO_SCALE_NV";
        case 0x8710: return "GL_DS_SCALE_NV";
        case 0x8711: return "GL_DT_SCALE_NV";
        case 0x8712: return "GL_MAGNITUDE_SCALE_NV";
        case 0x8713: return "GL_VIBRANCE_SCALE_NV";
        case 0x8714: return "GL_HI_BIAS_NV";
        case 0x8715: return "GL_LO_BIAS_NV";
        case 0x8716: return "GL_DS_BIAS_NV";
        case 0x8717: return "GL_DT_BIAS_NV";
        case 0x8718: return "GL_MAGNITUDE_BIAS_NV";
        case 0x8719: return "GL_VIBRANCE_BIAS_NV";
        case 0x871a: return "GL_TEXTURE_BORDER_VALUES_NV";
        case 0x871b: return "GL_TEXTURE_HI_SIZE_NV";
        case 0x871c: return "GL_TEXTURE_LO_SIZE_NV";
        case 0x871d: return "GL_TEXTURE_DS_SIZE_NV";
        case 0x871e: return "GL_TEXTURE_DT_SIZE_NV";
        case 0x871f: return "GL_TEXTURE_MAG_SIZE_NV";
#endif
#if defined(GL_ARB_vertex_blend)
        case 0x8722: return "GL_MODELVIEW2_ARB";
        case 0x8723: return "GL_MODELVIEW3_ARB";
        case 0x8724: return "GL_MODELVIEW4_ARB";
        case 0x8725: return "GL_MODELVIEW5_ARB";
        case 0x8726: return "GL_MODELVIEW6_ARB";
        case 0x8727: return "GL_MODELVIEW7_ARB";
        case 0x8728: return "GL_MODELVIEW8_ARB";
        case 0x8729: return "GL_MODELVIEW9_ARB";
        case 0x872a: return "GL_MODELVIEW10_ARB";
        case 0x872b: return "GL_MODELVIEW11_ARB";
        case 0x872c: return "GL_MODELVIEW12_ARB";
        case 0x872d: return "GL_MODELVIEW13_ARB";
        case 0x872e: return "GL_MODELVIEW14_ARB";
        case 0x872f: return "GL_MODELVIEW15_ARB";
        case 0x8730: return "GL_MODELVIEW16_ARB";
        case 0x8731: return "GL_MODELVIEW17_ARB";
        case 0x8732: return "GL_MODELVIEW18_ARB";
        case 0x8733: return "GL_MODELVIEW19_ARB";
        case 0x8734: return "GL_MODELVIEW20_ARB";
        case 0x8735: return "GL_MODELVIEW21_ARB";
        case 0x8736: return "GL_MODELVIEW22_ARB";
        case 0x8737: return "GL_MODELVIEW23_ARB";
        case 0x8738: return "GL_MODELVIEW24_ARB";
        case 0x8739: return "GL_MODELVIEW25_ARB";
        case 0x873a: return "GL_MODELVIEW26_ARB";
        case 0x873b: return "GL_MODELVIEW27_ARB";
        case 0x873c: return "GL_MODELVIEW28_ARB";
        case 0x873d: return "GL_MODELVIEW29_ARB";
        case 0x873e: return "GL_MODELVIEW30_ARB";
        case 0x873f: return "GL_MODELVIEW31_ARB";
#endif
        case 0x8740:
#if defined(GL_EXT_texture_env_dot3)
                     return "GL_DOT3_RGB_EXT";
#endif
#if defined(GL_AMD_program_binary_Z400)
                     return "GL_Z400_BINARY_AMD";
#endif
            break;
        case 0x8741:
#if defined(GL_EXT_texture_env_dot3)
                     return "GL_DOT3_RGBA_EXT";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_1)
                     return "GL_PROGRAM_BINARY_LENGTH";
#endif
#if defined(GL_OES_get_program_binary)
                     return "GL_PROGRAM_BINARY_LENGTH_OES";
#endif
            break;
        case 0x8742:
#if defined(GL_ATI_texture_mirror_once)
                     return "GL_MIRROR_CLAMP_ATI";
#endif
#if defined(GL_EXT_texture_mirror_clamp)
                     return "GL_MIRROR_CLAMP_EXT";
#endif
            break;
        case 0x8743:
#if defined(GL_VERSION_4_4)
                     return "GL_MIRROR_CLAMP_TO_EDGE";
#endif
#if defined(GL_ATI_texture_mirror_once)
                     return "GL_MIRROR_CLAMP_TO_EDGE_ATI";
#endif
#if defined(GL_EXT_texture_mirror_clamp)
                     return "GL_MIRROR_CLAMP_TO_EDGE_EXT";
#endif
            break;
#if defined(GL_ATI_texture_env_combine3)
        case 0x8744: return "GL_MODULATE_ADD_ATI";
        case 0x8745: return "GL_MODULATE_SIGNED_ADD_ATI";
        case 0x8746: return "GL_MODULATE_SUBTRACT_ATI";
#endif
#if defined(GL_AMD_stencil_operation_extended)
        case 0x874a: return "GL_SET_AMD";
        case 0x874b: return "GL_REPLACE_VALUE_AMD";
        case 0x874c: return "GL_STENCIL_OP_VALUE_AMD";
        case 0x874d: return "GL_STENCIL_BACK_OP_VALUE_AMD";
#endif
#if defined(GL_VERSION_4_3)
        case 0x874e: return "GL_VERTEX_ATTRIB_ARRAY_LONG";
#endif
#if defined(GL_AMD_occlusion_query_event)
        case 0x874f: return "GL_OCCLUSION_QUERY_EVENT_MASK_AMD";
#endif
#if defined(GL_MESA_ycbcr_texture)
        case 0x8757: return "GL_YCBCR_MESA";
#endif
#if defined(GL_MESA_pack_invert)
        case 0x8758: return "GL_PACK_INVERT_MESA";
#endif
#if defined(GL_MESAX_texture_stack)
        case 0x8759: return "GL_TEXTURE_1D_STACK_MESAX";
        case 0x875a: return "GL_TEXTURE_2D_STACK_MESAX";
        case 0x875b: return "GL_PROXY_TEXTURE_1D_STACK_MESAX";
        case 0x875c: return "GL_PROXY_TEXTURE_2D_STACK_MESAX";
        case 0x875d: return "GL_TEXTURE_1D_STACK_BINDING_MESAX";
        case 0x875e: return "GL_TEXTURE_2D_STACK_BINDING_MESAX";
#endif
#if defined(GL_ATI_vertex_array_object)
        case 0x8760: return "GL_STATIC_ATI";
        case 0x8761: return "GL_DYNAMIC_ATI";
        case 0x8762: return "GL_PRESERVE_ATI";
        case 0x8763: return "GL_DISCARD_ATI";
#endif
        case 0x8764:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_BUFFER_SIZE";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_BUFFER_SIZE_ARB";
#endif
#if defined(GL_ATI_vertex_array_object)
                     return "GL_OBJECT_BUFFER_SIZE_ATI";
#endif
            break;
        case 0x8765:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_BUFFER_USAGE";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_BUFFER_USAGE_ARB";
#endif
#if defined(GL_ATI_vertex_array_object)
                     return "GL_OBJECT_BUFFER_USAGE_ATI";
#endif
            break;
#if defined(GL_ATI_vertex_array_object)
        case 0x8766: return "GL_ARRAY_OBJECT_BUFFER_ATI";
        case 0x8767: return "GL_ARRAY_OBJECT_OFFSET_ATI";
#endif
#if defined(GL_ATI_element_array)
        case 0x8768: return "GL_ELEMENT_ARRAY_ATI";
        case 0x8769: return "GL_ELEMENT_ARRAY_TYPE_ATI";
        case 0x876a: return "GL_ELEMENT_ARRAY_POINTER_ATI";
#endif
#if defined(GL_ATI_vertex_streams)
        case 0x876b: return "GL_MAX_VERTEX_STREAMS_ATI";
        case 0x876c: return "GL_VERTEX_STREAM0_ATI";
        case 0x876d: return "GL_VERTEX_STREAM1_ATI";
        case 0x876e: return "GL_VERTEX_STREAM2_ATI";
        case 0x876f: return "GL_VERTEX_STREAM3_ATI";
        case 0x8770: return "GL_VERTEX_STREAM4_ATI";
        case 0x8771: return "GL_VERTEX_STREAM5_ATI";
        case 0x8772: return "GL_VERTEX_STREAM6_ATI";
        case 0x8773: return "GL_VERTEX_STREAM7_ATI";
        case 0x8774: return "GL_VERTEX_SOURCE_ATI";
#endif
#if defined(GL_ATI_envmap_bumpmap)
        case 0x8775: return "GL_BUMP_ROT_MATRIX_ATI";
        case 0x8776: return "GL_BUMP_ROT_MATRIX_SIZE_ATI";
        case 0x8777: return "GL_BUMP_NUM_TEX_UNITS_ATI";
        case 0x8778: return "GL_BUMP_TEX_UNITS_ATI";
        case 0x8779: return "GL_DUDV_ATI";
        case 0x877a: return "GL_DU8DV8_ATI";
        case 0x877b: return "GL_BUMP_ENVMAP_ATI";
        case 0x877c: return "GL_BUMP_TARGET_ATI";
#endif
#if defined(GL_EXT_vertex_shader)
        case 0x8780: return "GL_VERTEX_SHADER_EXT";
        case 0x8781: return "GL_VERTEX_SHADER_BINDING_EXT";
        case 0x8782: return "GL_OP_INDEX_EXT";
        case 0x8783: return "GL_OP_NEGATE_EXT";
        case 0x8784: return "GL_OP_DOT3_EXT";
        case 0x8785: return "GL_OP_DOT4_EXT";
        case 0x8786: return "GL_OP_MUL_EXT";
        case 0x8787: return "GL_OP_ADD_EXT";
        case 0x8788: return "GL_OP_MADD_EXT";
        case 0x8789: return "GL_OP_FRAC_EXT";
        case 0x878a: return "GL_OP_MAX_EXT";
        case 0x878b: return "GL_OP_MIN_EXT";
        case 0x878c: return "GL_OP_SET_GE_EXT";
        case 0x878d: return "GL_OP_SET_LT_EXT";
        case 0x878e: return "GL_OP_CLAMP_EXT";
        case 0x878f: return "GL_OP_FLOOR_EXT";
        case 0x8790: return "GL_OP_ROUND_EXT";
        case 0x8791: return "GL_OP_EXP_BASE_2_EXT";
        case 0x8792: return "GL_OP_LOG_BASE_2_EXT";
        case 0x8793: return "GL_OP_POWER_EXT";
        case 0x8794: return "GL_OP_RECIP_EXT";
        case 0x8795: return "GL_OP_RECIP_SQRT_EXT";
        case 0x8796: return "GL_OP_SUB_EXT";
        case 0x8797: return "GL_OP_CROSS_PRODUCT_EXT";
        case 0x8798: return "GL_OP_MULTIPLY_MATRIX_EXT";
        case 0x8799: return "GL_OP_MOV_EXT";
        case 0x879a: return "GL_OUTPUT_VERTEX_EXT";
        case 0x879b: return "GL_OUTPUT_COLOR0_EXT";
        case 0x879c: return "GL_OUTPUT_COLOR1_EXT";
        case 0x879d: return "GL_OUTPUT_TEXTURE_COORD0_EXT";
        case 0x879e: return "GL_OUTPUT_TEXTURE_COORD1_EXT";
        case 0x879f: return "GL_OUTPUT_TEXTURE_COORD2_EXT";
        case 0x87a0: return "GL_OUTPUT_TEXTURE_COORD3_EXT";
        case 0x87a1: return "GL_OUTPUT_TEXTURE_COORD4_EXT";
        case 0x87a2: return "GL_OUTPUT_TEXTURE_COORD5_EXT";
        case 0x87a3: return "GL_OUTPUT_TEXTURE_COORD6_EXT";
        case 0x87a4: return "GL_OUTPUT_TEXTURE_COORD7_EXT";
        case 0x87a5: return "GL_OUTPUT_TEXTURE_COORD8_EXT";
        case 0x87a6: return "GL_OUTPUT_TEXTURE_COORD9_EXT";
        case 0x87a7: return "GL_OUTPUT_TEXTURE_COORD10_EXT";
        case 0x87a8: return "GL_OUTPUT_TEXTURE_COORD11_EXT";
        case 0x87a9: return "GL_OUTPUT_TEXTURE_COORD12_EXT";
        case 0x87aa: return "GL_OUTPUT_TEXTURE_COORD13_EXT";
        case 0x87ab: return "GL_OUTPUT_TEXTURE_COORD14_EXT";
        case 0x87ac: return "GL_OUTPUT_TEXTURE_COORD15_EXT";
        case 0x87ad: return "GL_OUTPUT_TEXTURE_COORD16_EXT";
        case 0x87ae: return "GL_OUTPUT_TEXTURE_COORD17_EXT";
        case 0x87af: return "GL_OUTPUT_TEXTURE_COORD18_EXT";
        case 0x87b0: return "GL_OUTPUT_TEXTURE_COORD19_EXT";
        case 0x87b1: return "GL_OUTPUT_TEXTURE_COORD20_EXT";
        case 0x87b2: return "GL_OUTPUT_TEXTURE_COORD21_EXT";
        case 0x87b3: return "GL_OUTPUT_TEXTURE_COORD22_EXT";
        case 0x87b4: return "GL_OUTPUT_TEXTURE_COORD23_EXT";
        case 0x87b5: return "GL_OUTPUT_TEXTURE_COORD24_EXT";
        case 0x87b6: return "GL_OUTPUT_TEXTURE_COORD25_EXT";
        case 0x87b7: return "GL_OUTPUT_TEXTURE_COORD26_EXT";
        case 0x87b8: return "GL_OUTPUT_TEXTURE_COORD27_EXT";
        case 0x87b9: return "GL_OUTPUT_TEXTURE_COORD28_EXT";
        case 0x87ba: return "GL_OUTPUT_TEXTURE_COORD29_EXT";
        case 0x87bb: return "GL_OUTPUT_TEXTURE_COORD30_EXT";
        case 0x87bc: return "GL_OUTPUT_TEXTURE_COORD31_EXT";
        case 0x87bd: return "GL_OUTPUT_FOG_EXT";
        case 0x87be: return "GL_SCALAR_EXT";
        case 0x87bf: return "GL_VECTOR_EXT";
        case 0x87c0: return "GL_MATRIX_EXT";
        case 0x87c1: return "GL_VARIANT_EXT";
        case 0x87c2: return "GL_INVARIANT_EXT";
        case 0x87c3: return "GL_LOCAL_CONSTANT_EXT";
        case 0x87c4: return "GL_LOCAL_EXT";
        case 0x87c5: return "GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT";
        case 0x87c6: return "GL_MAX_VERTEX_SHADER_VARIANTS_EXT";
        case 0x87c7: return "GL_MAX_VERTEX_SHADER_INVARIANTS_EXT";
        case 0x87c8: return "GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT";
        case 0x87c9: return "GL_MAX_VERTEX_SHADER_LOCALS_EXT";
        case 0x87ca: return "GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT";
        case 0x87cb: return "GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT";
        case 0x87cc: return "GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT";
        case 0x87cd: return "GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT";
        case 0x87ce: return "GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT";
        case 0x87cf: return "GL_VERTEX_SHADER_INSTRUCTIONS_EXT";
        case 0x87d0: return "GL_VERTEX_SHADER_VARIANTS_EXT";
        case 0x87d1: return "GL_VERTEX_SHADER_INVARIANTS_EXT";
        case 0x87d2: return "GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT";
        case 0x87d3: return "GL_VERTEX_SHADER_LOCALS_EXT";
        case 0x87d4: return "GL_VERTEX_SHADER_OPTIMIZED_EXT";
        case 0x87d5: return "GL_X_EXT";
        case 0x87d6: return "GL_Y_EXT";
        case 0x87d7: return "GL_Z_EXT";
        case 0x87d8: return "GL_W_EXT";
        case 0x87d9: return "GL_NEGATIVE_X_EXT";
        case 0x87da: return "GL_NEGATIVE_Y_EXT";
        case 0x87db: return "GL_NEGATIVE_Z_EXT";
        case 0x87dc: return "GL_NEGATIVE_W_EXT";
        case 0x87dd: return "GL_ZERO_EXT";
        case 0x87de: return "GL_ONE_EXT";
        case 0x87df: return "GL_NEGATIVE_ONE_EXT";
        case 0x87e0: return "GL_NORMALIZED_RANGE_EXT";
        case 0x87e1: return "GL_FULL_RANGE_EXT";
        case 0x87e2: return "GL_CURRENT_VERTEX_EXT";
        case 0x87e3: return "GL_MVP_MATRIX_EXT";
        case 0x87e4: return "GL_VARIANT_VALUE_EXT";
        case 0x87e5: return "GL_VARIANT_DATATYPE_EXT";
        case 0x87e6: return "GL_VARIANT_ARRAY_STRIDE_EXT";
        case 0x87e7: return "GL_VARIANT_ARRAY_TYPE_EXT";
        case 0x87e8: return "GL_VARIANT_ARRAY_EXT";
        case 0x87e9: return "GL_VARIANT_ARRAY_POINTER_EXT";
        case 0x87ea: return "GL_INVARIANT_VALUE_EXT";
        case 0x87eb: return "GL_INVARIANT_DATATYPE_EXT";
        case 0x87ec: return "GL_LOCAL_CONSTANT_VALUE_EXT";
        case 0x87ed: return "GL_LOCAL_CONSTANT_DATATYPE_EXT";
#endif
#if defined(GL_AMD_compressed_ATC_texture)
        case 0x87ee: return "GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD";
#endif
#if defined(GL_ATI_pn_triangles)
        case 0x87f0: return "GL_PN_TRIANGLES_ATI";
        case 0x87f1: return "GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI";
        case 0x87f2: return "GL_PN_TRIANGLES_POINT_MODE_ATI";
        case 0x87f3: return "GL_PN_TRIANGLES_NORMAL_MODE_ATI";
        case 0x87f4: return "GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI";
        case 0x87f5: return "GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI";
        case 0x87f6: return "GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI";
        case 0x87f7: return "GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI";
        case 0x87f8: return "GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI";
#endif
#if defined(GL_AMD_compressed_3DC_texture)
        case 0x87f9: return "GL_3DC_X_AMD";
        case 0x87fa: return "GL_3DC_XY_AMD";
#endif
#if defined(GL_ATI_meminfo)
        case 0x87fb: return "GL_VBO_FREE_MEMORY_ATI";
        case 0x87fc: return "GL_TEXTURE_FREE_MEMORY_ATI";
        case 0x87fd: return "GL_RENDERBUFFER_FREE_MEMORY_ATI";
#endif
        case 0x87fe:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_1)
                     return "GL_NUM_PROGRAM_BINARY_FORMATS";
#endif
#if defined(GL_OES_get_program_binary)
                     return "GL_NUM_PROGRAM_BINARY_FORMATS_OES";
#endif
            break;
        case 0x87ff:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_1)
                     return "GL_PROGRAM_BINARY_FORMATS";
#endif
#if defined(GL_OES_get_program_binary)
                     return "GL_PROGRAM_BINARY_FORMATS_OES";
#endif
            break;
        case 0x8800:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_STENCIL_BACK_FUNC";
#endif
#if defined(GL_ATI_separate_stencil)
                     return "GL_STENCIL_BACK_FUNC_ATI";
#endif
            break;
        case 0x8801:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_STENCIL_BACK_FAIL";
#endif
#if defined(GL_ATI_separate_stencil)
                     return "GL_STENCIL_BACK_FAIL_ATI";
#endif
            break;
        case 0x8802:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_STENCIL_BACK_PASS_DEPTH_FAIL";
#endif
#if defined(GL_ATI_separate_stencil)
                     return "GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI";
#endif
            break;
        case 0x8803:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_STENCIL_BACK_PASS_DEPTH_PASS";
#endif
#if defined(GL_ATI_separate_stencil)
                     return "GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI";
#endif
            break;
#if defined(GL_ARB_fragment_program)
        case 0x8804: return "GL_FRAGMENT_PROGRAM_ARB";
        case 0x8805: return "GL_PROGRAM_ALU_INSTRUCTIONS_ARB";
        case 0x8806: return "GL_PROGRAM_TEX_INSTRUCTIONS_ARB";
        case 0x8807: return "GL_PROGRAM_TEX_INDIRECTIONS_ARB";
        case 0x8808: return "GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB";
        case 0x8809: return "GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB";
        case 0x880a: return "GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB";
        case 0x880b: return "GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB";
        case 0x880c: return "GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB";
        case 0x880d: return "GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB";
        case 0x880e: return "GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB";
        case 0x880f: return "GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB";
        case 0x8810: return "GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB";
#endif
        case 0x8814:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RGBA32F";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_RGBA32F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_RGBA32F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_RGBA_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_RGBA_FLOAT32_ATI";
#endif
            break;
        case 0x8815:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RGB32F";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_RGB32F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_RGB32F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_RGB_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_RGB_FLOAT32_ATI";
#endif
            break;
        case 0x8816:
#if defined(GL_ARB_texture_float)
                     return "GL_ALPHA32F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_ALPHA32F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_ALPHA_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_ALPHA_FLOAT32_ATI";
#endif
            break;
        case 0x8817:
#if defined(GL_ARB_texture_float)
                     return "GL_INTENSITY32F_ARB";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_INTENSITY_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_INTENSITY_FLOAT32_ATI";
#endif
            break;
        case 0x8818:
#if defined(GL_ARB_texture_float)
                     return "GL_LUMINANCE32F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_LUMINANCE32F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_LUMINANCE_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_LUMINANCE_FLOAT32_ATI";
#endif
            break;
        case 0x8819:
#if defined(GL_ARB_texture_float)
                     return "GL_LUMINANCE_ALPHA32F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_LUMINANCE_ALPHA32F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_LUMINANCE_ALPHA_FLOAT32_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_LUMINANCE_ALPHA_FLOAT32_ATI";
#endif
            break;
        case 0x881a:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RGBA16F";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_RGBA16F_ARB";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_RGBA16F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_RGBA_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_RGBA_FLOAT16_ATI";
#endif
            break;
        case 0x881b:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RGB16F";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_RGB16F_ARB";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_RGB16F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_RGB_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_RGB_FLOAT16_ATI";
#endif
            break;
        case 0x881c:
#if defined(GL_ARB_texture_float)
                     return "GL_ALPHA16F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_ALPHA16F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_ALPHA_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_ALPHA_FLOAT16_ATI";
#endif
            break;
        case 0x881d:
#if defined(GL_ARB_texture_float)
                     return "GL_INTENSITY16F_ARB";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_INTENSITY_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_INTENSITY_FLOAT16_ATI";
#endif
            break;
        case 0x881e:
#if defined(GL_ARB_texture_float)
                     return "GL_LUMINANCE16F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_LUMINANCE16F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_LUMINANCE_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_LUMINANCE_FLOAT16_ATI";
#endif
            break;
        case 0x881f:
#if defined(GL_ARB_texture_float)
                     return "GL_LUMINANCE_ALPHA16F_ARB";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_LUMINANCE_ALPHA16F_EXT";
#endif
#if defined(GL_APPLE_float_pixels)
                     return "GL_LUMINANCE_ALPHA_FLOAT16_APPLE";
#endif
#if defined(GL_ATI_texture_float)
                     return "GL_LUMINANCE_ALPHA_FLOAT16_ATI";
#endif
            break;
        case 0x8820:
#if defined(GL_ARB_color_buffer_float)
                     return "GL_RGBA_FLOAT_MODE_ARB";
#endif
#if defined(GL_ATI_pixel_format_float)
                     return "GL_RGBA_FLOAT_MODE_ATI";
#endif
            break;
#if defined(GL_QCOM_writeonly_rendering)
        case 0x8823: return "GL_WRITEONLY_RENDERING_QCOM";
#endif
        case 0x8824:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_MAX_DRAW_BUFFERS";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_MAX_DRAW_BUFFERS_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_MAX_DRAW_BUFFERS_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_MAX_DRAW_BUFFERS_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_MAX_DRAW_BUFFERS_NV";
#endif
            break;
        case 0x8825:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER0";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER0_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER0_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER0_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER0_NV";
#endif
            break;
        case 0x8826:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER1";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER1_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER1_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER1_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER1_NV";
#endif
            break;
        case 0x8827:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER2";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER2_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER2_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER2_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER2_NV";
#endif
            break;
        case 0x8828:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER3";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER3_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER3_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER3_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER3_NV";
#endif
            break;
        case 0x8829:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER4";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER4_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER4_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER4_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER4_NV";
#endif
            break;
        case 0x882a:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER5";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER5_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER5_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER5_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER5_NV";
#endif
            break;
        case 0x882b:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER6";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER6_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER6_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER6_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER6_NV";
#endif
            break;
        case 0x882c:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER7";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER7_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER7_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER7_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER7_NV";
#endif
            break;
        case 0x882d:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER8";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER8_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER8_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER8_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER8_NV";
#endif
            break;
        case 0x882e:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER9";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER9_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER9_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER9_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER9_NV";
#endif
            break;
        case 0x882f:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER10";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER10_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER10_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER10_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER10_NV";
#endif
            break;
        case 0x8830:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER11";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER11_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER11_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER11_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER11_NV";
#endif
            break;
        case 0x8831:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER12";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER12_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER12_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER12_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER12_NV";
#endif
            break;
        case 0x8832:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER13";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER13_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER13_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER13_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER13_NV";
#endif
            break;
        case 0x8833:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER14";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER14_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER14_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER14_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER14_NV";
#endif
            break;
        case 0x8834:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_DRAW_BUFFER15";
#endif
#if defined(GL_ARB_draw_buffers)
                     return "GL_DRAW_BUFFER15_ARB";
#endif
#if defined(GL_ATI_draw_buffers)
                     return "GL_DRAW_BUFFER15_ATI";
#endif
#if defined(GL_EXT_draw_buffers)
                     return "GL_DRAW_BUFFER15_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_DRAW_BUFFER15_NV";
#endif
            break;
#if defined(GL_ATI_pixel_format_float)
        case 0x8835: return "GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI";
#endif
        case 0x883d:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BLEND_EQUATION_ALPHA";
#endif
#if defined(GL_EXT_blend_equation_separate)
                     return "GL_BLEND_EQUATION_ALPHA_EXT";
#endif
            break;
#if defined(GL_AMD_framebuffer_sample_positions)
        case 0x883f: return "GL_SUBSAMPLE_DISTANCE_AMD";
#endif
#if defined(GL_ARB_matrix_palette)
        case 0x8840: return "GL_MATRIX_PALETTE_ARB";
        case 0x8841: return "GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB";
        case 0x8842: return "GL_MAX_PALETTE_MATRICES_ARB";
        case 0x8843: return "GL_CURRENT_PALETTE_MATRIX_ARB";
        case 0x8844: return "GL_MATRIX_INDEX_ARRAY_ARB";
        case 0x8845: return "GL_CURRENT_MATRIX_INDEX_ARB";
        case 0x8846: return "GL_MATRIX_INDEX_ARRAY_SIZE_ARB";
        case 0x8847: return "GL_MATRIX_INDEX_ARRAY_TYPE_ARB";
        case 0x8848: return "GL_MATRIX_INDEX_ARRAY_STRIDE_ARB";
        case 0x8849: return "GL_MATRIX_INDEX_ARRAY_POINTER_ARB";
#endif
        case 0x884a:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_1_4)
                     return "GL_TEXTURE_DEPTH_SIZE";
#endif
#if defined(GL_ARB_depth_texture)
                     return "GL_TEXTURE_DEPTH_SIZE_ARB";
#endif
            break;
        case 0x884b:
#if defined(GL_VERSION_1_4)
                     return "GL_DEPTH_TEXTURE_MODE";
#endif
#if defined(GL_ARB_depth_texture)
                     return "GL_DEPTH_TEXTURE_MODE_ARB";
#endif
            break;
        case 0x884c:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_4)
                     return "GL_TEXTURE_COMPARE_MODE";
#endif
#if defined(GL_ARB_shadow)
                     return "GL_TEXTURE_COMPARE_MODE_ARB";
#endif
#if defined(GL_EXT_shadow_samplers)
                     return "GL_TEXTURE_COMPARE_MODE_EXT";
#endif
            break;
        case 0x884d:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_4)
                     return "GL_TEXTURE_COMPARE_FUNC";
#endif
#if defined(GL_ARB_shadow)
                     return "GL_TEXTURE_COMPARE_FUNC_ARB";
#endif
#if defined(GL_EXT_shadow_samplers)
                     return "GL_TEXTURE_COMPARE_FUNC_EXT";
#endif
            break;
        case 0x884e:
#if defined(GL_EXT_texture_array)
                     return "GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COMPARE_REF_TO_TEXTURE";
#endif
#if defined(GL_EXT_shadow_samplers)
                     return "GL_COMPARE_REF_TO_TEXTURE_EXT";
#endif
#if defined(GL_VERSION_1_4)
                     return "GL_COMPARE_R_TO_TEXTURE";
#endif
#if defined(GL_ARB_shadow)
                     return "GL_COMPARE_R_TO_TEXTURE_ARB";
#endif
            break;
#if defined(__glcorearb_h_) || defined(__glext_h_)
        case 0x884f: return "GL_TEXTURE_CUBE_MAP_SEAMLESS";
#endif
#if defined(GL_NV_texture_shader3)
        case 0x8850: return "GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV";
        case 0x8851: return "GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV";
        case 0x8852: return "GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV";
        case 0x8853: return "GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV";
        case 0x8854: return "GL_OFFSET_HILO_TEXTURE_2D_NV";
        case 0x8855: return "GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV";
        case 0x8856: return "GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV";
        case 0x8857: return "GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV";
        case 0x8858: return "GL_DEPENDENT_HILO_TEXTURE_2D_NV";
        case 0x8859: return "GL_DEPENDENT_RGB_TEXTURE_3D_NV";
        case 0x885a: return "GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV";
        case 0x885b: return "GL_DOT_PRODUCT_PASS_THROUGH_NV";
        case 0x885c: return "GL_DOT_PRODUCT_TEXTURE_1D_NV";
        case 0x885d: return "GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV";
        case 0x885e: return "GL_HILO8_NV";
        case 0x885f: return "GL_SIGNED_HILO8_NV";
        case 0x8860: return "GL_FORCE_BLUE_TO_ONE_NV";
#endif
        case 0x8861:
#if defined(GL_VERSION_2_0)
                     return "GL_POINT_SPRITE";
#endif
#if defined(GL_ARB_point_sprite)
                     return "GL_POINT_SPRITE_ARB";
#endif
#if defined(GL_NV_point_sprite)
                     return "GL_POINT_SPRITE_NV";
#endif
            break;
        case 0x8862:
#if defined(GL_VERSION_2_0)
                     return "GL_COORD_REPLACE";
#endif
#if defined(GL_ARB_point_sprite)
                     return "GL_COORD_REPLACE_ARB";
#endif
#if defined(GL_NV_point_sprite)
                     return "GL_COORD_REPLACE_NV";
#endif
            break;
#if defined(GL_NV_point_sprite)
        case 0x8863: return "GL_POINT_SPRITE_R_MODE_NV";
#endif
        case 0x8865:
#if defined(GL_NV_occlusion_query)
                     return "GL_CURRENT_OCCLUSION_QUERY_ID_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_CURRENT_QUERY";
#endif
#if defined(GL_ARB_occlusion_query)
                     return "GL_CURRENT_QUERY_ARB";
#endif
#if defined(GL_EXT_disjoint_timer_query)
                     return "GL_CURRENT_QUERY_EXT";
#endif
            break;
        case 0x8866:
#if defined(GL_NV_occlusion_query)
                     return "GL_PIXEL_COUNT_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_QUERY_RESULT";
#endif
#if defined(GL_ARB_occlusion_query)
                     return "GL_QUERY_RESULT_ARB";
#endif
#if defined(GL_EXT_disjoint_timer_query)
                     return "GL_QUERY_RESULT_EXT";
#endif
            break;
        case 0x8867:
#if defined(GL_NV_occlusion_query)
                     return "GL_PIXEL_COUNT_AVAILABLE_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_QUERY_RESULT_AVAILABLE";
#endif
#if defined(GL_ARB_occlusion_query)
                     return "GL_QUERY_RESULT_AVAILABLE_ARB";
#endif
#if defined(GL_EXT_disjoint_timer_query)
                     return "GL_QUERY_RESULT_AVAILABLE_EXT";
#endif
            break;
#if defined(GL_NV_fragment_program)
        case 0x8868: return "GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV";
#endif
        case 0x8869:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_VERTEX_ATTRIBS";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_MAX_VERTEX_ATTRIBS_ARB";
#endif
            break;
        case 0x886a:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_NORMALIZED";
#endif
#if defined(GL_ARB_vertex_program)
                     return "GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB";
#endif
            break;
        case 0x886c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_INPUT_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES";
#endif
            break;
        case 0x886d:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES";
#endif
            break;
#if defined(GL_NV_copy_depth_to_color)
        case 0x886e: return "GL_DEPTH_STENCIL_TO_RGBA_NV";
        case 0x886f: return "GL_DEPTH_STENCIL_TO_BGRA_NV";
#endif
#if defined(GL_NV_fragment_program)
        case 0x8870: return "GL_FRAGMENT_PROGRAM_NV";
#endif
        case 0x8871:
#if defined(GL_VERSION_2_0)
                     return "GL_MAX_TEXTURE_COORDS";
#endif
#if defined(GL_ARB_fragment_program)
                     return "GL_MAX_TEXTURE_COORDS_ARB";
#endif
#if defined(GL_NV_fragment_program)
                     return "GL_MAX_TEXTURE_COORDS_NV";
#endif
            break;
        case 0x8872:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_ARB_fragment_program)
                     return "GL_MAX_TEXTURE_IMAGE_UNITS_ARB";
#endif
#if defined(GL_NV_fragment_program)
                     return "GL_MAX_TEXTURE_IMAGE_UNITS_NV";
#endif
            break;
#if defined(GL_NV_fragment_program)
        case 0x8873: return "GL_FRAGMENT_PROGRAM_BINDING_NV";
#endif
        case 0x8874:
#if defined(GL_ARB_fragment_program)
                     return "GL_PROGRAM_ERROR_STRING_ARB";
#endif
#if defined(GL_NV_fragment_program)
                     return "GL_PROGRAM_ERROR_STRING_NV";
#endif
            break;
#if defined(GL_ARB_fragment_program)
        case 0x8875: return "GL_PROGRAM_FORMAT_ASCII_ARB";
        case 0x8876: return "GL_PROGRAM_FORMAT_ARB";
#endif
#if defined(GL_NV_pixel_data_range)
        case 0x8878: return "GL_WRITE_PIXEL_DATA_RANGE_NV";
        case 0x8879: return "GL_READ_PIXEL_DATA_RANGE_NV";
        case 0x887a: return "GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV";
        case 0x887b: return "GL_READ_PIXEL_DATA_RANGE_LENGTH_NV";
        case 0x887c: return "GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV";
        case 0x887d: return "GL_READ_PIXEL_DATA_RANGE_POINTER_NV";
#endif
        case 0x887f:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_GEOMETRY_SHADER_INVOCATIONS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_GEOMETRY_SHADER_INVOCATIONS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_GEOMETRY_SHADER_INVOCATIONS_OES";
#endif
            break;
#if defined(GL_NV_float_buffer)
        case 0x8880: return "GL_FLOAT_R_NV";
        case 0x8881: return "GL_FLOAT_RG_NV";
        case 0x8882: return "GL_FLOAT_RGB_NV";
        case 0x8883: return "GL_FLOAT_RGBA_NV";
        case 0x8884: return "GL_FLOAT_R16_NV";
        case 0x8885: return "GL_FLOAT_R32_NV";
        case 0x8886: return "GL_FLOAT_RG16_NV";
        case 0x8887: return "GL_FLOAT_RG32_NV";
        case 0x8888: return "GL_FLOAT_RGB16_NV";
        case 0x8889: return "GL_FLOAT_RGB32_NV";
        case 0x888a: return "GL_FLOAT_RGBA16_NV";
        case 0x888b: return "GL_FLOAT_RGBA32_NV";
        case 0x888c: return "GL_TEXTURE_FLOAT_COMPONENTS_NV";
        case 0x888d: return "GL_FLOAT_CLEAR_COLOR_VALUE_NV";
        case 0x888e: return "GL_FLOAT_RGBA_MODE_NV";
#endif
#if defined(GL_NV_texture_expand_normal)
        case 0x888f: return "GL_TEXTURE_UNSIGNED_REMAP_MODE_NV";
#endif
#if defined(GL_EXT_depth_bounds_test)
        case 0x8890: return "GL_DEPTH_BOUNDS_TEST_EXT";
        case 0x8891: return "GL_DEPTH_BOUNDS_EXT";
#endif
        case 0x8892:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_ARRAY_BUFFER";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_ARRAY_BUFFER_ARB";
#endif
            break;
        case 0x8893:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_ELEMENT_ARRAY_BUFFER";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_ELEMENT_ARRAY_BUFFER_ARB";
#endif
            break;
        case 0x8894:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x8895:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_ELEMENT_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x8896:
#if defined(GL_VERSION_1_5)
                     return "GL_VERTEX_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_VERTEX_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x8897:
#if defined(GL_VERSION_1_5)
                     return "GL_NORMAL_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_NORMAL_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x8898:
#if defined(GL_VERSION_1_5)
                     return "GL_COLOR_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_COLOR_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x8899:
#if defined(GL_VERSION_1_5)
                     return "GL_INDEX_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_INDEX_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x889a:
#if defined(GL_VERSION_1_5)
                     return "GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x889b:
#if defined(GL_VERSION_1_5)
                     return "GL_EDGE_FLAG_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x889c:
#if defined(GL_VERSION_1_5)
                     return "GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x889d:
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB";
#endif
#if defined(GL_VERSION_1_5)
                     return "GL_FOG_COORD_ARRAY_BUFFER_BINDING";
#endif
            break;
        case 0x889e:
#if defined(GL_VERSION_1_5)
                     return "GL_WEIGHT_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
        case 0x889f:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB";
#endif
            break;
#if defined(GL_ARB_fragment_program)
        case 0x88a0: return "GL_PROGRAM_INSTRUCTIONS_ARB";
        case 0x88a1: return "GL_MAX_PROGRAM_INSTRUCTIONS_ARB";
        case 0x88a2: return "GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB";
        case 0x88a3: return "GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB";
        case 0x88a4: return "GL_PROGRAM_TEMPORARIES_ARB";
        case 0x88a5: return "GL_MAX_PROGRAM_TEMPORARIES_ARB";
        case 0x88a6: return "GL_PROGRAM_NATIVE_TEMPORARIES_ARB";
        case 0x88a7: return "GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB";
        case 0x88a8: return "GL_PROGRAM_PARAMETERS_ARB";
        case 0x88a9: return "GL_MAX_PROGRAM_PARAMETERS_ARB";
        case 0x88aa: return "GL_PROGRAM_NATIVE_PARAMETERS_ARB";
        case 0x88ab: return "GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB";
        case 0x88ac: return "GL_PROGRAM_ATTRIBS_ARB";
        case 0x88ad: return "GL_MAX_PROGRAM_ATTRIBS_ARB";
        case 0x88ae: return "GL_PROGRAM_NATIVE_ATTRIBS_ARB";
        case 0x88af: return "GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB";
#endif
#if defined(GL_ARB_vertex_program)
        case 0x88b0: return "GL_PROGRAM_ADDRESS_REGISTERS_ARB";
        case 0x88b1: return "GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB";
        case 0x88b2: return "GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB";
        case 0x88b3: return "GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB";
#endif
#if defined(GL_ARB_fragment_program)
        case 0x88b4: return "GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB";
        case 0x88b5: return "GL_MAX_PROGRAM_ENV_PARAMETERS_ARB";
        case 0x88b6: return "GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB";
        case 0x88b7: return "GL_TRANSPOSE_CURRENT_MATRIX_ARB";
#endif
        case 0x88b8:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_1_5)
                     return "GL_READ_ONLY";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_READ_ONLY_ARB";
#endif
            break;
        case 0x88b9:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_1_5)
                     return "GL_WRITE_ONLY";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_WRITE_ONLY_ARB";
#endif
#if defined(GL_OES_mapbuffer)
                     return "GL_WRITE_ONLY_OES";
#endif
            break;
        case 0x88ba:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_1_5)
                     return "GL_READ_WRITE";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_READ_WRITE_ARB";
#endif
            break;
        case 0x88bb:
#if defined(GL_VERSION_1_5)
                     return "GL_BUFFER_ACCESS";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_BUFFER_ACCESS_ARB";
#endif
#if defined(GL_OES_mapbuffer)
                     return "GL_BUFFER_ACCESS_OES";
#endif
            break;
        case 0x88bc:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_BUFFER_MAPPED";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_BUFFER_MAPPED_ARB";
#endif
#if defined(GL_OES_mapbuffer)
                     return "GL_BUFFER_MAPPED_OES";
#endif
            break;
        case 0x88bd:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_BUFFER_MAP_POINTER";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_BUFFER_MAP_POINTER_ARB";
#endif
#if defined(GL_OES_mapbuffer)
                     return "GL_BUFFER_MAP_POINTER_OES";
#endif
            break;
#if defined(GL_NV_vdpau_interop)
        case 0x88be: return "GL_WRITE_DISCARD_NV";
#endif
        case 0x88bf:
#if defined(GL_VERSION_3_3)
                     return "GL_TIME_ELAPSED";
#endif
#if defined(GL_EXT_timer_query) || defined(GL_EXT_disjoint_timer_query)
                     return "GL_TIME_ELAPSED_EXT";
#endif
            break;
#if defined(GL_ARB_fragment_program)
        case 0x88c0: return "GL_MATRIX0_ARB";
        case 0x88c1: return "GL_MATRIX1_ARB";
        case 0x88c2: return "GL_MATRIX2_ARB";
        case 0x88c3: return "GL_MATRIX3_ARB";
        case 0x88c4: return "GL_MATRIX4_ARB";
        case 0x88c5: return "GL_MATRIX5_ARB";
        case 0x88c6: return "GL_MATRIX6_ARB";
        case 0x88c7: return "GL_MATRIX7_ARB";
        case 0x88c8: return "GL_MATRIX8_ARB";
        case 0x88c9: return "GL_MATRIX9_ARB";
        case 0x88ca: return "GL_MATRIX10_ARB";
        case 0x88cb: return "GL_MATRIX11_ARB";
        case 0x88cc: return "GL_MATRIX12_ARB";
        case 0x88cd: return "GL_MATRIX13_ARB";
        case 0x88ce: return "GL_MATRIX14_ARB";
        case 0x88cf: return "GL_MATRIX15_ARB";
        case 0x88d0: return "GL_MATRIX16_ARB";
        case 0x88d1: return "GL_MATRIX17_ARB";
        case 0x88d2: return "GL_MATRIX18_ARB";
        case 0x88d3: return "GL_MATRIX19_ARB";
        case 0x88d4: return "GL_MATRIX20_ARB";
        case 0x88d5: return "GL_MATRIX21_ARB";
        case 0x88d6: return "GL_MATRIX22_ARB";
        case 0x88d7: return "GL_MATRIX23_ARB";
        case 0x88d8: return "GL_MATRIX24_ARB";
        case 0x88d9: return "GL_MATRIX25_ARB";
        case 0x88da: return "GL_MATRIX26_ARB";
        case 0x88db: return "GL_MATRIX27_ARB";
        case 0x88dc: return "GL_MATRIX28_ARB";
        case 0x88dd: return "GL_MATRIX29_ARB";
        case 0x88de: return "GL_MATRIX30_ARB";
        case 0x88df: return "GL_MATRIX31_ARB";
#endif
        case 0x88e0:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_STREAM_DRAW";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STREAM_DRAW_ARB";
#endif
            break;
        case 0x88e1:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_STREAM_READ";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STREAM_READ_ARB";
#endif
            break;
        case 0x88e2:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_STREAM_COPY";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STREAM_COPY_ARB";
#endif
            break;
        case 0x88e4:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_STATIC_DRAW";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STATIC_DRAW_ARB";
#endif
            break;
        case 0x88e5:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_STATIC_READ";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STATIC_READ_ARB";
#endif
            break;
        case 0x88e6:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_STATIC_COPY";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_STATIC_COPY_ARB";
#endif
            break;
        case 0x88e8:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_1_5)
                     return "GL_DYNAMIC_DRAW";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_DYNAMIC_DRAW_ARB";
#endif
            break;
        case 0x88e9:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_DYNAMIC_READ";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_DYNAMIC_READ_ARB";
#endif
            break;
        case 0x88ea:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_1_5)
                     return "GL_DYNAMIC_COPY";
#endif
#if defined(GL_ARB_vertex_buffer_object)
                     return "GL_DYNAMIC_COPY_ARB";
#endif
            break;
        case 0x88eb:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_PIXEL_PACK_BUFFER";
#endif
#if defined(GL_ARB_pixel_buffer_object)
                     return "GL_PIXEL_PACK_BUFFER_ARB";
#endif
#if defined(GL_EXT_pixel_buffer_object)
                     return "GL_PIXEL_PACK_BUFFER_EXT";
#endif
            break;
        case 0x88ec:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_PIXEL_UNPACK_BUFFER";
#endif
#if defined(GL_ARB_pixel_buffer_object)
                     return "GL_PIXEL_UNPACK_BUFFER_ARB";
#endif
#if defined(GL_EXT_pixel_buffer_object)
                     return "GL_PIXEL_UNPACK_BUFFER_EXT";
#endif
            break;
        case 0x88ed:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_PIXEL_PACK_BUFFER_BINDING";
#endif
#if defined(GL_ARB_pixel_buffer_object)
                     return "GL_PIXEL_PACK_BUFFER_BINDING_ARB";
#endif
#if defined(GL_EXT_pixel_buffer_object)
                     return "GL_PIXEL_PACK_BUFFER_BINDING_EXT";
#endif
            break;
#if defined(GL_NV_sRGB_formats)
        case 0x88ee: return "GL_ETC1_SRGB8_NV";
#endif
        case 0x88ef:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_PIXEL_UNPACK_BUFFER_BINDING";
#endif
#if defined(GL_ARB_pixel_buffer_object)
                     return "GL_PIXEL_UNPACK_BUFFER_BINDING_ARB";
#endif
#if defined(GL_EXT_pixel_buffer_object)
                     return "GL_PIXEL_UNPACK_BUFFER_BINDING_EXT";
#endif
            break;
        case 0x88f0:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_DEPTH24_STENCIL8";
#endif
#if defined(GL_EXT_packed_depth_stencil)
                     return "GL_DEPTH24_STENCIL8_EXT";
#endif
#if defined(GL_OES_packed_depth_stencil)
                     return "GL_DEPTH24_STENCIL8_OES";
#endif
            break;
        case 0x88f1:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_STENCIL_SIZE";
#endif
#if defined(GL_EXT_packed_depth_stencil)
                     return "GL_TEXTURE_STENCIL_SIZE_EXT";
#endif
            break;
#if defined(GL_EXT_stencil_clear_tag)
        case 0x88f3: return "GL_STENCIL_CLEAR_TAG_VALUE_EXT";
#endif
#if defined(GL_NV_fragment_program2)
        case 0x88f4: return "GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV";
        case 0x88f5: return "GL_MAX_PROGRAM_CALL_DEPTH_NV";
        case 0x88f6: return "GL_MAX_PROGRAM_IF_DEPTH_NV";
        case 0x88f7: return "GL_MAX_PROGRAM_LOOP_DEPTH_NV";
        case 0x88f8: return "GL_MAX_PROGRAM_LOOP_COUNT_NV";
#endif
        case 0x88f9:
#if defined(GL_VERSION_3_3)
                     return "GL_SRC1_COLOR";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_SRC1_COLOR_EXT";
#endif
            break;
        case 0x88fa:
#if defined(GL_VERSION_3_3)
                     return "GL_ONE_MINUS_SRC1_COLOR";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_ONE_MINUS_SRC1_COLOR_EXT";
#endif
            break;
        case 0x88fb:
#if defined(GL_VERSION_3_3)
                     return "GL_ONE_MINUS_SRC1_ALPHA";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_ONE_MINUS_SRC1_ALPHA_EXT";
#endif
            break;
        case 0x88fc:
#if defined(GL_VERSION_3_3)
                     return "GL_MAX_DUAL_SOURCE_DRAW_BUFFERS";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT";
#endif
            break;
        case 0x88fd:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_VERTEX_ATTRIB_ARRAY_INTEGER";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT";
#endif
#if defined(GL_NV_vertex_program4)
                     return "GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV";
#endif
            break;
        case 0x88fe:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_VERTEX_ATTRIB_ARRAY_DIVISOR";
#endif
#if defined(GL_ANGLE_instanced_arrays)
                     return "GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE";
#endif
#if defined(GL_ARB_instanced_arrays)
                     return "GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB";
#endif
#if defined(GL_EXT_instanced_arrays)
                     return "GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT";
#endif
#if defined(GL_NV_instanced_arrays)
                     return "GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV";
#endif
            break;
        case 0x88ff:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_ARRAY_TEXTURE_LAYERS";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_MAX_ARRAY_TEXTURE_LAYERS_EXT";
#endif
            break;
        case 0x8904:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MIN_PROGRAM_TEXEL_OFFSET";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_MIN_PROGRAM_TEXEL_OFFSET_EXT";
#endif
#if defined(GL_NV_gpu_program4)
                     return "GL_MIN_PROGRAM_TEXEL_OFFSET_NV";
#endif
            break;
        case 0x8905:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_PROGRAM_TEXEL_OFFSET";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_MAX_PROGRAM_TEXEL_OFFSET_EXT";
#endif
#if defined(GL_NV_gpu_program4)
                     return "GL_MAX_PROGRAM_TEXEL_OFFSET_NV";
#endif
            break;
#if defined(GL_NV_gpu_program4)
        case 0x8906: return "GL_PROGRAM_ATTRIB_COMPONENTS_NV";
        case 0x8907: return "GL_PROGRAM_RESULT_COMPONENTS_NV";
        case 0x8908: return "GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV";
        case 0x8909: return "GL_MAX_PROGRAM_RESULT_COMPONENTS_NV";
#endif
#if defined(GL_EXT_stencil_two_side)
        case 0x8910: return "GL_STENCIL_TEST_TWO_SIDE_EXT";
        case 0x8911: return "GL_ACTIVE_STENCIL_FACE_EXT";
#endif
#if defined(GL_EXT_texture_mirror_clamp)
        case 0x8912: return "GL_MIRROR_CLAMP_TO_BORDER_EXT";
#endif
        case 0x8914:
#if defined(GL_VERSION_1_5)
                     return "GL_SAMPLES_PASSED";
#endif
#if defined(GL_ARB_occlusion_query)
                     return "GL_SAMPLES_PASSED_ARB";
#endif
            break;
        case 0x8916:
#if defined(GL_EXT_geometry_shader)
                     return "GL_GEOMETRY_LINKED_VERTICES_OUT_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_GEOMETRY_LINKED_VERTICES_OUT_OES";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_GEOMETRY_VERTICES_OUT";
#endif
            break;
        case 0x8917:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_GEOMETRY_INPUT_TYPE";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_GEOMETRY_LINKED_INPUT_TYPE_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_GEOMETRY_LINKED_INPUT_TYPE_OES";
#endif
            break;
        case 0x8918:
#if defined(GL_EXT_geometry_shader)
                     return "GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_GEOMETRY_OUTPUT_TYPE";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
        case 0x8919: return "GL_SAMPLER_BINDING";
#endif
        case 0x891a:
#if defined(GL_VERSION_3_0)
                     return "GL_CLAMP_VERTEX_COLOR";
#endif
#if defined(GL_ARB_color_buffer_float)
                     return "GL_CLAMP_VERTEX_COLOR_ARB";
#endif
            break;
        case 0x891b:
#if defined(GL_VERSION_3_0)
                     return "GL_CLAMP_FRAGMENT_COLOR";
#endif
#if defined(GL_ARB_color_buffer_float)
                     return "GL_CLAMP_FRAGMENT_COLOR_ARB";
#endif
            break;
        case 0x891c:
#if defined(GL_VERSION_3_0)
                     return "GL_CLAMP_READ_COLOR";
#endif
#if defined(GL_ARB_color_buffer_float)
                     return "GL_CLAMP_READ_COLOR_ARB";
#endif
            break;
        case 0x891d:
#if defined(GL_VERSION_3_0)
                     return "GL_FIXED_ONLY";
#endif
#if defined(GL_ARB_color_buffer_float)
                     return "GL_FIXED_ONLY_ARB";
#endif
            break;
#if defined(GL_NV_tessellation_program5)
        case 0x891e: return "GL_TESS_CONTROL_PROGRAM_NV";
        case 0x891f: return "GL_TESS_EVALUATION_PROGRAM_NV";
#endif
#if defined(GL_ATI_fragment_shader)
        case 0x8920: return "GL_FRAGMENT_SHADER_ATI";
        case 0x8921: return "GL_REG_0_ATI";
        case 0x8922: return "GL_REG_1_ATI";
        case 0x8923: return "GL_REG_2_ATI";
        case 0x8924: return "GL_REG_3_ATI";
        case 0x8925: return "GL_REG_4_ATI";
        case 0x8926: return "GL_REG_5_ATI";
        case 0x8927: return "GL_REG_6_ATI";
        case 0x8928: return "GL_REG_7_ATI";
        case 0x8929: return "GL_REG_8_ATI";
        case 0x892a: return "GL_REG_9_ATI";
        case 0x892b: return "GL_REG_10_ATI";
        case 0x892c: return "GL_REG_11_ATI";
        case 0x892d: return "GL_REG_12_ATI";
        case 0x892e: return "GL_REG_13_ATI";
        case 0x892f: return "GL_REG_14_ATI";
        case 0x8930: return "GL_REG_15_ATI";
        case 0x8931: return "GL_REG_16_ATI";
        case 0x8932: return "GL_REG_17_ATI";
        case 0x8933: return "GL_REG_18_ATI";
        case 0x8934: return "GL_REG_19_ATI";
        case 0x8935: return "GL_REG_20_ATI";
        case 0x8936: return "GL_REG_21_ATI";
        case 0x8937: return "GL_REG_22_ATI";
        case 0x8938: return "GL_REG_23_ATI";
        case 0x8939: return "GL_REG_24_ATI";
        case 0x893a: return "GL_REG_25_ATI";
        case 0x893b: return "GL_REG_26_ATI";
        case 0x893c: return "GL_REG_27_ATI";
        case 0x893d: return "GL_REG_28_ATI";
        case 0x893e: return "GL_REG_29_ATI";
        case 0x893f: return "GL_REG_30_ATI";
        case 0x8940: return "GL_REG_31_ATI";
        case 0x8941: return "GL_CON_0_ATI";
        case 0x8942: return "GL_CON_1_ATI";
        case 0x8943: return "GL_CON_2_ATI";
        case 0x8944: return "GL_CON_3_ATI";
        case 0x8945: return "GL_CON_4_ATI";
        case 0x8946: return "GL_CON_5_ATI";
        case 0x8947: return "GL_CON_6_ATI";
        case 0x8948: return "GL_CON_7_ATI";
        case 0x8949: return "GL_CON_8_ATI";
        case 0x894a: return "GL_CON_9_ATI";
        case 0x894b: return "GL_CON_10_ATI";
        case 0x894c: return "GL_CON_11_ATI";
        case 0x894d: return "GL_CON_12_ATI";
        case 0x894e: return "GL_CON_13_ATI";
        case 0x894f: return "GL_CON_14_ATI";
        case 0x8950: return "GL_CON_15_ATI";
        case 0x8951: return "GL_CON_16_ATI";
        case 0x8952: return "GL_CON_17_ATI";
        case 0x8953: return "GL_CON_18_ATI";
        case 0x8954: return "GL_CON_19_ATI";
        case 0x8955: return "GL_CON_20_ATI";
        case 0x8956: return "GL_CON_21_ATI";
        case 0x8957: return "GL_CON_22_ATI";
        case 0x8958: return "GL_CON_23_ATI";
        case 0x8959: return "GL_CON_24_ATI";
        case 0x895a: return "GL_CON_25_ATI";
        case 0x895b: return "GL_CON_26_ATI";
        case 0x895c: return "GL_CON_27_ATI";
        case 0x895d: return "GL_CON_28_ATI";
        case 0x895e: return "GL_CON_29_ATI";
        case 0x895f: return "GL_CON_30_ATI";
        case 0x8960: return "GL_CON_31_ATI";
        case 0x8961: return "GL_MOV_ATI";
        case 0x8963: return "GL_ADD_ATI";
        case 0x8964: return "GL_MUL_ATI";
        case 0x8965: return "GL_SUB_ATI";
        case 0x8966: return "GL_DOT3_ATI";
        case 0x8967: return "GL_DOT4_ATI";
        case 0x8968: return "GL_MAD_ATI";
        case 0x8969: return "GL_LERP_ATI";
        case 0x896a: return "GL_CND_ATI";
        case 0x896b: return "GL_CND0_ATI";
        case 0x896c: return "GL_DOT2_ADD_ATI";
        case 0x896d: return "GL_SECONDARY_INTERPOLATOR_ATI";
        case 0x896e: return "GL_NUM_FRAGMENT_REGISTERS_ATI";
        case 0x896f: return "GL_NUM_FRAGMENT_CONSTANTS_ATI";
        case 0x8970: return "GL_NUM_PASSES_ATI";
        case 0x8971: return "GL_NUM_INSTRUCTIONS_PER_PASS_ATI";
        case 0x8972: return "GL_NUM_INSTRUCTIONS_TOTAL_ATI";
        case 0x8973: return "GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI";
        case 0x8974: return "GL_NUM_LOOPBACK_COMPONENTS_ATI";
        case 0x8975: return "GL_COLOR_ALPHA_PAIRING_ATI";
        case 0x8976: return "GL_SWIZZLE_STR_ATI";
        case 0x8977: return "GL_SWIZZLE_STQ_ATI";
        case 0x8978: return "GL_SWIZZLE_STR_DR_ATI";
        case 0x8979: return "GL_SWIZZLE_STQ_DQ_ATI";
        case 0x897a: return "GL_SWIZZLE_STRQ_ATI";
        case 0x897b: return "GL_SWIZZLE_STRQ_DQ_ATI";
#endif
#if defined(GL_OML_interlace)
        case 0x8980: return "GL_INTERLACE_OML";
        case 0x8981: return "GL_INTERLACE_READ_OML";
#endif
#if defined(GL_OML_subsample)
        case 0x8982: return "GL_FORMAT_SUBSAMPLE_24_24_OML";
        case 0x8983: return "GL_FORMAT_SUBSAMPLE_244_244_OML";
#endif
#if defined(GL_OML_resample)
        case 0x8984: return "GL_PACK_RESAMPLE_OML";
        case 0x8985: return "GL_UNPACK_RESAMPLE_OML";
        case 0x8986: return "GL_RESAMPLE_REPLICATE_OML";
        case 0x8987: return "GL_RESAMPLE_ZERO_FILL_OML";
        case 0x8988: return "GL_RESAMPLE_AVERAGE_OML";
        case 0x8989: return "GL_RESAMPLE_DECIMATE_OML";
#endif
#if defined(GL_APPLE_vertex_program_evaluators)
        case 0x8a00: return "GL_VERTEX_ATTRIB_MAP1_APPLE";
        case 0x8a01: return "GL_VERTEX_ATTRIB_MAP2_APPLE";
        case 0x8a02: return "GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE";
        case 0x8a03: return "GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE";
        case 0x8a04: return "GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE";
        case 0x8a05: return "GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE";
        case 0x8a06: return "GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE";
        case 0x8a07: return "GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE";
        case 0x8a08: return "GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE";
        case 0x8a09: return "GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE";
#endif
#if defined(GL_APPLE_fence)
        case 0x8a0a: return "GL_DRAW_PIXELS_APPLE";
        case 0x8a0b: return "GL_FENCE_APPLE";
#endif
#if defined(GL_APPLE_element_array)
        case 0x8a0c: return "GL_ELEMENT_ARRAY_APPLE";
        case 0x8a0d: return "GL_ELEMENT_ARRAY_TYPE_APPLE";
        case 0x8a0e: return "GL_ELEMENT_ARRAY_POINTER_APPLE";
#endif
#if defined(GL_APPLE_float_pixels)
        case 0x8a0f: return "GL_COLOR_FLOAT_APPLE";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8a11: return "GL_UNIFORM_BUFFER";
#endif
#if defined(GL_APPLE_flush_buffer_range)
        case 0x8a12: return "GL_BUFFER_SERIALIZED_MODIFY_APPLE";
        case 0x8a13: return "GL_BUFFER_FLUSHING_UNMAP_APPLE";
#endif
#if defined(GL_APPLE_aux_depth_stencil)
        case 0x8a14: return "GL_AUX_DEPTH_STENCIL_APPLE";
#endif
#if defined(GL_APPLE_row_bytes)
        case 0x8a15: return "GL_PACK_ROW_BYTES_APPLE";
        case 0x8a16: return "GL_UNPACK_ROW_BYTES_APPLE";
#endif
#if defined(GL_APPLE_object_purgeable)
        case 0x8a19: return "GL_RELEASED_APPLE";
        case 0x8a1a: return "GL_VOLATILE_APPLE";
        case 0x8a1b: return "GL_RETAINED_APPLE";
        case 0x8a1c: return "GL_UNDEFINED_APPLE";
        case 0x8a1d: return "GL_PURGEABLE_APPLE";
#endif
#if defined(GL_APPLE_rgb_422)
        case 0x8a1f: return "GL_RGB_422_APPLE";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8a28: return "GL_UNIFORM_BUFFER_BINDING";
        case 0x8a29: return "GL_UNIFORM_BUFFER_START";
        case 0x8a2a: return "GL_UNIFORM_BUFFER_SIZE";
        case 0x8a2b: return "GL_MAX_VERTEX_UNIFORM_BLOCKS";
#endif
        case 0x8a2c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_3_1)
                     return "GL_MAX_GEOMETRY_UNIFORM_BLOCKS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8a2d: return "GL_MAX_FRAGMENT_UNIFORM_BLOCKS";
        case 0x8a2e: return "GL_MAX_COMBINED_UNIFORM_BLOCKS";
        case 0x8a2f: return "GL_MAX_UNIFORM_BUFFER_BINDINGS";
        case 0x8a30: return "GL_MAX_UNIFORM_BLOCK_SIZE";
        case 0x8a31: return "GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
#endif
        case 0x8a32:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_3_1)
                     return "GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8a33: return "GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
        case 0x8a34: return "GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT";
        case 0x8a35: return "GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH";
        case 0x8a36: return "GL_ACTIVE_UNIFORM_BLOCKS";
        case 0x8a37: return "GL_UNIFORM_TYPE";
        case 0x8a38: return "GL_UNIFORM_SIZE";
        case 0x8a39: return "GL_UNIFORM_NAME_LENGTH";
        case 0x8a3a: return "GL_UNIFORM_BLOCK_INDEX";
        case 0x8a3b: return "GL_UNIFORM_OFFSET";
        case 0x8a3c: return "GL_UNIFORM_ARRAY_STRIDE";
        case 0x8a3d: return "GL_UNIFORM_MATRIX_STRIDE";
        case 0x8a3e: return "GL_UNIFORM_IS_ROW_MAJOR";
        case 0x8a3f: return "GL_UNIFORM_BLOCK_BINDING";
        case 0x8a40: return "GL_UNIFORM_BLOCK_DATA_SIZE";
        case 0x8a41: return "GL_UNIFORM_BLOCK_NAME_LENGTH";
        case 0x8a42: return "GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS";
        case 0x8a43: return "GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
        case 0x8a44: return "GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
#endif
#if defined(GL_VERSION_3_1)
        case 0x8a45: return "GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8a46: return "GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
#endif
#if defined(GL_EXT_texture_sRGB_decode)
        case 0x8a48: return "GL_TEXTURE_SRGB_DECODE_EXT";
        case 0x8a49: return "GL_DECODE_EXT";
        case 0x8a4a: return "GL_SKIP_DECODE_EXT";
#endif
#if defined(GL_EXT_debug_label)
        case 0x8a4f: return "GL_PROGRAM_PIPELINE_OBJECT_EXT";
#endif
#if defined(GL_APPLE_rgb_422)
        case 0x8a51: return "GL_RGB_RAW_422_APPLE";
#endif
#if defined(GL_EXT_shader_framebuffer_fetch)
        case 0x8a52: return "GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT";
#endif
#if defined(GL_APPLE_sync)
        case 0x8a53: return "GL_SYNC_OBJECT_APPLE";
#endif
#if defined(GL_EXT_pvrtc_sRGB)
        case 0x8a54: return "GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT";
        case 0x8a55: return "GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT";
        case 0x8a56: return "GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT";
        case 0x8a57: return "GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT";
#endif
        case 0x8b30:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAGMENT_SHADER";
#endif
#if defined(GL_ARB_fragment_shader)
                     return "GL_FRAGMENT_SHADER_ARB";
#endif
            break;
        case 0x8b31:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VERTEX_SHADER";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_VERTEX_SHADER_ARB";
#endif
            break;
        case 0x8b40:
#if defined(__glext_h_)
                     return "GL_PROGRAM_OBJECT_ARB";
#endif
#if defined(GL_EXT_debug_label)
                     return "GL_PROGRAM_OBJECT_EXT";
#endif
            break;
        case 0x8b48:
#if defined(__glext_h_)
                     return "GL_SHADER_OBJECT_ARB";
#endif
#if defined(GL_EXT_debug_label)
                     return "GL_SHADER_OBJECT_EXT";
#endif
            break;
        case 0x8b49:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_FRAGMENT_UNIFORM_COMPONENTS";
#endif
#if defined(GL_ARB_fragment_shader)
                     return "GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB";
#endif
            break;
        case 0x8b4a:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_VERTEX_UNIFORM_COMPONENTS";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB";
#endif
            break;
        case 0x8b4b:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_MAX_VARYING_COMPONENTS";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_MAX_VARYING_COMPONENTS_EXT";
#endif
#if defined(GL_VERSION_2_0)
                     return "GL_MAX_VARYING_FLOATS";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_MAX_VARYING_FLOATS_ARB";
#endif
            break;
        case 0x8b4c:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB";
#endif
            break;
        case 0x8b4d:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB";
#endif
            break;
#if defined(__glext_h_)
        case 0x8b4e: return "GL_OBJECT_TYPE_ARB";
#endif
        case 0x8b4f:
#if defined(__glext_h_)
                     return "GL_OBJECT_SUBTYPE_ARB";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_SHADER_TYPE";
#endif
            break;
        case 0x8b50:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_VEC2";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_VEC2_ARB";
#endif
            break;
        case 0x8b51:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_VEC3";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_VEC3_ARB";
#endif
            break;
        case 0x8b52:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_VEC4";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_VEC4_ARB";
#endif
            break;
        case 0x8b53:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_INT_VEC2";
#endif
#if defined(__glext_h_)
                     return "GL_INT_VEC2_ARB";
#endif
            break;
        case 0x8b54:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_INT_VEC3";
#endif
#if defined(__glext_h_)
                     return "GL_INT_VEC3_ARB";
#endif
            break;
        case 0x8b55:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_INT_VEC4";
#endif
#if defined(__glext_h_)
                     return "GL_INT_VEC4_ARB";
#endif
            break;
        case 0x8b56:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BOOL";
#endif
#if defined(__glext_h_)
                     return "GL_BOOL_ARB";
#endif
            break;
        case 0x8b57:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BOOL_VEC2";
#endif
#if defined(__glext_h_)
                     return "GL_BOOL_VEC2_ARB";
#endif
            break;
        case 0x8b58:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BOOL_VEC3";
#endif
#if defined(__glext_h_)
                     return "GL_BOOL_VEC3_ARB";
#endif
            break;
        case 0x8b59:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_BOOL_VEC4";
#endif
#if defined(__glext_h_)
                     return "GL_BOOL_VEC4_ARB";
#endif
            break;
        case 0x8b5a:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_MAT2";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_MAT2_ARB";
#endif
            break;
        case 0x8b5b:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_MAT3";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_MAT3_ARB";
#endif
            break;
        case 0x8b5c:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FLOAT_MAT4";
#endif
#if defined(__glext_h_)
                     return "GL_FLOAT_MAT4_ARB";
#endif
            break;
        case 0x8b5d:
#if defined(GL_VERSION_2_0)
                     return "GL_SAMPLER_1D";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_1D_ARB";
#endif
            break;
        case 0x8b5e:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLER_2D";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_2D_ARB";
#endif
            break;
        case 0x8b5f:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_SAMPLER_3D";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_3D_ARB";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_SAMPLER_3D_OES";
#endif
            break;
        case 0x8b60:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_SAMPLER_CUBE";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_CUBE_ARB";
#endif
            break;
        case 0x8b61:
#if defined(GL_VERSION_2_0)
                     return "GL_SAMPLER_1D_SHADOW";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_1D_SHADOW_ARB";
#endif
            break;
        case 0x8b62:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_SAMPLER_2D_SHADOW";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_2D_SHADOW_ARB";
#endif
#if defined(GL_EXT_shadow_samplers)
                     return "GL_SAMPLER_2D_SHADOW_EXT";
#endif
            break;
        case 0x8b63:
#if defined(GL_VERSION_3_1)
                     return "GL_SAMPLER_2D_RECT";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_2D_RECT_ARB";
#endif
            break;
        case 0x8b64:
#if defined(GL_VERSION_3_1)
                     return "GL_SAMPLER_2D_RECT_SHADOW";
#endif
#if defined(__glext_h_)
                     return "GL_SAMPLER_2D_RECT_SHADOW_ARB";
#endif
            break;
        case 0x8b65:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT2x3";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT2x3_NV";
#endif
            break;
        case 0x8b66:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT2x4";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT2x4_NV";
#endif
            break;
        case 0x8b67:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT3x2";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT3x2_NV";
#endif
            break;
        case 0x8b68:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT3x4";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT3x4_NV";
#endif
            break;
        case 0x8b69:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT4x2";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT4x2_NV";
#endif
            break;
        case 0x8b6a:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_FLOAT_MAT4x3";
#endif
#if defined(GL_NV_non_square_matrices)
                     return "GL_FLOAT_MAT4x3_NV";
#endif
            break;
        case 0x8b80:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_DELETE_STATUS";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_DELETE_STATUS_ARB";
#endif
            break;
        case 0x8b81:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_COMPILE_STATUS";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_COMPILE_STATUS_ARB";
#endif
            break;
        case 0x8b82:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_LINK_STATUS";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_LINK_STATUS_ARB";
#endif
            break;
        case 0x8b83:
#if defined(__glext_h_)
                     return "GL_OBJECT_VALIDATE_STATUS_ARB";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_VALIDATE_STATUS";
#endif
            break;
        case 0x8b84:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_INFO_LOG_LENGTH";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_INFO_LOG_LENGTH_ARB";
#endif
            break;
        case 0x8b85:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_ATTACHED_SHADERS";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_ATTACHED_OBJECTS_ARB";
#endif
            break;
        case 0x8b86:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_ACTIVE_UNIFORMS";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_ACTIVE_UNIFORMS_ARB";
#endif
            break;
        case 0x8b87:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_ACTIVE_UNIFORM_MAX_LENGTH";
#endif
#if defined(__glext_h_)
                     return "GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB";
#endif
            break;
        case 0x8b88:
#if defined(__glext_h_)
                     return "GL_OBJECT_SHADER_SOURCE_LENGTH_ARB";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_SHADER_SOURCE_LENGTH";
#endif
            break;
        case 0x8b89:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_ACTIVE_ATTRIBUTES";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_OBJECT_ACTIVE_ATTRIBUTES_ARB";
#endif
            break;
        case 0x8b8a:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_ACTIVE_ATTRIBUTE_MAX_LENGTH";
#endif
#if defined(GL_ARB_vertex_shader)
                     return "GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB";
#endif
            break;
        case 0x8b8b:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_0)
                     return "GL_FRAGMENT_SHADER_DERIVATIVE_HINT";
#endif
#if defined(GL_ARB_fragment_shader)
                     return "GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB";
#endif
#if defined(GL_OES_standard_derivatives)
                     return "GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES";
#endif
            break;
        case 0x8b8c:
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_SHADING_LANGUAGE_VERSION";
#endif
#if defined(GL_ARB_shading_language_100)
                     return "GL_SHADING_LANGUAGE_VERSION_ARB";
#endif
            break;
        case 0x8b8d:
#if defined(GL_EXT_separate_shader_objects)
                     return "GL_ACTIVE_PROGRAM_EXT";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_CURRENT_PROGRAM";
#endif
            break;
#if defined(GL_OES_compressed_paletted_texture)
        case 0x8b90: return "GL_PALETTE4_RGB8_OES";
        case 0x8b91: return "GL_PALETTE4_RGBA8_OES";
        case 0x8b92: return "GL_PALETTE4_R5_G6_B5_OES";
        case 0x8b93: return "GL_PALETTE4_RGBA4_OES";
        case 0x8b94: return "GL_PALETTE4_RGB5_A1_OES";
        case 0x8b95: return "GL_PALETTE8_RGB8_OES";
        case 0x8b96: return "GL_PALETTE8_RGBA8_OES";
        case 0x8b97: return "GL_PALETTE8_R5_G6_B5_OES";
        case 0x8b98: return "GL_PALETTE8_RGBA4_OES";
        case 0x8b99: return "GL_PALETTE8_RGB5_A1_OES";
#endif
        case 0x8b9a:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
                     return "GL_IMPLEMENTATION_COLOR_READ_TYPE";
#endif
#if defined(GL_OES_read_format)
                     return "GL_IMPLEMENTATION_COLOR_READ_TYPE_OES";
#endif
            break;
        case 0x8b9b:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
                     return "GL_IMPLEMENTATION_COLOR_READ_FORMAT";
#endif
#if defined(GL_OES_read_format)
                     return "GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES";
#endif
            break;
#if defined(GL_AMD_performance_monitor)
        case 0x8bc0: return "GL_COUNTER_TYPE_AMD";
        case 0x8bc1: return "GL_COUNTER_RANGE_AMD";
        case 0x8bc2: return "GL_UNSIGNED_INT64_AMD";
        case 0x8bc3: return "GL_PERCENTAGE_AMD";
        case 0x8bc4: return "GL_PERFMON_RESULT_AVAILABLE_AMD";
        case 0x8bc5: return "GL_PERFMON_RESULT_SIZE_AMD";
        case 0x8bc6: return "GL_PERFMON_RESULT_AMD";
#endif
#if defined(GL_QCOM_extended_get)
        case 0x8bd2: return "GL_TEXTURE_WIDTH_QCOM";
        case 0x8bd3: return "GL_TEXTURE_HEIGHT_QCOM";
        case 0x8bd4: return "GL_TEXTURE_DEPTH_QCOM";
        case 0x8bd5: return "GL_TEXTURE_INTERNAL_FORMAT_QCOM";
        case 0x8bd6: return "GL_TEXTURE_FORMAT_QCOM";
        case 0x8bd7: return "GL_TEXTURE_TYPE_QCOM";
        case 0x8bd8: return "GL_TEXTURE_IMAGE_VALID_QCOM";
        case 0x8bd9: return "GL_TEXTURE_NUM_LEVELS_QCOM";
        case 0x8bda: return "GL_TEXTURE_TARGET_QCOM";
        case 0x8bdb: return "GL_TEXTURE_OBJECT_VALID_QCOM";
        case 0x8bdc: return "GL_STATE_RESTORE";
#endif
#if defined(GL_EXT_YUV_target)
        case 0x8be7: return "GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT";
#endif
#if defined(GL_EXT_protected_textures)
        case 0x8bfa: return "GL_TEXTURE_PROTECTED_EXT";
#endif
#if defined(GL_IMG_texture_compression_pvrtc)
        case 0x8c00: return "GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        case 0x8c01: return "GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        case 0x8c02: return "GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        case 0x8c03: return "GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
#endif
#if defined(GL_IMG_shader_binary)
        case 0x8c0a: return "GL_SGX_BINARY_IMG";
#endif
        case 0x8c10:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_RED_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_RED_TYPE_ARB";
#endif
            break;
        case 0x8c11:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_GREEN_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_GREEN_TYPE_ARB";
#endif
            break;
        case 0x8c12:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_BLUE_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_BLUE_TYPE_ARB";
#endif
            break;
        case 0x8c13:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_ALPHA_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_ALPHA_TYPE_ARB";
#endif
            break;
        case 0x8c14:
#if defined(GL_VERSION_3_0)
                     return "GL_TEXTURE_LUMINANCE_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_LUMINANCE_TYPE_ARB";
#endif
            break;
        case 0x8c15:
#if defined(GL_VERSION_3_0)
                     return "GL_TEXTURE_INTENSITY_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_INTENSITY_TYPE_ARB";
#endif
            break;
        case 0x8c16:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_DEPTH_TYPE";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_TEXTURE_DEPTH_TYPE_ARB";
#endif
            break;
        case 0x8c17:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_NORMALIZED";
#endif
#if defined(GL_ARB_texture_float)
                     return "GL_UNSIGNED_NORMALIZED_ARB";
#endif
#if defined(GL_EXT_color_buffer_half_float)
                     return "GL_UNSIGNED_NORMALIZED_EXT";
#endif
            break;
        case 0x8c18:
#if defined(GL_VERSION_3_0)
                     return "GL_TEXTURE_1D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_TEXTURE_1D_ARRAY_EXT";
#endif
            break;
        case 0x8c19:
#if defined(GL_VERSION_3_0)
                     return "GL_PROXY_TEXTURE_1D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_PROXY_TEXTURE_1D_ARRAY_EXT";
#endif
            break;
        case 0x8c1a:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0) || defined(GL_EXT_sparse_texture)
                     return "GL_TEXTURE_2D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_TEXTURE_2D_ARRAY_EXT";
#endif
            break;
        case 0x8c1b:
#if defined(GL_VERSION_3_0)
                     return "GL_PROXY_TEXTURE_2D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_PROXY_TEXTURE_2D_ARRAY_EXT";
#endif
            break;
        case 0x8c1c:
#if defined(GL_VERSION_3_0)
                     return "GL_TEXTURE_BINDING_1D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_TEXTURE_BINDING_1D_ARRAY_EXT";
#endif
            break;
        case 0x8c1d:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TEXTURE_BINDING_2D_ARRAY";
#endif
#if defined(GL_EXT_texture_array)
                     return "GL_TEXTURE_BINDING_2D_ARRAY_EXT";
#endif
            break;
#if defined(GL_NV_geometry_program4)
        case 0x8c26: return "GL_GEOMETRY_PROGRAM_NV";
        case 0x8c27: return "GL_MAX_PROGRAM_OUTPUT_VERTICES_NV";
        case 0x8c28: return "GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV";
#endif
        case 0x8c29:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES";
#endif
            break;
        case 0x8c2a:
#if defined(GL_VERSION_3_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER";
#endif
#if defined(GL_ARB_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_ARB";
#endif
#if defined(GL_VERSION_4_4) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER_BINDING";
#endif
#if defined(GL_EXT_texture_buffer)
                     return "GL_TEXTURE_BUFFER_BINDING_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_BINDING_OES";
#endif
#if defined(GL_EXT_texture_buffer) || defined(GL_EXT_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_OES";
#endif
            break;
        case 0x8c2b:
#if defined(GL_VERSION_3_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_TEXTURE_BUFFER_SIZE";
#endif
#if defined(GL_ARB_texture_buffer_object)
                     return "GL_MAX_TEXTURE_BUFFER_SIZE_ARB";
#endif
#if defined(GL_EXT_texture_buffer) || defined(GL_EXT_texture_buffer_object)
                     return "GL_MAX_TEXTURE_BUFFER_SIZE_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_MAX_TEXTURE_BUFFER_SIZE_OES";
#endif
            break;
        case 0x8c2c:
#if defined(GL_VERSION_3_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BINDING_BUFFER";
#endif
#if defined(GL_ARB_texture_buffer_object)
                     return "GL_TEXTURE_BINDING_BUFFER_ARB";
#endif
#if defined(GL_EXT_texture_buffer) || defined(GL_EXT_texture_buffer_object)
                     return "GL_TEXTURE_BINDING_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BINDING_BUFFER_OES";
#endif
            break;
        case 0x8c2d:
#if defined(GL_VERSION_3_1) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER_DATA_STORE_BINDING";
#endif
#if defined(GL_ARB_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB";
#endif
#if defined(GL_EXT_texture_buffer) || defined(GL_EXT_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES";
#endif
            break;
        case 0x8c2e:
#if defined(GL_ARB_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_FORMAT_ARB";
#endif
#if defined(GL_EXT_texture_buffer_object)
                     return "GL_TEXTURE_BUFFER_FORMAT_EXT";
#endif
            break;
        case 0x8c2f:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_ANY_SAMPLES_PASSED";
#endif
#if defined(GL_EXT_occlusion_query_boolean)
                     return "GL_ANY_SAMPLES_PASSED_EXT";
#endif
            break;
        case 0x8c36:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_SAMPLE_SHADING";
#endif
#if defined(GL_ARB_sample_shading)
                     return "GL_SAMPLE_SHADING_ARB";
#endif
#if defined(GL_OES_sample_shading)
                     return "GL_SAMPLE_SHADING_OES";
#endif
            break;
        case 0x8c37:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MIN_SAMPLE_SHADING_VALUE";
#endif
#if defined(GL_ARB_sample_shading)
                     return "GL_MIN_SAMPLE_SHADING_VALUE_ARB";
#endif
#if defined(GL_OES_sample_shading)
                     return "GL_MIN_SAMPLE_SHADING_VALUE_OES";
#endif
            break;
        case 0x8c3a:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_R11F_G11F_B10F";
#endif
#if defined(GL_APPLE_texture_packed_float)
                     return "GL_R11F_G11F_B10F_APPLE";
#endif
#if defined(GL_EXT_packed_float)
                     return "GL_R11F_G11F_B10F_EXT";
#endif
            break;
        case 0x8c3b:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_10F_11F_11F_REV";
#endif
#if defined(GL_APPLE_texture_packed_float)
                     return "GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE";
#endif
#if defined(GL_EXT_packed_float)
                     return "GL_UNSIGNED_INT_10F_11F_11F_REV_EXT";
#endif
            break;
#if defined(GL_EXT_packed_float)
        case 0x8c3c: return "GL_RGBA_SIGNED_COMPONENTS_EXT";
#endif
        case 0x8c3d:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB9_E5";
#endif
#if defined(GL_APPLE_texture_packed_float)
                     return "GL_RGB9_E5_APPLE";
#endif
#if defined(GL_EXT_texture_shared_exponent)
                     return "GL_RGB9_E5_EXT";
#endif
            break;
        case 0x8c3e:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_5_9_9_9_REV";
#endif
#if defined(GL_APPLE_texture_packed_float)
                     return "GL_UNSIGNED_INT_5_9_9_9_REV_APPLE";
#endif
#if defined(GL_EXT_texture_shared_exponent)
                     return "GL_UNSIGNED_INT_5_9_9_9_REV_EXT";
#endif
            break;
        case 0x8c3f:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_1)
                     return "GL_TEXTURE_SHARED_SIZE";
#endif
#if defined(GL_EXT_texture_shared_exponent)
                     return "GL_TEXTURE_SHARED_SIZE_EXT";
#endif
            break;
        case 0x8c40:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_SRGB";
#endif
#if defined(GL_EXT_sRGB) || defined(GL_EXT_texture_sRGB)
                     return "GL_SRGB_EXT";
#endif
            break;
        case 0x8c41:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_SRGB8";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_SRGB8_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_SRGB8_NV";
#endif
            break;
        case 0x8c42:
#if defined(GL_VERSION_2_1)
                     return "GL_SRGB_ALPHA";
#endif
#if defined(GL_EXT_sRGB) || defined(GL_EXT_texture_sRGB)
                     return "GL_SRGB_ALPHA_EXT";
#endif
            break;
        case 0x8c43:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_2_1)
                     return "GL_SRGB8_ALPHA8";
#endif
#if defined(GL_EXT_sRGB) || defined(GL_EXT_texture_sRGB)
                     return "GL_SRGB8_ALPHA8_EXT";
#endif
            break;
        case 0x8c44:
#if defined(GL_VERSION_2_1)
                     return "GL_SLUMINANCE_ALPHA";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_SLUMINANCE_ALPHA_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_SLUMINANCE_ALPHA_NV";
#endif
            break;
        case 0x8c45:
#if defined(GL_VERSION_2_1)
                     return "GL_SLUMINANCE8_ALPHA8";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_SLUMINANCE8_ALPHA8_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_SLUMINANCE8_ALPHA8_NV";
#endif
            break;
        case 0x8c46:
#if defined(GL_VERSION_2_1)
                     return "GL_SLUMINANCE";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_SLUMINANCE_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_SLUMINANCE_NV";
#endif
            break;
        case 0x8c47:
#if defined(GL_VERSION_2_1)
                     return "GL_SLUMINANCE8";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_SLUMINANCE8_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_SLUMINANCE8_NV";
#endif
            break;
        case 0x8c48:
#if defined(GL_VERSION_2_1)
                     return "GL_COMPRESSED_SRGB";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_EXT";
#endif
            break;
        case 0x8c49:
#if defined(GL_VERSION_2_1)
                     return "GL_COMPRESSED_SRGB_ALPHA";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_ALPHA_EXT";
#endif
            break;
        case 0x8c4a:
#if defined(GL_VERSION_2_1)
                     return "GL_COMPRESSED_SLUMINANCE";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SLUMINANCE_EXT";
#endif
            break;
        case 0x8c4b:
#if defined(GL_VERSION_2_1)
                     return "GL_COMPRESSED_SLUMINANCE_ALPHA";
#endif
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SLUMINANCE_ALPHA_EXT";
#endif
            break;
        case 0x8c4c:
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_S3TC_DXT1_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_COMPRESSED_SRGB_S3TC_DXT1_NV";
#endif
            break;
        case 0x8c4d:
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV";
#endif
            break;
        case 0x8c4e:
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV";
#endif
            break;
        case 0x8c4f:
#if defined(GL_EXT_texture_sRGB)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
#endif
#if defined(GL_NV_sRGB_formats)
                     return "GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV";
#endif
            break;
#if defined(GL_EXT_texture_compression_latc)
        case 0x8c70: return "GL_COMPRESSED_LUMINANCE_LATC1_EXT";
        case 0x8c71: return "GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT";
        case 0x8c72: return "GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT";
        case 0x8c73: return "GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT";
#endif
#if defined(GL_NV_tessellation_program5)
        case 0x8c74: return "GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV";
        case 0x8c75: return "GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV";
#endif
        case 0x8c76:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT";
#endif
            break;
#if defined(GL_NV_transform_feedback)
        case 0x8c77: return "GL_BACK_PRIMARY_COLOR_NV";
        case 0x8c78: return "GL_BACK_SECONDARY_COLOR_NV";
        case 0x8c79: return "GL_TEXTURE_COORD_NV";
        case 0x8c7a: return "GL_CLIP_DISTANCE_NV";
        case 0x8c7b: return "GL_VERTEX_ID_NV";
        case 0x8c7c: return "GL_PRIMITIVE_ID_NV";
        case 0x8c7d: return "GL_GENERIC_ATTRIB_NV";
        case 0x8c7e: return "GL_TRANSFORM_FEEDBACK_ATTRIBS_NV";
#endif
        case 0x8c7f:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_MODE";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV";
#endif
            break;
        case 0x8c80:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV";
#endif
            break;
#if defined(GL_NV_transform_feedback)
        case 0x8c81: return "GL_ACTIVE_VARYINGS_NV";
        case 0x8c82: return "GL_ACTIVE_VARYING_MAX_LENGTH_NV";
#endif
        case 0x8c83:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_VARYINGS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_VARYINGS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_VARYINGS_NV";
#endif
            break;
        case 0x8c84:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_START";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_START_NV";
#endif
            break;
        case 0x8c85:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_SIZE";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV";
#endif
            break;
#if defined(GL_NV_transform_feedback)
        case 0x8c86: return "GL_TRANSFORM_FEEDBACK_RECORD_NV";
#endif
        case 0x8c87:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_2)
                     return "GL_PRIMITIVES_GENERATED";
#endif
#if defined(GL_EXT_transform_feedback) || defined(GL_EXT_geometry_shader)
                     return "GL_PRIMITIVES_GENERATED_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_PRIMITIVES_GENERATED_NV";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_PRIMITIVES_GENERATED_OES";
#endif
            break;
        case 0x8c88:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV";
#endif
            break;
        case 0x8c89:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RASTERIZER_DISCARD";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_RASTERIZER_DISCARD_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_RASTERIZER_DISCARD_NV";
#endif
            break;
        case 0x8c8a:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV";
#endif
            break;
        case 0x8c8b:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV";
#endif
            break;
        case 0x8c8c:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_INTERLEAVED_ATTRIBS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_INTERLEAVED_ATTRIBS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_INTERLEAVED_ATTRIBS_NV";
#endif
            break;
        case 0x8c8d:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_SEPARATE_ATTRIBS";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_SEPARATE_ATTRIBS_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_SEPARATE_ATTRIBS_NV";
#endif
            break;
        case 0x8c8e:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_NV";
#endif
            break;
        case 0x8c8f:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_BINDING";
#endif
#if defined(GL_EXT_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT";
#endif
#if defined(GL_NV_transform_feedback)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV";
#endif
            break;
#if defined(GL_AMD_compressed_ATC_texture)
        case 0x8c92: return "GL_ATC_RGB_AMD";
        case 0x8c93: return "GL_ATC_RGBA_EXPLICIT_ALPHA_AMD";
#endif
#if defined(GL_VERSION_2_0)
        case 0x8ca0: return "GL_POINT_SPRITE_COORD_ORIGIN";
        case 0x8ca1: return "GL_LOWER_LEFT";
        case 0x8ca2: return "GL_UPPER_LEFT";
#endif
#if defined(GL_VERSION_2_0) || defined(GL_ES_VERSION_2_0)
        case 0x8ca3: return "GL_STENCIL_BACK_REF";
        case 0x8ca4: return "GL_STENCIL_BACK_VALUE_MASK";
        case 0x8ca5: return "GL_STENCIL_BACK_WRITEMASK";
#endif
        case 0x8ca6:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_DRAW_FRAMEBUFFER_BINDING";
#endif
#if defined(GL_ANGLE_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_BINDING_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_DRAW_FRAMEBUFFER_BINDING_APPLE";
#endif
#if defined(GL_EXT_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_BINDING_EXT";
#endif
#if defined(GL_NV_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_BINDING_NV";
#endif
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_BINDING";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_BINDING_EXT";
#endif
            break;
        case 0x8ca7:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_BINDING";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_BINDING_EXT";
#endif
            break;
        case 0x8ca8:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_READ_FRAMEBUFFER";
#endif
#if defined(GL_ANGLE_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_READ_FRAMEBUFFER_APPLE";
#endif
#if defined(GL_EXT_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_EXT";
#endif
#if defined(GL_NV_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_NV";
#endif
            break;
        case 0x8ca9:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_DRAW_FRAMEBUFFER";
#endif
#if defined(GL_ANGLE_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_DRAW_FRAMEBUFFER_APPLE";
#endif
#if defined(GL_EXT_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_EXT";
#endif
#if defined(GL_NV_framebuffer_blit)
                     return "GL_DRAW_FRAMEBUFFER_NV";
#endif
            break;
        case 0x8caa:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_READ_FRAMEBUFFER_BINDING";
#endif
#if defined(GL_ANGLE_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_BINDING_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_READ_FRAMEBUFFER_BINDING_APPLE";
#endif
#if defined(GL_EXT_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_BINDING_EXT";
#endif
#if defined(GL_NV_framebuffer_blit)
                     return "GL_READ_FRAMEBUFFER_BINDING_NV";
#endif
            break;
        case 0x8cab:
#if defined(GL_NV_framebuffer_multisample_coverage)
                     return "GL_RENDERBUFFER_COVERAGE_SAMPLES_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_RENDERBUFFER_SAMPLES";
#endif
#if defined(GL_ANGLE_framebuffer_multisample)
                     return "GL_RENDERBUFFER_SAMPLES_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_RENDERBUFFER_SAMPLES_APPLE";
#endif
#if defined(GL_EXT_multisampled_render_to_texture) || defined(GL_EXT_framebuffer_multisample)
                     return "GL_RENDERBUFFER_SAMPLES_EXT";
#endif
#if defined(GL_NV_framebuffer_multisample)
                     return "GL_RENDERBUFFER_SAMPLES_NV";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x8cac: return "GL_DEPTH_COMPONENT32F";
        case 0x8cad: return "GL_DEPTH32F_STENCIL8";
#endif
        case 0x8cd0:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT";
#endif
            break;
        case 0x8cd1:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT";
#endif
            break;
        case 0x8cd2:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT";
#endif
            break;
        case 0x8cd3:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT";
#endif
            break;
        case 0x8cd4:
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT";
#endif
#if defined(GL_OES_texture_3D)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES";
#endif
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT";
#endif
            break;
        case 0x8cd5:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_COMPLETE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_COMPLETE_EXT";
#endif
            break;
        case 0x8cd6:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT";
#endif
            break;
        case 0x8cd7:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT";
#endif
            break;
        case 0x8cd9:
#if defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT";
#endif
            break;
#if defined(GL_EXT_framebuffer_object)
        case 0x8cda: return "GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT";
#endif
        case 0x8cdb:
#if defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT";
#endif
            break;
        case 0x8cdc:
#if defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT";
#endif
            break;
        case 0x8cdd:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER_UNSUPPORTED";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_UNSUPPORTED_EXT";
#endif
            break;
        case 0x8cdf:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_MAX_COLOR_ATTACHMENTS";
#endif
#if defined(GL_EXT_framebuffer_object) || defined(GL_EXT_draw_buffers)
                     return "GL_MAX_COLOR_ATTACHMENTS_EXT";
#endif
#if defined(GL_NV_fbo_color_attachments)
                     return "GL_MAX_COLOR_ATTACHMENTS_NV";
#endif
            break;
        case 0x8ce0:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT0";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT0_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT0_NV";
#endif
            break;
        case 0x8ce1:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT1";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT1_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT1_NV";
#endif
            break;
        case 0x8ce2:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT2";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT2_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT2_NV";
#endif
            break;
        case 0x8ce3:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT3";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT3_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT3_NV";
#endif
            break;
        case 0x8ce4:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT4";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT4_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT4_NV";
#endif
            break;
        case 0x8ce5:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT5";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT5_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT5_NV";
#endif
            break;
        case 0x8ce6:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT6";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT6_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT6_NV";
#endif
            break;
        case 0x8ce7:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT7";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT7_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT7_NV";
#endif
            break;
        case 0x8ce8:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT8";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT8_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT8_NV";
#endif
            break;
        case 0x8ce9:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT9";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT9_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT9_NV";
#endif
            break;
        case 0x8cea:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT10";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT10_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT10_NV";
#endif
            break;
        case 0x8ceb:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT11";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT11_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT11_NV";
#endif
            break;
        case 0x8cec:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT12";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT12_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT12_NV";
#endif
            break;
        case 0x8ced:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT13";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT13_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT13_NV";
#endif
            break;
        case 0x8cee:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT14";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT14_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT14_NV";
#endif
            break;
        case 0x8cef:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_COLOR_ATTACHMENT15";
#endif
#if defined(GL_EXT_draw_buffers) || defined(GL_EXT_framebuffer_object)
                     return "GL_COLOR_ATTACHMENT15_EXT";
#endif
#if defined(GL_NV_draw_buffers)
                     return "GL_COLOR_ATTACHMENT15_NV";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x8cf0: return "GL_COLOR_ATTACHMENT16";
        case 0x8cf1: return "GL_COLOR_ATTACHMENT17";
        case 0x8cf2: return "GL_COLOR_ATTACHMENT18";
        case 0x8cf3: return "GL_COLOR_ATTACHMENT19";
        case 0x8cf4: return "GL_COLOR_ATTACHMENT20";
        case 0x8cf5: return "GL_COLOR_ATTACHMENT21";
        case 0x8cf6: return "GL_COLOR_ATTACHMENT22";
        case 0x8cf7: return "GL_COLOR_ATTACHMENT23";
        case 0x8cf8: return "GL_COLOR_ATTACHMENT24";
        case 0x8cf9: return "GL_COLOR_ATTACHMENT25";
        case 0x8cfa: return "GL_COLOR_ATTACHMENT26";
        case 0x8cfb: return "GL_COLOR_ATTACHMENT27";
        case 0x8cfc: return "GL_COLOR_ATTACHMENT28";
        case 0x8cfd: return "GL_COLOR_ATTACHMENT29";
        case 0x8cfe: return "GL_COLOR_ATTACHMENT30";
        case 0x8cff: return "GL_COLOR_ATTACHMENT31";
#endif
        case 0x8d00:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_DEPTH_ATTACHMENT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_DEPTH_ATTACHMENT_EXT";
#endif
            break;
        case 0x8d20:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_STENCIL_ATTACHMENT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_STENCIL_ATTACHMENT_EXT";
#endif
            break;
        case 0x8d40:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_FRAMEBUFFER";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_FRAMEBUFFER_EXT";
#endif
            break;
        case 0x8d41:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_EXT";
#endif
            break;
        case 0x8d42:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_WIDTH";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_WIDTH_EXT";
#endif
            break;
        case 0x8d43:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_HEIGHT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_HEIGHT_EXT";
#endif
            break;
        case 0x8d44:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_INTERNAL_FORMAT";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_INTERNAL_FORMAT_EXT";
#endif
            break;
        case 0x8d46:
#if defined(GL_VERSION_3_0)
                     return "GL_STENCIL_INDEX1";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_STENCIL_INDEX1_EXT";
#endif
#if defined(GL_OES_stencil1)
                     return "GL_STENCIL_INDEX1_OES";
#endif
            break;
        case 0x8d47:
#if defined(GL_VERSION_3_0)
                     return "GL_STENCIL_INDEX4";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_STENCIL_INDEX4_EXT";
#endif
#if defined(GL_OES_stencil4)
                     return "GL_STENCIL_INDEX4_OES";
#endif
            break;
        case 0x8d48:
#if defined(GL_ES_VERSION_2_0) || defined(GL_VERSION_3_0)
                     return "GL_STENCIL_INDEX8";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_STENCIL_INDEX8_EXT";
#endif
#if defined(GL_OES_texture_stencil8)
                     return "GL_STENCIL_INDEX8_OES";
#endif
            break;
        case 0x8d49:
#if defined(GL_VERSION_3_0)
                     return "GL_STENCIL_INDEX16";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_STENCIL_INDEX16_EXT";
#endif
            break;
        case 0x8d50:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_RED_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_RED_SIZE_EXT";
#endif
            break;
        case 0x8d51:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_GREEN_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_GREEN_SIZE_EXT";
#endif
            break;
        case 0x8d52:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_BLUE_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_BLUE_SIZE_EXT";
#endif
            break;
        case 0x8d53:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_ALPHA_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_ALPHA_SIZE_EXT";
#endif
            break;
        case 0x8d54:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_DEPTH_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_DEPTH_SIZE_EXT";
#endif
            break;
        case 0x8d55:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_2_0)
                     return "GL_RENDERBUFFER_STENCIL_SIZE";
#endif
#if defined(GL_EXT_framebuffer_object)
                     return "GL_RENDERBUFFER_STENCIL_SIZE_EXT";
#endif
            break;
        case 0x8d56:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
#endif
#if defined(GL_ANGLE_framebuffer_multisample)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE";
#endif
#if defined(GL_EXT_multisampled_render_to_texture) || defined(GL_EXT_framebuffer_multisample)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT";
#endif
#if defined(GL_NV_framebuffer_multisample)
                     return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV";
#endif
            break;
        case 0x8d57:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_MAX_SAMPLES";
#endif
#if defined(GL_ANGLE_framebuffer_multisample)
                     return "GL_MAX_SAMPLES_ANGLE";
#endif
#if defined(GL_APPLE_framebuffer_multisample)
                     return "GL_MAX_SAMPLES_APPLE";
#endif
#if defined(GL_EXT_multisampled_render_to_texture) || defined(GL_EXT_framebuffer_multisample)
                     return "GL_MAX_SAMPLES_EXT";
#endif
#if defined(GL_NV_framebuffer_multisample)
                     return "GL_MAX_SAMPLES_NV";
#endif
            break;
#if defined(GL_OES_texture_half_float)
        case 0x8d61: return "GL_HALF_FLOAT_OES";
#endif
        case 0x8d62:
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
                     return "GL_RGB565";
#endif
#if defined(GL_OES_required_internalformat)
                     return "GL_RGB565_OES";
#endif
            break;
#if defined(GL_OES_compressed_ETC1_RGB8_texture)
        case 0x8d64: return "GL_ETC1_RGB8_OES";
#endif
#if defined(GL_OES_EGL_image_external)
        case 0x8d65: return "GL_TEXTURE_EXTERNAL_OES";
        case 0x8d66: return "GL_SAMPLER_EXTERNAL_OES";
        case 0x8d67: return "GL_TEXTURE_BINDING_EXTERNAL_OES";
        case 0x8d68: return "GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_0)
        case 0x8d69: return "GL_PRIMITIVE_RESTART_FIXED_INDEX";
#endif
        case 0x8d6a:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_0)
                     return "GL_ANY_SAMPLES_PASSED_CONSERVATIVE";
#endif
#if defined(GL_EXT_occlusion_query_boolean)
                     return "GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_0)
        case 0x8d6b: return "GL_MAX_ELEMENT_INDEX";
#endif
#if defined(GL_EXT_multisampled_render_to_texture)
        case 0x8d6c: return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT";
#endif
        case 0x8d70:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA32UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA32UI_EXT";
#endif
            break;
        case 0x8d71:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB32UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB32UI_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d72: return "GL_ALPHA32UI_EXT";
        case 0x8d73: return "GL_INTENSITY32UI_EXT";
        case 0x8d74: return "GL_LUMINANCE32UI_EXT";
        case 0x8d75: return "GL_LUMINANCE_ALPHA32UI_EXT";
#endif
        case 0x8d76:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA16UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA16UI_EXT";
#endif
            break;
        case 0x8d77:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB16UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB16UI_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d78: return "GL_ALPHA16UI_EXT";
        case 0x8d79: return "GL_INTENSITY16UI_EXT";
        case 0x8d7a: return "GL_LUMINANCE16UI_EXT";
        case 0x8d7b: return "GL_LUMINANCE_ALPHA16UI_EXT";
#endif
        case 0x8d7c:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA8UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA8UI_EXT";
#endif
            break;
        case 0x8d7d:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB8UI";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB8UI_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d7e: return "GL_ALPHA8UI_EXT";
        case 0x8d7f: return "GL_INTENSITY8UI_EXT";
        case 0x8d80: return "GL_LUMINANCE8UI_EXT";
        case 0x8d81: return "GL_LUMINANCE_ALPHA8UI_EXT";
#endif
        case 0x8d82:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA32I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA32I_EXT";
#endif
            break;
        case 0x8d83:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB32I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB32I_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d84: return "GL_ALPHA32I_EXT";
        case 0x8d85: return "GL_INTENSITY32I_EXT";
        case 0x8d86: return "GL_LUMINANCE32I_EXT";
        case 0x8d87: return "GL_LUMINANCE_ALPHA32I_EXT";
#endif
        case 0x8d88:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA16I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA16I_EXT";
#endif
            break;
        case 0x8d89:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB16I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB16I_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d8a: return "GL_ALPHA16I_EXT";
        case 0x8d8b: return "GL_INTENSITY16I_EXT";
        case 0x8d8c: return "GL_LUMINANCE16I_EXT";
        case 0x8d8d: return "GL_LUMINANCE_ALPHA16I_EXT";
#endif
        case 0x8d8e:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA8I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA8I_EXT";
#endif
            break;
        case 0x8d8f:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB8I";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB8I_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d90: return "GL_ALPHA8I_EXT";
        case 0x8d91: return "GL_INTENSITY8I_EXT";
        case 0x8d92: return "GL_LUMINANCE8I_EXT";
        case 0x8d93: return "GL_LUMINANCE_ALPHA8I_EXT";
#endif
        case 0x8d94:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RED_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RED_INTEGER_EXT";
#endif
            break;
        case 0x8d95:
#if defined(GL_VERSION_3_0)
                     return "GL_GREEN_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_GREEN_INTEGER_EXT";
#endif
            break;
        case 0x8d96:
#if defined(GL_VERSION_3_0)
                     return "GL_BLUE_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_BLUE_INTEGER_EXT";
#endif
            break;
        case 0x8d97:
#if defined(GL_VERSION_3_0)
                     return "GL_ALPHA_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_ALPHA_INTEGER_EXT";
#endif
            break;
        case 0x8d98:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGB_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGB_INTEGER_EXT";
#endif
            break;
        case 0x8d99:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_RGBA_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_RGBA_INTEGER_EXT";
#endif
            break;
        case 0x8d9a:
#if defined(GL_VERSION_3_0)
                     return "GL_BGR_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_BGR_INTEGER_EXT";
#endif
            break;
        case 0x8d9b:
#if defined(GL_VERSION_3_0)
                     return "GL_BGRA_INTEGER";
#endif
#if defined(GL_EXT_texture_integer)
                     return "GL_BGRA_INTEGER_EXT";
#endif
            break;
#if defined(GL_EXT_texture_integer)
        case 0x8d9c: return "GL_LUMINANCE_INTEGER_EXT";
        case 0x8d9d: return "GL_LUMINANCE_ALPHA_INTEGER_EXT";
        case 0x8d9e: return "GL_RGBA_INTEGER_MODE_EXT";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
        case 0x8d9f: return "GL_INT_2_10_10_10_REV";
#endif
#if defined(GL_NV_parameter_buffer_object)
        case 0x8da0: return "GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV";
        case 0x8da1: return "GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV";
        case 0x8da2: return "GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV";
        case 0x8da3: return "GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV";
        case 0x8da4: return "GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV";
#endif
#if defined(GL_NV_gpu_program4)
        case 0x8da5: return "GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV";
        case 0x8da6: return "GL_MAX_PROGRAM_GENERIC_RESULTS_NV";
#endif
        case 0x8da7:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_FRAMEBUFFER_ATTACHMENT_LAYERED";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES";
#endif
            break;
        case 0x8da8:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES";
#endif
            break;
        case 0x8da9:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT";
#endif
            break;
#if defined(GL_NV_transform_feedback)
        case 0x8daa: return "GL_LAYER_NV";
#endif
#if defined(GL_NV_depth_buffer_float)
        case 0x8dab: return "GL_DEPTH_COMPONENT32F_NV";
        case 0x8dac: return "GL_DEPTH32F_STENCIL8_NV";
#endif
        case 0x8dad:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_FLOAT_32_UNSIGNED_INT_24_8_REV";
#endif
#if defined(GL_NV_depth_buffer_float)
                     return "GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV";
#endif
            break;
#if defined(GL_ARB_shading_language_include)
        case 0x8dae: return "GL_SHADER_INCLUDE_ARB";
#endif
#if defined(GL_NV_depth_buffer_float)
        case 0x8daf: return "GL_DEPTH_BUFFER_FLOAT_MODE_NV";
#endif
        case 0x8db9:
#if defined(GL_VERSION_3_0)
                     return "GL_FRAMEBUFFER_SRGB";
#endif
#if defined(GL_EXT_framebuffer_sRGB) || defined(GL_EXT_sRGB_write_control)
                     return "GL_FRAMEBUFFER_SRGB_EXT";
#endif
            break;
#if defined(GL_EXT_framebuffer_sRGB)
        case 0x8dba: return "GL_FRAMEBUFFER_SRGB_CAPABLE_EXT";
#endif
        case 0x8dbb:
#if defined(GL_VERSION_3_0)
                     return "GL_COMPRESSED_RED_RGTC1";
#endif
#if defined(GL_EXT_texture_compression_rgtc)
                     return "GL_COMPRESSED_RED_RGTC1_EXT";
#endif
            break;
        case 0x8dbc:
#if defined(GL_VERSION_3_0)
                     return "GL_COMPRESSED_SIGNED_RED_RGTC1";
#endif
#if defined(GL_EXT_texture_compression_rgtc)
                     return "GL_COMPRESSED_SIGNED_RED_RGTC1_EXT";
#endif
            break;
        case 0x8dbd:
#if defined(GL_EXT_texture_compression_rgtc)
                     return "GL_COMPRESSED_RED_GREEN_RGTC2_EXT";
#endif
#if defined(GL_VERSION_3_0)
                     return "GL_COMPRESSED_RG_RGTC2";
#endif
            break;
        case 0x8dbe:
#if defined(GL_EXT_texture_compression_rgtc)
                     return "GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
#endif
#if defined(GL_VERSION_3_0)
                     return "GL_COMPRESSED_SIGNED_RG_RGTC2";
#endif
            break;
        case 0x8dc0:
#if defined(GL_VERSION_3_0)
                     return "GL_SAMPLER_1D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_SAMPLER_1D_ARRAY_EXT";
#endif
            break;
        case 0x8dc1:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_SAMPLER_2D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_SAMPLER_2D_ARRAY_EXT";
#endif
            break;
        case 0x8dc2:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_3_1)
                     return "GL_SAMPLER_BUFFER";
#endif
#if defined(GL_EXT_gpu_shader4) || defined(GL_EXT_texture_buffer)
                     return "GL_SAMPLER_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_SAMPLER_BUFFER_OES";
#endif
            break;
        case 0x8dc3:
#if defined(GL_VERSION_3_0)
                     return "GL_SAMPLER_1D_ARRAY_SHADOW";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_SAMPLER_1D_ARRAY_SHADOW_EXT";
#endif
            break;
        case 0x8dc4:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_SAMPLER_2D_ARRAY_SHADOW";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_SAMPLER_2D_ARRAY_SHADOW_EXT";
#endif
#if defined(GL_NV_shadow_samplers_array)
                     return "GL_SAMPLER_2D_ARRAY_SHADOW_NV";
#endif
            break;
        case 0x8dc5:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
                     return "GL_SAMPLER_CUBE_SHADOW";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_SAMPLER_CUBE_SHADOW_EXT";
#endif
#if defined(GL_NV_shadow_samplers_cube)
                     return "GL_SAMPLER_CUBE_SHADOW_NV";
#endif
            break;
        case 0x8dc6:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_VEC2";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_VEC2_EXT";
#endif
            break;
        case 0x8dc7:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_VEC3";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_VEC3_EXT";
#endif
            break;
        case 0x8dc8:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_VEC4";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_VEC4_EXT";
#endif
            break;
        case 0x8dc9:
#if defined(GL_VERSION_3_0)
                     return "GL_INT_SAMPLER_1D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_1D_EXT";
#endif
            break;
        case 0x8dca:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_INT_SAMPLER_2D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_2D_EXT";
#endif
            break;
        case 0x8dcb:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_INT_SAMPLER_3D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_3D_EXT";
#endif
            break;
        case 0x8dcc:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_INT_SAMPLER_CUBE";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_CUBE_EXT";
#endif
            break;
        case 0x8dcd:
#if defined(GL_VERSION_3_1)
                     return "GL_INT_SAMPLER_2D_RECT";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_2D_RECT_EXT";
#endif
            break;
        case 0x8dce:
#if defined(GL_VERSION_3_0)
                     return "GL_INT_SAMPLER_1D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_1D_ARRAY_EXT";
#endif
            break;
        case 0x8dcf:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_INT_SAMPLER_2D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_INT_SAMPLER_2D_ARRAY_EXT";
#endif
            break;
        case 0x8dd0:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_3_1)
                     return "GL_INT_SAMPLER_BUFFER";
#endif
#if defined(GL_EXT_gpu_shader4) || defined(GL_EXT_texture_buffer)
                     return "GL_INT_SAMPLER_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_INT_SAMPLER_BUFFER_OES";
#endif
            break;
        case 0x8dd1:
#if defined(GL_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_1D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_1D_EXT";
#endif
            break;
        case 0x8dd2:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_2D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_EXT";
#endif
            break;
        case 0x8dd3:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_3D";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_3D_EXT";
#endif
            break;
        case 0x8dd4:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE_EXT";
#endif
            break;
        case 0x8dd5:
#if defined(GL_VERSION_3_1)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_RECT";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT";
#endif
            break;
        case 0x8dd6:
#if defined(GL_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_1D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT";
#endif
            break;
        case 0x8dd7:
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_ARRAY";
#endif
#if defined(GL_EXT_gpu_shader4)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT";
#endif
            break;
        case 0x8dd8:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_3_1)
                     return "GL_UNSIGNED_INT_SAMPLER_BUFFER";
#endif
#if defined(GL_EXT_gpu_shader4) || defined(GL_EXT_texture_buffer)
                     return "GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_UNSIGNED_INT_SAMPLER_BUFFER_OES";
#endif
            break;
        case 0x8dd9:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_GEOMETRY_SHADER";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_GEOMETRY_SHADER_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_GEOMETRY_SHADER_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_GEOMETRY_SHADER_OES";
#endif
            break;
        case 0x8dda:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_GEOMETRY_VERTICES_OUT_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_GEOMETRY_VERTICES_OUT_EXT";
#endif
            break;
        case 0x8ddb:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_GEOMETRY_INPUT_TYPE_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_GEOMETRY_INPUT_TYPE_EXT";
#endif
            break;
        case 0x8ddc:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_GEOMETRY_OUTPUT_TYPE_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_GEOMETRY_OUTPUT_TYPE_EXT";
#endif
            break;
        case 0x8ddd:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT";
#endif
            break;
        case 0x8dde:
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_VERTEX_VARYING_COMPONENTS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4)
                     return "GL_MAX_VERTEX_VARYING_COMPONENTS_EXT";
#endif
            break;
        case 0x8ddf:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_UNIFORM_COMPONENTS";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES";
#endif
            break;
        case 0x8de0:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_OUTPUT_VERTICES";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES";
#endif
            break;
        case 0x8de1:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS";
#endif
#if defined(GL_ARB_geometry_shader4)
                     return "GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB";
#endif
#if defined(GL_EXT_geometry_shader4) || defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES";
#endif
            break;
#if defined(GL_EXT_bindable_uniform)
        case 0x8de2: return "GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT";
        case 0x8de3: return "GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT";
        case 0x8de4: return "GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT";
#endif
#if defined(GL_VERSION_4_0)
        case 0x8de5: return "GL_ACTIVE_SUBROUTINES";
        case 0x8de6: return "GL_ACTIVE_SUBROUTINE_UNIFORMS";
        case 0x8de7: return "GL_MAX_SUBROUTINES";
        case 0x8de8: return "GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS";
#endif
#if defined(GL_ARB_shading_language_include)
        case 0x8de9: return "GL_NAMED_STRING_LENGTH_ARB";
        case 0x8dea: return "GL_NAMED_STRING_TYPE_ARB";
#endif
#if defined(GL_EXT_bindable_uniform)
        case 0x8ded: return "GL_MAX_BINDABLE_UNIFORM_SIZE_EXT";
        case 0x8dee: return "GL_UNIFORM_BUFFER_EXT";
        case 0x8def: return "GL_UNIFORM_BUFFER_BINDING_EXT";
#endif
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
        case 0x8df0: return "GL_LOW_FLOAT";
        case 0x8df1: return "GL_MEDIUM_FLOAT";
        case 0x8df2: return "GL_HIGH_FLOAT";
        case 0x8df3: return "GL_LOW_INT";
        case 0x8df4: return "GL_MEDIUM_INT";
        case 0x8df5: return "GL_HIGH_INT";
#endif
#if defined(GL_OES_vertex_type_10_10_10_2)
        case 0x8df6: return "GL_UNSIGNED_INT_10_10_10_2_OES";
        case 0x8df7: return "GL_INT_10_10_10_2_OES";
#endif
#if defined(GL_VERSION_4_1) || defined(GL_ES_VERSION_2_0)
        case 0x8df8: return "GL_SHADER_BINARY_FORMATS";
        case 0x8df9: return "GL_NUM_SHADER_BINARY_FORMATS";
        case 0x8dfa: return "GL_SHADER_COMPILER";
        case 0x8dfb: return "GL_MAX_VERTEX_UNIFORM_VECTORS";
        case 0x8dfc: return "GL_MAX_VARYING_VECTORS";
        case 0x8dfd: return "GL_MAX_FRAGMENT_UNIFORM_VECTORS";
#endif
#if defined(GL_NV_framebuffer_multisample_coverage)
        case 0x8e10: return "GL_RENDERBUFFER_COLOR_SAMPLES_NV";
        case 0x8e11: return "GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV";
        case 0x8e12: return "GL_MULTISAMPLE_COVERAGE_MODES_NV";
#endif
        case 0x8e13:
#if defined(GL_VERSION_3_0)
                     return "GL_QUERY_WAIT";
#endif
#if defined(GL_NV_conditional_render)
                     return "GL_QUERY_WAIT_NV";
#endif
            break;
        case 0x8e14:
#if defined(GL_VERSION_3_0)
                     return "GL_QUERY_NO_WAIT";
#endif
#if defined(GL_NV_conditional_render)
                     return "GL_QUERY_NO_WAIT_NV";
#endif
            break;
        case 0x8e15:
#if defined(GL_VERSION_3_0)
                     return "GL_QUERY_BY_REGION_WAIT";
#endif
#if defined(GL_NV_conditional_render)
                     return "GL_QUERY_BY_REGION_WAIT_NV";
#endif
            break;
        case 0x8e16:
#if defined(GL_VERSION_3_0)
                     return "GL_QUERY_BY_REGION_NO_WAIT";
#endif
#if defined(GL_NV_conditional_render)
                     return "GL_QUERY_BY_REGION_NO_WAIT_NV";
#endif
            break;
#if defined(GL_VERSION_4_5)
        case 0x8e17: return "GL_QUERY_WAIT_INVERTED";
        case 0x8e18: return "GL_QUERY_NO_WAIT_INVERTED";
        case 0x8e19: return "GL_QUERY_BY_REGION_WAIT_INVERTED";
        case 0x8e1a: return "GL_QUERY_BY_REGION_NO_WAIT_INVERTED";
#endif
#if defined(GL_EXT_polygon_offset_clamp)
        case 0x8e1b: return "GL_POLYGON_OFFSET_CLAMP_EXT";
#endif
        case 0x8e1e:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES";
#endif
            break;
        case 0x8e1f:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES";
#endif
            break;
#if defined(GL_NV_framebuffer_mixed_samples)
        case 0x8e20: return "GL_COLOR_SAMPLES_NV";
#endif
        case 0x8e22:
#if defined(GL_EXT_debug_label) || defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_0)
                     return "GL_TRANSFORM_FEEDBACK";
#endif
#if defined(GL_NV_transform_feedback2)
                     return "GL_TRANSFORM_FEEDBACK_NV";
#endif
            break;
        case 0x8e23:
#if defined(GL_VERSION_4_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED";
#endif
#if defined(GL_NV_transform_feedback2)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
                     return "GL_TRANSFORM_FEEDBACK_PAUSED";
#endif
            break;
        case 0x8e24:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
                     return "GL_TRANSFORM_FEEDBACK_ACTIVE";
#endif
#if defined(GL_VERSION_4_0)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE";
#endif
#if defined(GL_NV_transform_feedback2)
                     return "GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV";
#endif
            break;
        case 0x8e25:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_0)
                     return "GL_TRANSFORM_FEEDBACK_BINDING";
#endif
#if defined(GL_NV_transform_feedback2)
                     return "GL_TRANSFORM_FEEDBACK_BINDING_NV";
#endif
            break;
#if defined(GL_NV_present_video)
        case 0x8e26: return "GL_FRAME_NV";
        case 0x8e27: return "GL_FIELDS_NV";
#endif
        case 0x8e28:
#if defined(GL_NV_present_video)
                     return "GL_CURRENT_TIME_NV";
#endif
#if defined(GL_VERSION_3_3)
                     return "GL_TIMESTAMP";
#endif
#if defined(GL_EXT_disjoint_timer_query)
                     return "GL_TIMESTAMP_EXT";
#endif
            break;
#if defined(GL_NV_present_video)
        case 0x8e29: return "GL_NUM_FILL_STREAMS_NV";
        case 0x8e2a: return "GL_PRESENT_TIME_NV";
        case 0x8e2b: return "GL_PRESENT_DURATION_NV";
#endif
#if defined(GL_NV_depth_nonlinear)
        case 0x8e2c: return "GL_DEPTH_COMPONENT16_NONLINEAR_NV";
#endif
#if defined(GL_EXT_direct_state_access)
        case 0x8e2d: return "GL_PROGRAM_MATRIX_EXT";
        case 0x8e2e: return "GL_TRANSPOSE_PROGRAM_MATRIX_EXT";
        case 0x8e2f: return "GL_PROGRAM_MATRIX_STACK_DEPTH_EXT";
#endif
        case 0x8e42:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_TEXTURE_SWIZZLE_R";
#endif
#if defined(GL_EXT_texture_swizzle)
                     return "GL_TEXTURE_SWIZZLE_R_EXT";
#endif
            break;
        case 0x8e43:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_TEXTURE_SWIZZLE_G";
#endif
#if defined(GL_EXT_texture_swizzle)
                     return "GL_TEXTURE_SWIZZLE_G_EXT";
#endif
            break;
        case 0x8e44:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_TEXTURE_SWIZZLE_B";
#endif
#if defined(GL_EXT_texture_swizzle)
                     return "GL_TEXTURE_SWIZZLE_B_EXT";
#endif
            break;
        case 0x8e45:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
                     return "GL_TEXTURE_SWIZZLE_A";
#endif
#if defined(GL_EXT_texture_swizzle)
                     return "GL_TEXTURE_SWIZZLE_A_EXT";
#endif
            break;
        case 0x8e46:
#if defined(GL_VERSION_3_3)
                     return "GL_TEXTURE_SWIZZLE_RGBA";
#endif
#if defined(GL_EXT_texture_swizzle)
                     return "GL_TEXTURE_SWIZZLE_RGBA_EXT";
#endif
            break;
#if defined(GL_VERSION_4_0)
        case 0x8e47: return "GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS";
        case 0x8e48: return "GL_ACTIVE_SUBROUTINE_MAX_LENGTH";
        case 0x8e49: return "GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH";
        case 0x8e4a: return "GL_NUM_COMPATIBLE_SUBROUTINES";
        case 0x8e4b: return "GL_COMPATIBLE_SUBROUTINES";
#endif
        case 0x8e4c:
#if defined(__glcorearb_h_) || defined(__glext_h_)
                     return "GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION";
#endif
#if defined(GL_EXT_provoking_vertex)
                     return "GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT";
#endif
            break;
        case 0x8e4d:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_FIRST_VERTEX_CONVENTION";
#endif
#if defined(GL_EXT_provoking_vertex) || defined(GL_EXT_geometry_shader)
                     return "GL_FIRST_VERTEX_CONVENTION_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_FIRST_VERTEX_CONVENTION_OES";
#endif
            break;
        case 0x8e4e:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_LAST_VERTEX_CONVENTION";
#endif
#if defined(GL_EXT_provoking_vertex) || defined(GL_EXT_geometry_shader)
                     return "GL_LAST_VERTEX_CONVENTION_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_LAST_VERTEX_CONVENTION_OES";
#endif
            break;
        case 0x8e4f:
#if defined(__glcorearb_h_) || defined(__glext_h_)
                     return "GL_PROVOKING_VERTEX";
#endif
#if defined(GL_EXT_provoking_vertex)
                     return "GL_PROVOKING_VERTEX_EXT";
#endif
            break;
        case 0x8e50:
#if defined(GL_ARB_sample_locations)
                     return "GL_SAMPLE_LOCATION_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_SAMPLE_LOCATION_NV";
#endif
#if defined(__glcorearb_h_) || defined(GL_ES_VERSION_3_1) || defined(__glext_h_)
                     return "GL_SAMPLE_POSITION";
#endif
#if defined(GL_NV_explicit_multisample)
                     return "GL_SAMPLE_POSITION_NV";
#endif
            break;
        case 0x8e51:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
                     return "GL_SAMPLE_MASK";
#endif
#if defined(GL_NV_explicit_multisample)
                     return "GL_SAMPLE_MASK_NV";
#endif
            break;
        case 0x8e52:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
                     return "GL_SAMPLE_MASK_VALUE";
#endif
#if defined(GL_NV_explicit_multisample)
                     return "GL_SAMPLE_MASK_VALUE_NV";
#endif
            break;
#if defined(GL_NV_explicit_multisample)
        case 0x8e53: return "GL_TEXTURE_BINDING_RENDERBUFFER_NV";
        case 0x8e54: return "GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV";
        case 0x8e55: return "GL_TEXTURE_RENDERBUFFER_NV";
        case 0x8e56: return "GL_SAMPLER_RENDERBUFFER_NV";
        case 0x8e57: return "GL_INT_SAMPLER_RENDERBUFFER_NV";
        case 0x8e58: return "GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV";
#endif
        case 0x8e59:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
                     return "GL_MAX_SAMPLE_MASK_WORDS";
#endif
#if defined(GL_NV_explicit_multisample)
                     return "GL_MAX_SAMPLE_MASK_WORDS_NV";
#endif
            break;
        case 0x8e5a:
#if defined(GL_NV_gpu_program5)
                     return "GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV";
#endif
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_GEOMETRY_SHADER_INVOCATIONS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES";
#endif
            break;
        case 0x8e5b:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MIN_FRAGMENT_INTERPOLATION_OFFSET";
#endif
#if defined(GL_NV_gpu_program5)
                     return "GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV";
#endif
#if defined(GL_OES_shader_multisample_interpolation)
                     return "GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES";
#endif
            break;
        case 0x8e5c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_FRAGMENT_INTERPOLATION_OFFSET";
#endif
#if defined(GL_NV_gpu_program5)
                     return "GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV";
#endif
#if defined(GL_OES_shader_multisample_interpolation)
                     return "GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES";
#endif
            break;
        case 0x8e5e:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_0)
                     return "GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET";
#endif
#if defined(GL_ARB_texture_gather)
                     return "GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB";
#endif
#if defined(GL_NV_gpu_program5)
                     return "GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV";
#endif
            break;
        case 0x8e5f:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_0)
                     return "GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET";
#endif
#if defined(GL_ARB_texture_gather)
                     return "GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB";
#endif
#if defined(GL_NV_gpu_program5)
                     return "GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV";
#endif
            break;
#if defined(GL_VERSION_4_0)
        case 0x8e70: return "GL_MAX_TRANSFORM_FEEDBACK_BUFFERS";
        case 0x8e71: return "GL_MAX_VERTEX_STREAMS";
#endif
        case 0x8e72:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_PATCH_VERTICES";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_PATCH_VERTICES_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_PATCH_VERTICES_OES";
#endif
            break;
#if defined(GL_VERSION_4_0)
        case 0x8e73: return "GL_PATCH_DEFAULT_INNER_LEVEL";
        case 0x8e74: return "GL_PATCH_DEFAULT_OUTER_LEVEL";
#endif
        case 0x8e75:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_CONTROL_OUTPUT_VERTICES";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_CONTROL_OUTPUT_VERTICES_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_CONTROL_OUTPUT_VERTICES_OES";
#endif
            break;
        case 0x8e76:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_GEN_MODE";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_GEN_MODE_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_GEN_MODE_OES";
#endif
            break;
        case 0x8e77:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_GEN_SPACING";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_GEN_SPACING_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_GEN_SPACING_OES";
#endif
            break;
        case 0x8e78:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_GEN_VERTEX_ORDER";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_GEN_VERTEX_ORDER_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_GEN_VERTEX_ORDER_OES";
#endif
            break;
        case 0x8e79:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_GEN_POINT_MODE";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_GEN_POINT_MODE_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_GEN_POINT_MODE_OES";
#endif
            break;
        case 0x8e7a:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_ISOLINES";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_ISOLINES_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_ISOLINES_OES";
#endif
            break;
        case 0x8e7b:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_FRACTIONAL_ODD";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_FRACTIONAL_ODD_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_FRACTIONAL_ODD_OES";
#endif
            break;
        case 0x8e7c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_FRACTIONAL_EVEN";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_FRACTIONAL_EVEN_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_FRACTIONAL_EVEN_OES";
#endif
            break;
        case 0x8e7d:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_PATCH_VERTICES";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_PATCH_VERTICES_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_PATCH_VERTICES_OES";
#endif
            break;
        case 0x8e7e:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_GEN_LEVEL";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_GEN_LEVEL_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_GEN_LEVEL_OES";
#endif
            break;
        case 0x8e7f:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES";
#endif
            break;
        case 0x8e80:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES";
#endif
            break;
        case 0x8e81:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES";
#endif
            break;
        case 0x8e82:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES";
#endif
            break;
        case 0x8e83:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES";
#endif
            break;
        case 0x8e84:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_PATCH_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_PATCH_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_PATCH_COMPONENTS_OES";
#endif
            break;
        case 0x8e85:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES";
#endif
            break;
        case 0x8e86:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES";
#endif
            break;
        case 0x8e87:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_EVALUATION_SHADER";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_EVALUATION_SHADER_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_EVALUATION_SHADER_OES";
#endif
            break;
        case 0x8e88:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TESS_CONTROL_SHADER";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_TESS_CONTROL_SHADER_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_TESS_CONTROL_SHADER_OES";
#endif
            break;
        case 0x8e89:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES";
#endif
            break;
        case 0x8e8a:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES";
#endif
            break;
        case 0x8e8c:
#if defined(GL_VERSION_4_2)
                     return "GL_COMPRESSED_RGBA_BPTC_UNORM";
#endif
#if defined(GL_ARB_texture_compression_bptc)
                     return "GL_COMPRESSED_RGBA_BPTC_UNORM_ARB";
#endif
            break;
        case 0x8e8d:
#if defined(GL_VERSION_4_2)
                     return "GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM";
#endif
#if defined(GL_ARB_texture_compression_bptc)
                     return "GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB";
#endif
            break;
        case 0x8e8e:
#if defined(GL_VERSION_4_2)
                     return "GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT";
#endif
#if defined(GL_ARB_texture_compression_bptc)
                     return "GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB";
#endif
            break;
        case 0x8e8f:
#if defined(GL_VERSION_4_2)
                     return "GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT";
#endif
#if defined(GL_ARB_texture_compression_bptc)
                     return "GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB";
#endif
            break;
#if defined(GL_NV_coverage_sample)
        case 0x8ed0: return "GL_COVERAGE_COMPONENT_NV";
        case 0x8ed1: return "GL_COVERAGE_COMPONENT4_NV";
        case 0x8ed2: return "GL_COVERAGE_ATTACHMENT_NV";
        case 0x8ed3: return "GL_COVERAGE_BUFFERS_NV";
        case 0x8ed4: return "GL_COVERAGE_SAMPLES_NV";
        case 0x8ed5: return "GL_COVERAGE_ALL_FRAGMENTS_NV";
        case 0x8ed6: return "GL_COVERAGE_EDGE_FRAGMENTS_NV";
        case 0x8ed7: return "GL_COVERAGE_AUTOMATIC_NV";
#endif
#if defined(GL_EXT_window_rectangles)
        case 0x8f10: return "GL_INCLUSIVE_EXT";
        case 0x8f11: return "GL_EXCLUSIVE_EXT";
        case 0x8f12: return "GL_WINDOW_RECTANGLE_EXT";
        case 0x8f13: return "GL_WINDOW_RECTANGLE_MODE_EXT";
        case 0x8f14: return "GL_MAX_WINDOW_RECTANGLES_EXT";
        case 0x8f15: return "GL_NUM_WINDOW_RECTANGLES_EXT";
#endif
#if defined(GL_NV_shader_buffer_load)
        case 0x8f1d: return "GL_BUFFER_GPU_ADDRESS_NV";
#endif
#if defined(GL_NV_vertex_buffer_unified_memory)
        case 0x8f1e: return "GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV";
        case 0x8f1f: return "GL_ELEMENT_ARRAY_UNIFIED_NV";
        case 0x8f20: return "GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV";
        case 0x8f21: return "GL_VERTEX_ARRAY_ADDRESS_NV";
        case 0x8f22: return "GL_NORMAL_ARRAY_ADDRESS_NV";
        case 0x8f23: return "GL_COLOR_ARRAY_ADDRESS_NV";
        case 0x8f24: return "GL_INDEX_ARRAY_ADDRESS_NV";
        case 0x8f25: return "GL_TEXTURE_COORD_ARRAY_ADDRESS_NV";
        case 0x8f26: return "GL_EDGE_FLAG_ARRAY_ADDRESS_NV";
        case 0x8f27: return "GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV";
        case 0x8f28: return "GL_FOG_COORD_ARRAY_ADDRESS_NV";
        case 0x8f29: return "GL_ELEMENT_ARRAY_ADDRESS_NV";
        case 0x8f2a: return "GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV";
        case 0x8f2b: return "GL_VERTEX_ARRAY_LENGTH_NV";
        case 0x8f2c: return "GL_NORMAL_ARRAY_LENGTH_NV";
        case 0x8f2d: return "GL_COLOR_ARRAY_LENGTH_NV";
        case 0x8f2e: return "GL_INDEX_ARRAY_LENGTH_NV";
        case 0x8f2f: return "GL_TEXTURE_COORD_ARRAY_LENGTH_NV";
        case 0x8f30: return "GL_EDGE_FLAG_ARRAY_LENGTH_NV";
        case 0x8f31: return "GL_SECONDARY_COLOR_ARRAY_LENGTH_NV";
        case 0x8f32: return "GL_FOG_COORD_ARRAY_LENGTH_NV";
        case 0x8f33: return "GL_ELEMENT_ARRAY_LENGTH_NV";
#endif
#if defined(GL_NV_shader_buffer_load)
        case 0x8f34: return "GL_GPU_ADDRESS_NV";
        case 0x8f35: return "GL_MAX_SHADER_BUFFER_ADDRESS_NV";
#endif
        case 0x8f36:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
                     return "GL_COPY_READ_BUFFER";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
                     return "GL_COPY_READ_BUFFER_BINDING";
#endif
#if defined(GL_NV_copy_buffer)
                     return "GL_COPY_READ_BUFFER_NV";
#endif
            break;
        case 0x8f37:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
                     return "GL_COPY_WRITE_BUFFER";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
                     return "GL_COPY_WRITE_BUFFER_BINDING";
#endif
#if defined(GL_NV_copy_buffer)
                     return "GL_COPY_WRITE_BUFFER_NV";
#endif
            break;
        case 0x8f38:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_MAX_IMAGE_UNITS";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_MAX_IMAGE_UNITS_EXT";
#endif
            break;
        case 0x8f39:
#if defined(GL_VERSION_4_2)
                     return "GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
                     return "GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES";
#endif
            break;
        case 0x8f3a:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_NAME";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_NAME_EXT";
#endif
            break;
        case 0x8f3b:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_LEVEL";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_LEVEL_EXT";
#endif
            break;
        case 0x8f3c:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_LAYERED";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_LAYERED_EXT";
#endif
            break;
        case 0x8f3d:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_LAYER";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_LAYER_EXT";
#endif
            break;
        case 0x8f3e:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_ACCESS";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_ACCESS_EXT";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_0)
        case 0x8f3f: return "GL_DRAW_INDIRECT_BUFFER";
#endif
#if defined(GL_NV_vertex_buffer_unified_memory)
        case 0x8f40: return "GL_DRAW_INDIRECT_UNIFIED_NV";
        case 0x8f41: return "GL_DRAW_INDIRECT_ADDRESS_NV";
        case 0x8f42: return "GL_DRAW_INDIRECT_LENGTH_NV";
#endif
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_0)
        case 0x8f43: return "GL_DRAW_INDIRECT_BUFFER_BINDING";
#endif
#if defined(GL_NV_gpu_program5)
        case 0x8f44: return "GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV";
        case 0x8f45: return "GL_MAX_PROGRAM_SUBROUTINE_NUM_NV";
#endif
        case 0x8f46:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT2";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT2_EXT";
#endif
            break;
        case 0x8f47:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT3";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT3_EXT";
#endif
            break;
        case 0x8f48:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT4";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT4_EXT";
#endif
            break;
        case 0x8f49:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT2x3";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT2x3_EXT";
#endif
            break;
        case 0x8f4a:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT2x4";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT2x4_EXT";
#endif
            break;
        case 0x8f4b:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT3x2";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT3x2_EXT";
#endif
            break;
        case 0x8f4c:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT3x4";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT3x4_EXT";
#endif
            break;
        case 0x8f4d:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT4x2";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT4x2_EXT";
#endif
            break;
        case 0x8f4e:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_MAT4x3";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_MAT4x3_EXT";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x8f4f: return "GL_VERTEX_BINDING_BUFFER";
#endif
#if defined(GL_ARM_mali_shader_binary)
        case 0x8f60: return "GL_MALI_SHADER_BINARY_ARM";
#endif
#if defined(GL_ARM_mali_program_binary)
        case 0x8f61: return "GL_MALI_PROGRAM_BINARY_ARM";
#endif
#if defined(GL_EXT_shader_pixel_local_storage)
        case 0x8f63: return "GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT";
        case 0x8f64: return "GL_SHADER_PIXEL_LOCAL_STORAGE_EXT";
#endif
#if defined(GL_ARM_shader_framebuffer_fetch)
        case 0x8f65: return "GL_FETCH_PER_SAMPLE_ARM";
        case 0x8f66: return "GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM";
#endif
#if defined(GL_EXT_shader_pixel_local_storage)
        case 0x8f67: return "GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT";
#endif
#if defined(GL_EXT_texture_snorm)
        case 0x8f90: return "GL_RED_SNORM";
        case 0x8f91: return "GL_RG_SNORM";
        case 0x8f92: return "GL_RGB_SNORM";
        case 0x8f93: return "GL_RGBA_SNORM";
#endif
#if defined(GL_EXT_render_snorm) || defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8f94: return "GL_R8_SNORM";
        case 0x8f95: return "GL_RG8_SNORM";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8f96: return "GL_RGB8_SNORM";
#endif
#if defined(GL_EXT_render_snorm) || defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8f97: return "GL_RGBA8_SNORM";
#endif
        case 0x8f98:
#if defined(GL_VERSION_3_1)
                     return "GL_R16_SNORM";
#endif
#if defined(GL_EXT_render_snorm)
                     return "GL_R16_SNORM_EXT";
#endif
            break;
        case 0x8f99:
#if defined(GL_VERSION_3_1)
                     return "GL_RG16_SNORM";
#endif
#if defined(GL_EXT_render_snorm)
                     return "GL_RG16_SNORM_EXT";
#endif
            break;
        case 0x8f9a:
#if defined(GL_VERSION_3_1)
                     return "GL_RGB16_SNORM";
#endif
#if defined(GL_EXT_texture_norm16)
                     return "GL_RGB16_SNORM_EXT";
#endif
            break;
        case 0x8f9b:
#if defined(GL_VERSION_3_1)
                     return "GL_RGBA16_SNORM";
#endif
#if defined(GL_EXT_render_snorm)
                     return "GL_RGBA16_SNORM_EXT";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_1)
        case 0x8f9c: return "GL_SIGNED_NORMALIZED";
#endif
#if defined(GL_VERSION_3_1)
        case 0x8f9d: return "GL_PRIMITIVE_RESTART";
        case 0x8f9e: return "GL_PRIMITIVE_RESTART_INDEX";
#endif
#if defined(GL_ARB_texture_gather)
        case 0x8f9f: return "GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB";
#endif
#if defined(GL_QCOM_perfmon_global_mode)
        case 0x8fa0: return "GL_PERFMON_GLOBAL_MODE_QCOM";
#endif
#if defined(GL_QCOM_binning_control)
        case 0x8fb0: return "GL_BINNING_CONTROL_HINT_QCOM";
        case 0x8fb1: return "GL_CPU_OPTIMIZED_QCOM";
        case 0x8fb2: return "GL_GPU_OPTIMIZED_QCOM";
        case 0x8fb3: return "GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM";
#endif
#if defined(GL_EXT_disjoint_timer_query)
        case 0x8fbb: return "GL_GPU_DISJOINT_EXT";
#endif
#if defined(GL_EXT_texture_sRGB_R8)
        case 0x8fbd: return "GL_SR8_EXT";
#endif
#if defined(GL_EXT_texture_sRGB_RG8)
        case 0x8fbe: return "GL_SRG8_EXT";
#endif
#if defined(GL_VIV_shader_binary)
        case 0x8fc4: return "GL_SHADER_BINARY_VIV";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
        case 0x8fe0: return "GL_INT8_NV";
        case 0x8fe1: return "GL_INT8_VEC2_NV";
        case 0x8fe2: return "GL_INT8_VEC3_NV";
        case 0x8fe3: return "GL_INT8_VEC4_NV";
        case 0x8fe4: return "GL_INT16_NV";
        case 0x8fe5: return "GL_INT16_VEC2_NV";
        case 0x8fe6: return "GL_INT16_VEC3_NV";
        case 0x8fe7: return "GL_INT16_VEC4_NV";
#endif
        case 0x8fe9:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_INT64_VEC2_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_INT64_VEC2_NV";
#endif
            break;
        case 0x8fea:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_INT64_VEC3_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_INT64_VEC3_NV";
#endif
            break;
        case 0x8feb:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_INT64_VEC4_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_INT64_VEC4_NV";
#endif
            break;
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
        case 0x8fec: return "GL_UNSIGNED_INT8_NV";
        case 0x8fed: return "GL_UNSIGNED_INT8_VEC2_NV";
        case 0x8fee: return "GL_UNSIGNED_INT8_VEC3_NV";
        case 0x8fef: return "GL_UNSIGNED_INT8_VEC4_NV";
        case 0x8ff0: return "GL_UNSIGNED_INT16_NV";
        case 0x8ff1: return "GL_UNSIGNED_INT16_VEC2_NV";
        case 0x8ff2: return "GL_UNSIGNED_INT16_VEC3_NV";
        case 0x8ff3: return "GL_UNSIGNED_INT16_VEC4_NV";
#endif
        case 0x8ff5:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_UNSIGNED_INT64_VEC2_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_UNSIGNED_INT64_VEC2_NV";
#endif
            break;
        case 0x8ff6:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_UNSIGNED_INT64_VEC3_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_UNSIGNED_INT64_VEC3_NV";
#endif
            break;
        case 0x8ff7:
#if defined(GL_ARB_gpu_shader_int64)
                     return "GL_UNSIGNED_INT64_VEC4_ARB";
#endif
#if defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5)
                     return "GL_UNSIGNED_INT64_VEC4_NV";
#endif
            break;
#if defined(GL_AMD_gpu_shader_half_float) || defined(GL_NV_gpu_shader5)
        case 0x8ff8: return "GL_FLOAT16_NV";
        case 0x8ff9: return "GL_FLOAT16_VEC2_NV";
        case 0x8ffa: return "GL_FLOAT16_VEC3_NV";
        case 0x8ffb: return "GL_FLOAT16_VEC4_NV";
#endif
        case 0x8ffc:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_VEC2";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_VEC2_EXT";
#endif
            break;
        case 0x8ffd:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_VEC3";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_VEC3_EXT";
#endif
            break;
        case 0x8ffe:
#if defined(GL_VERSION_4_0)
                     return "GL_DOUBLE_VEC4";
#endif
#if defined(GL_EXT_vertex_attrib_64bit)
                     return "GL_DOUBLE_VEC4_EXT";
#endif
            break;
#if defined(GL_AMD_vertex_shader_tessellator)
        case 0x9001: return "GL_SAMPLER_BUFFER_AMD";
        case 0x9002: return "GL_INT_SAMPLER_BUFFER_AMD";
        case 0x9003: return "GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD";
        case 0x9004: return "GL_TESSELLATION_MODE_AMD";
        case 0x9005: return "GL_TESSELLATION_FACTOR_AMD";
        case 0x9006: return "GL_DISCRETE_AMD";
        case 0x9007: return "GL_CONTINUOUS_AMD";
#endif
        case 0x9009:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TEXTURE_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_TEXTURE_CUBE_MAP_ARRAY_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_TEXTURE_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_TEXTURE_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x900a:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x900b:
#if defined(GL_VERSION_4_0)
                     return "GL_PROXY_TEXTURE_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB";
#endif
            break;
        case 0x900c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x900d:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES";
#endif
            break;
        case 0x900e:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_INT_SAMPLER_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x900f:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_0)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY";
#endif
#if defined(GL_ARB_texture_cube_map_array)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB";
#endif
#if defined(GL_EXT_texture_cube_map_array)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES";
#endif
            break;
#if defined(GL_EXT_texture_snorm)
        case 0x9010: return "GL_ALPHA_SNORM";
        case 0x9011: return "GL_LUMINANCE_SNORM";
        case 0x9012: return "GL_LUMINANCE_ALPHA_SNORM";
        case 0x9013: return "GL_INTENSITY_SNORM";
        case 0x9014: return "GL_ALPHA8_SNORM";
        case 0x9015: return "GL_LUMINANCE8_SNORM";
        case 0x9016: return "GL_LUMINANCE8_ALPHA8_SNORM";
        case 0x9017: return "GL_INTENSITY8_SNORM";
        case 0x9018: return "GL_ALPHA16_SNORM";
        case 0x9019: return "GL_LUMINANCE16_SNORM";
        case 0x901a: return "GL_LUMINANCE16_ALPHA16_SNORM";
        case 0x901b: return "GL_INTENSITY16_SNORM";
#endif
#if defined(GL_AMD_blend_minmax_factor)
        case 0x901c: return "GL_FACTOR_MIN_AMD";
        case 0x901d: return "GL_FACTOR_MAX_AMD";
#endif
#if defined(GL_AMD_depth_clamp_separate)
        case 0x901e: return "GL_DEPTH_CLAMP_NEAR_AMD";
        case 0x901f: return "GL_DEPTH_CLAMP_FAR_AMD";
#endif
#if defined(GL_NV_video_capture)
        case 0x9020: return "GL_VIDEO_BUFFER_NV";
        case 0x9021: return "GL_VIDEO_BUFFER_BINDING_NV";
        case 0x9022: return "GL_FIELD_UPPER_NV";
        case 0x9023: return "GL_FIELD_LOWER_NV";
        case 0x9024: return "GL_NUM_VIDEO_CAPTURE_STREAMS_NV";
        case 0x9025: return "GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV";
        case 0x9026: return "GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV";
        case 0x9027: return "GL_LAST_VIDEO_CAPTURE_STATUS_NV";
        case 0x9028: return "GL_VIDEO_BUFFER_PITCH_NV";
        case 0x9029: return "GL_VIDEO_COLOR_CONVERSION_MATRIX_NV";
        case 0x902a: return "GL_VIDEO_COLOR_CONVERSION_MAX_NV";
        case 0x902b: return "GL_VIDEO_COLOR_CONVERSION_MIN_NV";
        case 0x902c: return "GL_VIDEO_COLOR_CONVERSION_OFFSET_NV";
        case 0x902d: return "GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV";
        case 0x902e: return "GL_PARTIAL_SUCCESS_NV";
        case 0x902f: return "GL_SUCCESS_NV";
        case 0x9030: return "GL_FAILURE_NV";
        case 0x9031: return "GL_YCBYCR8_422_NV";
        case 0x9032: return "GL_YCBAYCR8A_4224_NV";
        case 0x9033: return "GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV";
        case 0x9034: return "GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV";
        case 0x9035: return "GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV";
        case 0x9036: return "GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV";
        case 0x9037: return "GL_Z4Y12Z4CB12Z4CR12_444_NV";
        case 0x9038: return "GL_VIDEO_CAPTURE_FRAME_WIDTH_NV";
        case 0x9039: return "GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV";
        case 0x903a: return "GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV";
        case 0x903b: return "GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV";
        case 0x903c: return "GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV";
#endif
#if defined(GL_NV_texture_multisample)
        case 0x9045: return "GL_TEXTURE_COVERAGE_SAMPLES_NV";
        case 0x9046: return "GL_TEXTURE_COLOR_SAMPLES_NV";
#endif
#if defined(GL_NVX_gpu_memory_info)
        case 0x9047: return "GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX";
        case 0x9048: return "GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX";
        case 0x9049: return "GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX";
        case 0x904a: return "GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX";
        case 0x904b: return "GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX";
#endif
        case 0x904c:
#if defined(GL_VERSION_4_2)
                     return "GL_IMAGE_1D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_1D_EXT";
#endif
            break;
        case 0x904d:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_2D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_2D_EXT";
#endif
            break;
        case 0x904e:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_3D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_3D_EXT";
#endif
            break;
        case 0x904f:
#if defined(GL_VERSION_4_2)
                     return "GL_IMAGE_2D_RECT";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_2D_RECT_EXT";
#endif
            break;
        case 0x9050:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_CUBE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_CUBE_EXT";
#endif
            break;
        case 0x9051:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BUFFER";
#endif
#if defined(GL_EXT_shader_image_load_store) || defined(GL_EXT_texture_buffer)
                     return "GL_IMAGE_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_IMAGE_BUFFER_OES";
#endif
            break;
        case 0x9052:
#if defined(GL_VERSION_4_2)
                     return "GL_IMAGE_1D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_1D_ARRAY_EXT";
#endif
            break;
        case 0x9053:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_2D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_2D_ARRAY_EXT";
#endif
            break;
        case 0x9054:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_CUBE_MAP_ARRAY";
#endif
#if defined(GL_EXT_texture_cube_map_array) || defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_IMAGE_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x9055:
#if defined(GL_VERSION_4_2)
                     return "GL_IMAGE_2D_MULTISAMPLE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_2D_MULTISAMPLE_EXT";
#endif
            break;
        case 0x9056:
#if defined(GL_VERSION_4_2)
                     return "GL_IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT";
#endif
            break;
        case 0x9057:
#if defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_1D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_1D_EXT";
#endif
            break;
        case 0x9058:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_2D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_2D_EXT";
#endif
            break;
        case 0x9059:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_3D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_3D_EXT";
#endif
            break;
        case 0x905a:
#if defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_2D_RECT";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_2D_RECT_EXT";
#endif
            break;
        case 0x905b:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_CUBE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_CUBE_EXT";
#endif
            break;
        case 0x905c:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_BUFFER";
#endif
#if defined(GL_EXT_shader_image_load_store) || defined(GL_EXT_texture_buffer)
                     return "GL_INT_IMAGE_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_INT_IMAGE_BUFFER_OES";
#endif
            break;
        case 0x905d:
#if defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_1D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_1D_ARRAY_EXT";
#endif
            break;
        case 0x905e:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_2D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_2D_ARRAY_EXT";
#endif
            break;
        case 0x905f:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_CUBE_MAP_ARRAY";
#endif
#if defined(GL_EXT_texture_cube_map_array) || defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_INT_IMAGE_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x9060:
#if defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_2D_MULTISAMPLE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_2D_MULTISAMPLE_EXT";
#endif
            break;
        case 0x9061:
#if defined(GL_VERSION_4_2)
                     return "GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT";
#endif
            break;
        case 0x9062:
#if defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_1D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_1D_EXT";
#endif
            break;
        case 0x9063:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_2D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_2D_EXT";
#endif
            break;
        case 0x9064:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_3D";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_3D_EXT";
#endif
            break;
        case 0x9065:
#if defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_2D_RECT";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT";
#endif
            break;
        case 0x9066:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_CUBE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_CUBE_EXT";
#endif
            break;
        case 0x9067:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_BUFFER";
#endif
#if defined(GL_EXT_shader_image_load_store) || defined(GL_EXT_texture_buffer)
                     return "GL_UNSIGNED_INT_IMAGE_BUFFER_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_UNSIGNED_INT_IMAGE_BUFFER_OES";
#endif
            break;
        case 0x9068:
#if defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_1D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT";
#endif
            break;
        case 0x9069:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_2D_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT";
#endif
            break;
        case 0x906a:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY";
#endif
#if defined(GL_EXT_texture_cube_map_array) || defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT";
#endif
#if defined(GL_OES_texture_cube_map_array)
                     return "GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES";
#endif
            break;
        case 0x906b:
#if defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT";
#endif
            break;
        case 0x906c:
#if defined(GL_VERSION_4_2)
                     return "GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT";
#endif
            break;
        case 0x906d:
#if defined(GL_VERSION_4_2)
                     return "GL_MAX_IMAGE_SAMPLES";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_MAX_IMAGE_SAMPLES_EXT";
#endif
            break;
        case 0x906e:
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
                     return "GL_IMAGE_BINDING_FORMAT";
#endif
#if defined(GL_EXT_shader_image_load_store)
                     return "GL_IMAGE_BINDING_FORMAT_EXT";
#endif
            break;
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_3)
        case 0x906f: return "GL_RGB10_A2UI";
#endif
#if defined(GL_NV_path_rendering)
        case 0x9070: return "GL_PATH_FORMAT_SVG_NV";
        case 0x9071: return "GL_PATH_FORMAT_PS_NV";
        case 0x9072: return "GL_STANDARD_FONT_NAME_NV";
        case 0x9073: return "GL_SYSTEM_FONT_NAME_NV";
        case 0x9074: return "GL_FILE_NAME_NV";
        case 0x9075: return "GL_PATH_STROKE_WIDTH_NV";
        case 0x9076: return "GL_PATH_END_CAPS_NV";
        case 0x9077: return "GL_PATH_INITIAL_END_CAP_NV";
        case 0x9078: return "GL_PATH_TERMINAL_END_CAP_NV";
        case 0x9079: return "GL_PATH_JOIN_STYLE_NV";
        case 0x907a: return "GL_PATH_MITER_LIMIT_NV";
        case 0x907b: return "GL_PATH_DASH_CAPS_NV";
        case 0x907c: return "GL_PATH_INITIAL_DASH_CAP_NV";
        case 0x907d: return "GL_PATH_TERMINAL_DASH_CAP_NV";
        case 0x907e: return "GL_PATH_DASH_OFFSET_NV";
        case 0x907f: return "GL_PATH_CLIENT_LENGTH_NV";
        case 0x9080: return "GL_PATH_FILL_MODE_NV";
        case 0x9081: return "GL_PATH_FILL_MASK_NV";
        case 0x9082: return "GL_PATH_FILL_COVER_MODE_NV";
        case 0x9083: return "GL_PATH_STROKE_COVER_MODE_NV";
        case 0x9084: return "GL_PATH_STROKE_MASK_NV";
        case 0x9088: return "GL_COUNT_UP_NV";
        case 0x9089: return "GL_COUNT_DOWN_NV";
        case 0x908a: return "GL_PATH_OBJECT_BOUNDING_BOX_NV";
        case 0x908b: return "GL_CONVEX_HULL_NV";
        case 0x908d: return "GL_BOUNDING_BOX_NV";
        case 0x908e: return "GL_TRANSLATE_X_NV";
        case 0x908f: return "GL_TRANSLATE_Y_NV";
        case 0x9090: return "GL_TRANSLATE_2D_NV";
        case 0x9091: return "GL_TRANSLATE_3D_NV";
        case 0x9092: return "GL_AFFINE_2D_NV";
        case 0x9094: return "GL_AFFINE_3D_NV";
        case 0x9096: return "GL_TRANSPOSE_AFFINE_2D_NV";
        case 0x9098: return "GL_TRANSPOSE_AFFINE_3D_NV";
        case 0x909a: return "GL_UTF8_NV";
        case 0x909b: return "GL_UTF16_NV";
        case 0x909c: return "GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV";
        case 0x909d: return "GL_PATH_COMMAND_COUNT_NV";
        case 0x909e: return "GL_PATH_COORD_COUNT_NV";
        case 0x909f: return "GL_PATH_DASH_ARRAY_COUNT_NV";
        case 0x90a0: return "GL_PATH_COMPUTED_LENGTH_NV";
        case 0x90a1: return "GL_PATH_FILL_BOUNDING_BOX_NV";
        case 0x90a2: return "GL_PATH_STROKE_BOUNDING_BOX_NV";
        case 0x90a3: return "GL_SQUARE_NV";
        case 0x90a4: return "GL_ROUND_NV";
        case 0x90a5: return "GL_TRIANGULAR_NV";
        case 0x90a6: return "GL_BEVEL_NV";
        case 0x90a7: return "GL_MITER_REVERT_NV";
        case 0x90a8: return "GL_MITER_TRUNCATE_NV";
        case 0x90a9: return "GL_SKIP_MISSING_GLYPH_NV";
        case 0x90aa: return "GL_USE_MISSING_GLYPH_NV";
        case 0x90ab: return "GL_PATH_ERROR_POSITION_NV";
        case 0x90ac: return "GL_PATH_FOG_GEN_MODE_NV";
        case 0x90ad: return "GL_ACCUM_ADJACENT_PAIRS_NV";
        case 0x90ae: return "GL_ADJACENT_PAIRS_NV";
        case 0x90af: return "GL_FIRST_TO_REST_NV";
        case 0x90b0: return "GL_PATH_GEN_MODE_NV";
        case 0x90b1: return "GL_PATH_GEN_COEFF_NV";
        case 0x90b2: return "GL_PATH_GEN_COLOR_FORMAT_NV";
        case 0x90b3: return "GL_PATH_GEN_COMPONENTS_NV";
        case 0x90b4: return "GL_PATH_DASH_OFFSET_RESET_NV";
        case 0x90b5: return "GL_MOVE_TO_RESETS_NV";
        case 0x90b6: return "GL_MOVE_TO_CONTINUES_NV";
        case 0x90b7: return "GL_PATH_STENCIL_FUNC_NV";
        case 0x90b8: return "GL_PATH_STENCIL_REF_NV";
        case 0x90b9: return "GL_PATH_STENCIL_VALUE_MASK_NV";
#endif
#if defined(GL_EXT_framebuffer_multisample_blit_scaled)
        case 0x90ba: return "GL_SCALED_RESOLVE_FASTEST_EXT";
        case 0x90bb: return "GL_SCALED_RESOLVE_NICEST_EXT";
#endif
#if defined(GL_VERSION_4_2)
        case 0x90bc: return "GL_MIN_MAP_BUFFER_ALIGNMENT";
#endif
#if defined(GL_NV_path_rendering)
        case 0x90bd: return "GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV";
        case 0x90be: return "GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV";
        case 0x90bf: return "GL_PATH_COVER_DEPTH_FUNC_NV";
#endif
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x90c7: return "GL_IMAGE_FORMAT_COMPATIBILITY_TYPE";
        case 0x90c8: return "GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE";
        case 0x90c9: return "GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS";
        case 0x90ca: return "GL_MAX_VERTEX_IMAGE_UNIFORMS";
#endif
        case 0x90cb:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES";
#endif
            break;
        case 0x90cc:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES";
#endif
            break;
        case 0x90cd:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_GEOMETRY_IMAGE_UNIFORMS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x90ce: return "GL_MAX_FRAGMENT_IMAGE_UNIFORMS";
        case 0x90cf: return "GL_MAX_COMBINED_IMAGE_UNIFORMS";
#endif
#if defined(GL_NV_deep_texture3D)
        case 0x90d0: return "GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV";
        case 0x90d1: return "GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x90d2: return "GL_SHADER_STORAGE_BUFFER";
        case 0x90d3: return "GL_SHADER_STORAGE_BUFFER_BINDING";
        case 0x90d4: return "GL_SHADER_STORAGE_BUFFER_START";
        case 0x90d5: return "GL_SHADER_STORAGE_BUFFER_SIZE";
        case 0x90d6: return "GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS";
#endif
        case 0x90d7:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES";
#endif
            break;
        case 0x90d8:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES";
#endif
            break;
        case 0x90d9:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x90da: return "GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS";
        case 0x90db: return "GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS";
        case 0x90dc: return "GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS";
        case 0x90dd: return "GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS";
        case 0x90de: return "GL_MAX_SHADER_STORAGE_BLOCK_SIZE";
        case 0x90df: return "GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT";
#endif
#if defined(GL_EXT_x11_sync_object)
        case 0x90e1: return "GL_SYNC_X11_FENCE_EXT";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x90ea: return "GL_DEPTH_STENCIL_TEXTURE_MODE";
#endif
        case 0x90eb:
#if defined(GL_ARB_compute_variable_group_size)
                     return "GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
                     return "GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS";
#endif
            break;
#if defined(GL_VERSION_4_3)
        case 0x90ec: return "GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER";
        case 0x90ed: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x90ee: return "GL_DISPATCH_INDIRECT_BUFFER";
        case 0x90ef: return "GL_DISPATCH_INDIRECT_BUFFER_BINDING";
#endif
#if defined(GL_EXT_multiview_draw_buffers)
        case 0x90f0: return "GL_COLOR_ATTACHMENT_EXT";
        case 0x90f1: return "GL_MULTIVIEW_EXT";
        case 0x90f2: return "GL_MAX_MULTIVIEW_BUFFERS_EXT";
#endif
        case 0x90f3:
#if defined(GL_KHR_robustness)
                     return "GL_CONTEXT_ROBUST_ACCESS";
#endif
#if defined(GL_EXT_robustness)
                     return "GL_CONTEXT_ROBUST_ACCESS_EXT";
#endif
#if defined(GL_KHR_robustness)
                     return "GL_CONTEXT_ROBUST_ACCESS_KHR";
#endif
            break;
#if defined(GL_NV_compute_program5)
        case 0x90fb: return "GL_COMPUTE_PROGRAM_NV";
        case 0x90fc: return "GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV";
#endif
#if defined(__glcorearb_h_) || defined(GL_NV_internalformat_sample_query) || defined(GL_ES_VERSION_3_1) || defined(__glext_h_)
        case 0x9100: return "GL_TEXTURE_2D_MULTISAMPLE";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_)
        case 0x9101: return "GL_PROXY_TEXTURE_2D_MULTISAMPLE";
#endif
        case 0x9102:
#if defined(__glcorearb_h_) || defined(GL_NV_internalformat_sample_query) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_OES_texture_storage_multisample_2d_array)
                     return "GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES";
#endif
            break;
#if defined(__glcorearb_h_) || defined(__glext_h_)
        case 0x9103: return "GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
        case 0x9104: return "GL_TEXTURE_BINDING_2D_MULTISAMPLE";
#endif
        case 0x9105:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_OES_texture_storage_multisample_2d_array)
                     return "GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES";
#endif
            break;
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
        case 0x9106: return "GL_TEXTURE_SAMPLES";
        case 0x9107: return "GL_TEXTURE_FIXED_SAMPLE_LOCATIONS";
        case 0x9108: return "GL_SAMPLER_2D_MULTISAMPLE";
        case 0x9109: return "GL_INT_SAMPLER_2D_MULTISAMPLE";
        case 0x910a: return "GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE";
#endif
        case 0x910b:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_OES_texture_storage_multisample_2d_array)
                     return "GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES";
#endif
            break;
        case 0x910c:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_OES_texture_storage_multisample_2d_array)
                     return "GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES";
#endif
            break;
        case 0x910d:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#if defined(GL_OES_texture_storage_multisample_2d_array)
                     return "GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES";
#endif
            break;
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_1)
        case 0x910e: return "GL_MAX_COLOR_TEXTURE_SAMPLES";
        case 0x910f: return "GL_MAX_DEPTH_TEXTURE_SAMPLES";
        case 0x9110: return "GL_MAX_INTEGER_SAMPLES";
#endif
        case 0x9111:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_MAX_SERVER_WAIT_TIMEOUT";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_MAX_SERVER_WAIT_TIMEOUT_APPLE";
#endif
            break;
        case 0x9112:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_OBJECT_TYPE";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_OBJECT_TYPE_APPLE";
#endif
            break;
        case 0x9113:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SYNC_CONDITION";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SYNC_CONDITION_APPLE";
#endif
            break;
        case 0x9114:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SYNC_STATUS";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SYNC_STATUS_APPLE";
#endif
            break;
        case 0x9115:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SYNC_FLAGS";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SYNC_FLAGS_APPLE";
#endif
            break;
        case 0x9116:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SYNC_FENCE";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SYNC_FENCE_APPLE";
#endif
            break;
        case 0x9117:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SYNC_GPU_COMMANDS_COMPLETE";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE";
#endif
            break;
        case 0x9118:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_UNSIGNALED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_UNSIGNALED_APPLE";
#endif
            break;
        case 0x9119:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_SIGNALED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_SIGNALED_APPLE";
#endif
            break;
        case 0x911a:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_ALREADY_SIGNALED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_ALREADY_SIGNALED_APPLE";
#endif
            break;
        case 0x911b:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_TIMEOUT_EXPIRED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_TIMEOUT_EXPIRED_APPLE";
#endif
            break;
        case 0x911c:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_CONDITION_SATISFIED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_CONDITION_SATISFIED_APPLE";
#endif
            break;
        case 0x911d:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
                     return "GL_WAIT_FAILED";
#endif
#if defined(GL_APPLE_sync)
                     return "GL_WAIT_FAILED_APPLE";
#endif
            break;
#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
        case 0x911f: return "GL_BUFFER_ACCESS_FLAGS";
        case 0x9120: return "GL_BUFFER_MAP_LENGTH";
        case 0x9121: return "GL_BUFFER_MAP_OFFSET";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
        case 0x9122: return "GL_MAX_VERTEX_OUTPUT_COMPONENTS";
#endif
        case 0x9123:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_INPUT_COMPONENTS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES";
#endif
            break;
        case 0x9124:
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_GEOMETRY_OUTPUT_COMPONENTS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES";
#endif
            break;
#if defined(__glcorearb_h_) || defined(__glext_h_) || defined(GL_ES_VERSION_3_0)
        case 0x9125: return "GL_MAX_FRAGMENT_INPUT_COMPONENTS";
#endif
#if defined(__glcorearb_h_) || defined(__glext_h_)
        case 0x9126: return "GL_CONTEXT_PROFILE_MASK";
#endif
#if defined(GL_VERSION_4_2)
        case 0x9127: return "GL_UNPACK_COMPRESSED_BLOCK_WIDTH";
        case 0x9128: return "GL_UNPACK_COMPRESSED_BLOCK_HEIGHT";
        case 0x9129: return "GL_UNPACK_COMPRESSED_BLOCK_DEPTH";
        case 0x912a: return "GL_UNPACK_COMPRESSED_BLOCK_SIZE";
        case 0x912b: return "GL_PACK_COMPRESSED_BLOCK_WIDTH";
        case 0x912c: return "GL_PACK_COMPRESSED_BLOCK_HEIGHT";
        case 0x912d: return "GL_PACK_COMPRESSED_BLOCK_DEPTH";
        case 0x912e: return "GL_PACK_COMPRESSED_BLOCK_SIZE";
#endif
        case 0x912f:
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
                     return "GL_TEXTURE_IMMUTABLE_FORMAT";
#endif
#if defined(GL_EXT_texture_storage)
                     return "GL_TEXTURE_IMMUTABLE_FORMAT_EXT";
#endif
            break;
#if defined(GL_IMG_program_binary)
        case 0x9130: return "GL_SGX_PROGRAM_BINARY_IMG";
#endif
#if defined(GL_IMG_multisampled_render_to_texture)
        case 0x9133: return "GL_RENDERBUFFER_SAMPLES_IMG";
        case 0x9134: return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG";
        case 0x9135: return "GL_MAX_SAMPLES_IMG";
        case 0x9136: return "GL_TEXTURE_SAMPLES_IMG";
#endif
#if defined(GL_IMG_texture_compression_pvrtc2)
        case 0x9137: return "GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG";
        case 0x9138: return "GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG";
#endif
#if defined(GL_IMG_texture_filter_cubic)
        case 0x9139: return "GL_CUBIC_IMG";
        case 0x913a: return "GL_CUBIC_MIPMAP_NEAREST_IMG";
        case 0x913b: return "GL_CUBIC_MIPMAP_LINEAR_IMG";
#endif
#if defined(GL_IMG_framebuffer_downsample)
        case 0x913c: return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG";
        case 0x913d: return "GL_NUM_DOWNSAMPLE_SCALES_IMG";
        case 0x913e: return "GL_DOWNSAMPLE_SCALES_IMG";
        case 0x913f: return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG";
#endif
        case 0x9143:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_DEBUG_MESSAGE_LENGTH";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_MAX_DEBUG_MESSAGE_LENGTH_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_MAX_DEBUG_MESSAGE_LENGTH_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_MAX_DEBUG_MESSAGE_LENGTH_KHR";
#endif
            break;
        case 0x9144:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_DEBUG_LOGGED_MESSAGES";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_MAX_DEBUG_LOGGED_MESSAGES_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_MAX_DEBUG_LOGGED_MESSAGES_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_MAX_DEBUG_LOGGED_MESSAGES_KHR";
#endif
            break;
        case 0x9145:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_LOGGED_MESSAGES";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_DEBUG_LOGGED_MESSAGES_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_LOGGED_MESSAGES_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_LOGGED_MESSAGES_KHR";
#endif
            break;
        case 0x9146:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SEVERITY_HIGH";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_DEBUG_SEVERITY_HIGH_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SEVERITY_HIGH_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SEVERITY_HIGH_KHR";
#endif
            break;
        case 0x9147:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SEVERITY_MEDIUM";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_DEBUG_SEVERITY_MEDIUM_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SEVERITY_MEDIUM_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SEVERITY_MEDIUM_KHR";
#endif
            break;
        case 0x9148:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_SEVERITY_LOW";
#endif
#if defined(GL_AMD_debug_output)
                     return "GL_DEBUG_SEVERITY_LOW_AMD";
#endif
#if defined(GL_ARB_debug_output)
                     return "GL_DEBUG_SEVERITY_LOW_ARB";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_SEVERITY_LOW_KHR";
#endif
            break;
#if defined(GL_AMD_debug_output)
        case 0x9149: return "GL_DEBUG_CATEGORY_API_ERROR_AMD";
        case 0x914a: return "GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD";
        case 0x914b: return "GL_DEBUG_CATEGORY_DEPRECATION_AMD";
        case 0x914c: return "GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD";
        case 0x914d: return "GL_DEBUG_CATEGORY_PERFORMANCE_AMD";
        case 0x914e: return "GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD";
        case 0x914f: return "GL_DEBUG_CATEGORY_APPLICATION_AMD";
        case 0x9150: return "GL_DEBUG_CATEGORY_OTHER_AMD";
#endif
        case 0x9151:
#if defined(GL_EXT_debug_label)
                     return "GL_BUFFER_OBJECT_EXT";
#endif
#if defined(GL_AMD_name_gen_delete)
                     return "GL_DATA_BUFFER_AMD";
#endif
            break;
#if defined(GL_AMD_name_gen_delete)
        case 0x9152: return "GL_PERFORMANCE_MONITOR_AMD";
#endif
        case 0x9153:
#if defined(GL_AMD_name_gen_delete)
                     return "GL_QUERY_OBJECT_AMD";
#endif
#if defined(GL_EXT_debug_label)
                     return "GL_QUERY_OBJECT_EXT";
#endif
            break;
        case 0x9154:
#if defined(GL_AMD_name_gen_delete)
                     return "GL_VERTEX_ARRAY_OBJECT_AMD";
#endif
#if defined(GL_EXT_debug_label)
                     return "GL_VERTEX_ARRAY_OBJECT_EXT";
#endif
            break;
#if defined(GL_AMD_name_gen_delete)
        case 0x9155: return "GL_SAMPLER_OBJECT_AMD";
#endif
#if defined(GL_AMD_pinned_memory)
        case 0x9160: return "GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD";
#endif
        case 0x9192:
#if defined(GL_VERSION_4_4)
                     return "GL_QUERY_BUFFER";
#endif
#if defined(GL_AMD_query_buffer_object)
                     return "GL_QUERY_BUFFER_AMD";
#endif
            break;
        case 0x9193:
#if defined(GL_VERSION_4_4)
                     return "GL_QUERY_BUFFER_BINDING";
#endif
#if defined(GL_AMD_query_buffer_object)
                     return "GL_QUERY_BUFFER_BINDING_AMD";
#endif
            break;
        case 0x9194:
#if defined(GL_VERSION_4_4)
                     return "GL_QUERY_RESULT_NO_WAIT";
#endif
#if defined(GL_AMD_query_buffer_object)
                     return "GL_QUERY_RESULT_NO_WAIT_AMD";
#endif
            break;
        case 0x9195:
#if defined(GL_AMD_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_X_AMD";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_X_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_X_EXT";
#endif
            break;
        case 0x9196:
#if defined(GL_AMD_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Y_AMD";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Y_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Y_EXT";
#endif
            break;
        case 0x9197:
#if defined(GL_AMD_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Z_AMD";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Z_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_Z_EXT";
#endif
            break;
        case 0x9198:
#if defined(GL_AMD_sparse_texture)
                     return "GL_MAX_SPARSE_TEXTURE_SIZE_AMD";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_MAX_SPARSE_TEXTURE_SIZE_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_MAX_SPARSE_TEXTURE_SIZE_EXT";
#endif
            break;
        case 0x9199:
#if defined(GL_AMD_sparse_texture)
                     return "GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT";
#endif
            break;
        case 0x919a:
#if defined(GL_AMD_sparse_texture)
                     return "GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS";
#endif
#if defined(GL_ARB_sparse_texture)
                     return "GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT";
#endif
            break;
#if defined(GL_AMD_sparse_texture)
        case 0x919b: return "GL_MIN_SPARSE_LEVEL_AMD";
        case 0x919c: return "GL_MIN_LOD_WARNING_AMD";
#endif
        case 0x919d:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER_OFFSET";
#endif
#if defined(GL_EXT_texture_buffer)
                     return "GL_TEXTURE_BUFFER_OFFSET_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_OFFSET_OES";
#endif
            break;
        case 0x919e:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER_SIZE";
#endif
#if defined(GL_EXT_texture_buffer)
                     return "GL_TEXTURE_BUFFER_SIZE_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_SIZE_OES";
#endif
            break;
        case 0x919f:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT";
#endif
#if defined(GL_EXT_texture_buffer)
                     return "GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT";
#endif
#if defined(GL_OES_texture_buffer)
                     return "GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES";
#endif
            break;
#if defined(GL_AMD_transform_feedback4)
        case 0x91a0: return "GL_STREAM_RASTERIZATION_AMD";
#endif
#if defined(GL_AMD_interleaved_elements)
        case 0x91a4: return "GL_VERTEX_ELEMENT_SWIZZLE_AMD";
        case 0x91a5: return "GL_VERTEX_ID_SWIZZLE_AMD";
#endif
        case 0x91a6:
#if defined(GL_ARB_sparse_texture)
                     return "GL_TEXTURE_SPARSE_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_TEXTURE_SPARSE_EXT";
#endif
            break;
        case 0x91a7:
#if defined(GL_ARB_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_INDEX_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_VIRTUAL_PAGE_SIZE_INDEX_EXT";
#endif
            break;
        case 0x91a8:
#if defined(GL_ARB_sparse_texture)
                     return "GL_NUM_VIRTUAL_PAGE_SIZES_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_NUM_VIRTUAL_PAGE_SIZES_EXT";
#endif
            break;
        case 0x91a9:
#if defined(GL_ARB_sparse_texture)
                     return "GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT";
#endif
            break;
        case 0x91aa:
#if defined(GL_ARB_sparse_texture)
                     return "GL_NUM_SPARSE_LEVELS_ARB";
#endif
#if defined(GL_EXT_sparse_texture)
                     return "GL_NUM_SPARSE_LEVELS_EXT";
#endif
            break;
#if defined(GL_AMD_framebuffer_sample_positions)
        case 0x91ae: return "GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD";
        case 0x91af: return "GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD";
#endif
#if defined(GL_ARB_parallel_shader_compile)
        case 0x91b0: return "GL_MAX_SHADER_COMPILER_THREADS_ARB";
        case 0x91b1: return "GL_COMPLETION_STATUS_ARB";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x91b9: return "GL_COMPUTE_SHADER";
        case 0x91bb: return "GL_MAX_COMPUTE_UNIFORM_BLOCKS";
        case 0x91bc: return "GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS";
        case 0x91bd: return "GL_MAX_COMPUTE_IMAGE_UNIFORMS";
        case 0x91be: return "GL_MAX_COMPUTE_WORK_GROUP_COUNT";
#endif
        case 0x91bf:
#if defined(GL_ARB_compute_variable_group_size)
                     return "GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
                     return "GL_MAX_COMPUTE_WORK_GROUP_SIZE";
#endif
            break;
#if defined(GL_AMD_gpu_shader_half_float)
        case 0x91c5: return "GL_FLOAT16_MAT2_AMD";
        case 0x91c6: return "GL_FLOAT16_MAT3_AMD";
        case 0x91c7: return "GL_FLOAT16_MAT4_AMD";
        case 0x91c8: return "GL_FLOAT16_MAT2x3_AMD";
        case 0x91c9: return "GL_FLOAT16_MAT2x4_AMD";
        case 0x91ca: return "GL_FLOAT16_MAT3x2_AMD";
        case 0x91cb: return "GL_FLOAT16_MAT3x4_AMD";
        case 0x91cc: return "GL_FLOAT16_MAT4x2_AMD";
        case 0x91cd: return "GL_FLOAT16_MAT4x3_AMD";
#endif
#if defined(GL_DMP_shader_binary)
        case 0x9250: return "GL_SHADER_BINARY_DMP";
#endif
#if defined(GL_DMP_program_binary)
        case 0x9251: return "GL_SMAPHS30_PROGRAM_BINARY_DMP";
        case 0x9252: return "GL_SMAPHS_PROGRAM_BINARY_DMP";
        case 0x9253: return "GL_DMP_PROGRAM_BINARY_DMP";
#endif
#if defined(GL_FJ_shader_binary_GCCSO)
        case 0x9260: return "GL_GCCSO_SHADER_BINARY_FJ";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_0)
        case 0x9270: return "GL_COMPRESSED_R11_EAC";
        case 0x9271: return "GL_COMPRESSED_SIGNED_R11_EAC";
        case 0x9272: return "GL_COMPRESSED_RG11_EAC";
        case 0x9273: return "GL_COMPRESSED_SIGNED_RG11_EAC";
        case 0x9274: return "GL_COMPRESSED_RGB8_ETC2";
        case 0x9275: return "GL_COMPRESSED_SRGB8_ETC2";
        case 0x9276: return "GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        case 0x9277: return "GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        case 0x9278: return "GL_COMPRESSED_RGBA8_ETC2_EAC";
        case 0x9279: return "GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
#endif
#if defined(GL_NV_blend_equation_advanced)
        case 0x9280: return "GL_BLEND_PREMULTIPLIED_SRC_NV";
        case 0x9281: return "GL_BLEND_OVERLAP_NV";
        case 0x9282: return "GL_UNCORRELATED_NV";
        case 0x9283: return "GL_DISJOINT_NV";
        case 0x9284: return "GL_CONJOINT_NV";
#endif
        case 0x9285:
#if defined(GL_KHR_blend_equation_advanced_coherent)
                     return "GL_BLEND_ADVANCED_COHERENT_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced_coherent)
                     return "GL_BLEND_ADVANCED_COHERENT_NV";
#endif
            break;
#if defined(GL_NV_blend_equation_advanced)
        case 0x9286: return "GL_SRC_NV";
        case 0x9287: return "GL_DST_NV";
        case 0x9288: return "GL_SRC_OVER_NV";
        case 0x9289: return "GL_DST_OVER_NV";
        case 0x928a: return "GL_SRC_IN_NV";
        case 0x928b: return "GL_DST_IN_NV";
        case 0x928c: return "GL_SRC_OUT_NV";
        case 0x928d: return "GL_DST_OUT_NV";
        case 0x928e: return "GL_SRC_ATOP_NV";
        case 0x928f: return "GL_DST_ATOP_NV";
        case 0x9291: return "GL_PLUS_NV";
        case 0x9292: return "GL_PLUS_DARKER_NV";
#endif
        case 0x9294:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_MULTIPLY";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_MULTIPLY_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_MULTIPLY_NV";
#endif
            break;
        case 0x9295:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_SCREEN";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_SCREEN_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_SCREEN_NV";
#endif
            break;
        case 0x9296:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_OVERLAY";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_OVERLAY_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_OVERLAY_NV";
#endif
            break;
        case 0x9297:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_DARKEN";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_DARKEN_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_DARKEN_NV";
#endif
            break;
        case 0x9298:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_LIGHTEN";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_LIGHTEN_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_LIGHTEN_NV";
#endif
            break;
        case 0x9299:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COLORDODGE";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_COLORDODGE_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_COLORDODGE_NV";
#endif
            break;
        case 0x929a:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COLORBURN";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_COLORBURN_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_COLORBURN_NV";
#endif
            break;
        case 0x929b:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_HARDLIGHT";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_HARDLIGHT_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_HARDLIGHT_NV";
#endif
            break;
        case 0x929c:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_SOFTLIGHT";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_SOFTLIGHT_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_SOFTLIGHT_NV";
#endif
            break;
        case 0x929e:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_DIFFERENCE";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_DIFFERENCE_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_DIFFERENCE_NV";
#endif
            break;
#if defined(GL_NV_blend_equation_advanced)
        case 0x929f: return "GL_MINUS_NV";
#endif
        case 0x92a0:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_EXCLUSION";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_EXCLUSION_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_EXCLUSION_NV";
#endif
            break;
#if defined(GL_NV_blend_equation_advanced)
        case 0x92a1: return "GL_CONTRAST_NV";
        case 0x92a3: return "GL_INVERT_RGB_NV";
        case 0x92a4: return "GL_LINEARDODGE_NV";
        case 0x92a5: return "GL_LINEARBURN_NV";
        case 0x92a6: return "GL_VIVIDLIGHT_NV";
        case 0x92a7: return "GL_LINEARLIGHT_NV";
        case 0x92a8: return "GL_PINLIGHT_NV";
        case 0x92a9: return "GL_HARDMIX_NV";
#endif
        case 0x92ad:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_HSL_HUE";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_HSL_HUE_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_HSL_HUE_NV";
#endif
            break;
        case 0x92ae:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_HSL_SATURATION";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_HSL_SATURATION_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_HSL_SATURATION_NV";
#endif
            break;
        case 0x92af:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_HSL_COLOR";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_HSL_COLOR_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_HSL_COLOR_NV";
#endif
            break;
        case 0x92b0:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_HSL_LUMINOSITY";
#endif
#if defined(GL_KHR_blend_equation_advanced)
                     return "GL_HSL_LUMINOSITY_KHR";
#endif
#if defined(GL_NV_blend_equation_advanced)
                     return "GL_HSL_LUMINOSITY_NV";
#endif
            break;
#if defined(GL_NV_blend_equation_advanced)
        case 0x92b1: return "GL_PLUS_CLAMPED_NV";
        case 0x92b2: return "GL_PLUS_CLAMPED_ALPHA_NV";
        case 0x92b3: return "GL_MINUS_CLAMPED_NV";
        case 0x92b4: return "GL_INVERT_OVG_NV";
#endif
#if defined(GL_NV_robustness_video_memory_purge)
        case 0x92bb: return "GL_PURGED_CONTEXT_RESET_NV";
#endif
        case 0x92be:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_PRIMITIVE_BOUNDING_BOX";
#endif
#if defined(GL_ARB_ES3_2_compatibility)
                     return "GL_PRIMITIVE_BOUNDING_BOX_ARB";
#endif
#if defined(GL_EXT_primitive_bounding_box)
                     return "GL_PRIMITIVE_BOUNDING_BOX_EXT";
#endif
#if defined(GL_OES_primitive_bounding_box)
                     return "GL_PRIMITIVE_BOUNDING_BOX_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x92c0: return "GL_ATOMIC_COUNTER_BUFFER";
        case 0x92c1: return "GL_ATOMIC_COUNTER_BUFFER_BINDING";
        case 0x92c2: return "GL_ATOMIC_COUNTER_BUFFER_START";
        case 0x92c3: return "GL_ATOMIC_COUNTER_BUFFER_SIZE";
#endif
#if defined(GL_VERSION_4_2)
        case 0x92c4: return "GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE";
        case 0x92c5: return "GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS";
        case 0x92c6: return "GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES";
        case 0x92c7: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER";
        case 0x92c8: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER";
        case 0x92c9: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER";
        case 0x92ca: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER";
        case 0x92cb: return "GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER";
#endif
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x92cc: return "GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS";
#endif
        case 0x92cd:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES";
#endif
            break;
        case 0x92ce:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES";
#endif
            break;
        case 0x92cf:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x92d0: return "GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS";
        case 0x92d1: return "GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS";
        case 0x92d2: return "GL_MAX_VERTEX_ATOMIC_COUNTERS";
#endif
        case 0x92d3:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES";
#endif
            break;
        case 0x92d4:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES";
#endif
            break;
        case 0x92d5:
#if defined(GL_ES_VERSION_3_2) || defined(GL_VERSION_4_2)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTERS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES";
#endif
            break;
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x92d6: return "GL_MAX_FRAGMENT_ATOMIC_COUNTERS";
        case 0x92d7: return "GL_MAX_COMBINED_ATOMIC_COUNTERS";
        case 0x92d8: return "GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE";
        case 0x92d9: return "GL_ACTIVE_ATOMIC_COUNTER_BUFFERS";
#endif
#if defined(GL_VERSION_4_2)
        case 0x92da: return "GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX";
#endif
#if defined(GL_ES_VERSION_3_1) || defined(GL_VERSION_4_2)
        case 0x92db: return "GL_UNSIGNED_INT_ATOMIC_COUNTER";
        case 0x92dc: return "GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS";
#endif
#if defined(GL_NV_fragment_coverage_to_color)
        case 0x92dd: return "GL_FRAGMENT_COVERAGE_TO_COLOR_NV";
        case 0x92de: return "GL_FRAGMENT_COVERAGE_COLOR_NV";
#endif
        case 0x92e0:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_DEBUG_OUTPUT";
#endif
#if defined(GL_KHR_debug)
                     return "GL_DEBUG_OUTPUT_KHR";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x92e1: return "GL_UNIFORM";
        case 0x92e2: return "GL_UNIFORM_BLOCK";
        case 0x92e3: return "GL_PROGRAM_INPUT";
        case 0x92e4: return "GL_PROGRAM_OUTPUT";
        case 0x92e5: return "GL_BUFFER_VARIABLE";
        case 0x92e6: return "GL_SHADER_STORAGE_BLOCK";
#endif
        case 0x92e7:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_IS_PER_PATCH";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_IS_PER_PATCH_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_IS_PER_PATCH_OES";
#endif
            break;
#if defined(GL_VERSION_4_3)
        case 0x92e8: return "GL_VERTEX_SUBROUTINE";
        case 0x92e9: return "GL_TESS_CONTROL_SUBROUTINE";
        case 0x92ea: return "GL_TESS_EVALUATION_SUBROUTINE";
        case 0x92eb: return "GL_GEOMETRY_SUBROUTINE";
        case 0x92ec: return "GL_FRAGMENT_SUBROUTINE";
        case 0x92ed: return "GL_COMPUTE_SUBROUTINE";
        case 0x92ee: return "GL_VERTEX_SUBROUTINE_UNIFORM";
        case 0x92ef: return "GL_TESS_CONTROL_SUBROUTINE_UNIFORM";
        case 0x92f0: return "GL_TESS_EVALUATION_SUBROUTINE_UNIFORM";
        case 0x92f1: return "GL_GEOMETRY_SUBROUTINE_UNIFORM";
        case 0x92f2: return "GL_FRAGMENT_SUBROUTINE_UNIFORM";
        case 0x92f3: return "GL_COMPUTE_SUBROUTINE_UNIFORM";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x92f4: return "GL_TRANSFORM_FEEDBACK_VARYING";
        case 0x92f5: return "GL_ACTIVE_RESOURCES";
        case 0x92f6: return "GL_MAX_NAME_LENGTH";
        case 0x92f7: return "GL_MAX_NUM_ACTIVE_VARIABLES";
#endif
#if defined(GL_VERSION_4_3)
        case 0x92f8: return "GL_MAX_NUM_COMPATIBLE_SUBROUTINES";
#endif
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x92f9: return "GL_NAME_LENGTH";
        case 0x92fa: return "GL_TYPE";
        case 0x92fb: return "GL_ARRAY_SIZE";
        case 0x92fc: return "GL_OFFSET";
        case 0x92fd: return "GL_BLOCK_INDEX";
        case 0x92fe: return "GL_ARRAY_STRIDE";
        case 0x92ff: return "GL_MATRIX_STRIDE";
        case 0x9300: return "GL_IS_ROW_MAJOR";
        case 0x9301: return "GL_ATOMIC_COUNTER_BUFFER_INDEX";
        case 0x9302: return "GL_BUFFER_BINDING";
        case 0x9303: return "GL_BUFFER_DATA_SIZE";
        case 0x9304: return "GL_NUM_ACTIVE_VARIABLES";
        case 0x9305: return "GL_ACTIVE_VARIABLES";
        case 0x9306: return "GL_REFERENCED_BY_VERTEX_SHADER";
#endif
        case 0x9307:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_REFERENCED_BY_TESS_CONTROL_SHADER";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES";
#endif
            break;
        case 0x9308:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_REFERENCED_BY_TESS_EVALUATION_SHADER";
#endif
#if defined(GL_EXT_tessellation_shader)
                     return "GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT";
#endif
#if defined(GL_OES_tessellation_shader)
                     return "GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES";
#endif
            break;
        case 0x9309:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_REFERENCED_BY_GEOMETRY_SHADER";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_REFERENCED_BY_GEOMETRY_SHADER_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_REFERENCED_BY_GEOMETRY_SHADER_OES";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x930a: return "GL_REFERENCED_BY_FRAGMENT_SHADER";
        case 0x930b: return "GL_REFERENCED_BY_COMPUTE_SHADER";
        case 0x930c: return "GL_TOP_LEVEL_ARRAY_SIZE";
        case 0x930d: return "GL_TOP_LEVEL_ARRAY_STRIDE";
        case 0x930e: return "GL_LOCATION";
#endif
        case 0x930f:
#if defined(GL_VERSION_4_3)
                     return "GL_LOCATION_INDEX";
#endif
#if defined(GL_EXT_blend_func_extended)
                     return "GL_LOCATION_INDEX_EXT";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x9310: return "GL_FRAMEBUFFER_DEFAULT_WIDTH";
        case 0x9311: return "GL_FRAMEBUFFER_DEFAULT_HEIGHT";
#endif
        case 0x9312:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_FRAMEBUFFER_DEFAULT_LAYERS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_FRAMEBUFFER_DEFAULT_LAYERS_OES";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x9313: return "GL_FRAMEBUFFER_DEFAULT_SAMPLES";
        case 0x9314: return "GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS";
        case 0x9315: return "GL_MAX_FRAMEBUFFER_WIDTH";
        case 0x9316: return "GL_MAX_FRAMEBUFFER_HEIGHT";
#endif
        case 0x9317:
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_2)
                     return "GL_MAX_FRAMEBUFFER_LAYERS";
#endif
#if defined(GL_EXT_geometry_shader)
                     return "GL_MAX_FRAMEBUFFER_LAYERS_EXT";
#endif
#if defined(GL_OES_geometry_shader)
                     return "GL_MAX_FRAMEBUFFER_LAYERS_OES";
#endif
            break;
#if defined(GL_VERSION_4_3) || defined(GL_ES_VERSION_3_1)
        case 0x9318: return "GL_MAX_FRAMEBUFFER_SAMPLES";
#endif
#if defined(GL_EXT_raster_multisample)
        case 0x9327: return "GL_RASTER_MULTISAMPLE_EXT";
        case 0x9328: return "GL_RASTER_SAMPLES_EXT";
        case 0x9329: return "GL_MAX_RASTER_SAMPLES_EXT";
        case 0x932a: return "GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT";
        case 0x932b: return "GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT";
        case 0x932c: return "GL_EFFECTIVE_RASTER_SAMPLES_EXT";
#endif
#if defined(GL_NV_framebuffer_mixed_samples)
        case 0x932d: return "GL_DEPTH_SAMPLES_NV";
        case 0x932e: return "GL_STENCIL_SAMPLES_NV";
        case 0x932f: return "GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV";
        case 0x9330: return "GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV";
        case 0x9331: return "GL_COVERAGE_MODULATION_TABLE_NV";
        case 0x9332: return "GL_COVERAGE_MODULATION_NV";
        case 0x9333: return "GL_COVERAGE_MODULATION_TABLE_SIZE_NV";
#endif
#if defined(GL_NV_shader_thread_group)
        case 0x9339: return "GL_WARP_SIZE_NV";
        case 0x933a: return "GL_WARPS_PER_SM_NV";
        case 0x933b: return "GL_SM_COUNT_NV";
#endif
#if defined(GL_NV_fill_rectangle)
        case 0x933c: return "GL_FILL_RECTANGLE_NV";
#endif
        case 0x933e:
#if defined(GL_ARB_sample_locations)
                     return "GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV";
#endif
            break;
        case 0x933f:
#if defined(GL_ARB_sample_locations)
                     return "GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV";
#endif
            break;
        case 0x9340:
#if defined(GL_ARB_sample_locations)
                     return "GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV";
#endif
            break;
        case 0x9341:
#if defined(GL_ARB_sample_locations)
                     return "GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_PROGRAMMABLE_SAMPLE_LOCATION_NV";
#endif
            break;
        case 0x9342:
#if defined(GL_ARB_sample_locations)
                     return "GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV";
#endif
            break;
        case 0x9343:
#if defined(GL_ARB_sample_locations)
                     return "GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB";
#endif
#if defined(GL_NV_sample_locations)
                     return "GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV";
#endif
            break;
#if defined(GL_ARB_compute_variable_group_size)
        case 0x9344: return "GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB";
        case 0x9345: return "GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB";
#endif
#if defined(GL_NV_conservative_raster)
        case 0x9346: return "GL_CONSERVATIVE_RASTERIZATION_NV";
#endif
#if defined(GL_VERSION_4_4)
        case 0x934a: return "GL_LOCATION_COMPONENT";
        case 0x934b: return "GL_TRANSFORM_FEEDBACK_BUFFER_INDEX";
        case 0x934c: return "GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE";
#endif
#if defined(GL_NV_viewport_swizzle)
        case 0x9350: return "GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV";
        case 0x9351: return "GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV";
        case 0x9352: return "GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV";
        case 0x9353: return "GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV";
        case 0x9354: return "GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV";
        case 0x9355: return "GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV";
        case 0x9356: return "GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV";
        case 0x9357: return "GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV";
        case 0x9358: return "GL_VIEWPORT_SWIZZLE_X_NV";
        case 0x9359: return "GL_VIEWPORT_SWIZZLE_Y_NV";
        case 0x935a: return "GL_VIEWPORT_SWIZZLE_Z_NV";
        case 0x935b: return "GL_VIEWPORT_SWIZZLE_W_NV";
#endif
#if defined(GL_VERSION_4_5)
        case 0x935c: return "GL_CLIP_ORIGIN";
        case 0x935d: return "GL_CLIP_DEPTH_MODE";
        case 0x935e: return "GL_NEGATIVE_ONE_TO_ONE";
        case 0x935f: return "GL_ZERO_TO_ONE";
#endif
#if defined(GL_VERSION_4_4)
        case 0x9365: return "GL_CLEAR_TEXTURE";
#endif
#if defined(GL_ARB_texture_filter_minmax)
        case 0x9366: return "GL_TEXTURE_REDUCTION_MODE_ARB";
        case 0x9367: return "GL_WEIGHTED_AVERAGE_ARB";
#endif
#if defined(GL_NV_path_rendering)
        case 0x9368: return "GL_FONT_GLYPHS_AVAILABLE_NV";
        case 0x9369: return "GL_FONT_TARGET_UNAVAILABLE_NV";
        case 0x936a: return "GL_FONT_UNAVAILABLE_NV";
        case 0x936b: return "GL_FONT_UNINTELLIGIBLE_NV";
        case 0x936c: return "GL_STANDARD_FONT_FORMAT_NV";
        case 0x936d: return "GL_FRAGMENT_INPUT_NV";
#endif
#if defined(GL_NV_uniform_buffer_unified_memory)
        case 0x936e: return "GL_UNIFORM_BUFFER_UNIFIED_NV";
        case 0x936f: return "GL_UNIFORM_BUFFER_ADDRESS_NV";
        case 0x9370: return "GL_UNIFORM_BUFFER_LENGTH_NV";
#endif
#if defined(GL_NV_internalformat_sample_query)
        case 0x9371: return "GL_MULTISAMPLES_NV";
        case 0x9372: return "GL_SUPERSAMPLE_SCALE_X_NV";
        case 0x9373: return "GL_SUPERSAMPLE_SCALE_Y_NV";
        case 0x9374: return "GL_CONFORMANT_NV";
#endif
#if defined(GL_NV_conservative_raster_dilate)
        case 0x9379: return "GL_CONSERVATIVE_RASTER_DILATE_NV";
        case 0x937a: return "GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV";
        case 0x937b: return "GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV";
#endif
#if defined(GL_NV_clip_space_w_scaling)
        case 0x937c: return "GL_VIEWPORT_POSITION_W_SCALE_NV";
        case 0x937d: return "GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV";
        case 0x937e: return "GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV";
#endif
#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_4_2)
        case 0x9380: return "GL_NUM_SAMPLE_COUNTS";
#endif
        case 0x9381:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_MULTISAMPLE_LINE_WIDTH_RANGE";
#endif
#if defined(GL_ARB_ES3_2_compatibility)
                     return "GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB";
#endif
            break;
        case 0x9382:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY";
#endif
#if defined(GL_ARB_ES3_2_compatibility)
                     return "GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB";
#endif
            break;
#if defined(GL_ANGLE_translated_shader_source)
        case 0x93a0: return "GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE";
#endif
#if defined(GL_APPLE_texture_format_BGRA8888)
        case 0x93a1: return "GL_BGRA8_EXT";
#endif
#if defined(GL_ANGLE_texture_usage)
        case 0x93a2: return "GL_TEXTURE_USAGE_ANGLE";
        case 0x93a3: return "GL_FRAMEBUFFER_ATTACHMENT_ANGLE";
#endif
#if defined(GL_ANGLE_pack_reverse_row_order)
        case 0x93a4: return "GL_PACK_REVERSE_ROW_ORDER_ANGLE";
#endif
#if defined(GL_ANGLE_program_binary)
        case 0x93a6: return "GL_PROGRAM_BINARY_ANGLE";
#endif
        case 0x93b0:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_4x4";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_4x4_KHR";
#endif
            break;
        case 0x93b1:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_5x4";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_5x4_KHR";
#endif
            break;
        case 0x93b2:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_5x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_5x5_KHR";
#endif
            break;
        case 0x93b3:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_6x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_6x5_KHR";
#endif
            break;
        case 0x93b4:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_6x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_6x6_KHR";
#endif
            break;
        case 0x93b5:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_8x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_8x5_KHR";
#endif
            break;
        case 0x93b6:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_8x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_8x6_KHR";
#endif
            break;
        case 0x93b7:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_8x8";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_8x8_KHR";
#endif
            break;
        case 0x93b8:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_10x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_10x5_KHR";
#endif
            break;
        case 0x93b9:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_10x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_10x6_KHR";
#endif
            break;
        case 0x93ba:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_10x8";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_10x8_KHR";
#endif
            break;
        case 0x93bb:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_10x10";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_10x10_KHR";
#endif
            break;
        case 0x93bc:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_12x10";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_12x10_KHR";
#endif
            break;
        case 0x93bd:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_RGBA_ASTC_12x12";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_RGBA_ASTC_12x12_KHR";
#endif
            break;
#if defined(GL_OES_texture_compression_astc)
        case 0x93c0: return "GL_COMPRESSED_RGBA_ASTC_3x3x3_OES";
        case 0x93c1: return "GL_COMPRESSED_RGBA_ASTC_4x3x3_OES";
        case 0x93c2: return "GL_COMPRESSED_RGBA_ASTC_4x4x3_OES";
        case 0x93c3: return "GL_COMPRESSED_RGBA_ASTC_4x4x4_OES";
        case 0x93c4: return "GL_COMPRESSED_RGBA_ASTC_5x4x4_OES";
        case 0x93c5: return "GL_COMPRESSED_RGBA_ASTC_5x5x4_OES";
        case 0x93c6: return "GL_COMPRESSED_RGBA_ASTC_5x5x5_OES";
        case 0x93c7: return "GL_COMPRESSED_RGBA_ASTC_6x5x5_OES";
        case 0x93c8: return "GL_COMPRESSED_RGBA_ASTC_6x6x5_OES";
        case 0x93c9: return "GL_COMPRESSED_RGBA_ASTC_6x6x6_OES";
#endif
        case 0x93d0:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
#endif
            break;
        case 0x93d1:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
#endif
            break;
        case 0x93d2:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
#endif
            break;
        case 0x93d3:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
#endif
            break;
        case 0x93d4:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
#endif
            break;
        case 0x93d5:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
#endif
            break;
        case 0x93d6:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
#endif
            break;
        case 0x93d7:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
#endif
            break;
        case 0x93d8:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
#endif
            break;
        case 0x93d9:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
#endif
            break;
        case 0x93da:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
#endif
            break;
        case 0x93db:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
#endif
            break;
        case 0x93dc:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
#endif
            break;
        case 0x93dd:
#if defined(GL_ES_VERSION_3_2)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12";
#endif
#if defined(GL_KHR_texture_compression_astc_hdr)
                     return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
#endif
            break;
#if defined(GL_OES_texture_compression_astc)
        case 0x93e0: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES";
        case 0x93e1: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES";
        case 0x93e2: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES";
        case 0x93e3: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES";
        case 0x93e4: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES";
        case 0x93e5: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES";
        case 0x93e6: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES";
        case 0x93e7: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES";
        case 0x93e8: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES";
        case 0x93e9: return "GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES";
#endif
#if defined(GL_EXT_pvrtc_sRGB)
        case 0x93f0: return "GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG";
        case 0x93f1: return "GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG";
#endif
#if defined(GL_INTEL_performance_query)
        case 0x94f0: return "GL_PERFQUERY_COUNTER_EVENT_INTEL";
        case 0x94f1: return "GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL";
        case 0x94f2: return "GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL";
        case 0x94f3: return "GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL";
        case 0x94f4: return "GL_PERFQUERY_COUNTER_RAW_INTEL";
        case 0x94f5: return "GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL";
        case 0x94f8: return "GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL";
        case 0x94f9: return "GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL";
        case 0x94fa: return "GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL";
        case 0x94fb: return "GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL";
        case 0x94fc: return "GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL";
        case 0x94fd: return "GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL";
        case 0x94fe: return "GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL";
        case 0x94ff: return "GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL";
        case 0x9500: return "GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL";
#endif
#if defined(GL_NV_conservative_raster_pre_snap_triangles)
        case 0x954d: return "GL_CONSERVATIVE_RASTER_MODE_NV";
        case 0x954e: return "GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV";
        case 0x954f: return "GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV";
#endif
#if defined(GL_OVR_multiview)
        case 0x9630: return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR";
        case 0x9631: return "GL_MAX_VIEWS_OVR";
        case 0x9632: return "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR";
        case 0x9633: return "GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR";
#endif
#if defined(GL_EXT_shader_pixel_local_storage2)
        case 0x9650: return "GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT";
        case 0x9651: return "GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT";
        case 0x9652: return "GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT";
#endif
#if defined(GL_IBM_rasterpos_clip)
        case 0x19262: return "GL_RASTER_POSITION_UNCLIPPED_IBM";
#endif
#if defined(GL_IBM_cull_vertex)
        case 0x1928a: return "GL_CULL_VERTEX_IBM";
#endif
#if defined(GL_IBM_static_data)
        case 0x19294: return "GL_ALL_STATIC_DATA_IBM";
        case 0x19295: return "GL_STATIC_VERTEX_ARRAY_IBM";
#endif
#if defined(GL_IBM_vertex_array_lists)
        case 0x1929e: return "GL_VERTEX_ARRAY_LIST_IBM";
        case 0x1929f: return "GL_NORMAL_ARRAY_LIST_IBM";
        case 0x192a0: return "GL_COLOR_ARRAY_LIST_IBM";
        case 0x192a1: return "GL_INDEX_ARRAY_LIST_IBM";
        case 0x192a2: return "GL_TEXTURE_COORD_ARRAY_LIST_IBM";
        case 0x192a3: return "GL_EDGE_FLAG_ARRAY_LIST_IBM";
        case 0x192a4: return "GL_FOG_COORDINATE_ARRAY_LIST_IBM";
        case 0x192a5: return "GL_SECONDARY_COLOR_ARRAY_LIST_IBM";
        case 0x192a8: return "GL_VERTEX_ARRAY_LIST_STRIDE_IBM";
        case 0x192a9: return "GL_NORMAL_ARRAY_LIST_STRIDE_IBM";
        case 0x192aa: return "GL_COLOR_ARRAY_LIST_STRIDE_IBM";
        case 0x192ab: return "GL_INDEX_ARRAY_LIST_STRIDE_IBM";
        case 0x192ac: return "GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM";
        case 0x192ad: return "GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM";
        case 0x192ae: return "GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM";
        case 0x192af: return "GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM";
#endif
#if defined(GL_PGI_misc_hints)
        case 0x1a1f8: return "GL_PREFER_DOUBLEBUFFER_HINT_PGI";
        case 0x1a1fd: return "GL_CONSERVE_MEMORY_HINT_PGI";
        case 0x1a1fe: return "GL_RECLAIM_MEMORY_HINT_PGI";
        case 0x1a202: return "GL_NATIVE_GRAPHICS_HANDLE_PGI";
        case 0x1a203: return "GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI";
        case 0x1a204: return "GL_NATIVE_GRAPHICS_END_HINT_PGI";
        case 0x1a20c: return "GL_ALWAYS_FAST_HINT_PGI";
        case 0x1a20d: return "GL_ALWAYS_SOFT_HINT_PGI";
        case 0x1a20e: return "GL_ALLOW_DRAW_OBJ_HINT_PGI";
        case 0x1a20f: return "GL_ALLOW_DRAW_WIN_HINT_PGI";
        case 0x1a210: return "GL_ALLOW_DRAW_FRG_HINT_PGI";
        case 0x1a211: return "GL_ALLOW_DRAW_MEM_HINT_PGI";
        case 0x1a216: return "GL_STRICT_DEPTHFUNC_HINT_PGI";
        case 0x1a217: return "GL_STRICT_LIGHTING_HINT_PGI";
        case 0x1a218: return "GL_STRICT_SCISSOR_HINT_PGI";
        case 0x1a219: return "GL_FULL_STIPPLE_HINT_PGI";
        case 0x1a220: return "GL_CLIP_NEAR_HINT_PGI";
        case 0x1a221: return "GL_CLIP_FAR_HINT_PGI";
        case 0x1a222: return "GL_WIDE_LINE_HINT_PGI";
        case 0x1a223: return "GL_BACK_NORMALS_HINT_PGI";
#endif
#if defined(GL_PGI_vertex_hints)
        case 0x1a22a: return "GL_VERTEX_DATA_HINT_PGI";
        case 0x1a22b: return "GL_VERTEX_CONSISTENT_HINT_PGI";
        case 0x1a22c: return "GL_MATERIAL_SIDE_HINT_PGI";
        case 0x1a22d: return "GL_MAX_VERTEX_HINT_PGI";
#endif
    }
    return "<UNKNOWN ENUM>";
}


const char* enum_to_string_GLU(GLenum e)
{
    switch (e) {
#if defined(__glu_h__)
        case 0x186a0: return "GLU_SMOOTH";
        case 0x186a1: return "GLU_FLAT";
        case 0x186a2: return "GLU_NONE";
        case 0x186aa: return "GLU_POINT";
        case 0x186ab: return "GLU_LINE";
        case 0x186ac: return "GLU_FILL";
        case 0x186ad: return "GLU_SILHOUETTE";
        case 0x186b4: return "GLU_OUTSIDE";
        case 0x186b5: return "GLU_INSIDE";
        case 0x18704: return "GLU_TESS_BEGIN";
        case 0x18705: return "GLU_TESS_VERTEX";
        case 0x18706: return "GLU_TESS_END";
        case 0x18707: return "GLU_TESS_ERROR";
        case 0x18708: return "GLU_TESS_EDGE_FLAG";
        case 0x18709: return "GLU_TESS_COMBINE";
        case 0x1870a: return "GLU_TESS_BEGIN_DATA";
        case 0x1870b: return "GLU_TESS_VERTEX_DATA";
        case 0x1870c: return "GLU_TESS_END_DATA";
        case 0x1870d: return "GLU_TESS_ERROR_DATA";
        case 0x1870e: return "GLU_TESS_EDGE_FLAG_DATA";
        case 0x1870f: return "GLU_TESS_COMBINE_DATA";
        case 0x18718: return "GLU_CW";
        case 0x18719: return "GLU_CCW";
        case 0x1871a: return "GLU_INTERIOR";
        case 0x1871b: return "GLU_EXTERIOR";
        case 0x1871c: return "GLU_UNKNOWN";
        case 0x18722: return "GLU_TESS_WINDING_ODD";
        case 0x18723: return "GLU_TESS_WINDING_NONZERO";
        case 0x18724: return "GLU_TESS_WINDING_POSITIVE";
        case 0x18725: return "GLU_TESS_WINDING_NEGATIVE";
        case 0x18726: return "GLU_TESS_WINDING_ABS_GEQ_TWO";
        case 0x1872c: return "GLU_TESS_WINDING_RULE";
        case 0x1872d: return "GLU_TESS_BOUNDARY_ONLY";
        case 0x1872e: return "GLU_TESS_TOLERANCE";
        case 0x18737: return "GLU_TESS_ERROR1";
        case 0x18738: return "GLU_TESS_ERROR2";
        case 0x18739: return "GLU_TESS_ERROR3";
        case 0x1873a: return "GLU_TESS_ERROR4";
        case 0x1873b: return "GLU_TESS_ERROR5";
        case 0x1873c: return "GLU_TESS_ERROR6";
        case 0x1873d: return "GLU_TESS_ERROR7";
        case 0x1873e: return "GLU_TESS_ERROR8";
        case 0x18768: return "GLU_AUTO_LOAD_MATRIX";
        case 0x18769: return "GLU_CULLING";
        case 0x1876a: return "GLU_PARAMETRIC_TOLERANCE";
        case 0x1876b: return "GLU_SAMPLING_TOLERANCE";
        case 0x1876c: return "GLU_DISPLAY_MODE";
        case 0x1876d: return "GLU_SAMPLING_METHOD";
        case 0x1876e: return "GLU_U_STEP";
        case 0x1876f: return "GLU_V_STEP";
        case 0x18772: return "GLU_MAP1_TRIM_2";
        case 0x18773: return "GLU_MAP1_TRIM_3";
        case 0x18777: return "GLU_PATH_LENGTH";
        case 0x18778: return "GLU_PARAMETRIC_ERROR";
        case 0x18779: return "GLU_DOMAIN_DISTANCE";
        case 0x18790: return "GLU_OUTLINE_POLYGON";
        case 0x18791: return "GLU_OUTLINE_PATCH";
        case 0x1879b: return "GLU_NURBS_ERROR1";
        case 0x1879c: return "GLU_NURBS_ERROR2";
        case 0x1879d: return "GLU_NURBS_ERROR3";
        case 0x1879e: return "GLU_NURBS_ERROR4";
        case 0x1879f: return "GLU_NURBS_ERROR5";
        case 0x187a0: return "GLU_NURBS_ERROR6";
        case 0x187a1: return "GLU_NURBS_ERROR7";
        case 0x187a2: return "GLU_NURBS_ERROR8";
        case 0x187a3: return "GLU_NURBS_ERROR9";
        case 0x187a4: return "GLU_NURBS_ERROR10";
        case 0x187a5: return "GLU_NURBS_ERROR11";
        case 0x187a6: return "GLU_NURBS_ERROR12";
        case 0x187a7: return "GLU_NURBS_ERROR13";
        case 0x187a8: return "GLU_NURBS_ERROR14";
        case 0x187a9: return "GLU_NURBS_ERROR15";
        case 0x187aa: return "GLU_NURBS_ERROR16";
        case 0x187ab: return "GLU_NURBS_ERROR17";
        case 0x187ac: return "GLU_NURBS_ERROR18";
        case 0x187ad: return "GLU_NURBS_ERROR19";
        case 0x187ae: return "GLU_NURBS_ERROR20";
        case 0x187af: return "GLU_NURBS_ERROR21";
        case 0x187b0: return "GLU_NURBS_ERROR22";
        case 0x187b1: return "GLU_NURBS_ERROR23";
        case 0x187b2: return "GLU_NURBS_ERROR24";
        case 0x187b3: return "GLU_NURBS_ERROR25";
        case 0x187b4: return "GLU_NURBS_ERROR26";
        case 0x187b5: return "GLU_NURBS_ERROR27";
        case 0x187b6: return "GLU_NURBS_ERROR28";
        case 0x187b7: return "GLU_NURBS_ERROR29";
        case 0x187b8: return "GLU_NURBS_ERROR30";
        case 0x187b9: return "GLU_NURBS_ERROR31";
        case 0x187ba: return "GLU_NURBS_ERROR32";
        case 0x187bb: return "GLU_NURBS_ERROR33";
        case 0x187bc: return "GLU_NURBS_ERROR34";
        case 0x187bd: return "GLU_NURBS_ERROR35";
        case 0x187be: return "GLU_NURBS_ERROR36";
        case 0x187bf: return "GLU_NURBS_ERROR37";
        case 0x189c0: return "GLU_VERSION";
        case 0x189c1: return "GLU_EXTENSIONS";
        case 0x18a24: return "GLU_INVALID_ENUM";
        case 0x18a25: return "GLU_INVALID_VALUE";
        case 0x18a26: return "GLU_OUT_OF_MEMORY";
        case 0x18a27: return "GLU_INCOMPATIBLE_GL_VERSION";
#endif
    }
    return enum_to_string_GL(e);
}


const char* enum_to_string_WGL(GLenum e)
{
    switch (e) {
#if defined(WGL_AMD_gpu_association)
        case 0x1f00: return "WGL_GPU_VENDOR_AMD";
        case 0x1f01: return "WGL_GPU_RENDERER_STRING_AMD";
        case 0x1f02: return "WGL_GPU_OPENGL_VERSION_STRING_AMD";
#endif
        case 0x2000:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NUMBER_PIXEL_FORMATS_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NUMBER_PIXEL_FORMATS_EXT";
#endif
            break;
        case 0x2001:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_DRAW_TO_WINDOW_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_DRAW_TO_WINDOW_EXT";
#endif
            break;
        case 0x2002:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_DRAW_TO_BITMAP_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_DRAW_TO_BITMAP_EXT";
#endif
            break;
        case 0x2003:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_ACCELERATION_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_ACCELERATION_EXT";
#endif
            break;
        case 0x2004:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NEED_PALETTE_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NEED_PALETTE_EXT";
#endif
            break;
        case 0x2005:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NEED_SYSTEM_PALETTE_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NEED_SYSTEM_PALETTE_EXT";
#endif
            break;
        case 0x2006:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SWAP_LAYER_BUFFERS_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SWAP_LAYER_BUFFERS_EXT";
#endif
            break;
        case 0x2007:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SWAP_METHOD_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SWAP_METHOD_EXT";
#endif
            break;
        case 0x2008:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NUMBER_OVERLAYS_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NUMBER_OVERLAYS_EXT";
#endif
            break;
        case 0x2009:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NUMBER_UNDERLAYS_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NUMBER_UNDERLAYS_EXT";
#endif
            break;
        case 0x200a:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_TRANSPARENT_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_TRANSPARENT_EXT";
#endif
            break;
#if defined(WGL_EXT_pixel_format)
        case 0x200b: return "WGL_TRANSPARENT_VALUE_EXT";
#endif
        case 0x200c:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SHARE_DEPTH_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SHARE_DEPTH_EXT";
#endif
            break;
        case 0x200d:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SHARE_STENCIL_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SHARE_STENCIL_EXT";
#endif
            break;
        case 0x200e:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SHARE_ACCUM_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SHARE_ACCUM_EXT";
#endif
            break;
        case 0x200f:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SUPPORT_GDI_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SUPPORT_GDI_EXT";
#endif
            break;
        case 0x2010:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SUPPORT_OPENGL_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SUPPORT_OPENGL_EXT";
#endif
            break;
        case 0x2011:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_DOUBLE_BUFFER_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_DOUBLE_BUFFER_EXT";
#endif
            break;
        case 0x2012:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_STEREO_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_STEREO_EXT";
#endif
            break;
        case 0x2013:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_PIXEL_TYPE_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_PIXEL_TYPE_EXT";
#endif
            break;
        case 0x2016:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_RED_SHIFT_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_RED_SHIFT_EXT";
#endif
            break;
        case 0x2018:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_GREEN_SHIFT_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_GREEN_SHIFT_EXT";
#endif
            break;
        case 0x201a:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_BLUE_SHIFT_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_BLUE_SHIFT_EXT";
#endif
            break;
        case 0x201c:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_ALPHA_SHIFT_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_ALPHA_SHIFT_EXT";
#endif
            break;
        case 0x2024:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_AUX_BUFFERS_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_AUX_BUFFERS_EXT";
#endif
            break;
        case 0x2025:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_NO_ACCELERATION_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_NO_ACCELERATION_EXT";
#endif
            break;
        case 0x2026:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_GENERIC_ACCELERATION_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_GENERIC_ACCELERATION_EXT";
#endif
            break;
        case 0x2027:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_FULL_ACCELERATION_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_FULL_ACCELERATION_EXT";
#endif
            break;
        case 0x2028:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SWAP_EXCHANGE_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SWAP_EXCHANGE_EXT";
#endif
            break;
        case 0x2029:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SWAP_COPY_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SWAP_COPY_EXT";
#endif
            break;
        case 0x202a:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_SWAP_UNDEFINED_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_SWAP_UNDEFINED_EXT";
#endif
            break;
        case 0x202b:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_TYPE_RGBA_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_TYPE_RGBA_EXT";
#endif
            break;
        case 0x202c:
#if defined(WGL_ARB_pixel_format)
                     return "WGL_TYPE_COLORINDEX_ARB";
#endif
#if defined(WGL_EXT_pixel_format)
                     return "WGL_TYPE_COLORINDEX_EXT";
#endif
            break;
        case 0x202d:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_DRAW_TO_PBUFFER_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_DRAW_TO_PBUFFER_EXT";
#endif
            break;
        case 0x202e:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_MAX_PBUFFER_PIXELS_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_MAX_PBUFFER_PIXELS_EXT";
#endif
            break;
        case 0x202f:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_MAX_PBUFFER_WIDTH_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_MAX_PBUFFER_WIDTH_EXT";
#endif
            break;
        case 0x2030:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_MAX_PBUFFER_HEIGHT_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_MAX_PBUFFER_HEIGHT_EXT";
#endif
            break;
#if defined(WGL_EXT_pbuffer)
        case 0x2031: return "WGL_OPTIMAL_PBUFFER_WIDTH_EXT";
        case 0x2032: return "WGL_OPTIMAL_PBUFFER_HEIGHT_EXT";
#endif
        case 0x2033:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_PBUFFER_LARGEST_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_PBUFFER_LARGEST_EXT";
#endif
            break;
        case 0x2034:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_PBUFFER_WIDTH_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_PBUFFER_WIDTH_EXT";
#endif
            break;
        case 0x2035:
#if defined(WGL_ARB_pbuffer)
                     return "WGL_PBUFFER_HEIGHT_ARB";
#endif
#if defined(WGL_EXT_pbuffer)
                     return "WGL_PBUFFER_HEIGHT_EXT";
#endif
            break;
#if defined(WGL_ARB_pbuffer)
        case 0x2036: return "WGL_PBUFFER_LOST_ARB";
#endif
#if defined(WGL_ARB_pixel_format)
        case 0x2037: return "WGL_TRANSPARENT_RED_VALUE_ARB";
        case 0x2038: return "WGL_TRANSPARENT_GREEN_VALUE_ARB";
        case 0x2039: return "WGL_TRANSPARENT_BLUE_VALUE_ARB";
        case 0x203a: return "WGL_TRANSPARENT_ALPHA_VALUE_ARB";
        case 0x203b: return "WGL_TRANSPARENT_INDEX_VALUE_ARB";
#endif
#if defined(WGL_EXT_depth_float)
        case 0x2040: return "WGL_DEPTH_FLOAT_EXT";
#endif
        case 0x2041:
#if defined(WGL_ARB_multisample)
                     return "WGL_SAMPLE_BUFFERS_ARB";
#endif
#if defined(WGL_EXT_multisample)
                     return "WGL_SAMPLE_BUFFERS_EXT";
#endif
            break;
        case 0x2042:
#if defined(WGL_NV_multisample_coverage)
                     return "WGL_COVERAGE_SAMPLES_NV";
#endif
#if defined(WGL_ARB_multisample)
                     return "WGL_SAMPLES_ARB";
#endif
#if defined(WGL_EXT_multisample)
                     return "WGL_SAMPLES_EXT";
#endif
            break;
#if defined(WGL_I3D_genlock)
        case 0x2044: return "WGL_GENLOCK_SOURCE_MULTIVIEW_I3D";
        case 0x2045: return "WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D";
        case 0x2046: return "WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D";
        case 0x2047: return "WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D";
        case 0x2048: return "WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D";
        case 0x2049: return "WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D";
        case 0x204a: return "WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D";
        case 0x204b: return "WGL_GENLOCK_SOURCE_EDGE_RISING_I3D";
        case 0x204c: return "WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D";
#endif
#if defined(WGL_I3D_gamma)
        case 0x204e: return "WGL_GAMMA_TABLE_SIZE_I3D";
        case 0x204f: return "WGL_GAMMA_EXCLUDE_DESKTOP_I3D";
#endif
#if defined(WGL_I3D_digital_video_control)
        case 0x2050: return "WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D";
        case 0x2051: return "WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D";
        case 0x2052: return "WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D";
        case 0x2053: return "WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D";
#endif
#if defined(WGL_3DL_stereo_control)
        case 0x2055: return "WGL_STEREO_EMITTER_ENABLE_3DL";
        case 0x2056: return "WGL_STEREO_EMITTER_DISABLE_3DL";
        case 0x2057: return "WGL_STEREO_POLARITY_NORMAL_3DL";
        case 0x2058: return "WGL_STEREO_POLARITY_INVERT_3DL";
#endif
#if defined(WGL_3DFX_multisample)
        case 0x2060: return "WGL_SAMPLE_BUFFERS_3DFX";
        case 0x2061: return "WGL_SAMPLES_3DFX";
#endif
#if defined(WGL_ARB_render_texture)
        case 0x2070: return "WGL_BIND_TO_TEXTURE_RGB_ARB";
        case 0x2071: return "WGL_BIND_TO_TEXTURE_RGBA_ARB";
        case 0x2072: return "WGL_TEXTURE_FORMAT_ARB";
        case 0x2073: return "WGL_TEXTURE_TARGET_ARB";
        case 0x2074: return "WGL_MIPMAP_TEXTURE_ARB";
        case 0x2075: return "WGL_TEXTURE_RGB_ARB";
        case 0x2076: return "WGL_TEXTURE_RGBA_ARB";
        case 0x2077: return "WGL_NO_TEXTURE_ARB";
        case 0x2078: return "WGL_TEXTURE_CUBE_MAP_ARB";
        case 0x2079: return "WGL_TEXTURE_1D_ARB";
        case 0x207a: return "WGL_TEXTURE_2D_ARB";
        case 0x207b: return "WGL_MIPMAP_LEVEL_ARB";
        case 0x207c: return "WGL_CUBE_MAP_FACE_ARB";
        case 0x207d: return "WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB";
        case 0x207e: return "WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB";
        case 0x207f: return "WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB";
        case 0x2080: return "WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB";
        case 0x2081: return "WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB";
        case 0x2082: return "WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB";
        case 0x2083: return "WGL_FRONT_LEFT_ARB";
        case 0x2084: return "WGL_FRONT_RIGHT_ARB";
        case 0x2085: return "WGL_BACK_LEFT_ARB";
        case 0x2086: return "WGL_BACK_RIGHT_ARB";
        case 0x2087: return "WGL_AUX0_ARB";
        case 0x2088: return "WGL_AUX1_ARB";
        case 0x2089: return "WGL_AUX2_ARB";
        case 0x208a: return "WGL_AUX3_ARB";
        case 0x208b: return "WGL_AUX4_ARB";
        case 0x208c: return "WGL_AUX5_ARB";
        case 0x208d: return "WGL_AUX6_ARB";
        case 0x208e: return "WGL_AUX7_ARB";
        case 0x208f: return "WGL_AUX8_ARB";
        case 0x2090: return "WGL_AUX9_ARB";
#endif
#if defined(WGL_ARB_create_context)
        case 0x2091: return "WGL_CONTEXT_MAJOR_VERSION_ARB";
        case 0x2092: return "WGL_CONTEXT_MINOR_VERSION_ARB";
        case 0x2093: return "WGL_CONTEXT_LAYER_PLANE_ARB";
        case 0x2094: return "WGL_CONTEXT_FLAGS_ARB";
#endif
#if defined(WGL_ARB_context_flush_control)
        case 0x2097: return "WGL_CONTEXT_RELEASE_BEHAVIOR_ARB";
        case 0x2098: return "WGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB";
#endif
#if defined(WGL_NV_render_texture_rectangle)
        case 0x20a0: return "WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV";
        case 0x20a1: return "WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV";
        case 0x20a2: return "WGL_TEXTURE_RECTANGLE_NV";
#endif
#if defined(WGL_NV_render_depth_texture)
        case 0x20a3: return "WGL_BIND_TO_TEXTURE_DEPTH_NV";
        case 0x20a4: return "WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV";
        case 0x20a5: return "WGL_DEPTH_TEXTURE_FORMAT_NV";
        case 0x20a6: return "WGL_TEXTURE_DEPTH_COMPONENT_NV";
        case 0x20a7: return "WGL_DEPTH_COMPONENT_NV";
#endif
#if defined(WGL_EXT_pixel_format_packed_float)
        case 0x20a8: return "WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT";
#endif
        case 0x20a9:
#if defined(WGL_ARB_framebuffer_sRGB)
                     return "WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB";
#endif
#if defined(WGL_EXT_framebuffer_sRGB)
                     return "WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT";
#endif
            break;
#if defined(WGL_NV_float_buffer)
        case 0x20b0: return "WGL_FLOAT_COMPONENTS_NV";
        case 0x20b1: return "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV";
        case 0x20b2: return "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV";
        case 0x20b3: return "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV";
        case 0x20b4: return "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV";
        case 0x20b5: return "WGL_TEXTURE_FLOAT_R_NV";
        case 0x20b6: return "WGL_TEXTURE_FLOAT_RG_NV";
        case 0x20b7: return "WGL_TEXTURE_FLOAT_RGB_NV";
        case 0x20b8: return "WGL_TEXTURE_FLOAT_RGBA_NV";
#endif
#if defined(WGL_NV_multisample_coverage)
        case 0x20b9: return "WGL_COLOR_SAMPLES_NV";
#endif
#if defined(WGL_NV_video_output)
        case 0x20c0: return "WGL_BIND_TO_VIDEO_RGB_NV";
        case 0x20c1: return "WGL_BIND_TO_VIDEO_RGBA_NV";
        case 0x20c2: return "WGL_BIND_TO_VIDEO_RGB_AND_DEPTH_NV";
        case 0x20c3: return "WGL_VIDEO_OUT_COLOR_NV";
        case 0x20c4: return "WGL_VIDEO_OUT_ALPHA_NV";
        case 0x20c5: return "WGL_VIDEO_OUT_DEPTH_NV";
        case 0x20c6: return "WGL_VIDEO_OUT_COLOR_AND_ALPHA_NV";
        case 0x20c7: return "WGL_VIDEO_OUT_COLOR_AND_DEPTH_NV";
        case 0x20c8: return "WGL_VIDEO_OUT_FRAME";
        case 0x20c9: return "WGL_VIDEO_OUT_FIELD_1";
        case 0x20ca: return "WGL_VIDEO_OUT_FIELD_2";
        case 0x20cb: return "WGL_VIDEO_OUT_STACKED_FIELDS_1_2";
        case 0x20cc: return "WGL_VIDEO_OUT_STACKED_FIELDS_2_1";
#endif
#if defined(WGL_NV_video_capture)
        case 0x20ce: return "WGL_UNIQUE_ID_NV";
        case 0x20cf: return "WGL_NUM_VIDEO_CAPTURE_SLOTS_NV";
#endif
#if defined(WGL_NV_present_video)
        case 0x20f0: return "WGL_NUM_VIDEO_SLOTS_NV";
#endif
        case 0x21a0:
#if defined(WGL_ARB_pixel_format_float)
                     return "WGL_TYPE_RGBA_FLOAT_ARB";
#endif
#if defined(WGL_ATI_pixel_format_float)
                     return "WGL_TYPE_RGBA_FLOAT_ATI";
#endif
            break;
#if defined(WGL_AMD_gpu_association)
        case 0x21a2: return "WGL_GPU_FASTEST_TARGET_GPUS_AMD";
        case 0x21a3: return "WGL_GPU_RAM_AMD";
        case 0x21a4: return "WGL_GPU_CLOCK_AMD";
        case 0x21a5: return "WGL_GPU_NUM_PIPES_AMD";
        case 0x21a6: return "WGL_GPU_NUM_SIMD_AMD";
        case 0x21a7: return "WGL_GPU_NUM_RB_AMD";
        case 0x21a8: return "WGL_GPU_NUM_SPI_AMD";
#endif
#if defined(WGL_EXT_colorspace)
        case 0x3087: return "WGL_COLORSPACE_EXT";
        case 0x3089: return "WGL_COLORSPACE_SRGB_EXT";
        case 0x308a: return "WGL_COLORSPACE_LINEAR_EXT";
#endif
#if defined(WGL_ARB_create_context_robustness)
        case 0x8252: return "WGL_LOSE_CONTEXT_ON_RESET_ARB";
        case 0x8256: return "WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB";
        case 0x8261: return "WGL_NO_RESET_NOTIFICATION_ARB";
#endif
#if defined(WGL_ARB_create_context_profile)
        case 0x9126: return "WGL_CONTEXT_PROFILE_MASK_ARB";
#endif
    }
    return enum_to_string_GL(e);
}


const char* enum_to_string_GLX(GLenum e)
{
    switch (e) {
#if defined(GLX_AMD_gpu_association)
        case 0x1f00: return "GLX_GPU_VENDOR_AMD";
        case 0x1f01: return "GLX_GPU_RENDERER_STRING_AMD";
        case 0x1f02: return "GLX_GPU_OPENGL_VERSION_STRING_AMD";
#endif
#if defined(GLX_ARB_create_context)
        case 0x2091: return "GLX_CONTEXT_MAJOR_VERSION_ARB";
        case 0x2092: return "GLX_CONTEXT_MINOR_VERSION_ARB";
        case 0x2094: return "GLX_CONTEXT_FLAGS_ARB";
#endif
#if defined(GLX_ARB_vertex_buffer_object)
        case 0x2095: return "GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB";
#endif
#if defined(GLX_ARB_context_flush_control)
        case 0x2097: return "GLX_CONTEXT_RELEASE_BEHAVIOR_ARB";
        case 0x2098: return "GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB";
#endif
#if defined(GLX_NV_float_buffer)
        case 0x20b0: return "GLX_FLOAT_COMPONENTS_NV";
#endif
#if defined(GLX_EXT_fbconfig_packed_float)
        case 0x20b1: return "GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT";
#endif
        case 0x20b2:
#if defined(GLX_ARB_framebuffer_sRGB)
                     return "GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB";
#endif
#if defined(GLX_EXT_framebuffer_sRGB)
                     return "GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT";
#endif
            break;
#if defined(GLX_NV_multisample_coverage)
        case 0x20b3: return "GLX_COLOR_SAMPLES_NV";
#endif
#if defined(GLX_ARB_fbconfig_float)
        case 0x20b9: return "GLX_RGBA_FLOAT_TYPE_ARB";
#endif
#if defined(GLX_NV_video_out)
        case 0x20c3: return "GLX_VIDEO_OUT_COLOR_NV";
        case 0x20c4: return "GLX_VIDEO_OUT_ALPHA_NV";
        case 0x20c5: return "GLX_VIDEO_OUT_DEPTH_NV";
        case 0x20c6: return "GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV";
        case 0x20c7: return "GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV";
        case 0x20c8: return "GLX_VIDEO_OUT_FRAME_NV";
        case 0x20c9: return "GLX_VIDEO_OUT_FIELD_1_NV";
        case 0x20ca: return "GLX_VIDEO_OUT_FIELD_2_NV";
        case 0x20cb: return "GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV";
        case 0x20cc: return "GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV";
#endif
#if defined(GLX_NV_video_capture)
        case 0x20cd: return "GLX_DEVICE_ID_NV";
        case 0x20ce: return "GLX_UNIQUE_ID_NV";
        case 0x20cf: return "GLX_NUM_VIDEO_CAPTURE_SLOTS_NV";
#endif
#if defined(GLX_EXT_texture_from_pixmap)
        case 0x20d0: return "GLX_BIND_TO_TEXTURE_RGB_EXT";
        case 0x20d1: return "GLX_BIND_TO_TEXTURE_RGBA_EXT";
        case 0x20d2: return "GLX_BIND_TO_MIPMAP_TEXTURE_EXT";
        case 0x20d3: return "GLX_BIND_TO_TEXTURE_TARGETS_EXT";
        case 0x20d4: return "GLX_Y_INVERTED_EXT";
        case 0x20d5: return "GLX_TEXTURE_FORMAT_EXT";
        case 0x20d6: return "GLX_TEXTURE_TARGET_EXT";
        case 0x20d7: return "GLX_MIPMAP_TEXTURE_EXT";
        case 0x20d8: return "GLX_TEXTURE_FORMAT_NONE_EXT";
        case 0x20d9: return "GLX_TEXTURE_FORMAT_RGB_EXT";
        case 0x20da: return "GLX_TEXTURE_FORMAT_RGBA_EXT";
        case 0x20db: return "GLX_TEXTURE_1D_EXT";
        case 0x20dc: return "GLX_TEXTURE_2D_EXT";
        case 0x20dd: return "GLX_TEXTURE_RECTANGLE_EXT";
#endif
        case 0x20de:
#if defined(GLX_EXT_texture_from_pixmap)
                     return "GLX_FRONT_EXT";
#endif
#if defined(GLX_EXT_texture_from_pixmap)
                     return "GLX_FRONT_LEFT_EXT";
#endif
            break;
#if defined(GLX_EXT_texture_from_pixmap)
        case 0x20df: return "GLX_FRONT_RIGHT_EXT";
#endif
        case 0x20e0:
#if defined(GLX_EXT_texture_from_pixmap)
                     return "GLX_BACK_EXT";
#endif
#if defined(GLX_EXT_texture_from_pixmap)
                     return "GLX_BACK_LEFT_EXT";
#endif
            break;
#if defined(GLX_EXT_texture_from_pixmap)
        case 0x20e1: return "GLX_BACK_RIGHT_EXT";
        case 0x20e2: return "GLX_AUX0_EXT";
        case 0x20e3: return "GLX_AUX1_EXT";
        case 0x20e4: return "GLX_AUX2_EXT";
        case 0x20e5: return "GLX_AUX3_EXT";
        case 0x20e6: return "GLX_AUX4_EXT";
        case 0x20e7: return "GLX_AUX5_EXT";
        case 0x20e8: return "GLX_AUX6_EXT";
        case 0x20e9: return "GLX_AUX7_EXT";
        case 0x20ea: return "GLX_AUX8_EXT";
        case 0x20eb: return "GLX_AUX9_EXT";
#endif
#if defined(GLX_NV_present_video)
        case 0x20f0: return "GLX_NUM_VIDEO_SLOTS_NV";
#endif
#if defined(GLX_EXT_swap_control)
        case 0x20f1: return "GLX_SWAP_INTERVAL_EXT";
        case 0x20f2: return "GLX_MAX_SWAP_INTERVAL_EXT";
#endif
#if defined(GLX_EXT_swap_control_tear)
        case 0x20f3: return "GLX_LATE_SWAPS_TEAR_EXT";
#endif
#if defined(GLX_EXT_buffer_age)
        case 0x20f4: return "GLX_BACK_BUFFER_AGE_EXT";
#endif
#if defined(GLX_EXT_stereo_tree)
        case 0x20f5: return "GLX_STEREO_TREE_EXT";
#endif
#if defined(GLX_EXT_libglvnd)
        case 0x20f6: return "GLX_VENDOR_NAMES_EXT";
#endif
#if defined(GLX_NV_robustness_video_memory_purge)
        case 0x20f7: return "GLX_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV";
#endif
#if defined(GLX_AMD_gpu_association)
        case 0x21a2: return "GLX_GPU_FASTEST_TARGET_GPUS_AMD";
        case 0x21a3: return "GLX_GPU_RAM_AMD";
        case 0x21a4: return "GLX_GPU_CLOCK_AMD";
        case 0x21a5: return "GLX_GPU_NUM_PIPES_AMD";
        case 0x21a6: return "GLX_GPU_NUM_SIMD_AMD";
        case 0x21a7: return "GLX_GPU_NUM_RB_AMD";
        case 0x21a8: return "GLX_GPU_NUM_SPI_AMD";
#endif
        case 0x8000:
#if defined(GLX_VERSION_1_3)
                     return "GLX_NONE";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_NONE_EXT";
#endif
            break;
        case 0x8001:
#if defined(GLX_VERSION_1_3)
                     return "GLX_SLOW_CONFIG";
#endif
#if defined(GLX_EXT_visual_rating)
                     return "GLX_SLOW_VISUAL_EXT";
#endif
            break;
        case 0x8002:
#if defined(GLX_VERSION_1_3)
                     return "GLX_TRUE_COLOR";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_TRUE_COLOR_EXT";
#endif
            break;
        case 0x8003:
#if defined(GLX_VERSION_1_3)
                     return "GLX_DIRECT_COLOR";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_DIRECT_COLOR_EXT";
#endif
            break;
        case 0x8004:
#if defined(GLX_VERSION_1_3)
                     return "GLX_PSEUDO_COLOR";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_PSEUDO_COLOR_EXT";
#endif
            break;
        case 0x8005:
#if defined(GLX_VERSION_1_3)
                     return "GLX_STATIC_COLOR";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_STATIC_COLOR_EXT";
#endif
            break;
        case 0x8006:
#if defined(GLX_VERSION_1_3)
                     return "GLX_GRAY_SCALE";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_GRAY_SCALE_EXT";
#endif
            break;
        case 0x8007:
#if defined(GLX_VERSION_1_3)
                     return "GLX_STATIC_GRAY";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_STATIC_GRAY_EXT";
#endif
            break;
        case 0x8008:
#if defined(GLX_VERSION_1_3)
                     return "GLX_TRANSPARENT_RGB";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_TRANSPARENT_RGB_EXT";
#endif
            break;
        case 0x8009:
#if defined(GLX_VERSION_1_3)
                     return "GLX_TRANSPARENT_INDEX";
#endif
#if defined(GLX_EXT_visual_info)
                     return "GLX_TRANSPARENT_INDEX_EXT";
#endif
            break;
#if defined(GLX_EXT_import_context)
        case 0x800a: return "GLX_SHARE_CONTEXT_EXT";
#endif
        case 0x800b:
#if defined(GLX_VERSION_1_3)
                     return "GLX_VISUAL_ID";
#endif
#if defined(GLX_EXT_import_context)
                     return "GLX_VISUAL_ID_EXT";
#endif
            break;
        case 0x800c:
#if defined(GLX_VERSION_1_3)
                     return "GLX_SCREEN";
#endif
#if defined(GLX_EXT_import_context)
                     return "GLX_SCREEN_EXT";
#endif
            break;
        case 0x800d:
#if defined(GLX_VERSION_1_3)
                     return "GLX_NON_CONFORMANT_CONFIG";
#endif
#if defined(GLX_EXT_visual_rating)
                     return "GLX_NON_CONFORMANT_VISUAL_EXT";
#endif
            break;
        case 0x8010:
#if defined(GLX_VERSION_1_3)
                     return "GLX_DRAWABLE_TYPE";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_DRAWABLE_TYPE_SGIX";
#endif
            break;
        case 0x8011:
#if defined(GLX_VERSION_1_3)
                     return "GLX_RENDER_TYPE";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_RENDER_TYPE_SGIX";
#endif
            break;
        case 0x8012:
#if defined(GLX_VERSION_1_3)
                     return "GLX_X_RENDERABLE";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_X_RENDERABLE_SGIX";
#endif
            break;
        case 0x8013:
#if defined(GLX_VERSION_1_3)
                     return "GLX_FBCONFIG_ID";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_FBCONFIG_ID_SGIX";
#endif
            break;
        case 0x8014:
#if defined(GLX_VERSION_1_3)
                     return "GLX_RGBA_TYPE";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_RGBA_TYPE_SGIX";
#endif
            break;
        case 0x8015:
#if defined(GLX_VERSION_1_3)
                     return "GLX_COLOR_INDEX_TYPE";
#endif
#if defined(GLX_SGIX_fbconfig)
                     return "GLX_COLOR_INDEX_TYPE_SGIX";
#endif
            break;
        case 0x8016:
#if defined(GLX_VERSION_1_3)
                     return "GLX_MAX_PBUFFER_WIDTH";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_MAX_PBUFFER_WIDTH_SGIX";
#endif
            break;
        case 0x8017:
#if defined(GLX_VERSION_1_3)
                     return "GLX_MAX_PBUFFER_HEIGHT";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_MAX_PBUFFER_HEIGHT_SGIX";
#endif
            break;
        case 0x8018:
#if defined(GLX_VERSION_1_3)
                     return "GLX_MAX_PBUFFER_PIXELS";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_MAX_PBUFFER_PIXELS_SGIX";
#endif
            break;
#if defined(GLX_SGIX_pbuffer)
        case 0x8019: return "GLX_OPTIMAL_PBUFFER_WIDTH_SGIX";
        case 0x801a: return "GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX";
#endif
        case 0x801b:
#if defined(GLX_VERSION_1_3)
                     return "GLX_PRESERVED_CONTENTS";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_PRESERVED_CONTENTS_SGIX";
#endif
            break;
        case 0x801c:
#if defined(GLX_VERSION_1_3)
                     return "GLX_LARGEST_PBUFFER";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_LARGEST_PBUFFER_SGIX";
#endif
            break;
        case 0x801d:
#if defined(GLX_VERSION_1_3)
                     return "GLX_WIDTH";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_WIDTH_SGIX";
#endif
            break;
        case 0x801e:
#if defined(GLX_VERSION_1_3)
                     return "GLX_HEIGHT";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_HEIGHT_SGIX";
#endif
            break;
        case 0x801f:
#if defined(GLX_VERSION_1_3)
                     return "GLX_EVENT_MASK";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_EVENT_MASK_SGIX";
#endif
            break;
        case 0x8020:
#if defined(GLX_VERSION_1_3)
                     return "GLX_DAMAGED";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_DAMAGED_SGIX";
#endif
            break;
        case 0x8021:
#if defined(GLX_VERSION_1_3)
                     return "GLX_SAVED";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_SAVED_SGIX";
#endif
            break;
        case 0x8022:
#if defined(GLX_VERSION_1_3)
                     return "GLX_WINDOW";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_WINDOW_SGIX";
#endif
            break;
        case 0x8023:
#if defined(GLX_VERSION_1_3)
                     return "GLX_PBUFFER";
#endif
#if defined(GLX_SGIX_pbuffer)
                     return "GLX_PBUFFER_SGIX";
#endif
            break;
#if defined(GLX_SGIX_dmbuffer)
        case 0x8024: return "GLX_DIGITAL_MEDIA_PBUFFER_SGIX";
#endif
#if defined(GLX_SGIS_blended_overlay)
        case 0x8025: return "GLX_BLENDED_RGBA_SGIS";
#endif
#if defined(GLX_SGIS_shared_multisample)
        case 0x8026: return "GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS";
        case 0x8027: return "GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS";
#endif
#if defined(GLX_SGIX_visual_select_group)
        case 0x8028: return "GLX_VISUAL_SELECT_GROUP_SGIX";
#endif
#if defined(GLX_SGIX_hyperpipe)
        case 0x8030: return "GLX_HYPERPIPE_ID_SGIX";
#endif
#if defined(GLX_VERSION_1_3)
        case 0x8040: return "GLX_PBUFFER_HEIGHT";
        case 0x8041: return "GLX_PBUFFER_WIDTH";
#endif
#if defined(GLX_3DFX_multisample)
        case 0x8050: return "GLX_SAMPLE_BUFFERS_3DFX";
        case 0x8051: return "GLX_SAMPLES_3DFX";
#endif
#if defined(GLX_OML_swap_method)
        case 0x8060: return "GLX_SWAP_METHOD_OML";
        case 0x8061: return "GLX_SWAP_EXCHANGE_OML";
        case 0x8062: return "GLX_SWAP_COPY_OML";
        case 0x8063: return "GLX_SWAP_UNDEFINED_OML";
#endif
#if defined(GLX_INTEL_swap_event)
        case 0x8180: return "GLX_EXCHANGE_COMPLETE_INTEL";
        case 0x8181: return "GLX_COPY_COMPLETE_INTEL";
        case 0x8182: return "GLX_FLIP_COMPLETE_INTEL";
#endif
#if defined(GLX_MESA_query_renderer)
        case 0x8183: return "GLX_RENDERER_VENDOR_ID_MESA";
        case 0x8184: return "GLX_RENDERER_DEVICE_ID_MESA";
        case 0x8185: return "GLX_RENDERER_VERSION_MESA";
        case 0x8186: return "GLX_RENDERER_ACCELERATED_MESA";
        case 0x8187: return "GLX_RENDERER_VIDEO_MEMORY_MESA";
        case 0x8188: return "GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA";
        case 0x8189: return "GLX_RENDERER_PREFERRED_PROFILE_MESA";
        case 0x818a: return "GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA";
        case 0x818b: return "GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA";
        case 0x818c: return "GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA";
        case 0x818d: return "GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA";
        case 0x818e: return "GLX_RENDERER_ID_MESA";
#endif
#if defined(GLX_ARB_create_context_robustness)
        case 0x8252: return "GLX_LOSE_CONTEXT_ON_RESET_ARB";
        case 0x8256: return "GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB";
        case 0x8261: return "GLX_NO_RESET_NOTIFICATION_ARB";
#endif
#if defined(GLX_ARB_create_context_profile)
        case 0x9126: return "GLX_CONTEXT_PROFILE_MASK_ARB";
#endif
        case 0x186a0:
#if defined(GLX_VERSION_1_4)
                     return "GLX_SAMPLE_BUFFERS";
#endif
#if defined(GLX_ARB_multisample)
                     return "GLX_SAMPLE_BUFFERS_ARB";
#endif
#if defined(GLX_SGIS_multisample)
                     return "GLX_SAMPLE_BUFFERS_SGIS";
#endif
            break;
        case 0x186a1:
#if defined(GLX_NV_multisample_coverage)
                     return "GLX_COVERAGE_SAMPLES_NV";
#endif
#if defined(GLX_VERSION_1_4)
                     return "GLX_SAMPLES";
#endif
#if defined(GLX_ARB_multisample)
                     return "GLX_SAMPLES_ARB";
#endif
#if defined(GLX_SGIS_multisample)
                     return "GLX_SAMPLES_SGIS";
#endif
            break;
    }
    return enum_to_string_GL(e);
}


const char* enum_to_string_EGL(GLenum e)
{
    switch (e) {
#if defined(EGL_KHR_context_flush_control)
        case 0x2097: return "EGL_CONTEXT_RELEASE_BEHAVIOR_KHR";
        case 0x2098: return "EGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR";
#endif
#if defined(EGL_VERSION_1_2)
        case 0x2710: return "EGL_DISPLAY_SCALING";
#endif
#if defined(EGL_VERSION_1_0)
        case 0x3000: return "EGL_SUCCESS";
        case 0x3001: return "EGL_NOT_INITIALIZED";
        case 0x3002: return "EGL_BAD_ACCESS";
        case 0x3003: return "EGL_BAD_ALLOC";
        case 0x3004: return "EGL_BAD_ATTRIBUTE";
        case 0x3005: return "EGL_BAD_CONFIG";
        case 0x3006: return "EGL_BAD_CONTEXT";
        case 0x3007: return "EGL_BAD_CURRENT_SURFACE";
        case 0x3008: return "EGL_BAD_DISPLAY";
        case 0x3009: return "EGL_BAD_MATCH";
        case 0x300a: return "EGL_BAD_NATIVE_PIXMAP";
        case 0x300b: return "EGL_BAD_NATIVE_WINDOW";
        case 0x300c: return "EGL_BAD_PARAMETER";
        case 0x300d: return "EGL_BAD_SURFACE";
#endif
#if defined(EGL_VERSION_1_1)
        case 0x300e: return "EGL_CONTEXT_LOST";
#endif
#if defined(EGL_VERSION_1_0)
        case 0x3020: return "EGL_BUFFER_SIZE";
        case 0x3021: return "EGL_ALPHA_SIZE";
        case 0x3022: return "EGL_BLUE_SIZE";
        case 0x3023: return "EGL_GREEN_SIZE";
        case 0x3024: return "EGL_RED_SIZE";
        case 0x3025: return "EGL_DEPTH_SIZE";
        case 0x3026: return "EGL_STENCIL_SIZE";
        case 0x3027: return "EGL_CONFIG_CAVEAT";
        case 0x3028: return "EGL_CONFIG_ID";
        case 0x3029: return "EGL_LEVEL";
        case 0x302a: return "EGL_MAX_PBUFFER_HEIGHT";
        case 0x302b: return "EGL_MAX_PBUFFER_PIXELS";
        case 0x302c: return "EGL_MAX_PBUFFER_WIDTH";
        case 0x302d: return "EGL_NATIVE_RENDERABLE";
        case 0x302e: return "EGL_NATIVE_VISUAL_ID";
        case 0x302f: return "EGL_NATIVE_VISUAL_TYPE";
        case 0x3031: return "EGL_SAMPLES";
        case 0x3032: return "EGL_SAMPLE_BUFFERS";
        case 0x3033: return "EGL_SURFACE_TYPE";
        case 0x3034: return "EGL_TRANSPARENT_TYPE";
        case 0x3035: return "EGL_TRANSPARENT_BLUE_VALUE";
        case 0x3036: return "EGL_TRANSPARENT_GREEN_VALUE";
        case 0x3037: return "EGL_TRANSPARENT_RED_VALUE";
        case 0x3038: return "EGL_NONE";
#endif
#if defined(EGL_VERSION_1_1)
        case 0x3039: return "EGL_BIND_TO_TEXTURE_RGB";
        case 0x303a: return "EGL_BIND_TO_TEXTURE_RGBA";
        case 0x303b: return "EGL_MIN_SWAP_INTERVAL";
        case 0x303c: return "EGL_MAX_SWAP_INTERVAL";
#endif
#if defined(EGL_VERSION_1_2)
        case 0x303d: return "EGL_LUMINANCE_SIZE";
        case 0x303e: return "EGL_ALPHA_MASK_SIZE";
        case 0x303f: return "EGL_COLOR_BUFFER_TYPE";
        case 0x3040: return "EGL_RENDERABLE_TYPE";
#endif
#if defined(EGL_VERSION_1_3)
        case 0x3041: return "EGL_MATCH_NATIVE_PIXMAP";
#endif
        case 0x3042:
#if defined(EGL_VERSION_1_3)
                     return "EGL_CONFORMANT";
#endif
#if defined(EGL_KHR_config_attribs)
                     return "EGL_CONFORMANT_KHR";
#endif
            break;
#if defined(EGL_KHR_lock_surface)
        case 0x3043: return "EGL_MATCH_FORMAT_KHR";
#endif
#if defined(EGL_VERSION_1_0)
        case 0x3050: return "EGL_SLOW_CONFIG";
        case 0x3051: return "EGL_NON_CONFORMANT_CONFIG";
        case 0x3052: return "EGL_TRANSPARENT_RGB";
        case 0x3053: return "EGL_VENDOR";
        case 0x3054: return "EGL_VERSION";
        case 0x3055: return "EGL_EXTENSIONS";
        case 0x3056: return "EGL_HEIGHT";
        case 0x3057: return "EGL_WIDTH";
        case 0x3058: return "EGL_LARGEST_PBUFFER";
        case 0x3059: return "EGL_DRAW";
        case 0x305a: return "EGL_READ";
        case 0x305b: return "EGL_CORE_NATIVE_ENGINE";
#endif
#if defined(EGL_VERSION_1_1)
        case 0x305c: return "EGL_NO_TEXTURE";
        case 0x305d: return "EGL_TEXTURE_RGB";
        case 0x305e: return "EGL_TEXTURE_RGBA";
        case 0x305f: return "EGL_TEXTURE_2D";
#endif
#if defined(EGL_NOK_texture_from_pixmap)
        case 0x307f: return "EGL_Y_INVERTED_NOK";
#endif
#if defined(EGL_VERSION_1_1)
        case 0x3080: return "EGL_TEXTURE_FORMAT";
        case 0x3081: return "EGL_TEXTURE_TARGET";
        case 0x3082: return "EGL_MIPMAP_TEXTURE";
        case 0x3083: return "EGL_MIPMAP_LEVEL";
        case 0x3084: return "EGL_BACK_BUFFER";
#endif
#if defined(EGL_VERSION_1_2)
        case 0x3085: return "EGL_SINGLE_BUFFER";
        case 0x3086: return "EGL_RENDER_BUFFER";
#endif
        case 0x3087:
#if defined(EGL_VERSION_1_2)
                     return "EGL_COLORSPACE";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_COLORSPACE";
#endif
            break;
        case 0x3088:
#if defined(EGL_VERSION_1_2)
                     return "EGL_ALPHA_FORMAT";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_ALPHA_FORMAT";
#endif
            break;
        case 0x3089:
#if defined(EGL_VERSION_1_2)
                     return "EGL_COLORSPACE_sRGB";
#endif
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_COLORSPACE_SRGB";
#endif
#if defined(EGL_KHR_gl_colorspace)
                     return "EGL_GL_COLORSPACE_SRGB_KHR";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_COLORSPACE_sRGB";
#endif
            break;
        case 0x308a:
#if defined(EGL_VERSION_1_2)
                     return "EGL_COLORSPACE_LINEAR";
#endif
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_COLORSPACE_LINEAR";
#endif
#if defined(EGL_KHR_gl_colorspace)
                     return "EGL_GL_COLORSPACE_LINEAR_KHR";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_COLORSPACE_LINEAR";
#endif
            break;
        case 0x308b:
#if defined(EGL_VERSION_1_2)
                     return "EGL_ALPHA_FORMAT_NONPRE";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_ALPHA_FORMAT_NONPRE";
#endif
            break;
        case 0x308c:
#if defined(EGL_VERSION_1_2)
                     return "EGL_ALPHA_FORMAT_PRE";
#endif
#if defined(EGL_VERSION_1_3)
                     return "EGL_VG_ALPHA_FORMAT_PRE";
#endif
            break;
#if defined(EGL_VERSION_1_2)
        case 0x308d: return "EGL_CLIENT_APIS";
        case 0x308e: return "EGL_RGB_BUFFER";
        case 0x308f: return "EGL_LUMINANCE_BUFFER";
        case 0x3090: return "EGL_HORIZONTAL_RESOLUTION";
        case 0x3091: return "EGL_VERTICAL_RESOLUTION";
        case 0x3092: return "EGL_PIXEL_ASPECT_RATIO";
        case 0x3093: return "EGL_SWAP_BEHAVIOR";
        case 0x3094: return "EGL_BUFFER_PRESERVED";
        case 0x3095: return "EGL_BUFFER_DESTROYED";
        case 0x3096: return "EGL_OPENVG_IMAGE";
        case 0x3097: return "EGL_CONTEXT_CLIENT_TYPE";
#endif
        case 0x3098:
#if defined(EGL_VERSION_1_3)
                     return "EGL_CONTEXT_CLIENT_VERSION";
#endif
#if defined(EGL_VERSION_1_5)
                     return "EGL_CONTEXT_MAJOR_VERSION";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_CONTEXT_MAJOR_VERSION_KHR";
#endif
            break;
#if defined(EGL_VERSION_1_4)
        case 0x3099: return "EGL_MULTISAMPLE_RESOLVE";
        case 0x309a: return "EGL_MULTISAMPLE_RESOLVE_DEFAULT";
        case 0x309b: return "EGL_MULTISAMPLE_RESOLVE_BOX";
#endif
        case 0x309c:
#if defined(EGL_VERSION_1_5)
                     return "EGL_CL_EVENT_HANDLE";
#endif
#if defined(EGL_KHR_cl_event)
                     return "EGL_CL_EVENT_HANDLE_KHR";
#endif
            break;
        case 0x309d:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_COLORSPACE";
#endif
#if defined(EGL_KHR_gl_colorspace)
                     return "EGL_GL_COLORSPACE_KHR";
#endif
            break;
#if defined(EGL_VERSION_1_2)
        case 0x30a0: return "EGL_OPENGL_ES_API";
        case 0x30a1: return "EGL_OPENVG_API";
#endif
#if defined(EGL_VERSION_1_4)
        case 0x30a2: return "EGL_OPENGL_API";
#endif
#if defined(EGL_KHR_image)
        case 0x30b0: return "EGL_NATIVE_PIXMAP_KHR";
#endif
        case 0x30b1:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_2D";
#endif
#if defined(EGL_KHR_gl_texture_2D_image)
                     return "EGL_GL_TEXTURE_2D_KHR";
#endif
            break;
        case 0x30b2:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_3D";
#endif
#if defined(EGL_KHR_gl_texture_3D_image)
                     return "EGL_GL_TEXTURE_3D_KHR";
#endif
            break;
        case 0x30b3:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR";
#endif
            break;
        case 0x30b4:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR";
#endif
            break;
        case 0x30b5:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR";
#endif
            break;
        case 0x30b6:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR";
#endif
            break;
        case 0x30b7:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR";
#endif
            break;
        case 0x30b8:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z";
#endif
#if defined(EGL_KHR_gl_texture_cubemap_image)
                     return "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR";
#endif
            break;
        case 0x30b9:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_RENDERBUFFER";
#endif
#if defined(EGL_KHR_gl_renderbuffer_image)
                     return "EGL_GL_RENDERBUFFER_KHR";
#endif
            break;
#if defined(EGL_KHR_vg_parent_image)
        case 0x30ba: return "EGL_VG_PARENT_IMAGE_KHR";
#endif
        case 0x30bc:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_LEVEL";
#endif
#if defined(EGL_KHR_gl_texture_2D_image)
                     return "EGL_GL_TEXTURE_LEVEL_KHR";
#endif
            break;
        case 0x30bd:
#if defined(EGL_VERSION_1_5)
                     return "EGL_GL_TEXTURE_ZOFFSET";
#endif
#if defined(EGL_KHR_gl_texture_3D_image)
                     return "EGL_GL_TEXTURE_ZOFFSET_KHR";
#endif
            break;
#if defined(EGL_NV_post_sub_buffer)
        case 0x30be: return "EGL_POST_SUB_BUFFER_SUPPORTED_NV";
#endif
#if defined(EGL_EXT_create_context_robustness)
        case 0x30bf: return "EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT";
#endif
#if defined(EGL_KHR_lock_surface)
        case 0x30c0: return "EGL_FORMAT_RGB_565_EXACT_KHR";
        case 0x30c1: return "EGL_FORMAT_RGB_565_KHR";
        case 0x30c2: return "EGL_FORMAT_RGBA_8888_EXACT_KHR";
        case 0x30c3: return "EGL_FORMAT_RGBA_8888_KHR";
        case 0x30c4: return "EGL_MAP_PRESERVE_PIXELS_KHR";
        case 0x30c5: return "EGL_LOCK_USAGE_HINT_KHR";
        case 0x30c6: return "EGL_BITMAP_POINTER_KHR";
        case 0x30c7: return "EGL_BITMAP_PITCH_KHR";
        case 0x30c8: return "EGL_BITMAP_ORIGIN_KHR";
        case 0x30c9: return "EGL_BITMAP_PIXEL_RED_OFFSET_KHR";
        case 0x30ca: return "EGL_BITMAP_PIXEL_GREEN_OFFSET_KHR";
        case 0x30cb: return "EGL_BITMAP_PIXEL_BLUE_OFFSET_KHR";
        case 0x30cc: return "EGL_BITMAP_PIXEL_ALPHA_OFFSET_KHR";
        case 0x30cd: return "EGL_BITMAP_PIXEL_LUMINANCE_OFFSET_KHR";
        case 0x30ce: return "EGL_LOWER_LEFT_KHR";
        case 0x30cf: return "EGL_UPPER_LEFT_KHR";
#endif
        case 0x30d2:
#if defined(EGL_VERSION_1_5)
                     return "EGL_IMAGE_PRESERVED";
#endif
#if defined(EGL_KHR_image_base)
                     return "EGL_IMAGE_PRESERVED_KHR";
#endif
            break;
#if defined(EGL_NV_coverage_sample)
        case 0x30e0: return "EGL_COVERAGE_BUFFERS_NV";
        case 0x30e1: return "EGL_COVERAGE_SAMPLES_NV";
#endif
#if defined(EGL_NV_depth_nonlinear)
        case 0x30e2: return "EGL_DEPTH_ENCODING_NV";
        case 0x30e3: return "EGL_DEPTH_ENCODING_NONLINEAR_NV";
#endif
#if defined(EGL_NV_sync)
        case 0x30e6: return "EGL_SYNC_PRIOR_COMMANDS_COMPLETE_NV";
        case 0x30e7: return "EGL_SYNC_STATUS_NV";
        case 0x30e8: return "EGL_SIGNALED_NV";
        case 0x30e9: return "EGL_UNSIGNALED_NV";
        case 0x30ea: return "EGL_ALREADY_SIGNALED_NV";
        case 0x30eb: return "EGL_TIMEOUT_EXPIRED_NV";
        case 0x30ec: return "EGL_CONDITION_SATISFIED_NV";
        case 0x30ed: return "EGL_SYNC_TYPE_NV";
        case 0x30ee: return "EGL_SYNC_CONDITION_NV";
        case 0x30ef: return "EGL_SYNC_FENCE_NV";
#endif
        case 0x30f0:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_PRIOR_COMMANDS_COMPLETE";
#endif
#if defined(EGL_KHR_fence_sync)
                     return "EGL_SYNC_PRIOR_COMMANDS_COMPLETE_KHR";
#endif
            break;
        case 0x30f1:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_STATUS";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_SYNC_STATUS_KHR";
#endif
            break;
        case 0x30f2:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SIGNALED";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_SIGNALED_KHR";
#endif
            break;
        case 0x30f3:
#if defined(EGL_VERSION_1_5)
                     return "EGL_UNSIGNALED";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_UNSIGNALED_KHR";
#endif
            break;
        case 0x30f5:
#if defined(EGL_VERSION_1_5)
                     return "EGL_TIMEOUT_EXPIRED";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_TIMEOUT_EXPIRED_KHR";
#endif
            break;
        case 0x30f6:
#if defined(EGL_VERSION_1_5)
                     return "EGL_CONDITION_SATISFIED";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_CONDITION_SATISFIED_KHR";
#endif
            break;
        case 0x30f7:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_TYPE";
#endif
#if defined(EGL_KHR_reusable_sync)
                     return "EGL_SYNC_TYPE_KHR";
#endif
            break;
        case 0x30f8:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_CONDITION";
#endif
#if defined(EGL_KHR_fence_sync)
                     return "EGL_SYNC_CONDITION_KHR";
#endif
            break;
        case 0x30f9:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_FENCE";
#endif
#if defined(EGL_KHR_fence_sync)
                     return "EGL_SYNC_FENCE_KHR";
#endif
            break;
#if defined(EGL_KHR_reusable_sync)
        case 0x30fa: return "EGL_SYNC_REUSABLE_KHR";
#endif
        case 0x30fb:
#if defined(EGL_VERSION_1_5)
                     return "EGL_CONTEXT_MINOR_VERSION";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_CONTEXT_MINOR_VERSION_KHR";
#endif
            break;
#if defined(EGL_KHR_create_context)
        case 0x30fc: return "EGL_CONTEXT_FLAGS_KHR";
#endif
        case 0x30fd:
#if defined(EGL_VERSION_1_5)
                     return "EGL_CONTEXT_OPENGL_PROFILE_MASK";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR";
#endif
            break;
        case 0x30fe:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_CL_EVENT";
#endif
#if defined(EGL_KHR_cl_event)
                     return "EGL_SYNC_CL_EVENT_KHR";
#endif
            break;
        case 0x30ff:
#if defined(EGL_VERSION_1_5)
                     return "EGL_SYNC_CL_EVENT_COMPLETE";
#endif
#if defined(EGL_KHR_cl_event)
                     return "EGL_SYNC_CL_EVENT_COMPLETE_KHR";
#endif
            break;
#if defined(EGL_IMG_context_priority)
        case 0x3100: return "EGL_CONTEXT_PRIORITY_LEVEL_IMG";
        case 0x3101: return "EGL_CONTEXT_PRIORITY_HIGH_IMG";
        case 0x3102: return "EGL_CONTEXT_PRIORITY_MEDIUM_IMG";
        case 0x3103: return "EGL_CONTEXT_PRIORITY_LOW_IMG";
#endif
#if defined(EGL_IMG_image_plane_attribs)
        case 0x3105: return "EGL_NATIVE_BUFFER_MULTIPLANE_SEPARATE_IMG";
        case 0x3106: return "EGL_NATIVE_BUFFER_PLANE_OFFSET_IMG";
#endif
#if defined(EGL_KHR_lock_surface2)
        case 0x3110: return "EGL_BITMAP_PIXEL_SIZE_KHR";
#endif
#if defined(EGL_NV_coverage_sample_resolve)
        case 0x3131: return "EGL_COVERAGE_SAMPLE_RESOLVE_NV";
        case 0x3132: return "EGL_COVERAGE_SAMPLE_RESOLVE_DEFAULT_NV";
        case 0x3133: return "EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV";
#endif
#if defined(EGL_EXT_multiview_window)
        case 0x3134: return "EGL_MULTIVIEW_VIEW_COUNT_EXT";
#endif
#if defined(EGL_NV_3dvision_surface)
        case 0x3136: return "EGL_AUTO_STEREO_NV";
#endif
#if defined(EGL_EXT_create_context_robustness)
        case 0x3138: return "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT";
#endif
        case 0x313d:
#if defined(EGL_EXT_buffer_age)
                     return "EGL_BUFFER_AGE_EXT";
#endif
#if defined(EGL_KHR_partial_update)
                     return "EGL_BUFFER_AGE_KHR";
#endif
            break;
#if defined(EGL_EXT_platform_device)
        case 0x313f: return "EGL_PLATFORM_DEVICE_EXT";
#endif
#if defined(EGL_ANDROID_image_native_buffer)
        case 0x3140: return "EGL_NATIVE_BUFFER_ANDROID";
#endif
#if defined(EGL_KHR_platform_android)
        case 0x3141: return "EGL_PLATFORM_ANDROID_KHR";
#endif
#if defined(EGL_ANDROID_recordable)
        case 0x3142: return "EGL_RECORDABLE_ANDROID";
#endif
#if defined(EGL_ANDROID_create_native_client_buffer)
        case 0x3143: return "EGL_NATIVE_BUFFER_USAGE_ANDROID";
#endif
#if defined(EGL_ANDROID_native_fence_sync)
        case 0x3144: return "EGL_SYNC_NATIVE_FENCE_ANDROID";
        case 0x3145: return "EGL_SYNC_NATIVE_FENCE_FD_ANDROID";
        case 0x3146: return "EGL_SYNC_NATIVE_FENCE_SIGNALED_ANDROID";
#endif
#if defined(EGL_ANDROID_framebuffer_target)
        case 0x3147: return "EGL_FRAMEBUFFER_TARGET_ANDROID";
#endif
#if defined(EGL_ANDROID_front_buffer_auto_refresh)
        case 0x314c: return "EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID";
#endif
#if defined(EGL_VERSION_1_5)
        case 0x31b0: return "EGL_CONTEXT_OPENGL_DEBUG";
        case 0x31b1: return "EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE";
        case 0x31b2: return "EGL_CONTEXT_OPENGL_ROBUST_ACCESS";
#endif
#if defined(EGL_KHR_create_context_no_error)
        case 0x31b3: return "EGL_CONTEXT_OPENGL_NO_ERROR_KHR";
#endif
        case 0x31bd:
#if defined(EGL_VERSION_1_5)
                     return "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR";
#endif
            break;
        case 0x31be:
#if defined(EGL_VERSION_1_5)
                     return "EGL_NO_RESET_NOTIFICATION";
#endif
#if defined(EGL_EXT_create_context_robustness)
                     return "EGL_NO_RESET_NOTIFICATION_EXT";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_NO_RESET_NOTIFICATION_KHR";
#endif
            break;
        case 0x31bf:
#if defined(EGL_VERSION_1_5)
                     return "EGL_LOSE_CONTEXT_ON_RESET";
#endif
#if defined(EGL_EXT_create_context_robustness)
                     return "EGL_LOSE_CONTEXT_ON_RESET_EXT";
#endif
#if defined(EGL_KHR_create_context)
                     return "EGL_LOSE_CONTEXT_ON_RESET_KHR";
#endif
            break;
#if defined(EGL_MESA_drm_image)
        case 0x31d0: return "EGL_DRM_BUFFER_FORMAT_MESA";
        case 0x31d1: return "EGL_DRM_BUFFER_USE_MESA";
        case 0x31d2: return "EGL_DRM_BUFFER_FORMAT_ARGB32_MESA";
        case 0x31d3: return "EGL_DRM_BUFFER_MESA";
        case 0x31d4: return "EGL_DRM_BUFFER_STRIDE_MESA";
#endif
        case 0x31d5:
#if defined(EGL_EXT_platform_x11)
                     return "EGL_PLATFORM_X11_EXT";
#endif
#if defined(EGL_KHR_platform_x11)
                     return "EGL_PLATFORM_X11_KHR";
#endif
            break;
        case 0x31d6:
#if defined(EGL_EXT_platform_x11)
                     return "EGL_PLATFORM_X11_SCREEN_EXT";
#endif
#if defined(EGL_KHR_platform_x11)
                     return "EGL_PLATFORM_X11_SCREEN_KHR";
#endif
            break;
        case 0x31d7:
#if defined(EGL_KHR_platform_gbm)
                     return "EGL_PLATFORM_GBM_KHR";
#endif
#if defined(EGL_MESA_platform_gbm)
                     return "EGL_PLATFORM_GBM_MESA";
#endif
            break;
        case 0x31d8:
#if defined(EGL_EXT_platform_wayland)
                     return "EGL_PLATFORM_WAYLAND_EXT";
#endif
#if defined(EGL_KHR_platform_wayland)
                     return "EGL_PLATFORM_WAYLAND_KHR";
#endif
            break;
#if defined(EGL_MESA_platform_surfaceless)
        case 0x31dd: return "EGL_PLATFORM_SURFACELESS_MESA";
#endif
#if defined(EGL_KHR_stream_fifo)
        case 0x31fc: return "EGL_STREAM_FIFO_LENGTH_KHR";
        case 0x31fd: return "EGL_STREAM_TIME_NOW_KHR";
        case 0x31fe: return "EGL_STREAM_TIME_CONSUMER_KHR";
        case 0x31ff: return "EGL_STREAM_TIME_PRODUCER_KHR";
#endif
#if defined(EGL_ANGLE_d3d_share_handle_client_buffer)
        case 0x3200: return "EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE";
#endif
#if defined(EGL_ANGLE_window_fixed_size)
        case 0x3201: return "EGL_FIXED_SIZE_ANGLE";
#endif
#if defined(EGL_KHR_stream)
        case 0x3210: return "EGL_CONSUMER_LATENCY_USEC_KHR";
        case 0x3212: return "EGL_PRODUCER_FRAME_KHR";
        case 0x3213: return "EGL_CONSUMER_FRAME_KHR";
        case 0x3214: return "EGL_STREAM_STATE_KHR";
        case 0x3215: return "EGL_STREAM_STATE_CREATED_KHR";
        case 0x3216: return "EGL_STREAM_STATE_CONNECTING_KHR";
        case 0x3217: return "EGL_STREAM_STATE_EMPTY_KHR";
        case 0x3218: return "EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR";
        case 0x3219: return "EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR";
        case 0x321a: return "EGL_STREAM_STATE_DISCONNECTED_KHR";
        case 0x321b: return "EGL_BAD_STREAM_KHR";
        case 0x321c: return "EGL_BAD_STATE_KHR";
#endif
#if defined(EGL_KHR_stream_consumer_gltexture)
        case 0x321e: return "EGL_CONSUMER_ACQUIRE_TIMEOUT_USEC_KHR";
#endif
#if defined(EGL_NV_stream_sync)
        case 0x321f: return "EGL_SYNC_NEW_FRAME_NV";
#endif
#if defined(EGL_EXT_device_base)
        case 0x322b: return "EGL_BAD_DEVICE_EXT";
        case 0x322c: return "EGL_DEVICE_EXT";
#endif
#if defined(EGL_EXT_output_base)
        case 0x322d: return "EGL_BAD_OUTPUT_LAYER_EXT";
        case 0x322e: return "EGL_BAD_OUTPUT_PORT_EXT";
        case 0x322f: return "EGL_SWAP_INTERVAL_EXT";
#endif
#if defined(EGL_EXT_device_drm)
        case 0x3233: return "EGL_DRM_DEVICE_FILE_EXT";
#endif
#if defined(EGL_EXT_output_drm)
        case 0x3234: return "EGL_DRM_CRTC_EXT";
        case 0x3235: return "EGL_DRM_PLANE_EXT";
        case 0x3236: return "EGL_DRM_CONNECTOR_EXT";
#endif
#if defined(EGL_EXT_device_openwf)
        case 0x3237: return "EGL_OPENWF_DEVICE_ID_EXT";
#endif
#if defined(EGL_EXT_output_openwf)
        case 0x3238: return "EGL_OPENWF_PIPELINE_ID_EXT";
        case 0x3239: return "EGL_OPENWF_PORT_ID_EXT";
#endif
#if defined(EGL_NV_device_cuda)
        case 0x323a: return "EGL_CUDA_DEVICE_NV";
#endif
#if defined(EGL_NV_cuda_event)
        case 0x323b: return "EGL_CUDA_EVENT_HANDLE_NV";
        case 0x323c: return "EGL_SYNC_CUDA_EVENT_NV";
        case 0x323d: return "EGL_SYNC_CUDA_EVENT_COMPLETE_NV";
#endif
#if defined(EGL_NV_stream_cross_partition)
        case 0x323f: return "EGL_STREAM_CROSS_PARTITION_NV";
#endif
#if defined(EGL_NV_stream_remote)
        case 0x3240: return "EGL_STREAM_STATE_INITIALIZING_NV";
        case 0x3241: return "EGL_STREAM_TYPE_NV";
        case 0x3242: return "EGL_STREAM_PROTOCOL_NV";
        case 0x3243: return "EGL_STREAM_ENDPOINT_NV";
        case 0x3244: return "EGL_STREAM_LOCAL_NV";
#endif
#if defined(EGL_NV_stream_cross_process)
        case 0x3245: return "EGL_STREAM_CROSS_PROCESS_NV";
#endif
#if defined(EGL_NV_stream_remote)
        case 0x3246: return "EGL_STREAM_PROTOCOL_FD_NV";
        case 0x3247: return "EGL_STREAM_PRODUCER_NV";
        case 0x3248: return "EGL_STREAM_CONSUMER_NV";
#endif
#if defined(EGL_NV_stream_socket)
        case 0x324b: return "EGL_STREAM_PROTOCOL_SOCKET_NV";
        case 0x324c: return "EGL_SOCKET_HANDLE_NV";
        case 0x324d: return "EGL_SOCKET_TYPE_NV";
#endif
#if defined(EGL_NV_stream_socket_unix)
        case 0x324e: return "EGL_SOCKET_TYPE_UNIX_NV";
#endif
#if defined(EGL_NV_stream_socket_inet)
        case 0x324f: return "EGL_SOCKET_TYPE_INET_NV";
#endif
#if defined(EGL_NV_stream_metadata)
        case 0x3250: return "EGL_MAX_STREAM_METADATA_BLOCKS_NV";
        case 0x3251: return "EGL_MAX_STREAM_METADATA_BLOCK_SIZE_NV";
        case 0x3252: return "EGL_MAX_STREAM_METADATA_TOTAL_SIZE_NV";
        case 0x3253: return "EGL_PRODUCER_METADATA_NV";
        case 0x3254: return "EGL_CONSUMER_METADATA_NV";
        case 0x3255: return "EGL_METADATA0_SIZE_NV";
        case 0x3256: return "EGL_METADATA1_SIZE_NV";
        case 0x3257: return "EGL_METADATA2_SIZE_NV";
        case 0x3258: return "EGL_METADATA3_SIZE_NV";
        case 0x3259: return "EGL_METADATA0_TYPE_NV";
        case 0x325a: return "EGL_METADATA1_TYPE_NV";
        case 0x325b: return "EGL_METADATA2_TYPE_NV";
        case 0x325c: return "EGL_METADATA3_TYPE_NV";
#endif
#if defined(EGL_EXT_image_dma_buf_import)
        case 0x3270: return "EGL_LINUX_DMA_BUF_EXT";
        case 0x3271: return "EGL_LINUX_DRM_FOURCC_EXT";
        case 0x3272: return "EGL_DMA_BUF_PLANE0_FD_EXT";
        case 0x3273: return "EGL_DMA_BUF_PLANE0_OFFSET_EXT";
        case 0x3274: return "EGL_DMA_BUF_PLANE0_PITCH_EXT";
        case 0x3275: return "EGL_DMA_BUF_PLANE1_FD_EXT";
        case 0x3276: return "EGL_DMA_BUF_PLANE1_OFFSET_EXT";
        case 0x3277: return "EGL_DMA_BUF_PLANE1_PITCH_EXT";
        case 0x3278: return "EGL_DMA_BUF_PLANE2_FD_EXT";
        case 0x3279: return "EGL_DMA_BUF_PLANE2_OFFSET_EXT";
        case 0x327a: return "EGL_DMA_BUF_PLANE2_PITCH_EXT";
        case 0x327b: return "EGL_YUV_COLOR_SPACE_HINT_EXT";
        case 0x327c: return "EGL_SAMPLE_RANGE_HINT_EXT";
        case 0x327d: return "EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT";
        case 0x327e: return "EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT";
        case 0x327f: return "EGL_ITU_REC601_EXT";
        case 0x3280: return "EGL_ITU_REC709_EXT";
        case 0x3281: return "EGL_ITU_REC2020_EXT";
        case 0x3282: return "EGL_YUV_FULL_RANGE_EXT";
        case 0x3283: return "EGL_YUV_NARROW_RANGE_EXT";
        case 0x3284: return "EGL_YUV_CHROMA_SITING_0_EXT";
        case 0x3285: return "EGL_YUV_CHROMA_SITING_0_5_EXT";
#endif
#if defined(EGL_ARM_pixmap_multisample_discard)
        case 0x3286: return "EGL_DISCARD_SAMPLES_ARM";
#endif
#if defined(EGL_ARM_implicit_external_sync)
        case 0x328a: return "EGL_SYNC_PRIOR_COMMANDS_IMPLICIT_EXTERNAL_ARM";
#endif
#if defined(EGL_TIZEN_image_native_buffer)
        case 0x32a0: return "EGL_NATIVE_BUFFER_TIZEN";
#endif
#if defined(EGL_TIZEN_image_native_surface)
        case 0x32a1: return "EGL_NATIVE_SURFACE_TIZEN";
#endif
#if defined(EGL_EXT_protected_content)
        case 0x32c0: return "EGL_PROTECTED_CONTENT_EXT";
#endif
#if defined(EGL_EXT_yuv_surface)
        case 0x3300: return "EGL_YUV_BUFFER_EXT";
        case 0x3301: return "EGL_YUV_ORDER_EXT";
        case 0x3302: return "EGL_YUV_ORDER_YUV_EXT";
        case 0x3303: return "EGL_YUV_ORDER_YVU_EXT";
        case 0x3304: return "EGL_YUV_ORDER_YUYV_EXT";
        case 0x3305: return "EGL_YUV_ORDER_UYVY_EXT";
        case 0x3306: return "EGL_YUV_ORDER_YVYU_EXT";
        case 0x3307: return "EGL_YUV_ORDER_VYUY_EXT";
        case 0x3308: return "EGL_YUV_ORDER_AYUV_EXT";
        case 0x330a: return "EGL_YUV_CSC_STANDARD_EXT";
        case 0x330b: return "EGL_YUV_CSC_STANDARD_601_EXT";
        case 0x330c: return "EGL_YUV_CSC_STANDARD_709_EXT";
        case 0x330d: return "EGL_YUV_CSC_STANDARD_2020_EXT";
        case 0x3311: return "EGL_YUV_NUMBER_OF_PLANES_EXT";
        case 0x3312: return "EGL_YUV_SUBSAMPLE_EXT";
        case 0x3313: return "EGL_YUV_SUBSAMPLE_4_2_0_EXT";
        case 0x3314: return "EGL_YUV_SUBSAMPLE_4_2_2_EXT";
        case 0x3315: return "EGL_YUV_SUBSAMPLE_4_4_4_EXT";
        case 0x3317: return "EGL_YUV_DEPTH_RANGE_EXT";
        case 0x3318: return "EGL_YUV_DEPTH_RANGE_LIMITED_EXT";
        case 0x3319: return "EGL_YUV_DEPTH_RANGE_FULL_EXT";
        case 0x331a: return "EGL_YUV_PLANE_BPP_EXT";
        case 0x331b: return "EGL_YUV_PLANE_BPP_0_EXT";
        case 0x331c: return "EGL_YUV_PLANE_BPP_8_EXT";
        case 0x331d: return "EGL_YUV_PLANE_BPP_10_EXT";
#endif
#if defined(EGL_NV_stream_metadata)
        case 0x3328: return "EGL_PENDING_METADATA_NV";
#endif
#if defined(EGL_NV_stream_fifo_next)
        case 0x3329: return "EGL_PENDING_FRAME_NV";
        case 0x332a: return "EGL_STREAM_TIME_PENDING_NV";
#endif
#if defined(EGL_NV_stream_consumer_gltexture_yuv)
        case 0x332c: return "EGL_YUV_PLANE0_TEXTURE_UNIT_NV";
        case 0x332d: return "EGL_YUV_PLANE1_TEXTURE_UNIT_NV";
        case 0x332e: return "EGL_YUV_PLANE2_TEXTURE_UNIT_NV";
#endif
#if defined(EGL_NV_stream_reset)
        case 0x3334: return "EGL_SUPPORT_RESET_NV";
        case 0x3335: return "EGL_SUPPORT_REUSE_NV";
#endif
#if defined(EGL_NV_stream_fifo_synchronous)
        case 0x3336: return "EGL_STREAM_FIFO_SYNCHRONOUS_NV";
#endif
#if defined(EGL_NV_stream_frame_limits)
        case 0x3337: return "EGL_PRODUCER_MAX_FRAME_HINT_NV";
        case 0x3338: return "EGL_CONSUMER_MAX_FRAME_HINT_NV";
#endif
#if defined(EGL_EXT_pixel_format_float)
        case 0x3339: return "EGL_COLOR_COMPONENT_TYPE_EXT";
        case 0x333a: return "EGL_COLOR_COMPONENT_TYPE_FIXED_EXT";
        case 0x333b: return "EGL_COLOR_COMPONENT_TYPE_FLOAT_EXT";
#endif
#if defined(EGL_EXT_gl_colorspace_bt2020_linear)
        case 0x333f: return "EGL_GL_COLORSPACE_BT2020_LINEAR_EXT";
#endif
#if defined(EGL_EXT_gl_colorspace_bt2020_pq)
        case 0x3340: return "EGL_GL_COLORSPACE_BT2020_PQ_EXT";
#endif
#if defined(EGL_EXT_surface_SMPTE2086_metadata)
        case 0x3341: return "EGL_SMPTE2086_DISPLAY_PRIMARY_RX_EXT";
        case 0x3342: return "EGL_SMPTE2086_DISPLAY_PRIMARY_RY_EXT";
        case 0x3343: return "EGL_SMPTE2086_DISPLAY_PRIMARY_GX_EXT";
        case 0x3344: return "EGL_SMPTE2086_DISPLAY_PRIMARY_GY_EXT";
        case 0x3345: return "EGL_SMPTE2086_DISPLAY_PRIMARY_BX_EXT";
        case 0x3346: return "EGL_SMPTE2086_DISPLAY_PRIMARY_BY_EXT";
        case 0x3347: return "EGL_SMPTE2086_WHITE_POINT_X_EXT";
        case 0x3348: return "EGL_SMPTE2086_WHITE_POINT_Y_EXT";
        case 0x3349: return "EGL_SMPTE2086_MAX_LUMINANCE_EXT";
        case 0x334a: return "EGL_SMPTE2086_MIN_LUMINANCE_EXT";
#endif
#if defined(EGL_NV_robustness_video_memory_purge)
        case 0x334c: return "EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV";
#endif
#if defined(EGL_NV_stream_cross_object)
        case 0x334d: return "EGL_STREAM_CROSS_OBJECT_NV";
#endif
#if defined(EGL_NV_stream_cross_display)
        case 0x334e: return "EGL_STREAM_CROSS_DISPLAY_NV";
#endif
#if defined(EGL_NV_stream_cross_system)
        case 0x334f: return "EGL_STREAM_CROSS_SYSTEM_NV";
#endif
#if defined(EGL_EXT_gl_colorspace_scrgb_linear)
        case 0x3350: return "EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT";
#endif
#if defined(EGL_ANGLE_device_d3d)
        case 0x33a0: return "EGL_D3D9_DEVICE_ANGLE";
        case 0x33a1: return "EGL_D3D11_DEVICE_ANGLE";
#endif
#if defined(EGL_KHR_debug)
        case 0x33b0: return "EGL_OBJECT_THREAD_KHR";
        case 0x33b1: return "EGL_OBJECT_DISPLAY_KHR";
        case 0x33b2: return "EGL_OBJECT_CONTEXT_KHR";
        case 0x33b3: return "EGL_OBJECT_SURFACE_KHR";
        case 0x33b4: return "EGL_OBJECT_IMAGE_KHR";
        case 0x33b5: return "EGL_OBJECT_SYNC_KHR";
        case 0x33b6: return "EGL_OBJECT_STREAM_KHR";
        case 0x33b8: return "EGL_DEBUG_CALLBACK_KHR";
        case 0x33b9: return "EGL_DEBUG_MSG_CRITICAL_KHR";
        case 0x33ba: return "EGL_DEBUG_MSG_ERROR_KHR";
        case 0x33bb: return "EGL_DEBUG_MSG_WARN_KHR";
        case 0x33bc: return "EGL_DEBUG_MSG_INFO_KHR";
#endif
#if defined(EGL_EXT_image_dma_buf_import_modifiers)
        case 0x3440: return "EGL_DMA_BUF_PLANE3_FD_EXT";
        case 0x3441: return "EGL_DMA_BUF_PLANE3_OFFSET_EXT";
        case 0x3442: return "EGL_DMA_BUF_PLANE3_PITCH_EXT";
        case 0x3443: return "EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT";
        case 0x3444: return "EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT";
        case 0x3445: return "EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT";
        case 0x3446: return "EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT";
        case 0x3447: return "EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT";
        case 0x3448: return "EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT";
        case 0x3449: return "EGL_DMA_BUF_PLANE3_MODIFIER_LO_EXT";
        case 0x344a: return "EGL_DMA_BUF_PLANE3_MODIFIER_HI_EXT";
#endif
#if defined(EGL_EXT_compositor)
        case 0x3460: return "EGL_PRIMARY_COMPOSITOR_CONTEXT_EXT";
        case 0x3461: return "EGL_EXTERNAL_REF_ID_EXT";
        case 0x3462: return "EGL_COMPOSITOR_DROP_NEWEST_FRAME_EXT";
        case 0x3463: return "EGL_COMPOSITOR_KEEP_NEWEST_FRAME_EXT";
#endif
#if defined(EGL_HI_colorformats)
        case 0x8f70: return "EGL_COLOR_FORMAT_HI";
        case 0x8f71: return "EGL_COLOR_RGB_HI";
        case 0x8f72: return "EGL_COLOR_RGBA_HI";
        case 0x8f73: return "EGL_COLOR_ARGB_HI";
#endif
#if defined(EGL_HI_clientpixmap)
        case 0x8f74: return "EGL_CLIENT_PIXMAP_POINTER_HI";
#endif
    }
    return enum_to_string_GL(e);
}



#ifdef GLATTER_GL

#ifdef __gl2ext_h_
#ifdef GL_AMD_performance_monitor
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeletePerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenPerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorCounterDataAMD, (monitor, pname, dataSize, data, bytesWritten), (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorCounterInfoAMD, (group, counter, pname, data), (GLuint group, GLuint counter, GLenum pname, void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorCounterStringAMD, (group, counter, bufSize, length, counterString), (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorCountersAMD, (group, numCounters, maxActiveCounters, counterSize, counters), (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorGroupStringAMD, (group, bufSize, length, groupString), (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfMonitorGroupsAMD, (numGroups, groupsSize, groups), (GLint *numGroups, GLsizei groupsSize, GLuint *groups))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSelectPerfMonitorCountersAMD, (monitor, enable, group, numCounters, counterList), (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList))
#endif // GL_AMD_performance_monitor
#ifdef GL_ANGLE_framebuffer_blit
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlitFramebufferANGLE, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
#endif // GL_ANGLE_framebuffer_blit
#ifdef GL_ANGLE_framebuffer_multisample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisampleANGLE, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_ANGLE_framebuffer_multisample
#ifdef GL_ANGLE_instanced_arrays
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysInstancedANGLE, (mode, first, count, primcount), (GLenum mode, GLint first, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedANGLE, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribDivisorANGLE, (index, divisor), (GLuint index, GLuint divisor))
#endif // GL_ANGLE_instanced_arrays
#ifdef GL_ANGLE_translated_shader_source
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTranslatedShaderSourceANGLE, (shader, bufsize, length, source), (GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source))
#endif // GL_ANGLE_translated_shader_source
#ifdef GL_APPLE_copy_texture_levels
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyTextureLevelsAPPLE, (destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount), (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount))
#endif // GL_APPLE_copy_texture_levels
#ifdef GL_APPLE_framebuffer_multisample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisampleAPPLE, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glResolveMultisampleFramebufferAPPLE, (), ())
#endif // GL_APPLE_framebuffer_multisample
#ifdef GL_APPLE_sync
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glClientWaitSyncAPPLE, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteSyncAPPLE, (sync), (GLsync sync))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLsync, GL_APIENTRY, glFenceSyncAPPLE, (condition, flags), (GLenum condition, GLbitfield flags))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetInteger64vAPPLE, (pname, params), (GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSyncivAPPLE, (sync, pname, bufSize, length, values), (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsSyncAPPLE, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glWaitSyncAPPLE, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
#endif // GL_APPLE_sync
#ifdef GL_EXT_base_instance
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysInstancedBaseInstanceEXT, (mode, first, count, instancecount, baseinstance), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedBaseInstanceEXT, (mode, count, type, indices, instancecount, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedBaseVertexBaseInstanceEXT, (mode, count, type, indices, instancecount, basevertex, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance))
#endif // GL_EXT_base_instance
#ifdef GL_EXT_blend_func_extended
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindFragDataLocationEXT, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindFragDataLocationIndexedEXT, (program, colorNumber, index, name), (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetFragDataIndexEXT, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetProgramResourceLocationIndexEXT, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
#endif // GL_EXT_blend_func_extended
#ifdef GL_EXT_buffer_storage
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBufferStorageEXT, (target, size, data, flags), (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags))
#endif // GL_EXT_buffer_storage
#ifdef GL_EXT_clear_texture
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearTexImageEXT, (texture, level, format, type, data), (GLuint texture, GLint level, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearTexSubImageEXT, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data))
#endif // GL_EXT_clear_texture
#ifdef GL_EXT_copy_image
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyImageSubDataEXT, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
#endif // GL_EXT_copy_image
#ifdef GL_EXT_debug_label
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetObjectLabelEXT, (type, object, bufSize, length, label), (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glLabelObjectEXT, (type, object, length, label), (GLenum type, GLuint object, GLsizei length, const GLchar *label))
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glInsertEventMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPopGroupMarkerEXT, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPushGroupMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_discard_framebuffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDiscardFramebufferEXT, (target, numAttachments, attachments), (GLenum target, GLsizei numAttachments, const GLenum *attachments))
#endif // GL_EXT_discard_framebuffer
#ifdef GL_EXT_disjoint_timer_query
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginQueryEXT, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteQueriesEXT, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndQueryEXT, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenQueriesEXT, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryObjecti64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryObjectivEXT, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryObjectui64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryObjectuivEXT, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsQueryEXT, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glQueryCounterEXT, (id, target), (GLuint id, GLenum target))
#endif // GL_EXT_disjoint_timer_query
#ifdef GL_EXT_draw_buffers
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawBuffersEXT, (n, bufs), (GLsizei n, const GLenum *bufs))
#endif // GL_EXT_draw_buffers
#ifdef GL_EXT_draw_buffers_indexed
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationSeparateiEXT, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationiEXT, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFuncSeparateiEXT, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFunciEXT, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glColorMaskiEXT, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisableiEXT, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnableiEXT, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsEnablediEXT, (target, index), (GLenum target, GLuint index))
#endif // GL_EXT_draw_buffers_indexed
#ifdef GL_EXT_draw_elements_base_vertex
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsBaseVertexEXT, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedBaseVertexEXT, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawRangeElementsBaseVertexEXT, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawElementsBaseVertexEXT, (mode, count, type, indices, primcount, basevertex), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const GLint *basevertex))
#endif // GL_EXT_draw_elements_base_vertex
#ifdef GL_EXT_draw_instanced
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysInstancedEXT, (mode, start, count, primcount), (GLenum mode, GLint start, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedEXT, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_draw_transform_feedback
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawTransformFeedbackEXT, (mode, id), (GLenum mode, GLuint id))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawTransformFeedbackInstancedEXT, (mode, id, instancecount), (GLenum mode, GLuint id, GLsizei instancecount))
#endif // GL_EXT_draw_transform_feedback
#ifdef GL_EXT_geometry_shader
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureEXT, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
#endif // GL_EXT_geometry_shader
#ifdef GL_EXT_instanced_arrays
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribDivisorEXT, (index, divisor), (GLuint index, GLuint divisor))
#endif // GL_EXT_instanced_arrays
#ifdef GL_EXT_map_buffer_range
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFlushMappedBufferRangeEXT, (target, offset, length), (GLenum target, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(return, GL, GL_APICALL , void *, GL_APIENTRY, glMapBufferRangeEXT, (target, offset, length, access), (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access))
#endif // GL_EXT_map_buffer_range
#ifdef GL_EXT_multi_draw_arrays
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawArraysEXT, (mode, first, count, primcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawElementsEXT, (mode, count, type, indices, primcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount))
#endif // GL_EXT_multi_draw_arrays
#ifdef GL_EXT_multi_draw_indirect
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawArraysIndirectEXT, (mode, indirect, drawcount, stride), (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawElementsIndirectEXT, (mode, type, indirect, drawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride))
#endif // GL_EXT_multi_draw_indirect
#ifdef GL_EXT_multisampled_render_to_texture
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture2DMultisampleEXT, (target, attachment, textarget, texture, level, samples), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisampleEXT, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_EXT_multisampled_render_to_texture
#ifdef GL_EXT_multiview_draw_buffers
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawBuffersIndexedEXT, (n, location, indices), (GLint n, const GLenum *location, const GLint *indices))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetIntegeri_vEXT, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadBufferIndexedEXT, (src, index), (GLenum src, GLint index))
#endif // GL_EXT_multiview_draw_buffers
#ifdef GL_EXT_polygon_offset_clamp
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPolygonOffsetClampEXT, (factor, units, clamp), (GLfloat factor, GLfloat units, GLfloat clamp))
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_primitive_bounding_box
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPrimitiveBoundingBoxEXT, (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW))
#endif // GL_EXT_primitive_bounding_box
#ifdef GL_EXT_raster_multisample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRasterSamplesEXT, (samples, fixedsamplelocations), (GLuint samples, GLboolean fixedsamplelocations))
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_robustness
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glGetGraphicsResetStatusEXT, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformfvEXT, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformivEXT, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadnPixelsEXT, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
#endif // GL_EXT_robustness
#ifdef GL_EXT_separate_shader_objects
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glActiveShaderProgramEXT, (pipeline, program), (GLuint pipeline, GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindProgramPipelineEXT, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glCreateShaderProgramvEXT, (type, count, strings), (GLenum type, GLsizei count, const GLchar **strings))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteProgramPipelinesEXT, (n, pipelines), (GLsizei n, const GLuint *pipelines))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenProgramPipelinesEXT, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramPipelineInfoLogEXT, (pipeline, bufSize, length, infoLog), (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramPipelineivEXT, (pipeline, pname, params), (GLuint pipeline, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsProgramPipelineEXT, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramParameteriEXT, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1fEXT, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1iEXT, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1uiEXT, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2fEXT, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2iEXT, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2uiEXT, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3fEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3iEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3uiEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4fEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4iEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4uiEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUseProgramStagesEXT, (pipeline, stages, program), (GLuint pipeline, GLbitfield stages, GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glValidateProgramPipelineEXT, (pipeline), (GLuint pipeline))
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_shader_pixel_local_storage2
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearPixelLocalStorageuiEXT, (offset, n, values), (GLsizei offset, GLsizei n, const GLuint *values))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferPixelLocalStorageSizeEXT, (target, size), (GLuint target, GLsizei size))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLsizei, GL_APIENTRY, glGetFramebufferPixelLocalStorageSizeEXT, (target), (GLuint target))
#endif // GL_EXT_shader_pixel_local_storage2
#ifdef GL_EXT_sparse_texture
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexPageCommitmentEXT, (target, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
#endif // GL_EXT_sparse_texture
#ifdef GL_EXT_tessellation_shader
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPatchParameteriEXT, (pname, value), (GLenum pname, GLint value))
#endif // GL_EXT_tessellation_shader
#ifdef GL_EXT_texture_border_clamp
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIivEXT, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIuivEXT, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIivEXT, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIuivEXT, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
#endif // GL_EXT_texture_border_clamp
#ifdef GL_EXT_texture_buffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBufferEXT, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBufferRangeEXT, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
#endif // GL_EXT_texture_buffer
#ifdef GL_EXT_texture_storage
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage1DEXT, (target, levels, internalformat, width), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage2DEXT, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage3DEXT, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTextureStorage1DEXT, (texture, target, levels, internalformat, width), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTextureStorage2DEXT, (texture, target, levels, internalformat, width, height), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTextureStorage3DEXT, (texture, target, levels, internalformat, width, height, depth), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
#endif // GL_EXT_texture_storage
#ifdef GL_EXT_texture_view
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTextureViewEXT, (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers))
#endif // GL_EXT_texture_view
#ifdef GL_EXT_window_rectangles
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glWindowRectanglesEXT, (mode, count, box), (GLenum mode, GLsizei count, const GLint *box))
#endif // GL_EXT_window_rectangles
#ifdef GL_IMG_bindless_texture
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint64, GL_APIENTRY, glGetTextureHandleIMG, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint64, GL_APIENTRY, glGetTextureSamplerHandleIMG, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformHandleui64IMG, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformHandleui64vIMG, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformHandleui64IMG, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformHandleui64vIMG, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
#endif // GL_IMG_bindless_texture
#ifdef GL_IMG_framebuffer_downsample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture2DDownsampleIMG, (target, attachment, textarget, texture, level, xscale, yscale), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureLayerDownsampleIMG, (target, attachment, texture, level, layer, xscale, yscale), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale))
#endif // GL_IMG_framebuffer_downsample
#ifdef GL_IMG_multisampled_render_to_texture
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture2DMultisampleIMG, (target, attachment, textarget, texture, level, samples), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisampleIMG, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_IMG_multisampled_render_to_texture
#ifdef GL_INTEL_framebuffer_CMAA
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glApplyFramebufferAttachmentCMAAINTEL, (), ())
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_performance_query
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCreatePerfQueryINTEL, (queryId, queryHandle), (GLuint queryId, GLuint *queryHandle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeletePerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFirstPerfQueryIdINTEL, (queryId), (GLuint *queryId))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetNextPerfQueryIdINTEL, (queryId, nextQueryId), (GLuint queryId, GLuint *nextQueryId))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfCounterInfoINTEL, (queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue), (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfQueryDataINTEL, (queryHandle, flags, dataSize, data, bytesWritten), (GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfQueryIdByNameINTEL, (queryName, queryId), (GLchar *queryName, GLuint *queryId))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPerfQueryInfoINTEL, (queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask), (GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask))
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendBarrierKHR, (), ())
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_KHR_debug
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageCallbackKHR, (callback, userParam), (GLDEBUGPROCKHR callback, const void *userParam))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageControlKHR, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageInsertKHR, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glGetDebugMessageLogKHR, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetObjectLabelKHR, (identifier, name, bufSize, length, label), (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetObjectPtrLabelKHR, (ptr, bufSize, length, label), (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPointervKHR, (pname, params), (GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glObjectLabelKHR, (identifier, name, length, label), (GLenum identifier, GLuint name, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glObjectPtrLabelKHR, (ptr, length, label), (const void *ptr, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPopDebugGroupKHR, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPushDebugGroupKHR, (source, id, length, message), (GLenum source, GLuint id, GLsizei length, const GLchar *message))
#endif // GL_KHR_debug
#ifdef GL_KHR_robustness
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glGetGraphicsResetStatusKHR, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformfvKHR, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformivKHR, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformuivKHR, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadnPixelsKHR, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
#endif // GL_KHR_robustness
#ifdef GL_NV_bindless_texture
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint64, GL_APIENTRY, glGetImageHandleNV, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint64, GL_APIENTRY, glGetTextureHandleNV, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint64, GL_APIENTRY, glGetTextureSamplerHandleNV, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsImageHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMakeImageHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMakeImageHandleResidentNV, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMakeTextureHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMakeTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformHandleui64NV, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformHandleui64vNV, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformHandleui64NV, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformHandleui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendBarrierNV, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendParameteriNV, (pname, value), (GLenum pname, GLint value))
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_conditional_render
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginConditionalRenderNV, (id, mode), (GLuint id, GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndConditionalRenderNV, (), ())
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSubpixelPrecisionBiasNV, (xbits, ybits), (GLuint xbits, GLuint ybits))
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_pre_snap_triangles
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glConservativeRasterParameteriNV, (pname, param), (GLenum pname, GLint param))
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_copy_buffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyBufferSubDataNV, (readTarget, writeTarget, readOffset, writeOffset, size), (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
#endif // GL_NV_copy_buffer
#ifdef GL_NV_coverage_sample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverageMaskNV, (mask), (GLboolean mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverageOperationNV, (operation), (GLenum operation))
#endif // GL_NV_coverage_sample
#ifdef GL_NV_draw_buffers
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawBuffersNV, (n, bufs), (GLsizei n, const GLenum *bufs))
#endif // GL_NV_draw_buffers
#ifdef GL_NV_draw_instanced
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysInstancedNV, (mode, first, count, primcount), (GLenum mode, GLint first, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedNV, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
#endif // GL_NV_draw_instanced
#ifdef GL_NV_fence
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteFencesNV, (n, fences), (GLsizei n, const GLuint *fences))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFinishFenceNV, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenFencesNV, (n, fences), (GLsizei n, GLuint *fences))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFenceivNV, (fence, pname, params), (GLuint fence, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsFenceNV, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSetFenceNV, (fence, condition), (GLuint fence, GLenum condition))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glTestFenceNV, (fence), (GLuint fence))
#endif // GL_NV_fence
#ifdef GL_NV_fragment_coverage_to_color
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFragmentCoverageColorNV, (color), (GLuint color))
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_framebuffer_blit
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlitFramebufferNV, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
#endif // GL_NV_framebuffer_blit
#ifdef GL_NV_framebuffer_mixed_samples
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverageModulationNV, (components), (GLenum components))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverageModulationTableNV, (n, v), (GLsizei n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetCoverageModulationTableNV, (bufsize, v), (GLsizei bufsize, GLfloat *v))
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_framebuffer_multisample
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisampleNV, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_NV_framebuffer_multisample
#ifdef GL_NV_gpu_shader5
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetUniformi64vNV, (program, location, params), (GLuint program, GLint location, GLint64EXT *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1i64NV, (program, location, x), (GLuint program, GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1ui64NV, (program, location, x), (GLuint program, GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2i64NV, (program, location, x, y), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2ui64NV, (program, location, x, y), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3i64NV, (program, location, x, y, z), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3ui64NV, (program, location, x, y, z), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4i64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4ui64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1i64NV, (location, x), (GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1ui64NV, (location, x), (GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2i64NV, (location, x, y), (GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2ui64NV, (location, x, y), (GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3i64NV, (location, x, y, z), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3ui64NV, (location, x, y, z), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4i64NV, (location, x, y, z, w), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4ui64NV, (location, x, y, z, w), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
#endif // GL_NV_gpu_shader5
#ifdef GL_NV_instanced_arrays
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribDivisorNV, (index, divisor), (GLuint index, GLuint divisor))
#endif // GL_NV_instanced_arrays
#ifdef GL_NV_internalformat_sample_query
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetInternalformatSampleivNV, (target, internalformat, samples, pname, bufSize, params), (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params))
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_non_square_matrices
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix2x3fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix2x4fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix3x2fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix3x4fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix4x2fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix4x3fvNV, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
#endif // GL_NV_non_square_matrices
#ifdef GL_NV_path_rendering
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyPathNV, (resultPath, srcPath), (GLuint resultPath, GLuint srcPath))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverFillPathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCoverStrokePathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeletePathsNV, (path, range), (GLuint path, GLsizei range))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glGenPathsNV, (range), (GLsizei range))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathCommandsNV, (path, commands), (GLuint path, GLubyte *commands))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathCoordsNV, (path, coords), (GLuint path, GLfloat *coords))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathDashArrayNV, (path, dashArray), (GLuint path, GLfloat *dashArray))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLfloat, GL_APIENTRY, glGetPathLengthNV, (path, startSegment, numSegments), (GLuint path, GLsizei startSegment, GLsizei numSegments))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathMetricRangeNV, (metricQueryMask, firstPathName, numPaths, stride, metrics), (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathMetricsNV, (metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics), (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPathSpacingNV, (pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing), (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramResourcefvNV, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glInterpolatePathsNV, (resultPath, pathA, pathB, weight), (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsPathNV, (path), (GLuint path))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsPointInFillPathNV, (path, mask, x, y), (GLuint path, GLuint mask, GLfloat x, GLfloat y))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsPointInStrokePathNV, (path, x, y), (GLuint path, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixLoad3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixLoad3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixLoadTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixMult3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixMult3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMatrixMultTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathCommandsNV, (path, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathCoordsNV, (path, numCoords, coordType, coords), (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathCoverDepthFuncNV, (func), (GLenum func))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathDashArrayNV, (path, dashCount, dashArray), (GLuint path, GLsizei dashCount, const GLfloat *dashArray))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glPathGlyphIndexArrayNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glPathGlyphIndexRangeNV, (fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount), (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathGlyphRangeNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathGlyphsNV, (firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glPathMemoryGlyphIndexArrayNV, (firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathParameterfNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathParameteriNV, (path, pname, value), (GLuint path, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathStencilDepthOffsetNV, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathStencilFuncNV, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathStringNV, (path, format, length, pathString), (GLuint path, GLenum format, GLsizei length, const void *pathString))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathSubCommandsNV, (path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPathSubCoordsNV, (path, coordStart, numCoords, coordType, coords), (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glPointAlongPathNV, (path, startSegment, numSegments, distance, x, y, tangentX, tangentY), (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramPathFragmentInputGenNV, (program, location, genMode, components, coeffs), (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilFillPathNV, (path, fillMode, mask), (GLuint path, GLenum fillMode, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilStrokePathNV, (path, reference, mask), (GLuint path, GLint reference, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilThenCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilThenCoverFillPathNV, (path, fillMode, mask, coverMode), (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilThenCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilThenCoverStrokePathNV, (path, reference, mask, coverMode), (GLuint path, GLint reference, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTransformPathNV, (resultPath, srcPath, transformType, transformValues), (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glWeightPathsNV, (resultPath, numPaths, paths, weights), (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights))
#endif // GL_NV_path_rendering
#ifdef GL_NV_polygon_mode
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPolygonModeNV, (face, mode), (GLenum face, GLenum mode))
#endif // GL_NV_polygon_mode
#ifdef GL_NV_read_buffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadBufferNV, (mode), (GLenum mode))
#endif // GL_NV_read_buffer
#ifdef GL_NV_sample_locations
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferSampleLocationsfvNV, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glNamedFramebufferSampleLocationsfvNV, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glResolveDepthValuesNV, (), ())
#endif // GL_NV_sample_locations
#ifdef GL_NV_viewport_array
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthRangeArrayfvNV, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthRangeIndexedfNV, (index, n, f), (GLuint index, GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisableiNV, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnableiNV, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFloati_vNV, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsEnablediNV, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorArrayvNV, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorIndexedNV, (index, left, bottom, width, height), (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorIndexedvNV, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportArrayvNV, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportIndexedfNV, (index, x, y, w, h), (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportIndexedfvNV, (index, v), (GLuint index, const GLfloat *v))
#endif // GL_NV_viewport_array
#ifdef GL_NV_viewport_swizzle
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportSwizzleNV, (index, swizzlex, swizzley, swizzlez, swizzlew), (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew))
#endif // GL_NV_viewport_swizzle
#ifdef GL_OES_EGL_image
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEGLImageTargetRenderbufferStorageOES, (target, image), (GLenum target, GLeglImageOES image))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEGLImageTargetTexture2DOES, (target, image), (GLenum target, GLeglImageOES image))
#endif // GL_OES_EGL_image
#ifdef GL_OES_copy_image
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyImageSubDataOES, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
#endif // GL_OES_copy_image
#ifdef GL_OES_draw_buffers_indexed
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationSeparateiOES, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationiOES, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFuncSeparateiOES, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFunciOES, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glColorMaskiOES, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisableiOES, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnableiOES, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsEnablediOES, (target, index), (GLenum target, GLuint index))
#endif // GL_OES_draw_buffers_indexed
#ifdef GL_OES_draw_elements_base_vertex
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsBaseVertexOES, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedBaseVertexOES, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawRangeElementsBaseVertexOES, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMultiDrawElementsBaseVertexOES, (mode, count, type, indices, primcount, basevertex), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const GLint *basevertex))
#endif // GL_OES_draw_elements_base_vertex
#ifdef GL_OES_geometry_shader
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureOES, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
#endif // GL_OES_geometry_shader
#ifdef GL_OES_get_program_binary
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramBinaryOES, (program, bufSize, length, binaryFormat, binary), (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramBinaryOES, (program, binaryFormat, binary, length), (GLuint program, GLenum binaryFormat, const void *binary, GLint length))
#endif // GL_OES_get_program_binary
#ifdef GL_OES_mapbuffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBufferPointervOES, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(return, GL, GL_APICALL , void *, GL_APIENTRY, glMapBufferOES, (target, access), (GLenum target, GLenum access))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glUnmapBufferOES, (target), (GLenum target))
#endif // GL_OES_mapbuffer
#ifdef GL_OES_primitive_bounding_box
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPrimitiveBoundingBoxOES, (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW))
#endif // GL_OES_primitive_bounding_box
#ifdef GL_OES_sample_shading
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMinSampleShadingOES, (value), (GLfloat value))
#endif // GL_OES_sample_shading
#ifdef GL_OES_tessellation_shader
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPatchParameteriOES, (pname, value), (GLenum pname, GLint value))
#endif // GL_OES_tessellation_shader
#ifdef GL_OES_texture_3D
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexImage3DOES, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexSubImage3DOES, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyTexSubImage3DOES, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture3DOES, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexImage3DOES, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexSubImage3DOES, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
#endif // GL_OES_texture_3D
#ifdef GL_OES_texture_border_clamp
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIivOES, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIuivOES, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIivOES, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIuivOES, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIivOES, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIuivOES, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIivOES, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIuivOES, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
#endif // GL_OES_texture_border_clamp
#ifdef GL_OES_texture_buffer
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBufferOES, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBufferRangeOES, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
#endif // GL_OES_texture_buffer
#ifdef GL_OES_texture_storage_multisample_2d_array
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage3DMultisampleOES, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
#endif // GL_OES_texture_storage_multisample_2d_array
#ifdef GL_OES_texture_view
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTextureViewOES, (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers))
#endif // GL_OES_texture_view
#ifdef GL_OES_vertex_array_object
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindVertexArrayOES, (array), (GLuint array))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteVertexArraysOES, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenVertexArraysOES, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsVertexArrayOES, (array), (GLuint array))
#endif // GL_OES_vertex_array_object
#ifdef GL_OES_viewport_array
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthRangeArrayfvOES, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthRangeIndexedfOES, (index, n, f), (GLuint index, GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFloati_vOES, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorArrayvOES, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorIndexedOES, (index, left, bottom, width, height), (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissorIndexedvOES, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportArrayvOES, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportIndexedfOES, (index, x, y, w, h), (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewportIndexedfvOES, (index, v), (GLuint index, const GLfloat *v))
#endif // GL_OES_viewport_array
#ifdef GL_OVR_multiview
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureMultiviewOVR, (target, attachment, texture, level, baseViewIndex, numViews), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews))
#endif // GL_OVR_multiview
#ifdef GL_OVR_multiview_multisampled_render_to_texture
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureMultisampleMultiviewOVR, (target, attachment, texture, level, samples, baseViewIndex, numViews), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews))
#endif // GL_OVR_multiview_multisampled_render_to_texture
#ifdef GL_QCOM_alpha_test
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glAlphaFuncQCOM, (func, ref), (GLenum func, GLclampf ref))
#endif // GL_QCOM_alpha_test
#ifdef GL_QCOM_driver_control
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisableDriverControlQCOM, (driverControl), (GLuint driverControl))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnableDriverControlQCOM, (driverControl), (GLuint driverControl))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetDriverControlStringQCOM, (driverControl, bufSize, length, driverControlString), (GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetDriverControlsQCOM, (num, size, driverControls), (GLint *num, GLsizei size, GLuint *driverControls))
#endif // GL_QCOM_driver_control
#ifdef GL_QCOM_extended_get
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetBufferPointervQCOM, (target, params), (GLenum target, void **params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetBuffersQCOM, (buffers, maxBuffers, numBuffers), (GLuint *buffers, GLint maxBuffers, GLint *numBuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetFramebuffersQCOM, (framebuffers, maxFramebuffers, numFramebuffers), (GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetRenderbuffersQCOM, (renderbuffers, maxRenderbuffers, numRenderbuffers), (GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetTexLevelParameterivQCOM, (texture, face, level, pname, params), (GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetTexSubImageQCOM, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetTexturesQCOM, (textures, maxTextures, numTextures), (GLuint *textures, GLint maxTextures, GLint *numTextures))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtTexObjectStateOverrideiQCOM, (target, pname, param), (GLenum target, GLenum pname, GLint param))
#endif // GL_QCOM_extended_get
#ifdef GL_QCOM_extended_get2
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetProgramBinarySourceQCOM, (program, shadertype, source, length), (GLuint program, GLenum shadertype, GLchar *source, GLint *length))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetProgramsQCOM, (programs, maxPrograms, numPrograms), (GLuint *programs, GLint maxPrograms, GLint *numPrograms))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glExtGetShadersQCOM, (shaders, maxShaders, numShaders), (GLuint *shaders, GLint maxShaders, GLint *numShaders))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glExtIsProgramBinaryQCOM, (program), (GLuint program))
#endif // GL_QCOM_extended_get2
#ifdef GL_QCOM_tiled_rendering
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndTilingQCOM, (preserveMask), (GLbitfield preserveMask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStartTilingQCOM, (x, y, width, height, preserveMask), (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask))
#endif // GL_QCOM_tiled_rendering
#endif // __gl2ext_h_

#ifdef __gl32_h_
#ifdef GL_ES_VERSION_2_0
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glActiveTexture, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glAttachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindAttribLocation, (program, index, name), (GLuint program, GLuint index, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindBuffer, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindFramebuffer, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindRenderbuffer, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindTexture, (target, texture), (GLenum target, GLuint texture))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquation, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationSeparate, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFunc, (sfactor, dfactor), (GLenum sfactor, GLenum dfactor))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFuncSeparate, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBufferData, (target, size, data, usage), (GLenum target, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glCheckFramebufferStatus, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClear, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearDepthf, (d), (GLfloat d))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearStencil, (s), (GLint s))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glColorMask, (red, green, blue, alpha), (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompileShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexImage2D, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyTexImage2D, (target, level, internalformat, x, y, width, height, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyTexSubImage2D, (target, level, xoffset, yoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glCreateProgram, (), ())
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glCreateShader, (type), (GLenum type))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCullFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteBuffers, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteFramebuffers, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteRenderbuffers, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteTextures, (n, textures), (GLsizei n, const GLuint *textures))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthFunc, (func), (GLenum func))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthMask, (flag), (GLboolean flag))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDepthRangef, (n, f), (GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDetachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArrays, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElements, (mode, count, type, indices), (GLenum mode, GLsizei count, GLenum type, const void *indices))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFinish, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFlush, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferRenderbuffer, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture2D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFrontFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenTextures, (n, textures), (GLsizei n, GLuint *textures))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenerateMipmap, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetActiveAttrib, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetActiveUniform, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetAttachedShaders, (program, maxCount, count, shaders), (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetAttribLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBooleanv, (pname, data), (GLenum pname, GLboolean *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glGetError, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFloatv, (pname, data), (GLenum pname, GLfloat *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFramebufferAttachmentParameteriv, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetIntegerv, (pname, data), (GLenum pname, GLint *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramInfoLog, (program, bufSize, length, infoLog), (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramiv, (program, pname, params), (GLuint program, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetRenderbufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetShaderInfoLog, (shader, bufSize, length, infoLog), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetShaderPrecisionFormat, (shadertype, precisiontype, range, precision), (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetShaderSource, (shader, bufSize, length, source), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetShaderiv, (shader, pname, params), (GLuint shader, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , const GLubyte *, GL_APIENTRY, glGetString, (name), (GLenum name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetUniformLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetUniformfv, (program, location, params), (GLuint program, GLint location, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetUniformiv, (program, location, params), (GLuint program, GLint location, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetVertexAttribPointerv, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetVertexAttribfv, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetVertexAttribiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glHint, (target, mode), (GLenum target, GLenum mode))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsBuffer, (buffer), (GLuint buffer))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsEnabled, (cap), (GLenum cap))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsFramebuffer, (framebuffer), (GLuint framebuffer))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsProgram, (program), (GLuint program))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsRenderbuffer, (renderbuffer), (GLuint renderbuffer))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsShader, (shader), (GLuint shader))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsTexture, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glLineWidth, (width), (GLfloat width))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glLinkProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPixelStorei, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPolygonOffset, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadPixels, (x, y, width, height, format, type, pixels), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReleaseShaderCompiler, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorage, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSampleCoverage, (value, invert), (GLfloat value, GLboolean invert))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glScissor, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glShaderBinary, (count, shaders, binaryformat, binary, length), (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glShaderSource, (shader, count, string, length), (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilFunc, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilFuncSeparate, (face, func, ref, mask), (GLenum face, GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilMask, (mask), (GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilMaskSeparate, (face, mask), (GLenum face, GLuint mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilOp, (fail, zfail, zpass), (GLenum fail, GLenum zfail, GLenum zpass))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glStencilOpSeparate, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexImage2D, (target, level, internalformat, width, height, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterf, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1f, (location, v0), (GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1i, (location, v0), (GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2f, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2i, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3f, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3i, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4f, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4i, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUseProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glValidateProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib1f, (index, x), (GLuint index, GLfloat x))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib1fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib2f, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib2fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib3f, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib3fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib4f, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttrib4fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribPointer, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glViewport, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
#endif // GL_ES_VERSION_2_0
#ifdef GL_ES_VERSION_3_0
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginQuery, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBeginTransformFeedback, (primitiveMode), (GLenum primitiveMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindBufferBase, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindBufferRange, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindSampler, (unit, sampler), (GLuint unit, GLuint sampler))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindTransformFeedback, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlitFramebuffer, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearBufferfi, (buffer, drawbuffer, depth, stencil), (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearBufferfv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearBufferiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glClearBufferuiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glClientWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexImage3D, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCompressedTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyBufferSubData, (readTarget, writeTarget, readOffset, writeOffset, size), (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteQueries, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteSamplers, (count, samplers), (GLsizei count, const GLuint *samplers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteSync, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteTransformFeedbacks, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteVertexArrays, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysInstanced, (mode, first, count, instancecount), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawBuffers, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstanced, (mode, count, type, indices, instancecount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawRangeElements, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndQuery, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEndTransformFeedback, (), ())
GLATTER_FBLOCK(return, GL, GL_APICALL , GLsync, GL_APIENTRY, glFenceSync, (condition, flags), (GLenum condition, GLbitfield flags))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFlushMappedBufferRange, (target, offset, length), (GLenum target, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTextureLayer, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenQueries, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenSamplers, (count, samplers), (GLsizei count, GLuint *samplers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetActiveUniformBlockName, (program, uniformBlockIndex, bufSize, length, uniformBlockName), (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetActiveUniformBlockiv, (program, uniformBlockIndex, pname, params), (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetActiveUniformsiv, (program, uniformCount, uniformIndices, pname, params), (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBufferParameteri64v, (target, pname, params), (GLenum target, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBufferPointerv, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetFragDataLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetInteger64i_v, (target, index, data), (GLenum target, GLuint index, GLint64 *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetInteger64v, (pname, data), (GLenum pname, GLint64 *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetIntegeri_v, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetInternalformativ, (target, internalformat, pname, bufSize, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramBinary, (program, bufSize, length, binaryFormat, binary), (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryObjectuiv, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetQueryiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterfv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameteriv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , const GLubyte *, GL_APIENTRY, glGetStringi, (name, index), (GLenum name, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSynciv, (sync, pname, bufSize, length, values), (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTransformFeedbackVarying, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glGetUniformBlockIndex, (program, uniformBlockName), (GLuint program, const GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetUniformIndices, (program, uniformCount, uniformNames, uniformIndices), (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetUniformuiv, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetVertexAttribIiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetVertexAttribIuiv, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glInvalidateFramebuffer, (target, numAttachments, attachments), (GLenum target, GLsizei numAttachments, const GLenum *attachments))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glInvalidateSubFramebuffer, (target, numAttachments, attachments, x, y, width, height), (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsQuery, (id), (GLuint id))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsSampler, (sampler), (GLuint sampler))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsSync, (sync), (GLsync sync))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsTransformFeedback, (id), (GLuint id))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(return, GL, GL_APICALL , void *, GL_APIENTRY, glMapBufferRange, (target, offset, length, access), (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPauseTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramBinary, (program, binaryFormat, binary, length), (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramParameteri, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadBuffer, (src), (GLenum src))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glRenderbufferStorageMultisample, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glResumeTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterf, (sampler, pname, param), (GLuint sampler, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterfv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameteri, (sampler, pname, param), (GLuint sampler, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameteriv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage2D, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage3D, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTransformFeedbackVaryings, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1ui, (location, v0), (GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform1uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2ui, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform2uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3ui, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform3uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4ui, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniform4uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformBlockBinding, (program, uniformBlockIndex, uniformBlockBinding), (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix2x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix2x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix3x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix3x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix4x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUniformMatrix4x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glUnmapBuffer, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribDivisor, (index, divisor), (GLuint index, GLuint divisor))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribI4i, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribI4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribI4ui, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribI4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribIPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
#endif // GL_ES_VERSION_3_0
#ifdef GL_ES_VERSION_3_1
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glActiveShaderProgram, (pipeline, program), (GLuint pipeline, GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindImageTexture, (unit, texture, level, layered, layer, access, format), (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBindVertexBuffer, (bindingindex, buffer, offset, stride), (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glCreateShaderProgramv, (type, count, strings), (GLenum type, GLsizei count, const GLchar *const*strings))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDeleteProgramPipelines, (n, pipelines), (GLsizei n, const GLuint *pipelines))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDispatchCompute, (num_groups_x, num_groups_y, num_groups_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDispatchComputeIndirect, (indirect), (GLintptr indirect))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawArraysIndirect, (mode, indirect), (GLenum mode, const void *indirect))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsIndirect, (mode, type, indirect), (GLenum mode, GLenum type, const void *indirect))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGenProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetBooleani_v, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetFramebufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetMultisamplefv, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramInterfaceiv, (program, programInterface, pname, params), (GLuint program, GLenum programInterface, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramPipelineInfoLog, (pipeline, bufSize, length, infoLog), (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramPipelineiv, (pipeline, pname, params), (GLuint pipeline, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glGetProgramResourceIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLint, GL_APIENTRY, glGetProgramResourceLocation, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramResourceName, (program, programInterface, index, bufSize, length, name), (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetProgramResourceiv, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexLevelParameterfv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexLevelParameteriv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMemoryBarrier, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMemoryBarrierByRegion, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1f, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1i, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1ui, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform1uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2f, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2i, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2ui, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform2uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3f, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3i, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3ui, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform3uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4f, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4i, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4ui, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniform4uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix2x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix3x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glProgramUniformMatrix4x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSampleMaski, (maskNumber, mask), (GLuint maskNumber, GLbitfield mask))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glUseProgramStages, (pipeline, stages, program), (GLuint pipeline, GLbitfield stages, GLuint program))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glValidateProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribBinding, (attribindex, bindingindex), (GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribFormat, (attribindex, size, type, normalized, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexAttribIFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glVertexBindingDivisor, (bindingindex, divisor), (GLuint bindingindex, GLuint divisor))
#endif // GL_ES_VERSION_3_1
#ifdef GL_ES_VERSION_3_2
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendBarrier, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationSeparatei, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendEquationi, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFuncSeparatei, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glBlendFunci, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glColorMaski, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glCopyImageSubData, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageCallback, (callback, userParam), (GLDEBUGPROC callback, const void *userParam))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageControl, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDebugMessageInsert, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDisablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsBaseVertex, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawElementsInstancedBaseVertex, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glDrawRangeElementsBaseVertex, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glEnablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glFramebufferTexture, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLuint, GL_APIENTRY, glGetDebugMessageLog, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLenum, GL_APIENTRY, glGetGraphicsResetStatus, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetObjectLabel, (identifier, name, bufSize, length, label), (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetObjectPtrLabel, (ptr, bufSize, length, label), (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetPointerv, (pname, params), (GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetSamplerParameterIuiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformfv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glGetnUniformuiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(return, GL, GL_APICALL , GLboolean, GL_APIENTRY, glIsEnabledi, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glMinSampleShading, (value), (GLfloat value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glObjectLabel, (identifier, name, length, label), (GLenum identifier, GLuint name, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glObjectPtrLabel, (ptr, length, label), (const void *ptr, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPatchParameteri, (pname, value), (GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPopDebugGroup, (), ())
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPrimitiveBoundingBox, (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glPushDebugGroup, (source, id, length, message), (GLenum source, GLuint id, GLsizei length, const GLchar *message))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glReadnPixels, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glSamplerParameterIuiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBuffer, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexBufferRange, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GL_APICALL , void, GL_APIENTRY, glTexStorage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
#endif // GL_ES_VERSION_3_2
#endif // __gl32_h_

#ifdef __gl_h_
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glAccum, (op, value), (GLenum op, GLfloat value))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glAlphaFunc, (func, ref), (GLenum func, GLclampf ref))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLboolean, APIENTRY, glAreTexturesResident, (n, textures, residences), (GLsizei n, const GLuint *textures, GLboolean *residences))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glArrayElement, (i), (GLint i))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glBegin, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glBindTexture, (target, texture), (GLenum target, GLuint texture))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glBitmap, (width, height, xorig, yorig, xmove, ymove, bitmap), (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glBlendFunc, (sfactor, dfactor), (GLenum sfactor, GLenum dfactor))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCallList, (list), (GLuint list))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCallLists, (n, type, lists), (GLsizei n, GLenum type, const GLvoid *lists))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClear, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClearAccum, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClearColor, (red, green, blue, alpha), (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClearDepth, (depth), (GLclampd depth))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClearIndex, (c), (GLfloat c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClearStencil, (s), (GLint s))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glClipPlane, (plane, equation), (GLenum plane, const GLdouble *equation))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3b, (red, green, blue), (GLbyte red, GLbyte green, GLbyte blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3bv, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3d, (red, green, blue), (GLdouble red, GLdouble green, GLdouble blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3f, (red, green, blue), (GLfloat red, GLfloat green, GLfloat blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3i, (red, green, blue), (GLint red, GLint green, GLint blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3s, (red, green, blue), (GLshort red, GLshort green, GLshort blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3ub, (red, green, blue), (GLubyte red, GLubyte green, GLubyte blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3ubv, (v), (const GLubyte *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3ui, (red, green, blue), (GLuint red, GLuint green, GLuint blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3uiv, (v), (const GLuint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3us, (red, green, blue), (GLushort red, GLushort green, GLushort blue))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor3usv, (v), (const GLushort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4b, (red, green, blue, alpha), (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4bv, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4d, (red, green, blue, alpha), (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4f, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4i, (red, green, blue, alpha), (GLint red, GLint green, GLint blue, GLint alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4s, (red, green, blue, alpha), (GLshort red, GLshort green, GLshort blue, GLshort alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4ub, (red, green, blue, alpha), (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4ubv, (v), (const GLubyte *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4ui, (red, green, blue, alpha), (GLuint red, GLuint green, GLuint blue, GLuint alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4uiv, (v), (const GLuint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4us, (red, green, blue, alpha), (GLushort red, GLushort green, GLushort blue, GLushort alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColor4usv, (v), (const GLushort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColorMask, (red, green, blue, alpha), (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColorMaterial, (face, mode), (GLenum face, GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glColorPointer, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCopyPixels, (x, y, width, height, type), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCopyTexImage1D, (target, level, internalFormat, x, y, width, border), (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCopyTexImage2D, (target, level, internalFormat, x, y, width, height, border), (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCopyTexSubImage1D, (target, level, xoffset, x, y, width), (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCopyTexSubImage2D, (target, level, xoffset, yoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glCullFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDeleteLists, (list, range), (GLuint list, GLsizei range))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDeleteTextures, (n, textures), (GLsizei n, const GLuint *textures))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDepthFunc, (func), (GLenum func))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDepthMask, (flag), (GLboolean flag))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDepthRange, (zNear, zFar), (GLclampd zNear, GLclampd zFar))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDisable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDisableClientState, (array), (GLenum array))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDrawArrays, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDrawBuffer, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDrawElements, (mode, count, type, indices), (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glDrawPixels, (width, height, format, type, pixels), (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEdgeFlag, (flag), (GLboolean flag))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEdgeFlagPointer, (stride, pointer), (GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEdgeFlagv, (flag), (const GLboolean *flag))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEnable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEnableClientState, (array), (GLenum array))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEnd, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEndList, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord1d, (u), (GLdouble u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord1dv, (u), (const GLdouble *u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord1f, (u), (GLfloat u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord1fv, (u), (const GLfloat *u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord2d, (u, v), (GLdouble u, GLdouble v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord2dv, (u), (const GLdouble *u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord2f, (u, v), (GLfloat u, GLfloat v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalCoord2fv, (u), (const GLfloat *u))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalMesh1, (mode, i1, i2), (GLenum mode, GLint i1, GLint i2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalMesh2, (mode, i1, i2, j1, j2), (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalPoint1, (i), (GLint i))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glEvalPoint2, (i, j), (GLint i, GLint j))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFeedbackBuffer, (size, type, buffer), (GLsizei size, GLenum type, GLfloat *buffer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFinish, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFlush, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFogf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFogfv, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFogi, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFogiv, (pname, params), (GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFrontFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glFrustum, (left, right, bottom, top, zNear, zFar), (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLuint, APIENTRY, glGenLists, (range), (GLsizei range))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGenTextures, (n, textures), (GLsizei n, GLuint *textures))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetBooleanv, (pname, params), (GLenum pname, GLboolean *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetClipPlane, (plane, equation), (GLenum plane, GLdouble *equation))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetDoublev, (pname, params), (GLenum pname, GLdouble *params))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLenum, APIENTRY, glGetError, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetFloatv, (pname, params), (GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetIntegerv, (pname, params), (GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetLightfv, (light, pname, params), (GLenum light, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetLightiv, (light, pname, params), (GLenum light, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetMapdv, (target, query, v), (GLenum target, GLenum query, GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetMapfv, (target, query, v), (GLenum target, GLenum query, GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetMapiv, (target, query, v), (GLenum target, GLenum query, GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetMaterialfv, (face, pname, params), (GLenum face, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetMaterialiv, (face, pname, params), (GLenum face, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetPixelMapfv, (map, values), (GLenum map, GLfloat *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetPixelMapuiv, (map, values), (GLenum map, GLuint *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetPixelMapusv, (map, values), (GLenum map, GLushort *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetPointerv, (pname, params), (GLenum pname, GLvoid* *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetPolygonStipple, (mask), (GLubyte *mask))
GLATTER_FBLOCK(return, GL, WINGDIAPI , const GLubyte *, APIENTRY, glGetString, (name), (GLenum name))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexEnvfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexEnviv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexGendv, (coord, pname, params), (GLenum coord, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexGenfv, (coord, pname, params), (GLenum coord, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexGeniv, (coord, pname, params), (GLenum coord, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexImage, (target, level, format, type, pixels), (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexLevelParameterfv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexLevelParameteriv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glGetTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glHint, (target, mode), (GLenum target, GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexMask, (mask), (GLuint mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexPointer, (type, stride, pointer), (GLenum type, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexd, (c), (GLdouble c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexdv, (c), (const GLdouble *c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexf, (c), (GLfloat c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexfv, (c), (const GLfloat *c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexi, (c), (GLint c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexiv, (c), (const GLint *c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexs, (c), (GLshort c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexsv, (c), (const GLshort *c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexub, (c), (GLubyte c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glIndexubv, (c), (const GLubyte *c))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glInitNames, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glInterleavedArrays, (format, stride, pointer), (GLenum format, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLboolean, APIENTRY, glIsEnabled, (cap), (GLenum cap))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLboolean, APIENTRY, glIsList, (list), (GLuint list))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLboolean, APIENTRY, glIsTexture, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightModelf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightModelfv, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightModeli, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightModeliv, (pname, params), (GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightf, (light, pname, param), (GLenum light, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightfv, (light, pname, params), (GLenum light, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLighti, (light, pname, param), (GLenum light, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLightiv, (light, pname, params), (GLenum light, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLineStipple, (factor, pattern), (GLint factor, GLushort pattern))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLineWidth, (width), (GLfloat width))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glListBase, (base), (GLuint base))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLoadIdentity, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLoadMatrixd, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLoadMatrixf, (m), (const GLfloat *m))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLoadName, (name), (GLuint name))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glLogicOp, (opcode), (GLenum opcode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMap1d, (target, u1, u2, stride, order, points), (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMap1f, (target, u1, u2, stride, order, points), (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMap2d, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMap2f, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMapGrid1d, (un, u1, u2), (GLint un, GLdouble u1, GLdouble u2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMapGrid1f, (un, u1, u2), (GLint un, GLfloat u1, GLfloat u2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMapGrid2d, (un, u1, u2, vn, v1, v2), (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMapGrid2f, (un, u1, u2, vn, v1, v2), (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMaterialf, (face, pname, param), (GLenum face, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMaterialfv, (face, pname, params), (GLenum face, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMateriali, (face, pname, param), (GLenum face, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMaterialiv, (face, pname, params), (GLenum face, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMatrixMode, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMultMatrixd, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glMultMatrixf, (m), (const GLfloat *m))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNewList, (list, mode), (GLuint list, GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3b, (nx, ny, nz), (GLbyte nx, GLbyte ny, GLbyte nz))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3bv, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3d, (nx, ny, nz), (GLdouble nx, GLdouble ny, GLdouble nz))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3f, (nx, ny, nz), (GLfloat nx, GLfloat ny, GLfloat nz))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3i, (nx, ny, nz), (GLint nx, GLint ny, GLint nz))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3s, (nx, ny, nz), (GLshort nx, GLshort ny, GLshort nz))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormal3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glNormalPointer, (type, stride, pointer), (GLenum type, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glOrtho, (left, right, bottom, top, zNear, zFar), (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPassThrough, (token), (GLfloat token))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelMapfv, (map, mapsize, values), (GLenum map, GLsizei mapsize, const GLfloat *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelMapuiv, (map, mapsize, values), (GLenum map, GLsizei mapsize, const GLuint *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelMapusv, (map, mapsize, values), (GLenum map, GLsizei mapsize, const GLushort *values))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelStoref, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelStorei, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelTransferf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelTransferi, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPixelZoom, (xfactor, yfactor), (GLfloat xfactor, GLfloat yfactor))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPointSize, (size), (GLfloat size))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPolygonMode, (face, mode), (GLenum face, GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPolygonOffset, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPolygonStipple, (mask), (const GLubyte *mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPopAttrib, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPopClientAttrib, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPopMatrix, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPopName, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPrioritizeTextures, (n, textures, priorities), (GLsizei n, const GLuint *textures, const GLclampf *priorities))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPushAttrib, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPushClientAttrib, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPushMatrix, (), ())
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glPushName, (name), (GLuint name))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2d, (x, y), (GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2f, (x, y), (GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2i, (x, y), (GLint x, GLint y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2s, (x, y), (GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos2sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3d, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3f, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3i, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3s, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4d, (x, y, z, w), (GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4f, (x, y, z, w), (GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4i, (x, y, z, w), (GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4s, (x, y, z, w), (GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRasterPos4sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glReadBuffer, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glReadPixels, (x, y, width, height, format, type, pixels), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectd, (x1, y1, x2, y2), (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectdv, (v1, v2), (const GLdouble *v1, const GLdouble *v2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectf, (x1, y1, x2, y2), (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectfv, (v1, v2), (const GLfloat *v1, const GLfloat *v2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRecti, (x1, y1, x2, y2), (GLint x1, GLint y1, GLint x2, GLint y2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectiv, (v1, v2), (const GLint *v1, const GLint *v2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRects, (x1, y1, x2, y2), (GLshort x1, GLshort y1, GLshort x2, GLshort y2))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRectsv, (v1, v2), (const GLshort *v1, const GLshort *v2))
GLATTER_FBLOCK(return, GL, WINGDIAPI , GLint, APIENTRY, glRenderMode, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRotated, (angle, x, y, z), (GLdouble angle, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glRotatef, (angle, x, y, z), (GLfloat angle, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glScaled, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glScalef, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glScissor, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glSelectBuffer, (size, buffer), (GLsizei size, GLuint *buffer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glShadeModel, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glStencilFunc, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glStencilMask, (mask), (GLuint mask))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glStencilOp, (fail, zfail, zpass), (GLenum fail, GLenum zfail, GLenum zpass))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1d, (s), (GLdouble s))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1f, (s), (GLfloat s))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1i, (s), (GLint s))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1s, (s), (GLshort s))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord1sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2d, (s, t), (GLdouble s, GLdouble t))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2f, (s, t), (GLfloat s, GLfloat t))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2i, (s, t), (GLint s, GLint t))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2s, (s, t), (GLshort s, GLshort t))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord2sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3d, (s, t, r), (GLdouble s, GLdouble t, GLdouble r))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3f, (s, t, r), (GLfloat s, GLfloat t, GLfloat r))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3i, (s, t, r), (GLint s, GLint t, GLint r))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3s, (s, t, r), (GLshort s, GLshort t, GLshort r))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4d, (s, t, r, q), (GLdouble s, GLdouble t, GLdouble r, GLdouble q))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4f, (s, t, r, q), (GLfloat s, GLfloat t, GLfloat r, GLfloat q))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4i, (s, t, r, q), (GLint s, GLint t, GLint r, GLint q))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4s, (s, t, r, q), (GLshort s, GLshort t, GLshort r, GLshort q))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoord4sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexCoordPointer, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexEnvf, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexEnvfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexEnvi, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexEnviv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGend, (coord, pname, param), (GLenum coord, GLenum pname, GLdouble param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGendv, (coord, pname, params), (GLenum coord, GLenum pname, const GLdouble *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGenf, (coord, pname, param), (GLenum coord, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGenfv, (coord, pname, params), (GLenum coord, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGeni, (coord, pname, param), (GLenum coord, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexGeniv, (coord, pname, params), (GLenum coord, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexImage1D, (target, level, internalformat, width, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexImage2D, (target, level, internalformat, width, height, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexParameterf, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexSubImage1D, (target, level, xoffset, width, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTranslated, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glTranslatef, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2d, (x, y), (GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2f, (x, y), (GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2i, (x, y), (GLint x, GLint y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2s, (x, y), (GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex2sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3d, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3f, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3i, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3s, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4d, (x, y, z, w), (GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4f, (x, y, z, w), (GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4i, (x, y, z, w), (GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4s, (x, y, z, w), (GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertex4sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glVertexPointer, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer))
GLATTER_FBLOCK(, GL, WINGDIAPI , void, APIENTRY, glViewport, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
#endif // __gl_h_

#ifdef __glcorearb_h_
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glClientWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteSync, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsBaseVertex, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseVertex, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElementsBaseVertex, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(return, GL, GLAPI , GLsync, APIENTRY, glFenceSync, (condition, flags), (GLenum condition, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameteri64v, (target, pname, params), (GLenum target, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInteger64i_v, (target, index, data), (GLenum target, GLuint index, GLint64 *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInteger64v, (pname, data), (GLenum pname, GLint64 *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultisamplefv, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSynciv, (sync, pname, bufSize, length, values), (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsSync, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsBaseVertex, (mode, count, type, indices, drawcount, basevertex), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProvokingVertex, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMaski, (maskNumber, mask), (GLuint maskNumber, GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
#ifdef GL_AMD_performance_monitor
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenPerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterDataAMD, (monitor, pname, dataSize, data, bytesWritten), (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterInfoAMD, (group, counter, pname, data), (GLuint group, GLuint counter, GLenum pname, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterStringAMD, (group, counter, bufSize, length, counterString), (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCountersAMD, (group, numCounters, maxActiveCounters, counterSize, counters), (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorGroupStringAMD, (group, bufSize, length, groupString), (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorGroupsAMD, (numGroups, groupsSize, groups), (GLint *numGroups, GLsizei groupsSize, GLuint *groups))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSelectPerfMonitorCountersAMD, (monitor, enable, group, numCounters, counterList), (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList))
#endif // GL_AMD_performance_monitor
#ifdef GL_ARB_bindless_texture
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetImageHandleARB, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureHandleARB, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureSamplerHandleARB, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLui64vARB, (index, pname, params), (GLuint index, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsImageHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleResidentARB, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64ARB, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64vARB, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64ARB, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64ARB, (index, x), (GLuint index, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64vARB, (index, v), (GLuint index, const GLuint64EXT *v))
#endif // GL_ARB_bindless_texture
#ifdef GL_ARB_cl_event
GLATTER_FBLOCK(return, GL, GLAPI , GLsync, APIENTRY, glCreateSyncFromCLeventARB, (context, event, flags), (struct _cl_context *context, struct _cl_event *event, GLbitfield flags))
#endif // GL_ARB_cl_event
#ifdef GL_ARB_compute_variable_group_size
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchComputeGroupSizeARB, (num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z))
#endif // GL_ARB_compute_variable_group_size
#ifdef GL_ARB_debug_output
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageCallbackARB, (callback, userParam), (GLDEBUGPROCARB callback, const void *userParam))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageControlARB, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageInsertARB, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetDebugMessageLogARB, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
#endif // GL_ARB_debug_output
#ifdef GL_ARB_draw_buffers_blend
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparateiARB, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationiARB, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparateiARB, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFunciARB, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
#endif // GL_ARB_draw_buffers_blend
#ifdef GL_ARB_indirect_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirectCountARB, (mode, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirectCountARB, (mode, type, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
#endif // GL_ARB_indirect_parameters
#ifdef GL_ARB_robustness
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glGetGraphicsResetStatusARB, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnCompressedTexImageARB, (target, lod, bufSize, img), (GLenum target, GLint lod, GLsizei bufSize, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnTexImageARB, (target, level, format, type, bufSize, img), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformdvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformfvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformuivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadnPixelsARB, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
#endif // GL_ARB_robustness
#ifdef GL_ARB_sample_shading
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinSampleShadingARB, (value), (GLfloat value))
#endif // GL_ARB_sample_shading
#ifdef GL_ARB_shading_language_include
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileShaderIncludeARB, (shader, count, path, length), (GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedStringARB, (namelen, name, bufSize, stringlen, string), (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedStringivARB, (namelen, name, pname, params), (GLint namelen, const GLchar *name, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedStringARB, (type, namelen, name, stringlen, string), (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string))
#endif // GL_ARB_shading_language_include
#ifdef GL_ARB_sparse_buffer
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferPageCommitmentARB, (target, offset, size, commit), (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferPageCommitmentARB, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferPageCommitmentEXT, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
#endif // GL_ARB_sparse_buffer
#ifdef GL_ARB_sparse_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexPageCommitmentARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
#endif // GL_ARB_sparse_texture
#ifdef GL_EXT_debug_label
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectLabelEXT, (type, object, bufSize, length, label), (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLabelObjectEXT, (type, object, length, label), (GLenum type, GLuint object, GLsizei length, const GLchar *label))
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInsertEventMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPopGroupMarkerEXT, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPushGroupMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_draw_instanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstancedEXT, (mode, start, count, primcount), (GLenum mode, GLint start, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedEXT, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_polygon_offset_clamp
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonOffsetClampEXT, (factor, units, clamp), (GLfloat factor, GLfloat units, GLfloat clamp))
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_raster_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterSamplesEXT, (samples, fixedsamplelocations), (GLuint samples, GLboolean fixedsamplelocations))
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_separate_shader_objects
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveProgramEXT, (program), (GLuint program))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShaderProgramEXT, (type, string), (GLenum type, const GLchar *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseShaderProgramEXT, (type, program), (GLenum type, GLuint program))
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_window_rectangles
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowRectanglesEXT, (mode, count, box), (GLenum mode, GLsizei count, const GLint *box))
#endif // GL_EXT_window_rectangles
#ifdef GL_INTEL_framebuffer_CMAA
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glApplyFramebufferAttachmentCMAAINTEL, (), ())
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_performance_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreatePerfQueryINTEL, (queryId, queryHandle), (GLuint queryId, GLuint *queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFirstPerfQueryIdINTEL, (queryId), (GLuint *queryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNextPerfQueryIdINTEL, (queryId, nextQueryId), (GLuint queryId, GLuint *nextQueryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfCounterInfoINTEL, (queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue), (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryDataINTEL, (queryHandle, flags, dataSize, data, bytesWritten), (GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryIdByNameINTEL, (queryName, queryId), (GLchar *queryName, GLuint *queryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryInfoINTEL, (queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask), (GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask))
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendBarrierKHR, (), ())
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_NV_bindless_texture
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetImageHandleNV, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureHandleNV, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureSamplerHandleNV, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsImageHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleResidentNV, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64NV, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64vNV, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64NV, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendBarrierNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendParameteriNV, (pname, value), (GLenum pname, GLint value))
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_conditional_render
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginConditionalRenderNV, (id, mode), (GLuint id, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndConditionalRenderNV, (), ())
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSubpixelPrecisionBiasNV, (xbits, ybits), (GLuint xbits, GLuint ybits))
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_pre_snap_triangles
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConservativeRasterParameteriNV, (pname, param), (GLenum pname, GLint param))
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_fragment_coverage_to_color
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentCoverageColorNV, (color), (GLuint color))
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_framebuffer_mixed_samples
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverageModulationNV, (components), (GLenum components))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverageModulationTableNV, (n, v), (GLsizei n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCoverageModulationTableNV, (bufsize, v), (GLsizei bufsize, GLfloat *v))
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_gpu_shader5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformi64vNV, (program, location, params), (GLuint program, GLint location, GLint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64NV, (program, location, x), (GLuint program, GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64NV, (program, location, x), (GLuint program, GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64NV, (program, location, x, y), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64NV, (program, location, x, y), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64NV, (program, location, x, y, z), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64NV, (program, location, x, y, z), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64NV, (location, x), (GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64NV, (location, x), (GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64NV, (location, x, y), (GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64NV, (location, x, y), (GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64NV, (location, x, y, z), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64NV, (location, x, y, z), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64NV, (location, x, y, z, w), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64NV, (location, x, y, z, w), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
#endif // GL_NV_gpu_shader5
#ifdef GL_NV_internalformat_sample_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformatSampleivNV, (target, internalformat, samples, pname, bufSize, params), (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params))
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_path_rendering
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyPathNV, (resultPath, srcPath), (GLuint resultPath, GLuint srcPath))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverFillPathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverStrokePathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePathsNV, (path, range), (GLuint path, GLsizei range))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenPathsNV, (range), (GLsizei range))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathCommandsNV, (path, commands), (GLuint path, GLubyte *commands))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathCoordsNV, (path, coords), (GLuint path, GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathDashArrayNV, (path, dashArray), (GLuint path, GLfloat *dashArray))
GLATTER_FBLOCK(return, GL, GLAPI , GLfloat, APIENTRY, glGetPathLengthNV, (path, startSegment, numSegments), (GLuint path, GLsizei startSegment, GLsizei numSegments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathMetricRangeNV, (metricQueryMask, firstPathName, numPaths, stride, metrics), (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathMetricsNV, (metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics), (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathSpacingNV, (pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing), (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourcefvNV, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInterpolatePathsNV, (resultPath, pathA, pathB, weight), (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPathNV, (path), (GLuint path))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPointInFillPathNV, (path, mask, x, y), (GLuint path, GLuint mask, GLfloat x, GLfloat y))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPointInStrokePathNV, (path, x, y), (GLuint path, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoad3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoad3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMult3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMult3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCommandsNV, (path, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCoordsNV, (path, numCoords, coordType, coords), (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCoverDepthFuncNV, (func), (GLenum func))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathDashArrayNV, (path, dashCount, dashArray), (GLuint path, GLsizei dashCount, const GLfloat *dashArray))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathGlyphIndexArrayNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathGlyphIndexRangeNV, (fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount), (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathGlyphRangeNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathGlyphsNV, (firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathMemoryGlyphIndexArrayNV, (firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterfNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameteriNV, (path, pname, value), (GLuint path, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStencilDepthOffsetNV, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStencilFuncNV, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStringNV, (path, format, length, pathString), (GLuint path, GLenum format, GLsizei length, const void *pathString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathSubCommandsNV, (path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathSubCoordsNV, (path, coordStart, numCoords, coordType, coords), (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glPointAlongPathNV, (path, startSegment, numSegments, distance, x, y, tangentX, tangentY), (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramPathFragmentInputGenNV, (program, location, genMode, components, coeffs), (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFillPathNV, (path, fillMode, mask), (GLuint path, GLenum fillMode, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilStrokePathNV, (path, reference, mask), (GLuint path, GLint reference, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverFillPathNV, (path, fillMode, mask, coverMode), (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverStrokePathNV, (path, reference, mask, coverMode), (GLuint path, GLint reference, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformPathNV, (resultPath, srcPath, transformType, transformValues), (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightPathsNV, (resultPath, numPaths, paths, weights), (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights))
#endif // GL_NV_path_rendering
#ifdef GL_NV_sample_locations
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferSampleLocationsfvNV, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferSampleLocationsfvNV, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResolveDepthValuesNV, (), ())
#endif // GL_NV_sample_locations
#ifdef GL_NV_viewport_swizzle
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportSwizzleNV, (index, swizzlex, swizzley, swizzlez, swizzlew), (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew))
#endif // GL_NV_viewport_swizzle
#ifdef GL_OVR_multiview
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureMultiviewOVR, (target, attachment, texture, level, baseViewIndex, numViews), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews))
#endif // GL_OVR_multiview
#ifdef GL_VERSION_1_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFunc, (sfactor, dfactor), (GLenum sfactor, GLenum dfactor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClear, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepth, (depth), (GLdouble depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearStencil, (s), (GLint s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorMask, (red, green, blue, alpha), (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCullFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthFunc, (func), (GLenum func))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthMask, (flag), (GLboolean flag))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRange, (near, far), (GLdouble near, GLdouble far))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawBuffer, (buf), (GLenum buf))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnable, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinish, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlush, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFrontFace, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBooleanv, (pname, data), (GLenum pname, GLboolean *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDoublev, (pname, data), (GLenum pname, GLdouble *data))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glGetError, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFloatv, (pname, data), (GLenum pname, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegerv, (pname, data), (GLenum pname, GLint *data))
GLATTER_FBLOCK(return, GL, GLAPI , const GLubyte *, APIENTRY, glGetString, (name), (GLenum name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexImage, (target, level, format, type, pixels), (GLenum target, GLint level, GLenum format, GLenum type, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexLevelParameterfv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexLevelParameteriv, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glHint, (target, mode), (GLenum target, GLenum mode))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsEnabled, (cap), (GLenum cap))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLineWidth, (width), (GLfloat width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLogicOp, (opcode), (GLenum opcode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelStoref, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelStorei, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointSize, (size), (GLfloat size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonMode, (face, mode), (GLenum face, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadBuffer, (src), (GLenum src))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadPixels, (x, y, width, height, format, type, pixels), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissor, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFunc, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilMask, (mask), (GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilOp, (fail, zfail, zpass), (GLenum fail, GLenum zfail, GLenum zpass))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage1D, (target, level, internalformat, width, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage2D, (target, level, internalformat, width, height, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterf, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewport, (x, y, width, height), (GLint x, GLint y, GLsizei width, GLsizei height))
#endif // GL_VERSION_1_0
#ifdef GL_VERSION_1_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTexture, (target, texture), (GLenum target, GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexImage1D, (target, level, internalformat, x, y, width, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexImage2D, (target, level, internalformat, x, y, width, height, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage1D, (target, level, xoffset, x, y, width), (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage2D, (target, level, xoffset, yoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteTextures, (n, textures), (GLsizei n, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArrays, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElements, (mode, count, type, indices), (GLenum mode, GLsizei count, GLenum type, const void *indices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenTextures, (n, textures), (GLsizei n, GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPointerv, (pname, params), (GLenum pname, void **params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTexture, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonOffset, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage1D, (target, level, xoffset, width, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
#endif // GL_VERSION_1_1
#ifdef GL_VERSION_1_2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElements, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
#endif // GL_VERSION_1_2
#ifdef GL_VERSION_1_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveTexture, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage1D, (target, level, internalformat, width, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage2D, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage3D, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage1D, (target, level, xoffset, width, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTexImage, (target, level, img), (GLenum target, GLint level, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleCoverage, (value, invert), (GLfloat value, GLboolean invert))
#endif // GL_VERSION_1_3
#ifdef GL_VERSION_1_4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquation, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparate, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArrays, (mode, first, count, drawcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElements, (mode, count, type, indices, drawcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfv, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameteri, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameteriv, (pname, params), (GLenum pname, const GLint *params))
#endif // GL_VERSION_1_4
#ifdef GL_VERSION_1_5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginQuery, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffer, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferData, (target, size, data, usage), (GLenum target, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteBuffers, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteQueries, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndQuery, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenQueries, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferPointerv, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectiv, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectuiv, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsBuffer, (buffer), (GLuint buffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsQuery, (id), (GLuint id))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapBuffer, (target, access), (GLenum target, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapBuffer, (target), (GLenum target))
#endif // GL_VERSION_1_5
#ifdef GL_VERSION_2_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAttachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindAttribLocation, (program, index, name), (GLuint program, GLuint index, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparate, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileShader, (shader), (GLuint shader))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateProgram, (), ())
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShader, (type), (GLenum type))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDetachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawBuffers, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveAttrib, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniform, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetAttachedShaders, (program, maxCount, count, shaders), (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetAttribLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramInfoLog, (program, bufSize, length, infoLog), (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramiv, (program, pname, params), (GLuint program, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderInfoLog, (shader, bufSize, length, infoLog), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderSource, (shader, bufSize, length, source), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderiv, (shader, pname, params), (GLuint shader, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetUniformLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformfv, (program, location, params), (GLuint program, GLint location, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformiv, (program, location, params), (GLuint program, GLint location, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribPointerv, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribfv, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgram, (program), (GLuint program))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLinkProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderSource, (shader, count, string, length), (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFuncSeparate, (face, func, ref, mask), (GLenum face, GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilMaskSeparate, (face, mask), (GLenum face, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilOpSeparate, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1f, (location, v0), (GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i, (location, v0), (GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2f, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3f, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4f, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glValidateProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1d, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1f, (index, x), (GLuint index, GLfloat x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1s, (index, x), (GLuint index, GLshort x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2f, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2s, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3f, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3s, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nbv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Niv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nsv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nub, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nuiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nusv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4f, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4s, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribPointer, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
#endif // GL_VERSION_2_0
#ifdef GL_VERSION_2_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
#endif // GL_VERSION_2_1
#ifdef GL_VERSION_3_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginConditionalRender, (id, mode), (GLuint id, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginTransformFeedback, (primitiveMode), (GLenum primitiveMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferBase, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferRange, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragDataLocation, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFramebuffer, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindRenderbuffer, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlitFramebuffer, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckFramebufferStatus, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClampColor, (target, clamp), (GLenum target, GLenum clamp))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferfi, (buffer, drawbuffer, depth, stencil), (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferfv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferuiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorMaski, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFramebuffers, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteRenderbuffers, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteVertexArrays, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndConditionalRender, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedBufferRange, (target, offset, length), (GLenum target, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferRenderbuffer, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture1D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture2D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture3D, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureLayer, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateMipmap, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBooleani_v, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetFragDataLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferAttachmentParameteriv, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegeri_v, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetRenderbufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , const GLubyte *, APIENTRY, glGetStringi, (name, index), (GLenum name, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackVarying, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformuiv, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIuiv, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsEnabledi, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsFramebuffer, (framebuffer), (GLuint framebuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsRenderbuffer, (renderbuffer), (GLuint renderbuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapBufferRange, (target, offset, length, access), (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorage, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorageMultisample, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackVaryings, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui, (location, v0), (GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1i, (index, x), (GLuint index, GLint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1ui, (index, x), (GLuint index, GLuint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2i, (index, x, y), (GLuint index, GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2ui, (index, x, y), (GLuint index, GLuint x, GLuint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3i, (index, x, y, z), (GLuint index, GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3ui, (index, x, y, z), (GLuint index, GLuint x, GLuint y, GLuint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4i, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ui, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
#endif // GL_VERSION_3_0
#ifdef GL_VERSION_3_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyBufferSubData, (readTarget, writeTarget, readOffset, writeOffset, size), (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstanced, (mode, first, count, instancecount), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstanced, (mode, count, type, indices, instancecount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformBlockName, (program, uniformBlockIndex, bufSize, length, uniformBlockName), (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformBlockiv, (program, uniformBlockIndex, pname, params), (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformName, (program, uniformIndex, bufSize, length, uniformName), (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformsiv, (program, uniformCount, uniformIndices, pname, params), (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetUniformBlockIndex, (program, uniformBlockName), (GLuint program, const GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformIndices, (program, uniformCount, uniformNames, uniformIndices), (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrimitiveRestartIndex, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBuffer, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformBlockBinding, (program, uniformBlockIndex, uniformBlockBinding), (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding))
#endif // GL_VERSION_3_1
#ifdef GL_VERSION_3_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragDataLocationIndexed, (program, colorNumber, index, name), (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindSampler, (unit, sampler), (GLuint unit, GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteSamplers, (count, samplers), (GLsizei count, const GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenSamplers, (count, samplers), (GLsizei count, GLuint *samplers))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetFragDataIndex, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjecti64v, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectui64v, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterIiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterIuiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterfv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameteriv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsSampler, (sampler), (GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glQueryCounter, (id, target), (GLuint id, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterIiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterIuiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterf, (sampler, pname, param), (GLuint sampler, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterfv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameteri, (sampler, pname, param), (GLuint sampler, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameteriv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribDivisor, (index, divisor), (GLuint index, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP1ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP1uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP2ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP2uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP3ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP3uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP4ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP4uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
#endif // GL_VERSION_3_3
#ifdef GL_VERSION_4_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginQueryIndexed, (target, index, id), (GLenum target, GLuint index, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTransformFeedback, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparatei, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationi, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparatei, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFunci, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteTransformFeedbacks, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysIndirect, (mode, indirect), (GLenum mode, const void *indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsIndirect, (mode, type, indirect), (GLenum mode, GLenum type, const void *indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedback, (mode, id), (GLenum mode, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackStream, (mode, id, stream), (GLenum mode, GLuint id, GLuint stream))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndQueryIndexed, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineName, (program, shadertype, index, bufsize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineUniformName, (program, shadertype, index, bufsize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineUniformiv, (program, shadertype, index, pname, values), (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramStageiv, (program, shadertype, pname, values), (GLuint program, GLenum shadertype, GLenum pname, GLint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryIndexediv, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetSubroutineIndex, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetSubroutineUniformLocation, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformSubroutineuiv, (shadertype, location, params), (GLenum shadertype, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformdv, (program, location, params), (GLuint program, GLint location, GLdouble *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTransformFeedback, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinSampleShading, (value), (GLfloat value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPatchParameterfv, (pname, values), (GLenum pname, const GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPatchParameteri, (pname, value), (GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPauseTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResumeTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1d, (location, x), (GLint location, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2d, (location, x, y), (GLint location, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3d, (location, x, y, z), (GLint location, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4d, (location, x, y, z, w), (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformSubroutinesuiv, (shadertype, count, indices), (GLenum shadertype, GLsizei count, const GLuint *indices))
#endif // GL_VERSION_4_0
#ifdef GL_VERSION_4_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveShaderProgram, (pipeline, program), (GLuint pipeline, GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepthf, (d), (GLfloat d))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShaderProgramv, (type, count, strings), (GLenum type, GLsizei count, const GLchar *const*strings))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgramPipelines, (n, pipelines), (GLsizei n, const GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangeArrayv, (first, count, v), (GLuint first, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangeIndexed, (index, n, f), (GLuint index, GLdouble n, GLdouble f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangef, (n, f), (GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDoublei_v, (target, index, data), (GLenum target, GLuint index, GLdouble *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFloati_v, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramBinary, (program, bufSize, length, binaryFormat, binary), (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramPipelineInfoLog, (pipeline, bufSize, length, infoLog), (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramPipelineiv, (pipeline, pname, params), (GLuint pipeline, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderPrecisionFormat, (shadertype, precisiontype, range, precision), (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramBinary, (program, binaryFormat, binary, length), (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameteri, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1d, (program, location, v0), (GLuint program, GLint location, GLdouble v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1f, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2d, (program, location, v0, v1), (GLuint program, GLint location, GLdouble v0, GLdouble v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2f, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3d, (program, location, v0, v1, v2), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3f, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4d, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4f, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReleaseShaderCompiler, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorArrayv, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorIndexed, (index, left, bottom, width, height), (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorIndexedv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderBinary, (count, shaders, binaryformat, binary, length), (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseProgramStages, (pipeline, stages, program), (GLuint pipeline, GLbitfield stages, GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glValidateProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1d, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportArrayv, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportIndexedf, (index, x, y, w, h), (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportIndexedfv, (index, v), (GLuint index, const GLfloat *v))
#endif // GL_VERSION_4_1
#ifdef GL_VERSION_4_2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindImageTexture, (unit, texture, level, layered, layer, access, format), (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstancedBaseInstance, (mode, first, count, instancecount, baseinstance), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseInstance, (mode, count, type, indices, instancecount, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseVertexBaseInstance, (mode, count, type, indices, instancecount, basevertex, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackInstanced, (mode, id, instancecount), (GLenum mode, GLuint id, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackStreamInstanced, (mode, id, stream, instancecount), (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveAtomicCounterBufferiv, (program, bufferIndex, pname, params), (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformativ, (target, internalformat, pname, bufSize, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMemoryBarrier, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage1D, (target, levels, internalformat, width), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage2D, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage3D, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
#endif // GL_VERSION_4_2
#ifdef GL_VERSION_4_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexBuffer, (bindingindex, buffer, offset, stride), (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferData, (target, internalformat, format, type, data), (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferSubData, (target, internalformat, offset, size, format, type, data), (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyImageSubData, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageCallback, (callback, userParam), (GLDEBUGPROC callback, const void *userParam))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageControl, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageInsert, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchCompute, (num_groups_x, num_groups_y, num_groups_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchComputeIndirect, (indirect), (GLintptr indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetDebugMessageLog, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformati64v, (target, internalformat, pname, bufSize, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectLabel, (identifier, name, bufSize, length, label), (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectPtrLabel, (ptr, bufSize, length, label), (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramInterfaceiv, (program, programInterface, pname, params), (GLuint program, GLenum programInterface, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetProgramResourceIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetProgramResourceLocation, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetProgramResourceLocationIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourceName, (program, programInterface, index, bufSize, length, name), (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourceiv, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateBufferData, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateBufferSubData, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateFramebuffer, (target, numAttachments, attachments), (GLenum target, GLsizei numAttachments, const GLenum *attachments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateSubFramebuffer, (target, numAttachments, attachments, x, y, width, height), (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateTexImage, (texture, level), (GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirect, (mode, indirect, drawcount, stride), (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirect, (mode, type, indirect, drawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glObjectLabel, (identifier, name, length, label), (GLenum identifier, GLuint name, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glObjectPtrLabel, (ptr, length, label), (const void *ptr, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPopDebugGroup, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPushDebugGroup, (source, id, length, message), (GLenum source, GLuint id, GLsizei length, const GLchar *message))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderStorageBlockBinding, (program, storageBlockIndex, storageBlockBinding), (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBufferRange, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureView, (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribBinding, (attribindex, bindingindex), (GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribFormat, (attribindex, size, type, normalized, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexBindingDivisor, (bindingindex, divisor), (GLuint bindingindex, GLuint divisor))
#endif // GL_VERSION_4_3
#ifdef GL_VERSION_4_4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffersBase, (target, first, count, buffers), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffersRange, (target, first, count, buffers, offsets, sizes), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindImageTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindSamplers, (first, count, samplers), (GLuint first, GLsizei count, const GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexBuffers, (first, count, buffers, offsets, strides), (GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferStorage, (target, size, data, flags), (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearTexImage, (texture, level, format, type, data), (GLuint texture, GLint level, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data))
#endif // GL_VERSION_4_4
#ifdef GL_VERSION_4_5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTextureUnit, (unit, texture), (GLuint unit, GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlitNamedFramebuffer, (readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckNamedFramebufferStatus, (framebuffer, target), (GLuint framebuffer, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferData, (buffer, internalformat, format, type, data), (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferSubData, (buffer, internalformat, offset, size, format, type, data), (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferfi, (framebuffer, buffer, drawbuffer, depth, stencil), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferfv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferuiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClipControl, (origin, depth), (GLenum origin, GLenum depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage1D, (texture, level, xoffset, width, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyNamedBufferSubData, (readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage1D, (texture, level, xoffset, x, y, width), (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage2D, (texture, level, xoffset, yoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateQueries, (target, n, ids), (GLenum target, GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateSamplers, (n, samplers), (GLsizei n, GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateTextures, (target, n, textures), (GLenum target, GLsizei n, GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedNamedBufferRange, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateTextureMipmap, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTextureImage, (texture, level, bufSize, pixels), (GLuint texture, GLint level, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glGetGraphicsResetStatus, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameteri64v, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameteriv, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferPointerv, (buffer, pname, params), (GLuint buffer, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferAttachmentParameteriv, (framebuffer, attachment, pname, params), (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferParameteriv, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedRenderbufferParameteriv, (renderbuffer, pname, params), (GLuint renderbuffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjecti64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectui64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectuiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureImage, (texture, level, format, type, bufSize, pixels), (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameterfv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameteriv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterfv, (texture, pname, params), (GLuint texture, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameteriv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbacki64_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint64 *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbacki_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackiv, (xfb, pname, param), (GLuint xfb, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIndexed64iv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint64 *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIndexediv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayiv, (vaobj, pname, param), (GLuint vaobj, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnCompressedTexImage, (target, lod, bufSize, pixels), (GLenum target, GLint lod, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnTexImage, (target, level, format, type, bufSize, pixels), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformdv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformfv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformuiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateNamedFramebufferData, (framebuffer, numAttachments, attachments), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateNamedFramebufferSubData, (framebuffer, numAttachments, attachments, x, y, width, height), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBuffer, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBufferRange, (buffer, offset, length, access), (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMemoryBarrierByRegion, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferData, (buffer, size, data, usage), (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferStorage, (buffer, size, data, flags), (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferDrawBuffer, (framebuffer, buf), (GLuint framebuffer, GLenum buf))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferDrawBuffers, (framebuffer, n, bufs), (GLuint framebuffer, GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferParameteri, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferReadBuffer, (framebuffer, src), (GLuint framebuffer, GLenum src))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferRenderbuffer, (framebuffer, attachment, renderbuffertarget, renderbuffer), (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTexture, (framebuffer, attachment, texture, level), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTextureLayer, (framebuffer, attachment, texture, level, layer), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorage, (renderbuffer, internalformat, width, height), (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorageMultisample, (renderbuffer, samples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadnPixels, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBarrier, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBuffer, (texture, internalformat, buffer), (GLuint texture, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBufferRange, (texture, internalformat, buffer, offset, size), (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterf, (texture, pname, param), (GLuint texture, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterfv, (texture, pname, param), (GLuint texture, GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameteri, (texture, pname, param), (GLuint texture, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameteriv, (texture, pname, param), (GLuint texture, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage1D, (texture, levels, internalformat, width), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2D, (texture, levels, internalformat, width, height), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2DMultisample, (texture, samples, internalformat, width, height, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3D, (texture, levels, internalformat, width, height, depth), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3DMultisample, (texture, samples, internalformat, width, height, depth, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage1D, (texture, level, xoffset, width, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackBufferBase, (xfb, index, buffer), (GLuint xfb, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackBufferRange, (xfb, index, buffer, offset, size), (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapNamedBuffer, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribBinding, (vaobj, attribindex, bindingindex), (GLuint vaobj, GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribFormat, (vaobj, attribindex, size, type, normalized, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribIFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribLFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayBindingDivisor, (vaobj, bindingindex, divisor), (GLuint vaobj, GLuint bindingindex, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayElementBuffer, (vaobj, buffer), (GLuint vaobj, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexBuffer, (vaobj, bindingindex, buffer, offset, stride), (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexBuffers, (vaobj, first, count, buffers, offsets, strides), (GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
#endif // GL_VERSION_4_5
#endif // __glcorearb_h_

#ifdef __glext_h_
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAttachObjectARB, (containerObj, obj), (GLhandleARB containerObj, GLhandleARB obj))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glClientWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileShaderARB, (shaderObj), (GLhandleARB shaderObj))
GLATTER_FBLOCK(return, GL, GLAPI , GLhandleARB, APIENTRY, glCreateProgramObjectARB, (), ())
GLATTER_FBLOCK(return, GL, GLAPI , GLhandleARB, APIENTRY, glCreateShaderObjectARB, (shaderType), (GLenum shaderType))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteObjectARB, (obj), (GLhandleARB obj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteSync, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDetachObjectARB, (containerObj, attachedObj), (GLhandleARB containerObj, GLhandleARB attachedObj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsBaseVertex, (mode, count, type, indices, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseVertex, (mode, count, type, indices, instancecount, basevertex), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElementsBaseVertex, (mode, start, end, count, type, indices, basevertex), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex))
GLATTER_FBLOCK(return, GL, GLAPI , GLsync, APIENTRY, glFenceSync, (condition, flags), (GLenum condition, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformARB, (programObj, index, maxLength, length, size, type, name), (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetAttachedObjectsARB, (containerObj, maxCount, count, obj), (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameteri64v, (target, pname, params), (GLenum target, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLhandleARB, APIENTRY, glGetHandleARB, (pname), (GLenum pname))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInfoLogARB, (obj, maxLength, length, infoLog), (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInteger64i_v, (target, index, data), (GLenum target, GLuint index, GLint64 *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInteger64v, (pname, data), (GLenum pname, GLint64 *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultisamplefv, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectParameterfvARB, (obj, pname, params), (GLhandleARB obj, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectParameterivARB, (obj, pname, params), (GLhandleARB obj, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderSourceARB, (obj, maxLength, length, source), (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSynciv, (sync, pname, bufSize, length, values), (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetUniformLocationARB, (programObj, name), (GLhandleARB programObj, const GLcharARB *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformfvARB, (programObj, location, params), (GLhandleARB programObj, GLint location, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformivARB, (programObj, location, params), (GLhandleARB programObj, GLint location, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsSync, (sync), (GLsync sync))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLinkProgramARB, (programObj), (GLhandleARB programObj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsBaseVertex, (mode, count, type, indices, drawcount, basevertex), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProvokingVertex, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMaski, (maskNumber, mask), (GLuint maskNumber, GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderSourceARB, (shaderObj, count, string, length), (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1fARB, (location, v0), (GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1iARB, (location, v0), (GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2fARB, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2iARB, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3fARB, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3iARB, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4fARB, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4fvARB, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4iARB, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ivARB, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4fvARB, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseProgramObjectARB, (programObj), (GLhandleARB programObj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glValidateProgramARB, (programObj), (GLhandleARB programObj))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWaitSync, (sync, flags, timeout), (GLsync sync, GLbitfield flags, GLuint64 timeout))
#ifdef GL_3DFX_tbuffer
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTbufferMask3DFX, (mask), (GLuint mask))
#endif // GL_3DFX_tbuffer
#ifdef GL_AMD_debug_output
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageCallbackAMD, (callback, userParam), (GLDEBUGPROCAMD callback, void *userParam))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageEnableAMD, (category, severity, count, ids, enabled), (GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageInsertAMD, (category, severity, id, length, buf), (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetDebugMessageLogAMD, (count, bufsize, categories, severities, ids, lengths, message), (GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message))
#endif // GL_AMD_debug_output
#ifdef GL_AMD_draw_buffers_blend
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationIndexedAMD, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparateIndexedAMD, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncIndexedAMD, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparateIndexedAMD, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
#endif // GL_AMD_draw_buffers_blend
#ifdef GL_AMD_framebuffer_sample_positions
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferSamplePositionsfvAMD, (target, numsamples, pixelindex, values), (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferParameterfvAMD, (target, pname, numsamples, pixelindex, size, values), (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferParameterfvAMD, (framebuffer, pname, numsamples, pixelindex, size, values), (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferSamplePositionsfvAMD, (framebuffer, numsamples, pixelindex, values), (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values))
#endif // GL_AMD_framebuffer_sample_positions
#ifdef GL_AMD_gpu_shader_int64
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformi64vNV, (program, location, params), (GLuint program, GLint location, GLint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformui64vNV, (program, location, params), (GLuint program, GLint location, GLuint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64NV, (program, location, x), (GLuint program, GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64NV, (program, location, x), (GLuint program, GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64NV, (program, location, x, y), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64NV, (program, location, x, y), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64NV, (program, location, x, y, z), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64NV, (program, location, x, y, z), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64NV, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64NV, (location, x), (GLint location, GLint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64NV, (location, x), (GLint location, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64NV, (location, x, y), (GLint location, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64NV, (location, x, y), (GLint location, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64NV, (location, x, y, z), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64NV, (location, x, y, z), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64NV, (location, x, y, z, w), (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64vNV, (location, count, value), (GLint location, GLsizei count, const GLint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64NV, (location, x, y, z, w), (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
#endif // GL_AMD_gpu_shader_int64
#ifdef GL_AMD_interleaved_elements
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribParameteriAMD, (index, pname, param), (GLuint index, GLenum pname, GLint param))
#endif // GL_AMD_interleaved_elements
#ifdef GL_AMD_multi_draw_indirect
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirectAMD, (mode, indirect, primcount, stride), (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirectAMD, (mode, type, indirect, primcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride))
#endif // GL_AMD_multi_draw_indirect
#ifdef GL_AMD_name_gen_delete
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteNamesAMD, (identifier, num, names), (GLenum identifier, GLuint num, const GLuint *names))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenNamesAMD, (identifier, num, names), (GLenum identifier, GLuint num, GLuint *names))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsNameAMD, (identifier, name), (GLenum identifier, GLuint name))
#endif // GL_AMD_name_gen_delete
#ifdef GL_AMD_occlusion_query_event
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glQueryObjectParameteruiAMD, (target, id, pname, param), (GLenum target, GLuint id, GLenum pname, GLuint param))
#endif // GL_AMD_occlusion_query_event
#ifdef GL_AMD_performance_monitor
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndPerfMonitorAMD, (monitor), (GLuint monitor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenPerfMonitorsAMD, (n, monitors), (GLsizei n, GLuint *monitors))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterDataAMD, (monitor, pname, dataSize, data, bytesWritten), (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterInfoAMD, (group, counter, pname, data), (GLuint group, GLuint counter, GLenum pname, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCounterStringAMD, (group, counter, bufSize, length, counterString), (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorCountersAMD, (group, numCounters, maxActiveCounters, counterSize, counters), (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorGroupStringAMD, (group, bufSize, length, groupString), (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfMonitorGroupsAMD, (numGroups, groupsSize, groups), (GLint *numGroups, GLsizei groupsSize, GLuint *groups))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSelectPerfMonitorCountersAMD, (monitor, enable, group, numCounters, counterList), (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList))
#endif // GL_AMD_performance_monitor
#ifdef GL_AMD_sample_positions
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetMultisamplefvAMD, (pname, index, val), (GLenum pname, GLuint index, const GLfloat *val))
#endif // GL_AMD_sample_positions
#ifdef GL_AMD_sparse_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorageSparseAMD, (target, internalFormat, width, height, depth, layers, flags), (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorageSparseAMD, (texture, target, internalFormat, width, height, depth, layers, flags), (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags))
#endif // GL_AMD_sparse_texture
#ifdef GL_AMD_stencil_operation_extended
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilOpValueAMD, (face, value), (GLenum face, GLuint value))
#endif // GL_AMD_stencil_operation_extended
#ifdef GL_AMD_vertex_shader_tessellator
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTessellationFactorAMD, (factor), (GLfloat factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTessellationModeAMD, (mode), (GLenum mode))
#endif // GL_AMD_vertex_shader_tessellator
#ifdef GL_APPLE_element_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementArrayAPPLE, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElementArrayAPPLE, (mode, start, end, first, count), (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glElementPointerAPPLE, (type, pointer), (GLenum type, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementArrayAPPLE, (mode, first, count, primcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawRangeElementArrayAPPLE, (mode, start, end, first, count, primcount), (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount))
#endif // GL_APPLE_element_array
#ifdef GL_APPLE_fence
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFencesAPPLE, (n, fences), (GLsizei n, const GLuint *fences))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinishFenceAPPLE, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinishObjectAPPLE, (object, name), (GLenum object, GLint name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenFencesAPPLE, (n, fences), (GLsizei n, GLuint *fences))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsFenceAPPLE, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetFenceAPPLE, (fence), (GLuint fence))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glTestFenceAPPLE, (fence), (GLuint fence))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glTestObjectAPPLE, (object, name), (GLenum object, GLuint name))
#endif // GL_APPLE_fence
#ifdef GL_APPLE_flush_buffer_range
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferParameteriAPPLE, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedBufferRangeAPPLE, (target, offset, size), (GLenum target, GLintptr offset, GLsizeiptr size))
#endif // GL_APPLE_flush_buffer_range
#ifdef GL_APPLE_object_purgeable
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectParameterivAPPLE, (objectType, name, pname, params), (GLenum objectType, GLuint name, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glObjectPurgeableAPPLE, (objectType, name, option), (GLenum objectType, GLuint name, GLenum option))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glObjectUnpurgeableAPPLE, (objectType, name, option), (GLenum objectType, GLuint name, GLenum option))
#endif // GL_APPLE_object_purgeable
#ifdef GL_APPLE_texture_range
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterPointervAPPLE, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureRangeAPPLE, (target, length, pointer), (GLenum target, GLsizei length, const void *pointer))
#endif // GL_APPLE_texture_range
#ifdef GL_APPLE_vertex_array_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexArrayAPPLE, (array), (GLuint array))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteVertexArraysAPPLE, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenVertexArraysAPPLE, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsVertexArrayAPPLE, (array), (GLuint array))
#endif // GL_APPLE_vertex_array_object
#ifdef GL_APPLE_vertex_array_range
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushVertexArrayRangeAPPLE, (length, pointer), (GLsizei length, void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayParameteriAPPLE, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayRangeAPPLE, (length, pointer), (GLsizei length, void *pointer))
#endif // GL_APPLE_vertex_array_range
#ifdef GL_APPLE_vertex_program_evaluators
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexAttribAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexAttribAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsVertexAttribEnabledAPPLE, (index, pname), (GLuint index, GLenum pname))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapVertexAttrib1dAPPLE, (index, size, u1, u2, stride, order, points), (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapVertexAttrib1fAPPLE, (index, size, u1, u2, stride, order, points), (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapVertexAttrib2dAPPLE, (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapVertexAttrib2fAPPLE, (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points))
#endif // GL_APPLE_vertex_program_evaluators
#ifdef GL_ARB_ES3_2_compatibility
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrimitiveBoundingBoxARB, (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW), (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW))
#endif // GL_ARB_ES3_2_compatibility
#ifdef GL_ARB_bindless_texture
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetImageHandleARB, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureHandleARB, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureSamplerHandleARB, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLui64vARB, (index, pname, params), (GLuint index, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsImageHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleResidentARB, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleNonResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleResidentARB, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64ARB, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64vARB, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64ARB, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64ARB, (index, x), (GLuint index, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64vARB, (index, v), (GLuint index, const GLuint64EXT *v))
#endif // GL_ARB_bindless_texture
#ifdef GL_ARB_cl_event
GLATTER_FBLOCK(return, GL, GLAPI , GLsync, APIENTRY, glCreateSyncFromCLeventARB, (context, event, flags), (struct _cl_context *context, struct _cl_event *event, GLbitfield flags))
#endif // GL_ARB_cl_event
#ifdef GL_ARB_color_buffer_float
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClampColorARB, (target, clamp), (GLenum target, GLenum clamp))
#endif // GL_ARB_color_buffer_float
#ifdef GL_ARB_compute_variable_group_size
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchComputeGroupSizeARB, (num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z))
#endif // GL_ARB_compute_variable_group_size
#ifdef GL_ARB_debug_output
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageCallbackARB, (callback, userParam), (GLDEBUGPROCARB callback, const void *userParam))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageControlARB, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageInsertARB, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetDebugMessageLogARB, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
#endif // GL_ARB_debug_output
#ifdef GL_ARB_draw_buffers
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawBuffersARB, (n, bufs), (GLsizei n, const GLenum *bufs))
#endif // GL_ARB_draw_buffers
#ifdef GL_ARB_draw_buffers_blend
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparateiARB, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationiARB, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparateiARB, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFunciARB, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
#endif // GL_ARB_draw_buffers_blend
#ifdef GL_ARB_draw_instanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstancedARB, (mode, first, count, primcount), (GLenum mode, GLint first, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedARB, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
#endif // GL_ARB_draw_instanced
#ifdef GL_ARB_fragment_program
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindProgramARB, (target, program), (GLenum target, GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgramsARB, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenProgramsARB, (n, programs), (GLsizei n, GLuint *programs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramEnvParameterdvARB, (target, index, params), (GLenum target, GLuint index, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramEnvParameterfvARB, (target, index, params), (GLenum target, GLuint index, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramLocalParameterdvARB, (target, index, params), (GLenum target, GLuint index, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramLocalParameterfvARB, (target, index, params), (GLenum target, GLuint index, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramStringARB, (target, pname, string), (GLenum target, GLenum pname, void *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgramARB, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameter4dARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameter4dvARB, (target, index, params), (GLenum target, GLuint index, const GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameter4fARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameter4fvARB, (target, index, params), (GLenum target, GLuint index, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameter4dARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameter4dvARB, (target, index, params), (GLenum target, GLuint index, const GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameter4fARB, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameter4fvARB, (target, index, params), (GLenum target, GLuint index, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramStringARB, (target, format, len, string), (GLenum target, GLenum format, GLsizei len, const void *string))
#endif // GL_ARB_fragment_program
#ifdef GL_ARB_geometry_shader4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureARB, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureFaceARB, (target, attachment, texture, level, face), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureLayerARB, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameteriARB, (program, pname, value), (GLuint program, GLenum pname, GLint value))
#endif // GL_ARB_geometry_shader4
#ifdef GL_ARB_gpu_shader_int64
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformi64vARB, (program, location, params), (GLuint program, GLint location, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformui64vARB, (program, location, params), (GLuint program, GLint location, GLuint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformi64vARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformui64vARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64ARB, (program, location, x), (GLuint program, GLint location, GLint64 x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64ARB, (program, location, x), (GLuint program, GLint location, GLuint64 x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64ARB, (program, location, x, y), (GLuint program, GLint location, GLint64 x, GLint64 y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64ARB, (program, location, x, y), (GLuint program, GLint location, GLuint64 x, GLuint64 y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64ARB, (program, location, x, y, z), (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64ARB, (program, location, x, y, z), (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64ARB, (program, location, x, y, z, w), (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64ARB, (program, location, x, y, z, w), (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui64vARB, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64ARB, (location, x), (GLint location, GLint64 x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64ARB, (location, x), (GLint location, GLuint64 x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64ARB, (location, x, y), (GLint location, GLint64 x, GLint64 y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64ARB, (location, x, y), (GLint location, GLuint64 x, GLuint64 y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64ARB, (location, x, y, z), (GLint location, GLint64 x, GLint64 y, GLint64 z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64ARB, (location, x, y, z), (GLint location, GLuint64 x, GLuint64 y, GLuint64 z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64ARB, (location, x, y, z, w), (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i64vARB, (location, count, value), (GLint location, GLsizei count, const GLint64 *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64ARB, (location, x, y, z, w), (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui64vARB, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
#endif // GL_ARB_gpu_shader_int64
#ifdef GL_ARB_imaging
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorSubTable, (target, start, count, format, type, data), (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTable, (target, internalformat, width, format, type, table), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionFilter1D, (target, internalformat, width, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionFilter2D, (target, internalformat, width, height, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterf, (target, pname, params), (GLenum target, GLenum pname, GLfloat params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterfv, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameteri, (target, pname, params), (GLenum target, GLenum pname, GLint params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameteriv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyColorSubTable, (target, start, x, y, width), (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyColorTable, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyConvolutionFilter1D, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyConvolutionFilter2D, (target, internalformat, x, y, width, height), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTable, (target, format, type, table), (GLenum target, GLenum format, GLenum type, void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionFilter, (target, format, type, image), (GLenum target, GLenum format, GLenum type, void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogram, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmax, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmaxParameterfv, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmaxParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSeparableFilter, (target, format, type, row, column, span), (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glHistogram, (target, width, internalformat, sink), (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinmax, (target, internalformat, sink), (GLenum target, GLenum internalformat, GLboolean sink))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResetHistogram, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResetMinmax, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSeparableFilter2D, (target, internalformat, width, height, format, type, row, column), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column))
#endif // GL_ARB_imaging
#ifdef GL_ARB_indirect_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirectCountARB, (mode, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirectCountARB, (mode, type, indirect, drawcount, maxdrawcount, stride), (GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride))
#endif // GL_ARB_indirect_parameters
#ifdef GL_ARB_instanced_arrays
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribDivisorARB, (index, divisor), (GLuint index, GLuint divisor))
#endif // GL_ARB_instanced_arrays
#ifdef GL_ARB_matrix_palette
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCurrentPaletteMatrixARB, (index), (GLint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixIndexPointerARB, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixIndexubvARB, (size, indices), (GLint size, const GLubyte *indices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixIndexuivARB, (size, indices), (GLint size, const GLuint *indices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixIndexusvARB, (size, indices), (GLint size, const GLushort *indices))
#endif // GL_ARB_matrix_palette
#ifdef GL_ARB_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleCoverageARB, (value, invert), (GLfloat value, GLboolean invert))
#endif // GL_ARB_multisample
#ifdef GL_ARB_multitexture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveTextureARB, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClientActiveTextureARB, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1dARB, (target, s), (GLenum target, GLdouble s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1fARB, (target, s), (GLenum target, GLfloat s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1iARB, (target, s), (GLenum target, GLint s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1sARB, (target, s), (GLenum target, GLshort s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2dARB, (target, s, t), (GLenum target, GLdouble s, GLdouble t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2fARB, (target, s, t), (GLenum target, GLfloat s, GLfloat t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2iARB, (target, s, t), (GLenum target, GLint s, GLint t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2sARB, (target, s, t), (GLenum target, GLshort s, GLshort t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3dARB, (target, s, t, r), (GLenum target, GLdouble s, GLdouble t, GLdouble r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3fARB, (target, s, t, r), (GLenum target, GLfloat s, GLfloat t, GLfloat r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3iARB, (target, s, t, r), (GLenum target, GLint s, GLint t, GLint r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3sARB, (target, s, t, r), (GLenum target, GLshort s, GLshort t, GLshort r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3svARB, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4dARB, (target, s, t, r, q), (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4dvARB, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4fARB, (target, s, t, r, q), (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4fvARB, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4iARB, (target, s, t, r, q), (GLenum target, GLint s, GLint t, GLint r, GLint q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4ivARB, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4sARB, (target, s, t, r, q), (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4svARB, (target, v), (GLenum target, const GLshort *v))
#endif // GL_ARB_multitexture
#ifdef GL_ARB_occlusion_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginQueryARB, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteQueriesARB, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndQueryARB, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenQueriesARB, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectivARB, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectuivARB, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsQueryARB, (id), (GLuint id))
#endif // GL_ARB_occlusion_query
#ifdef GL_ARB_parallel_shader_compile
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMaxShaderCompilerThreadsARB, (count), (GLuint count))
#endif // GL_ARB_parallel_shader_compile
#ifdef GL_ARB_point_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfARB, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfvARB, (pname, params), (GLenum pname, const GLfloat *params))
#endif // GL_ARB_point_parameters
#ifdef GL_ARB_robustness
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glGetGraphicsResetStatusARB, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnColorTableARB, (target, format, type, bufSize, table), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnCompressedTexImageARB, (target, lod, bufSize, img), (GLenum target, GLint lod, GLsizei bufSize, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnConvolutionFilterARB, (target, format, type, bufSize, image), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnHistogramARB, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapdvARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapfvARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapivARB, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMinmaxARB, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapfvARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapuivARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLuint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapusvARB, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLushort *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPolygonStippleARB, (bufSize, pattern), (GLsizei bufSize, GLubyte *pattern))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnSeparableFilterARB, (target, format, type, rowBufSize, row, columnBufSize, column, span), (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnTexImageARB, (target, level, format, type, bufSize, img), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformdvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformfvARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformuivARB, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadnPixelsARB, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
#endif // GL_ARB_robustness
#ifdef GL_ARB_sample_locations
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvaluateDepthValuesARB, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferSampleLocationsfvARB, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferSampleLocationsfvARB, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
#endif // GL_ARB_sample_locations
#ifdef GL_ARB_sample_shading
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinSampleShadingARB, (value), (GLfloat value))
#endif // GL_ARB_sample_shading
#ifdef GL_ARB_shading_language_include
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileShaderIncludeARB, (shader, count, path, length), (GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedStringARB, (namelen, name, bufSize, stringlen, string), (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedStringivARB, (namelen, name, pname, params), (GLint namelen, const GLchar *name, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsNamedStringARB, (namelen, name), (GLint namelen, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedStringARB, (type, namelen, name, stringlen, string), (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string))
#endif // GL_ARB_shading_language_include
#ifdef GL_ARB_sparse_buffer
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferPageCommitmentARB, (target, offset, size, commit), (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferPageCommitmentARB, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferPageCommitmentEXT, (buffer, offset, size, commit), (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit))
#endif // GL_ARB_sparse_buffer
#ifdef GL_ARB_sparse_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexPageCommitmentARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
#endif // GL_ARB_sparse_texture
#ifdef GL_ARB_texture_buffer_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBufferARB, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
#endif // GL_ARB_texture_buffer_object
#ifdef GL_ARB_texture_compression
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage1DARB, (target, level, internalformat, width, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage2DARB, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage3DARB, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage1DARB, (target, level, xoffset, width, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage2DARB, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage3DARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTexImageARB, (target, level, img), (GLenum target, GLint level, void *img))
#endif // GL_ARB_texture_compression
#ifdef GL_ARB_transpose_matrix
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadTransposeMatrixdARB, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadTransposeMatrixfARB, (m), (const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultTransposeMatrixdARB, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultTransposeMatrixfARB, (m), (const GLfloat *m))
#endif // GL_ARB_transpose_matrix
#ifdef GL_ARB_vertex_blend
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexBlendARB, (count), (GLint count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightPointerARB, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightbvARB, (size, weights), (GLint size, const GLbyte *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightdvARB, (size, weights), (GLint size, const GLdouble *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightfvARB, (size, weights), (GLint size, const GLfloat *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightivARB, (size, weights), (GLint size, const GLint *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightsvARB, (size, weights), (GLint size, const GLshort *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightubvARB, (size, weights), (GLint size, const GLubyte *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightuivARB, (size, weights), (GLint size, const GLuint *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightusvARB, (size, weights), (GLint size, const GLushort *weights))
#endif // GL_ARB_vertex_blend
#ifdef GL_ARB_vertex_buffer_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferARB, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferDataARB, (target, size, data, usage), (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferSubDataARB, (target, offset, size, data), (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteBuffersARB, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenBuffersARB, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameterivARB, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferPointervARB, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferSubDataARB, (target, offset, size, data), (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsBufferARB, (buffer), (GLuint buffer))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapBufferARB, (target, access), (GLenum target, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapBufferARB, (target), (GLenum target))
#endif // GL_ARB_vertex_buffer_object
#ifdef GL_ARB_vertex_program
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexAttribArrayARB, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexAttribArrayARB, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribPointervARB, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribdvARB, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribfvARB, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribivARB, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dARB, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fARB, (index, x), (GLuint index, GLfloat x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1sARB, (index, x), (GLuint index, GLshort x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dARB, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fARB, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2sARB, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dARB, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fARB, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3sARB, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NbvARB, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NivARB, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NsvARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NubARB, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NubvARB, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NuivARB, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4NusvARB, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4bvARB, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dARB, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dvARB, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fARB, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fvARB, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ivARB, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4sARB, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4svARB, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ubvARB, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4uivARB, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4usvARB, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribPointerARB, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
#endif // GL_ARB_vertex_program
#ifdef GL_ARB_vertex_shader
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindAttribLocationARB, (programObj, index, name), (GLhandleARB programObj, GLuint index, const GLcharARB *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveAttribARB, (programObj, index, maxLength, length, size, type, name), (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetAttribLocationARB, (programObj, name), (GLhandleARB programObj, const GLcharARB *name))
#endif // GL_ARB_vertex_shader
#ifdef GL_ARB_window_pos
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2dARB, (x, y), (GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2dvARB, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2fARB, (x, y), (GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2fvARB, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2iARB, (x, y), (GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2ivARB, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2sARB, (x, y), (GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2svARB, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3dARB, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3dvARB, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3fARB, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3fvARB, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3iARB, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3ivARB, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3sARB, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3svARB, (v), (const GLshort *v))
#endif // GL_ARB_window_pos
#ifdef GL_ATI_draw_buffers
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawBuffersATI, (n, bufs), (GLsizei n, const GLenum *bufs))
#endif // GL_ATI_draw_buffers
#ifdef GL_ATI_element_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementArrayATI, (mode, count), (GLenum mode, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElementArrayATI, (mode, start, end, count), (GLenum mode, GLuint start, GLuint end, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glElementPointerATI, (type, pointer), (GLenum type, const void *pointer))
#endif // GL_ATI_element_array
#ifdef GL_ATI_envmap_bumpmap
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexBumpParameterfvATI, (pname, param), (GLenum pname, GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexBumpParameterivATI, (pname, param), (GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBumpParameterfvATI, (pname, param), (GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBumpParameterivATI, (pname, param), (GLenum pname, const GLint *param))
#endif // GL_ATI_envmap_bumpmap
#ifdef GL_ATI_fragment_shader
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAlphaFragmentOp1ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAlphaFragmentOp2ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAlphaFragmentOp3ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginFragmentShaderATI, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragmentShaderATI, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorFragmentOp1ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorFragmentOp2ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorFragmentOp3ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFragmentShaderATI, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndFragmentShaderATI, (), ())
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenFragmentShadersATI, (range), (GLuint range))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPassTexCoordATI, (dst, coord, swizzle), (GLuint dst, GLuint coord, GLenum swizzle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMapATI, (dst, interp, swizzle), (GLuint dst, GLuint interp, GLenum swizzle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetFragmentShaderConstantATI, (dst, value), (GLuint dst, const GLfloat *value))
#endif // GL_ATI_fragment_shader
#ifdef GL_ATI_map_object_buffer
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUnmapObjectBufferATI, (buffer), (GLuint buffer))
#endif // GL_ATI_map_object_buffer
#ifdef GL_ATI_pn_triangles
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPNTrianglesfATI, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPNTrianglesiATI, (pname, param), (GLenum pname, GLint param))
#endif // GL_ATI_pn_triangles
#ifdef GL_ATI_separate_stencil
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFuncSeparateATI, (frontfunc, backfunc, ref, mask), (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilOpSeparateATI, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
#endif // GL_ATI_separate_stencil
#ifdef GL_ATI_vertex_array_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glArrayObjectATI, (array, size, type, stride, buffer, offset), (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFreeObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetArrayObjectfvATI, (array, pname, params), (GLenum array, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetArrayObjectivATI, (array, pname, params), (GLenum array, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectBufferfvATI, (buffer, pname, params), (GLuint buffer, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectBufferivATI, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantArrayObjectfvATI, (id, pname, params), (GLuint id, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantArrayObjectivATI, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsObjectBufferATI, (buffer), (GLuint buffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glNewObjectBufferATI, (size, pointer, usage), (GLsizei size, const void *pointer, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUpdateObjectBufferATI, (buffer, offset, size, pointer, preserve), (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantArrayObjectATI, (id, type, stride, buffer, offset), (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset))
#endif // GL_ATI_vertex_array_object
#ifdef GL_ATI_vertex_attrib_array_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribArrayObjectfvATI, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribArrayObjectivATI, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribArrayObjectATI, (index, size, type, normalized, stride, buffer, offset), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset))
#endif // GL_ATI_vertex_attrib_array_object
#ifdef GL_ATI_vertex_streams
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClientActiveVertexStreamATI, (stream), (GLenum stream))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3bATI, (stream, nx, ny, nz), (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3bvATI, (stream, coords), (GLenum stream, const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3dATI, (stream, nx, ny, nz), (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3fATI, (stream, nx, ny, nz), (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3iATI, (stream, nx, ny, nz), (GLenum stream, GLint nx, GLint ny, GLint nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3sATI, (stream, nx, ny, nz), (GLenum stream, GLshort nx, GLshort ny, GLshort nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalStream3svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexBlendEnvfATI, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexBlendEnviATI, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1dATI, (stream, x), (GLenum stream, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1fATI, (stream, x), (GLenum stream, GLfloat x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1iATI, (stream, x), (GLenum stream, GLint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1sATI, (stream, x), (GLenum stream, GLshort x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream1svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2dATI, (stream, x, y), (GLenum stream, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2fATI, (stream, x, y), (GLenum stream, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2iATI, (stream, x, y), (GLenum stream, GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2sATI, (stream, x, y), (GLenum stream, GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream2svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3dATI, (stream, x, y, z), (GLenum stream, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3fATI, (stream, x, y, z), (GLenum stream, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3iATI, (stream, x, y, z), (GLenum stream, GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3sATI, (stream, x, y, z), (GLenum stream, GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream3svATI, (stream, coords), (GLenum stream, const GLshort *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4dATI, (stream, x, y, z, w), (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4dvATI, (stream, coords), (GLenum stream, const GLdouble *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4fATI, (stream, x, y, z, w), (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4fvATI, (stream, coords), (GLenum stream, const GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4iATI, (stream, x, y, z, w), (GLenum stream, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4ivATI, (stream, coords), (GLenum stream, const GLint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4sATI, (stream, x, y, z, w), (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexStream4svATI, (stream, coords), (GLenum stream, const GLshort *coords))
#endif // GL_ATI_vertex_streams
#ifdef GL_EXT_bindable_uniform
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetUniformBufferSizeEXT, (program, location), (GLuint program, GLint location))
GLATTER_FBLOCK(return, GL, GLAPI , GLintptr, APIENTRY, glGetUniformOffsetEXT, (program, location), (GLuint program, GLint location))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformBufferEXT, (program, location, buffer), (GLuint program, GLint location, GLuint buffer))
#endif // GL_EXT_bindable_uniform
#ifdef GL_EXT_blend_color
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendColorEXT, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
#endif // GL_EXT_blend_color
#ifdef GL_EXT_blend_equation_separate
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparateEXT, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
#endif // GL_EXT_blend_equation_separate
#ifdef GL_EXT_blend_func_separate
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparateEXT, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
#endif // GL_EXT_blend_func_separate
#ifdef GL_EXT_blend_minmax
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationEXT, (mode), (GLenum mode))
#endif // GL_EXT_blend_minmax
#ifdef GL_EXT_color_subtable
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorSubTableEXT, (target, start, count, format, type, data), (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyColorSubTableEXT, (target, start, x, y, width), (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width))
#endif // GL_EXT_color_subtable
#ifdef GL_EXT_compiled_vertex_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLockArraysEXT, (first, count), (GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUnlockArraysEXT, (), ())
#endif // GL_EXT_compiled_vertex_array
#ifdef GL_EXT_convolution
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionFilter1DEXT, (target, internalformat, width, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionFilter2DEXT, (target, internalformat, width, height, format, type, image), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterfEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameteriEXT, (target, pname, params), (GLenum target, GLenum pname, GLint params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyConvolutionFilter1DEXT, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyConvolutionFilter2DEXT, (target, internalformat, x, y, width, height), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionFilterEXT, (target, format, type, image), (GLenum target, GLenum format, GLenum type, void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSeparableFilterEXT, (target, format, type, row, column, span), (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSeparableFilter2DEXT, (target, internalformat, width, height, format, type, row, column), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column))
#endif // GL_EXT_convolution
#ifdef GL_EXT_coordinate_frame
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3bEXT, (bx, by, bz), (GLbyte bx, GLbyte by, GLbyte bz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3bvEXT, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3dEXT, (bx, by, bz), (GLdouble bx, GLdouble by, GLdouble bz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3dvEXT, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3fEXT, (bx, by, bz), (GLfloat bx, GLfloat by, GLfloat bz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3fvEXT, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3iEXT, (bx, by, bz), (GLint bx, GLint by, GLint bz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3ivEXT, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3sEXT, (bx, by, bz), (GLshort bx, GLshort by, GLshort bz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormal3svEXT, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBinormalPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3bEXT, (tx, ty, tz), (GLbyte tx, GLbyte ty, GLbyte tz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3bvEXT, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3dEXT, (tx, ty, tz), (GLdouble tx, GLdouble ty, GLdouble tz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3dvEXT, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3fEXT, (tx, ty, tz), (GLfloat tx, GLfloat ty, GLfloat tz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3fvEXT, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3iEXT, (tx, ty, tz), (GLint tx, GLint ty, GLint tz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3ivEXT, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3sEXT, (tx, ty, tz), (GLshort tx, GLshort ty, GLshort tz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangent3svEXT, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTangentPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
#endif // GL_EXT_coordinate_frame
#ifdef GL_EXT_copy_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexImage1DEXT, (target, level, internalformat, x, y, width, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexImage2DEXT, (target, level, internalformat, x, y, width, height, border), (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage1DEXT, (target, level, xoffset, x, y, width), (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage2DEXT, (target, level, xoffset, yoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage3DEXT, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
#endif // GL_EXT_copy_texture
#ifdef GL_EXT_cull_vertex
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCullParameterdvEXT, (pname, params), (GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCullParameterfvEXT, (pname, params), (GLenum pname, GLfloat *params))
#endif // GL_EXT_cull_vertex
#ifdef GL_EXT_debug_label
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectLabelEXT, (type, object, bufSize, length, label), (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLabelObjectEXT, (type, object, length, label), (GLenum type, GLuint object, GLsizei length, const GLchar *label))
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInsertEventMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPopGroupMarkerEXT, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPushGroupMarkerEXT, (length, marker), (GLsizei length, const GLchar *marker))
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_depth_bounds_test
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthBoundsEXT, (zmin, zmax), (GLclampd zmin, GLclampd zmax))
#endif // GL_EXT_depth_bounds_test
#ifdef GL_EXT_direct_state_access
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindMultiTextureEXT, (texunit, target, texture), (GLenum texunit, GLenum target, GLuint texture))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckNamedFramebufferStatusEXT, (framebuffer, target), (GLuint framebuffer, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferDataEXT, (buffer, internalformat, format, type, data), (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferSubDataEXT, (buffer, internalformat, offset, size, format, type, data), (GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClientAttribDefaultEXT, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexImage1DEXT, (texunit, target, level, internalformat, width, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexImage2DEXT, (texunit, target, level, internalformat, width, height, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexImage3DEXT, (texunit, target, level, internalformat, width, height, depth, border, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexSubImage1DEXT, (texunit, target, level, xoffset, width, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureImage1DEXT, (texture, target, level, internalformat, width, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureImage2DEXT, (texture, target, level, internalformat, width, height, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureImage3DEXT, (texture, target, level, internalformat, width, height, depth, border, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage1DEXT, (texture, target, level, xoffset, width, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyMultiTexImage1DEXT, (texunit, target, level, internalformat, x, y, width, border), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyMultiTexImage2DEXT, (texunit, target, level, internalformat, x, y, width, height, border), (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyMultiTexSubImage1DEXT, (texunit, target, level, xoffset, x, y, width), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, x, y, width, height), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureImage1DEXT, (texture, target, level, internalformat, x, y, width, border), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureImage2DEXT, (texture, target, level, internalformat, x, y, width, height, border), (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage1DEXT, (texture, target, level, xoffset, x, y, width), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, x, y, width, height), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableClientStateIndexedEXT, (array, index), (GLenum array, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableClientStateiEXT, (array, index), (GLenum array, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexArrayAttribEXT, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexArrayEXT, (vaobj, array), (GLuint vaobj, GLenum array))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableClientStateIndexedEXT, (array, index), (GLenum array, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableClientStateiEXT, (array, index), (GLenum array, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexArrayAttribEXT, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexArrayEXT, (vaobj, array), (GLuint vaobj, GLenum array))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedNamedBufferRangeEXT, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferDrawBufferEXT, (framebuffer, mode), (GLuint framebuffer, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferDrawBuffersEXT, (framebuffer, n, bufs), (GLuint framebuffer, GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferReadBufferEXT, (framebuffer, mode), (GLuint framebuffer, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateMultiTexMipmapEXT, (texunit, target), (GLenum texunit, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateTextureMipmapEXT, (texture, target), (GLuint texture, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBooleanIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedMultiTexImageEXT, (texunit, target, lod, img), (GLenum texunit, GLenum target, GLint lod, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTextureImageEXT, (texture, target, lod, img), (GLuint texture, GLenum target, GLint lod, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDoubleIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLdouble *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDoublei_vEXT, (pname, index, params), (GLenum pname, GLuint index, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFloatIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFloati_vEXT, (pname, index, params), (GLenum pname, GLuint index, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferParameterivEXT, (framebuffer, pname, params), (GLuint framebuffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegerIndexedvEXT, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexEnvfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexEnvivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexGendvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexGenfvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexGenivEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexImageEXT, (texunit, target, level, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexLevelParameterfvEXT, (texunit, target, level, pname, params), (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexLevelParameterivEXT, (texunit, target, level, pname, params), (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexParameterIivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexParameterIuivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexParameterfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultiTexParameterivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameterivEXT, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferPointervEXT, (buffer, pname, params), (GLuint buffer, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferSubDataEXT, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferAttachmentParameterivEXT, (framebuffer, attachment, pname, params), (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferParameterivEXT, (framebuffer, pname, params), (GLuint framebuffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramLocalParameterIivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramLocalParameterIuivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramLocalParameterdvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramLocalParameterfvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramStringEXT, (program, target, pname, string), (GLuint program, GLenum target, GLenum pname, void *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedProgramivEXT, (program, target, pname, params), (GLuint program, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedRenderbufferParameterivEXT, (renderbuffer, pname, params), (GLuint renderbuffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPointerIndexedvEXT, (target, index, data), (GLenum target, GLuint index, void **data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPointeri_vEXT, (pname, index, params), (GLenum pname, GLuint index, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureImageEXT, (texture, target, level, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameterfvEXT, (texture, target, level, pname, params), (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameterivEXT, (texture, target, level, pname, params), (GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIuivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterfvEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIntegeri_vEXT, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIntegervEXT, (vaobj, pname, param), (GLuint vaobj, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayPointeri_vEXT, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, void **param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayPointervEXT, (vaobj, pname, param), (GLuint vaobj, GLenum pname, void **param))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsEnabledIndexedEXT, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBufferEXT, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBufferRangeEXT, (buffer, offset, length, access), (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixFrustumEXT, (mode, left, right, bottom, top, zNear, zFar), (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadIdentityEXT, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadTransposedEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadTransposefEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoaddEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadfEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultTransposedEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultTransposefEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultdEXT, (mode, m), (GLenum mode, const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultfEXT, (mode, m), (GLenum mode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixOrthoEXT, (mode, left, right, bottom, top, zNear, zFar), (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixPopEXT, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixPushEXT, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixRotatedEXT, (mode, angle, x, y, z), (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixRotatefEXT, (mode, angle, x, y, z), (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixScaledEXT, (mode, x, y, z), (GLenum mode, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixScalefEXT, (mode, x, y, z), (GLenum mode, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixTranslatedEXT, (mode, x, y, z), (GLenum mode, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixTranslatefEXT, (mode, x, y, z), (GLenum mode, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexBufferEXT, (texunit, target, internalformat, buffer), (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordPointerEXT, (texunit, size, type, stride, pointer), (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexEnvfEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexEnvfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexEnviEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexEnvivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGendEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLdouble param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGendvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGenfEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGenfvEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGeniEXT, (texunit, coord, pname, param), (GLenum texunit, GLenum coord, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexGenivEXT, (texunit, coord, pname, params), (GLenum texunit, GLenum coord, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexImage1DEXT, (texunit, target, level, internalformat, width, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexImage2DEXT, (texunit, target, level, internalformat, width, height, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexImage3DEXT, (texunit, target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameterIivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameterIuivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameterfEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameterfvEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameteriEXT, (texunit, target, pname, param), (GLenum texunit, GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexParameterivEXT, (texunit, target, pname, params), (GLenum texunit, GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexRenderbufferEXT, (texunit, target, renderbuffer), (GLenum texunit, GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexSubImage1DEXT, (texunit, target, level, xoffset, width, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexSubImage2DEXT, (texunit, target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexSubImage3DEXT, (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferDataEXT, (buffer, size, data, usage), (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferStorageEXT, (buffer, size, data, flags), (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferSubDataEXT, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedCopyBufferSubDataEXT, (readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferParameteriEXT, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferRenderbufferEXT, (framebuffer, attachment, renderbuffertarget, renderbuffer), (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTexture1DEXT, (framebuffer, attachment, textarget, texture, level), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTexture2DEXT, (framebuffer, attachment, textarget, texture, level), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTexture3DEXT, (framebuffer, attachment, textarget, texture, level, zoffset), (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTextureEXT, (framebuffer, attachment, texture, level), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTextureFaceEXT, (framebuffer, attachment, texture, level, face), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTextureLayerEXT, (framebuffer, attachment, texture, level, layer), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameter4dEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameter4dvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameter4fEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameter4fvEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameterI4iEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameterI4ivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameterI4uiEXT, (program, target, index, x, y, z, w), (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameterI4uivEXT, (program, target, index, params), (GLuint program, GLenum target, GLuint index, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParameters4fvEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParametersI4ivEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramLocalParametersI4uivEXT, (program, target, index, count, params), (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedProgramStringEXT, (program, target, format, len, string), (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorageEXT, (renderbuffer, internalformat, width, height), (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorageMultisampleCoverageEXT, (renderbuffer, coverageSamples, colorSamples, internalformat, width, height), (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorageMultisampleEXT, (renderbuffer, samples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1dEXT, (program, location, x), (GLuint program, GLint location, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1fEXT, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1iEXT, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1uiEXT, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2dEXT, (program, location, x, y), (GLuint program, GLint location, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2fEXT, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2iEXT, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2uiEXT, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3dEXT, (program, location, x, y, z), (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3fEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3iEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3uiEXT, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4dEXT, (program, location, x, y, z, w), (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4dvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4fEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4fvEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4iEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4uiEXT, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4uivEXT, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3dvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3fvEXT, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPushClientAttribDefaultEXT, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBufferEXT, (texture, target, internalformat, buffer), (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBufferRangeEXT, (texture, target, internalformat, buffer, offset, size), (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage1DEXT, (texture, target, level, internalformat, width, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage2DEXT, (texture, target, level, internalformat, width, height, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage3DEXT, (texture, target, level, internalformat, width, height, depth, border, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexturePageCommitmentEXT, (texture, level, xoffset, yoffset, zoffset, width, height, depth, commit), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIuivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterfEXT, (texture, target, pname, param), (GLuint texture, GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterfvEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameteriEXT, (texture, target, pname, param), (GLuint texture, GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterivEXT, (texture, target, pname, params), (GLuint texture, GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureRenderbufferEXT, (texture, target, renderbuffer), (GLuint texture, GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage1DEXT, (texture, target, levels, internalformat, width), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2DEXT, (texture, target, levels, internalformat, width, height), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2DMultisampleEXT, (texture, target, samples, internalformat, width, height, fixedsamplelocations), (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3DEXT, (texture, target, levels, internalformat, width, height, depth), (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3DMultisampleEXT, (texture, target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage1DEXT, (texture, target, level, xoffset, width, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage2DEXT, (texture, target, level, xoffset, yoffset, width, height, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage3DEXT, (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapNamedBufferEXT, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayBindVertexBufferEXT, (vaobj, bindingindex, buffer, offset, stride), (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayColorOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayEdgeFlagOffsetEXT, (vaobj, buffer, stride, offset), (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayFogCoordOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayIndexOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayMultiTexCoordOffsetEXT, (vaobj, buffer, texunit, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayNormalOffsetEXT, (vaobj, buffer, type, stride, offset), (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArraySecondaryColorOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayTexCoordOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribBindingEXT, (vaobj, attribindex, bindingindex), (GLuint vaobj, GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribDivisorEXT, (vaobj, index, divisor), (GLuint vaobj, GLuint index, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribFormatEXT, (vaobj, attribindex, size, type, normalized, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribIFormatEXT, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribIOffsetEXT, (vaobj, buffer, index, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribLFormatEXT, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribLOffsetEXT, (vaobj, buffer, index, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexAttribOffsetEXT, (vaobj, buffer, index, size, type, normalized, stride, offset), (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexBindingDivisorEXT, (vaobj, bindingindex, divisor), (GLuint vaobj, GLuint bindingindex, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexOffsetEXT, (vaobj, buffer, size, type, stride, offset), (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset))
#endif // GL_EXT_direct_state_access
#ifdef GL_EXT_draw_buffers2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorMaskIndexedEXT, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
#endif // GL_EXT_draw_buffers2
#ifdef GL_EXT_draw_instanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstancedEXT, (mode, start, count, primcount), (GLenum mode, GLint start, GLsizei count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedEXT, (mode, count, type, indices, primcount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount))
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_draw_range_elements
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElementsEXT, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
#endif // GL_EXT_draw_range_elements
#ifdef GL_EXT_fog_coord
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordPointerEXT, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoorddEXT, (coord), (GLdouble coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoorddvEXT, (coord), (const GLdouble *coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordfEXT, (coord), (GLfloat coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordfvEXT, (coord), (const GLfloat *coord))
#endif // GL_EXT_fog_coord
#ifdef GL_EXT_framebuffer_blit
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlitFramebufferEXT, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
#endif // GL_EXT_framebuffer_blit
#ifdef GL_EXT_framebuffer_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorageMultisampleEXT, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_EXT_framebuffer_multisample
#ifdef GL_EXT_framebuffer_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFramebufferEXT, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindRenderbufferEXT, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckFramebufferStatusEXT, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFramebuffersEXT, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteRenderbuffersEXT, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferRenderbufferEXT, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture1DEXT, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture2DEXT, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture3DEXT, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenFramebuffersEXT, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenRenderbuffersEXT, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateMipmapEXT, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferAttachmentParameterivEXT, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetRenderbufferParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsFramebufferEXT, (framebuffer), (GLuint framebuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsRenderbufferEXT, (renderbuffer), (GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorageEXT, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_EXT_framebuffer_object
#ifdef GL_EXT_geometry_shader4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameteriEXT, (program, pname, value), (GLuint program, GLenum pname, GLint value))
#endif // GL_EXT_geometry_shader4
#ifdef GL_EXT_gpu_program_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameters4fvEXT, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameters4fvEXT, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLfloat *params))
#endif // GL_EXT_gpu_program_parameters
#ifdef GL_EXT_gpu_shader4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragDataLocationEXT, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetFragDataLocationEXT, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformuivEXT, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1uiEXT, (location, v0), (GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2uiEXT, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3uiEXT, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4uiEXT, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4uivEXT, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
#endif // GL_EXT_gpu_shader4
#ifdef GL_EXT_histogram
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramEXT, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmaxEXT, (target, reset, format, type, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmaxParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMinmaxParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glHistogramEXT, (target, width, internalformat, sink), (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinmaxEXT, (target, internalformat, sink), (GLenum target, GLenum internalformat, GLboolean sink))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResetHistogramEXT, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResetMinmaxEXT, (target), (GLenum target))
#endif // GL_EXT_histogram
#ifdef GL_EXT_index_func
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexFuncEXT, (func, ref), (GLenum func, GLclampf ref))
#endif // GL_EXT_index_func
#ifdef GL_EXT_index_material
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexMaterialEXT, (face, mode), (GLenum face, GLenum mode))
#endif // GL_EXT_index_material
#ifdef GL_EXT_light_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glApplyTextureEXT, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureLightEXT, (pname), (GLenum pname))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureMaterialEXT, (face, mode), (GLenum face, GLenum mode))
#endif // GL_EXT_light_texture
#ifdef GL_EXT_multi_draw_arrays
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysEXT, (mode, first, count, primcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsEXT, (mode, count, type, indices, primcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount))
#endif // GL_EXT_multi_draw_arrays
#ifdef GL_EXT_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMaskEXT, (value, invert), (GLclampf value, GLboolean invert))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplePatternEXT, (pattern), (GLenum pattern))
#endif // GL_EXT_multisample
#ifdef GL_EXT_paletted_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableEXT, (target, internalFormat, width, format, type, table), (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableEXT, (target, format, type, data), (GLenum target, GLenum format, GLenum type, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
#endif // GL_EXT_paletted_texture
#ifdef GL_EXT_pixel_transform
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPixelTransformParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPixelTransformParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTransformParameterfEXT, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTransformParameterfvEXT, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTransformParameteriEXT, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTransformParameterivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
#endif // GL_EXT_pixel_transform
#ifdef GL_EXT_point_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfEXT, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfvEXT, (pname, params), (GLenum pname, const GLfloat *params))
#endif // GL_EXT_point_parameters
#ifdef GL_EXT_polygon_offset
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonOffsetEXT, (factor, bias), (GLfloat factor, GLfloat bias))
#endif // GL_EXT_polygon_offset
#ifdef GL_EXT_polygon_offset_clamp
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonOffsetClampEXT, (factor, units, clamp), (GLfloat factor, GLfloat units, GLfloat clamp))
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_provoking_vertex
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProvokingVertexEXT, (mode), (GLenum mode))
#endif // GL_EXT_provoking_vertex
#ifdef GL_EXT_raster_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterSamplesEXT, (samples, fixedsamplelocations), (GLuint samples, GLboolean fixedsamplelocations))
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_secondary_color
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3bEXT, (red, green, blue), (GLbyte red, GLbyte green, GLbyte blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3bvEXT, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3dEXT, (red, green, blue), (GLdouble red, GLdouble green, GLdouble blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3dvEXT, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3fEXT, (red, green, blue), (GLfloat red, GLfloat green, GLfloat blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3fvEXT, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3iEXT, (red, green, blue), (GLint red, GLint green, GLint blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ivEXT, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3sEXT, (red, green, blue), (GLshort red, GLshort green, GLshort blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3svEXT, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ubEXT, (red, green, blue), (GLubyte red, GLubyte green, GLubyte blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ubvEXT, (v), (const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3uiEXT, (red, green, blue), (GLuint red, GLuint green, GLuint blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3uivEXT, (v), (const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3usEXT, (red, green, blue), (GLushort red, GLushort green, GLushort blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3usvEXT, (v), (const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorPointerEXT, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
#endif // GL_EXT_secondary_color
#ifdef GL_EXT_separate_shader_objects
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveProgramEXT, (program), (GLuint program))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShaderProgramEXT, (type, string), (GLenum type, const GLchar *string))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseShaderProgramEXT, (type, program), (GLenum type, GLuint program))
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_shader_image_load_store
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindImageTextureEXT, (index, texture, level, layered, layer, access, format), (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMemoryBarrierEXT, (barriers), (GLbitfield barriers))
#endif // GL_EXT_shader_image_load_store
#ifdef GL_EXT_stencil_clear_tag
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilClearTagEXT, (stencilTagBits, stencilClearTag), (GLsizei stencilTagBits, GLuint stencilClearTag))
#endif // GL_EXT_stencil_clear_tag
#ifdef GL_EXT_stencil_two_side
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveStencilFaceEXT, (face), (GLenum face))
#endif // GL_EXT_stencil_two_side
#ifdef GL_EXT_subtexture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage1DEXT, (target, level, xoffset, width, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage2DEXT, (target, level, xoffset, yoffset, width, height, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
#endif // GL_EXT_subtexture
#ifdef GL_EXT_texture3D
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3DEXT, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage3DEXT, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
#endif // GL_EXT_texture3D
#ifdef GL_EXT_texture_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureLayerEXT, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
#endif // GL_EXT_texture_array
#ifdef GL_EXT_texture_buffer_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBufferEXT, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
#endif // GL_EXT_texture_buffer_object
#ifdef GL_EXT_texture_integer
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearColorIiEXT, (red, green, blue, alpha), (GLint red, GLint green, GLint blue, GLint alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearColorIuiEXT, (red, green, blue, alpha), (GLuint red, GLuint green, GLuint blue, GLuint alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIuivEXT, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
#endif // GL_EXT_texture_integer
#ifdef GL_EXT_texture_object
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glAreTexturesResidentEXT, (n, textures, residences), (GLsizei n, const GLuint *textures, GLboolean *residences))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTextureEXT, (target, texture), (GLenum target, GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteTexturesEXT, (n, textures), (GLsizei n, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenTexturesEXT, (n, textures), (GLsizei n, GLuint *textures))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTextureEXT, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrioritizeTexturesEXT, (n, textures, priorities), (GLsizei n, const GLuint *textures, const GLclampf *priorities))
#endif // GL_EXT_texture_object
#ifdef GL_EXT_texture_perturb_normal
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureNormalEXT, (mode), (GLenum mode))
#endif // GL_EXT_texture_perturb_normal
#ifdef GL_EXT_timer_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjecti64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectui64vEXT, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
#endif // GL_EXT_timer_query
#ifdef GL_EXT_transform_feedback
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginTransformFeedbackEXT, (primitiveMode), (GLenum primitiveMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferBaseEXT, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferOffsetEXT, (target, index, buffer, offset), (GLenum target, GLuint index, GLuint buffer, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferRangeEXT, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndTransformFeedbackEXT, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackVaryingEXT, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackVaryingsEXT, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
#endif // GL_EXT_transform_feedback
#ifdef GL_EXT_vertex_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glArrayElementEXT, (i), (GLint i))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysEXT, (mode, first, count), (GLenum mode, GLint first, GLsizei count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEdgeFlagPointerEXT, (stride, count, pointer), (GLsizei stride, GLsizei count, const GLboolean *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPointervEXT, (pname, params), (GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexPointerEXT, (type, stride, count, pointer), (GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalPointerEXT, (type, stride, count, pointer), (GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexPointerEXT, (size, type, stride, count, pointer), (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer))
#endif // GL_EXT_vertex_array
#ifdef GL_EXT_vertex_attrib_64bit
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLdvEXT, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1dEXT, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2dEXT, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3dEXT, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4dEXT, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4dvEXT, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLPointerEXT, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
#endif // GL_EXT_vertex_attrib_64bit
#ifdef GL_EXT_vertex_shader
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginVertexShaderEXT, (), ())
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glBindLightParameterEXT, (light, value), (GLenum light, GLenum value))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glBindMaterialParameterEXT, (face, value), (GLenum face, GLenum value))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glBindParameterEXT, (value), (GLenum value))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glBindTexGenParameterEXT, (unit, coord, value), (GLenum unit, GLenum coord, GLenum value))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glBindTextureUnitParameterEXT, (unit, value), (GLenum unit, GLenum value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexShaderEXT, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteVertexShaderEXT, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVariantClientStateEXT, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVariantClientStateEXT, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndVertexShaderEXT, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glExtractComponentEXT, (res, src, num), (GLuint res, GLuint src, GLuint num))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenSymbolsEXT, (datatype, storagetype, range, components), (GLenum datatype, GLenum storagetype, GLenum range, GLuint components))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenVertexShadersEXT, (range), (GLuint range))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInvariantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInvariantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInvariantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetLocalConstantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetLocalConstantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetLocalConstantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantBooleanvEXT, (id, value, data), (GLuint id, GLenum value, GLboolean *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantFloatvEXT, (id, value, data), (GLuint id, GLenum value, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantIntegervEXT, (id, value, data), (GLuint id, GLenum value, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVariantPointervEXT, (id, value, data), (GLuint id, GLenum value, void **data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInsertComponentEXT, (res, src, num), (GLuint res, GLuint src, GLuint num))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsVariantEnabledEXT, (id, cap), (GLuint id, GLenum cap))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetInvariantEXT, (id, type, addr), (GLuint id, GLenum type, const void *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetLocalConstantEXT, (id, type, addr), (GLuint id, GLenum type, const void *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderOp1EXT, (op, res, arg1), (GLenum op, GLuint res, GLuint arg1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderOp2EXT, (op, res, arg1, arg2), (GLenum op, GLuint res, GLuint arg1, GLuint arg2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderOp3EXT, (op, res, arg1, arg2, arg3), (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSwizzleEXT, (res, in, outX, outY, outZ, outW), (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantPointerEXT, (id, type, stride, addr), (GLuint id, GLenum type, GLuint stride, const void *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantbvEXT, (id, addr), (GLuint id, const GLbyte *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantdvEXT, (id, addr), (GLuint id, const GLdouble *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantfvEXT, (id, addr), (GLuint id, const GLfloat *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantivEXT, (id, addr), (GLuint id, const GLint *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantsvEXT, (id, addr), (GLuint id, const GLshort *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantubvEXT, (id, addr), (GLuint id, const GLubyte *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantuivEXT, (id, addr), (GLuint id, const GLuint *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVariantusvEXT, (id, addr), (GLuint id, const GLushort *addr))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWriteMaskEXT, (res, in, outX, outY, outZ, outW), (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW))
#endif // GL_EXT_vertex_shader
#ifdef GL_EXT_vertex_weighting
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexWeightPointerEXT, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexWeightfEXT, (weight), (GLfloat weight))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexWeightfvEXT, (weight), (const GLfloat *weight))
#endif // GL_EXT_vertex_weighting
#ifdef GL_EXT_window_rectangles
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowRectanglesEXT, (mode, count, box), (GLenum mode, GLsizei count, const GLint *box))
#endif // GL_EXT_window_rectangles
#ifdef GL_EXT_x11_sync_object
GLATTER_FBLOCK(return, GL, GLAPI , GLsync, APIENTRY, glImportSyncEXT, (external_sync_type, external_sync, flags), (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags))
#endif // GL_EXT_x11_sync_object
#ifdef GL_GREMEDY_frame_terminator
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFrameTerminatorGREMEDY, (), ())
#endif // GL_GREMEDY_frame_terminator
#ifdef GL_GREMEDY_string_marker
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStringMarkerGREMEDY, (len, string), (GLsizei len, const void *string))
#endif // GL_GREMEDY_string_marker
#ifdef GL_HP_image_transform
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetImageTransformParameterfvHP, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetImageTransformParameterivHP, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glImageTransformParameterfHP, (target, pname, param), (GLenum target, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glImageTransformParameterfvHP, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glImageTransformParameteriHP, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glImageTransformParameterivHP, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
#endif // GL_HP_image_transform
#ifdef GL_IBM_multimode_draw_arrays
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiModeDrawArraysIBM, (mode, first, count, primcount, modestride), (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiModeDrawElementsIBM, (mode, count, type, indices, primcount, modestride), (const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride))
#endif // GL_IBM_multimode_draw_arrays
#ifdef GL_IBM_static_data
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushStaticDataIBM, (target), (GLenum target))
#endif // GL_IBM_static_data
#ifdef GL_IBM_vertex_array_lists
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEdgeFlagPointerListIBM, (stride, pointer, ptrstride), (GLint stride, const GLboolean **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalPointerListIBM, (type, stride, pointer, ptrstride), (GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexPointerListIBM, (size, type, stride, pointer, ptrstride), (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride))
#endif // GL_IBM_vertex_array_lists
#ifdef GL_INGR_blend_func_separate
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparateINGR, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
#endif // GL_INGR_blend_func_separate
#ifdef GL_INTEL_framebuffer_CMAA
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glApplyFramebufferAttachmentCMAAINTEL, (), ())
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_map_texture
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapTexture2DINTEL, (texture, level, access, stride, layout), (GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSyncTextureINTEL, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUnmapTexture2DINTEL, (texture, level), (GLuint texture, GLint level))
#endif // GL_INTEL_map_texture
#ifdef GL_INTEL_parallel_arrays
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalPointervINTEL, (type, pointer), (GLenum type, const void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexPointervINTEL, (size, type, pointer), (GLint size, GLenum type, const void **pointer))
#endif // GL_INTEL_parallel_arrays
#ifdef GL_INTEL_performance_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreatePerfQueryINTEL, (queryId, queryHandle), (GLuint queryId, GLuint *queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndPerfQueryINTEL, (queryHandle), (GLuint queryHandle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFirstPerfQueryIdINTEL, (queryId), (GLuint *queryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNextPerfQueryIdINTEL, (queryId, nextQueryId), (GLuint queryId, GLuint *nextQueryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfCounterInfoINTEL, (queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue), (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryDataINTEL, (queryHandle, flags, dataSize, data, bytesWritten), (GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryIdByNameINTEL, (queryName, queryId), (GLchar *queryName, GLuint *queryId))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPerfQueryInfoINTEL, (queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask), (GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask))
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendBarrierKHR, (), ())
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_MESA_resize_buffers
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResizeBuffersMESA, (), ())
#endif // GL_MESA_resize_buffers
#ifdef GL_MESA_window_pos
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2dMESA, (x, y), (GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2dvMESA, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2fMESA, (x, y), (GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2fvMESA, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2iMESA, (x, y), (GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2ivMESA, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2sMESA, (x, y), (GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2svMESA, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3dMESA, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3dvMESA, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3fMESA, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3fvMESA, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3iMESA, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3ivMESA, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3sMESA, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3svMESA, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4dMESA, (x, y, z, w), (GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4dvMESA, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4fMESA, (x, y, z, w), (GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4fvMESA, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4iMESA, (x, y, z, w), (GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4ivMESA, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4sMESA, (x, y, z, w), (GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos4svMESA, (v), (const GLshort *v))
#endif // GL_MESA_window_pos
#ifdef GL_NVX_conditional_render
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginConditionalRenderNVX, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndConditionalRenderNVX, (), ())
#endif // GL_NVX_conditional_render
#ifdef GL_NV_bindless_multi_draw_indirect
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirectBindlessNV, (mode, indirect, drawCount, stride, vertexBufferCount), (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirectBindlessNV, (mode, type, indirect, drawCount, stride, vertexBufferCount), (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount))
#endif // GL_NV_bindless_multi_draw_indirect
#ifdef GL_NV_bindless_multi_draw_indirect_count
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirectBindlessCountNV, (mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount), (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirectBindlessCountNV, (mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount), (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount))
#endif // GL_NV_bindless_multi_draw_indirect_count
#ifdef GL_NV_bindless_texture
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetImageHandleNV, (texture, level, layered, layer, format), (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureHandleNV, (texture), (GLuint texture))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint64, APIENTRY, glGetTextureSamplerHandleNV, (texture, sampler), (GLuint texture, GLuint sampler))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsImageHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeImageHandleResidentNV, (handle, access), (GLuint64 handle, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleNonResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeTextureHandleResidentNV, (handle), (GLuint64 handle))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64NV, (program, location, value), (GLuint program, GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformHandleui64vNV, (program, location, count, values), (GLuint program, GLint location, GLsizei count, const GLuint64 *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64NV, (location, value), (GLint location, GLuint64 value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformHandleui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64 *value))
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendBarrierNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendParameteriNV, (pname, value), (GLenum pname, GLint value))
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_clip_space_w_scaling
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportPositionWScaleNV, (index, xcoeff, ycoeff), (GLuint index, GLfloat xcoeff, GLfloat ycoeff))
#endif // GL_NV_clip_space_w_scaling
#ifdef GL_NV_command_list
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCallCommandListNV, (list), (GLuint list))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCommandListSegmentsNV, (list, segments), (GLuint list, GLuint segments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileCommandListNV, (list), (GLuint list))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateCommandListsNV, (n, lists), (GLsizei n, GLuint *lists))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateStatesNV, (n, states), (GLsizei n, GLuint *states))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteCommandListsNV, (n, lists), (GLsizei n, const GLuint *lists))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteStatesNV, (n, states), (GLsizei n, const GLuint *states))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawCommandsAddressNV, (primitiveMode, indirects, sizes, count), (GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawCommandsNV, (primitiveMode, buffer, indirects, sizes, count), (GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawCommandsStatesAddressNV, (indirects, sizes, states, fbos, count), (const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawCommandsStatesNV, (buffer, indirects, sizes, states, fbos, count), (GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetCommandHeaderNV, (tokenID, size), (GLenum tokenID, GLuint size))
GLATTER_FBLOCK(return, GL, GLAPI , GLushort, APIENTRY, glGetStageIndexNV, (shadertype), (GLenum shadertype))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsCommandListNV, (list), (GLuint list))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsStateNV, (state), (GLuint state))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glListDrawCommandsStatesClientNV, (list, segment, indirects, sizes, states, fbos, count), (GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStateCaptureNV, (state, mode), (GLuint state, GLenum mode))
#endif // GL_NV_command_list
#ifdef GL_NV_conditional_render
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginConditionalRenderNV, (id, mode), (GLuint id, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndConditionalRenderNV, (), ())
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSubpixelPrecisionBiasNV, (xbits, ybits), (GLuint xbits, GLuint ybits))
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_dilate
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConservativeRasterParameterfNV, (pname, value), (GLenum pname, GLfloat value))
#endif // GL_NV_conservative_raster_dilate
#ifdef GL_NV_conservative_raster_pre_snap_triangles
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConservativeRasterParameteriNV, (pname, param), (GLenum pname, GLint param))
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_copy_image
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyImageSubDataNV, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
#endif // GL_NV_copy_image
#ifdef GL_NV_depth_buffer_float
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepthdNV, (depth), (GLdouble depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthBoundsdNV, (zmin, zmax), (GLdouble zmin, GLdouble zmax))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangedNV, (zNear, zFar), (GLdouble zNear, GLdouble zFar))
#endif // GL_NV_depth_buffer_float
#ifdef GL_NV_draw_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTextureNV, (texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1), (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1))
#endif // GL_NV_draw_texture
#ifdef GL_NV_evaluators
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvalMapsNV, (target, mode), (GLenum target, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapAttribParameterfvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapAttribParameterivNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapControlPointsNV, (target, index, type, ustride, vstride, packed, points), (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapParameterfvNV, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapParameterivNV, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapControlPointsNV, (target, index, type, ustride, vstride, uorder, vorder, packed, points), (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapParameterfvNV, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapParameterivNV, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
#endif // GL_NV_evaluators
#ifdef GL_NV_explicit_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMultisamplefvNV, (pname, index, val), (GLenum pname, GLuint index, GLfloat *val))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMaskIndexedNV, (index, mask), (GLuint index, GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexRenderbufferNV, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
#endif // GL_NV_explicit_multisample
#ifdef GL_NV_fence
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFencesNV, (n, fences), (GLsizei n, const GLuint *fences))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinishFenceNV, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenFencesNV, (n, fences), (GLsizei n, GLuint *fences))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFenceivNV, (fence, pname, params), (GLuint fence, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsFenceNV, (fence), (GLuint fence))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSetFenceNV, (fence, condition), (GLuint fence, GLenum condition))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glTestFenceNV, (fence), (GLuint fence))
#endif // GL_NV_fence
#ifdef GL_NV_fragment_coverage_to_color
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentCoverageColorNV, (color), (GLuint color))
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_fragment_program
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramNamedParameterdvNV, (id, len, name, params), (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramNamedParameterfvNV, (id, len, name, params), (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramNamedParameter4dNV, (id, len, name, x, y, z, w), (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramNamedParameter4dvNV, (id, len, name, v), (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramNamedParameter4fNV, (id, len, name, x, y, z, w), (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramNamedParameter4fvNV, (id, len, name, v), (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v))
#endif // GL_NV_fragment_program
#ifdef GL_NV_framebuffer_mixed_samples
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverageModulationNV, (components), (GLenum components))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverageModulationTableNV, (n, v), (GLsizei n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCoverageModulationTableNV, (bufsize, v), (GLsizei bufsize, GLfloat *v))
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_framebuffer_multisample_coverage
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorageMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalformat, width, height), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height))
#endif // GL_NV_framebuffer_multisample_coverage
#ifdef GL_NV_geometry_program4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureEXT, (target, attachment, texture, level), (GLenum target, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureFaceEXT, (target, attachment, texture, level, face), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramVertexLimitNV, (target, limit), (GLenum target, GLint limit))
#endif // GL_NV_geometry_program4
#ifdef GL_NV_gpu_program4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramEnvParameterIivNV, (target, index, params), (GLenum target, GLuint index, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramEnvParameterIuivNV, (target, index, params), (GLenum target, GLuint index, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramLocalParameterIivNV, (target, index, params), (GLenum target, GLuint index, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramLocalParameterIuivNV, (target, index, params), (GLenum target, GLuint index, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameterI4iNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameterI4ivNV, (target, index, params), (GLenum target, GLuint index, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameterI4uiNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParameterI4uivNV, (target, index, params), (GLenum target, GLuint index, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParametersI4ivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramEnvParametersI4uivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameterI4iNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameterI4ivNV, (target, index, params), (GLenum target, GLuint index, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameterI4uiNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParameterI4uivNV, (target, index, params), (GLenum target, GLuint index, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParametersI4ivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramLocalParametersI4uivNV, (target, index, count, params), (GLenum target, GLuint index, GLsizei count, const GLuint *params))
#endif // GL_NV_gpu_program4
#ifdef GL_NV_gpu_program5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramSubroutineParameteruivNV, (target, index, param), (GLenum target, GLuint index, GLuint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramSubroutineParametersuivNV, (target, count, params), (GLenum target, GLsizei count, const GLuint *params))
#endif // GL_NV_gpu_program5
#ifdef GL_NV_half_float
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3hNV, (red, green, blue), (GLhalfNV red, GLhalfNV green, GLhalfNV blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4hNV, (red, green, blue, alpha), (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordhNV, (fog), (GLhalfNV fog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordhvNV, (fog), (const GLhalfNV *fog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1hNV, (target, s), (GLenum target, GLhalfNV s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2hNV, (target, s, t), (GLenum target, GLhalfNV s, GLhalfNV t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3hNV, (target, s, t, r), (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4hNV, (target, s, t, r, q), (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4hvNV, (target, v), (GLenum target, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3hNV, (nx, ny, nz), (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3hNV, (red, green, blue), (GLhalfNV red, GLhalfNV green, GLhalfNV blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1hNV, (s), (GLhalfNV s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2hNV, (s, t), (GLhalfNV s, GLhalfNV t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3hNV, (s, t, r), (GLhalfNV s, GLhalfNV t, GLhalfNV r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4hNV, (s, t, r, q), (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2hNV, (x, y), (GLhalfNV x, GLhalfNV y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3hNV, (x, y, z), (GLhalfNV x, GLhalfNV y, GLhalfNV z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4hNV, (x, y, z, w), (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4hvNV, (v), (const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1hNV, (index, x), (GLuint index, GLhalfNV x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2hNV, (index, x, y), (GLuint index, GLhalfNV x, GLhalfNV y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3hNV, (index, x, y, z), (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4hNV, (index, x, y, z, w), (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4hvNV, (index, v), (GLuint index, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs1hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs2hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs3hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs4hvNV, (index, n, v), (GLuint index, GLsizei n, const GLhalfNV *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexWeighthNV, (weight), (GLhalfNV weight))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexWeighthvNV, (weight), (const GLhalfNV *weight))
#endif // GL_NV_half_float
#ifdef GL_NV_internalformat_sample_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformatSampleivNV, (target, internalformat, samples, pname, bufSize, params), (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params))
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_occlusion_query
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginOcclusionQueryNV, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteOcclusionQueriesNV, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndOcclusionQueryNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenOcclusionQueriesNV, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetOcclusionQueryivNV, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetOcclusionQueryuivNV, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsOcclusionQueryNV, (id), (GLuint id))
#endif // GL_NV_occlusion_query
#ifdef GL_NV_parameter_buffer_object
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramBufferParametersIivNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramBufferParametersIuivNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramBufferParametersfvNV, (target, bindingIndex, wordIndex, count, params), (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params))
#endif // GL_NV_parameter_buffer_object
#ifdef GL_NV_path_rendering
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyPathNV, (resultPath, srcPath), (GLuint resultPath, GLuint srcPath))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverFillPathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCoverStrokePathNV, (path, coverMode), (GLuint path, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeletePathsNV, (path, range), (GLuint path, GLsizei range))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenPathsNV, (range), (GLsizei range))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathColorGenfvNV, (color, pname, value), (GLenum color, GLenum pname, GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathColorGenivNV, (color, pname, value), (GLenum color, GLenum pname, GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathCommandsNV, (path, commands), (GLuint path, GLubyte *commands))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathCoordsNV, (path, coords), (GLuint path, GLfloat *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathDashArrayNV, (path, dashArray), (GLuint path, GLfloat *dashArray))
GLATTER_FBLOCK(return, GL, GLAPI , GLfloat, APIENTRY, glGetPathLengthNV, (path, startSegment, numSegments), (GLuint path, GLsizei startSegment, GLsizei numSegments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathMetricRangeNV, (metricQueryMask, firstPathName, numPaths, stride, metrics), (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathMetricsNV, (metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics), (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathSpacingNV, (pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing), (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathTexGenfvNV, (texCoordSet, pname, value), (GLenum texCoordSet, GLenum pname, GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPathTexGenivNV, (texCoordSet, pname, value), (GLenum texCoordSet, GLenum pname, GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourcefvNV, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInterpolatePathsNV, (resultPath, pathA, pathB, weight), (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPathNV, (path), (GLuint path))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPointInFillPathNV, (path, mask, x, y), (GLuint path, GLuint mask, GLfloat x, GLfloat y))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsPointInStrokePathNV, (path, x, y), (GLuint path, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoad3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoad3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixLoadTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMult3x2fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMult3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMatrixMultTranspose3x3fNV, (matrixMode, m), (GLenum matrixMode, const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathColorGenNV, (color, genMode, colorFormat, coeffs), (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCommandsNV, (path, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCoordsNV, (path, numCoords, coordType, coords), (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathCoverDepthFuncNV, (func), (GLenum func))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathDashArrayNV, (path, dashCount, dashArray), (GLuint path, GLsizei dashCount, const GLfloat *dashArray))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathFogGenNV, (genMode), (GLenum genMode))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathGlyphIndexArrayNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathGlyphIndexRangeNV, (fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount), (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathGlyphRangeNV, (firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathGlyphsNV, (firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glPathMemoryGlyphIndexArrayNV, (firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale), (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterfNV, (path, pname, value), (GLuint path, GLenum pname, GLfloat value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterfvNV, (path, pname, value), (GLuint path, GLenum pname, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameteriNV, (path, pname, value), (GLuint path, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathParameterivNV, (path, pname, value), (GLuint path, GLenum pname, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStencilDepthOffsetNV, (factor, units), (GLfloat factor, GLfloat units))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStencilFuncNV, (func, ref, mask), (GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathStringNV, (path, format, length, pathString), (GLuint path, GLenum format, GLsizei length, const void *pathString))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathSubCommandsNV, (path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords), (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathSubCoordsNV, (path, coordStart, numCoords, coordType, coords), (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPathTexGenNV, (texCoordSet, genMode, components, coeffs), (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glPointAlongPathNV, (path, startSegment, numSegments, distance, x, y, tangentX, tangentY), (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramPathFragmentInputGenNV, (program, location, genMode, components, coeffs), (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFillPathNV, (path, fillMode, mask), (GLuint path, GLenum fillMode, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilStrokePathNV, (path, reference, mask), (GLuint path, GLint reference, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverFillPathInstancedNV, (numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverFillPathNV, (path, fillMode, mask, coverMode), (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverStrokePathInstancedNV, (numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues), (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilThenCoverStrokePathNV, (path, reference, mask, coverMode), (GLuint path, GLint reference, GLuint mask, GLenum coverMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformPathNV, (resultPath, srcPath, transformType, transformValues), (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWeightPathsNV, (resultPath, numPaths, paths, weights), (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights))
#endif // GL_NV_path_rendering
#ifdef GL_NV_pixel_data_range
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushPixelDataRangeNV, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelDataRangeNV, (target, length, pointer), (GLenum target, GLsizei length, const void *pointer))
#endif // GL_NV_pixel_data_range
#ifdef GL_NV_point_sprite
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameteriNV, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterivNV, (pname, params), (GLenum pname, const GLint *params))
#endif // GL_NV_point_sprite
#ifdef GL_NV_present_video
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoi64vNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoivNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoui64vNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideouivNV, (video_slot, pname, params), (GLuint video_slot, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPresentFrameDualFillNV, (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3), (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPresentFrameKeyedNV, (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1), (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1))
#endif // GL_NV_present_video
#ifdef GL_NV_primitive_restart
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrimitiveRestartIndexNV, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrimitiveRestartNV, (), ())
#endif // GL_NV_primitive_restart
#ifdef GL_NV_register_combiners
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerInputNV, (stage, portion, variable, input, mapping, componentUsage), (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerOutputNV, (stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum), (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerParameterfNV, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerParameterfvNV, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerParameteriNV, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerParameterivNV, (pname, params), (GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinalCombinerInputNV, (variable, input, mapping, componentUsage), (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCombinerInputParameterfvNV, (stage, portion, variable, pname, params), (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCombinerInputParameterivNV, (stage, portion, variable, pname, params), (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCombinerOutputParameterfvNV, (stage, portion, pname, params), (GLenum stage, GLenum portion, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCombinerOutputParameterivNV, (stage, portion, pname, params), (GLenum stage, GLenum portion, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFinalCombinerInputParameterfvNV, (variable, pname, params), (GLenum variable, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFinalCombinerInputParameterivNV, (variable, pname, params), (GLenum variable, GLenum pname, GLint *params))
#endif // GL_NV_register_combiners
#ifdef GL_NV_register_combiners2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCombinerStageParameterfvNV, (stage, pname, params), (GLenum stage, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCombinerStageParameterfvNV, (stage, pname, params), (GLenum stage, GLenum pname, GLfloat *params))
#endif // GL_NV_register_combiners2
#ifdef GL_NV_sample_locations
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferSampleLocationsfvNV, (target, start, count, v), (GLenum target, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferSampleLocationsfvNV, (framebuffer, start, count, v), (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResolveDepthValuesNV, (), ())
#endif // GL_NV_sample_locations
#ifdef GL_NV_shader_buffer_load
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameterui64vNV, (target, pname, params), (GLenum target, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegerui64vNV, (value, result), (GLenum value, GLuint64EXT *result))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameterui64vNV, (buffer, pname, params), (GLuint buffer, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsBufferResidentNV, (target), (GLenum target))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsNamedBufferResidentNV, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeBufferNonResidentNV, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeBufferResidentNV, (target, access), (GLenum target, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeNamedBufferNonResidentNV, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMakeNamedBufferResidentNV, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformui64NV, (program, location, value), (GLuint program, GLint location, GLuint64EXT value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformui64vNV, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformui64NV, (location, value), (GLint location, GLuint64EXT value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformui64vNV, (location, count, value), (GLint location, GLsizei count, const GLuint64EXT *value))
#endif // GL_NV_shader_buffer_load
#ifdef GL_NV_texture_barrier
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBarrierNV, (), ())
#endif // GL_NV_texture_barrier
#ifdef GL_NV_texture_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage2DMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3DMultisampleCoverageNV, (target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations), (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage2DMultisampleCoverageNV, (texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage2DMultisampleNV, (texture, target, samples, internalFormat, width, height, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage3DMultisampleCoverageNV, (texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureImage3DMultisampleNV, (texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations), (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations))
#endif // GL_NV_texture_multisample
#ifdef GL_NV_transform_feedback
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveVaryingNV, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginTransformFeedbackNV, (primitiveMode), (GLenum primitiveMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferBaseNV, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferOffsetNV, (target, index, buffer, offset), (GLenum target, GLuint index, GLuint buffer, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferRangeNV, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndTransformFeedbackNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveVaryingNV, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackVaryingNV, (program, index, location), (GLuint program, GLuint index, GLint *location))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetVaryingLocationNV, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackAttribsNV, (count, attribs, bufferMode), (GLsizei count, const GLint *attribs, GLenum bufferMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackStreamAttribsNV, (count, attribs, nbuffers, bufstreams, bufferMode), (GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackVaryingsNV, (program, count, locations, bufferMode), (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode))
#endif // GL_NV_transform_feedback
#ifdef GL_NV_transform_feedback2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTransformFeedbackNV, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteTransformFeedbacksNV, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackNV, (mode, id), (GLenum mode, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenTransformFeedbacksNV, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTransformFeedbackNV, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPauseTransformFeedbackNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResumeTransformFeedbackNV, (), ())
#endif // GL_NV_transform_feedback2
#ifdef GL_NV_vdpau_interop
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUFiniNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUGetSurfaceivNV, (surface, pname, bufSize, length, values), (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUInitNV, (vdpDevice, getProcAddress), (const void *vdpDevice, const void *getProcAddress))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glVDPAUIsSurfaceNV, (surface), (GLvdpauSurfaceNV surface))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUMapSurfacesNV, (numSurfaces, surfaces), (GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces))
GLATTER_FBLOCK(return, GL, GLAPI , GLvdpauSurfaceNV, APIENTRY, glVDPAURegisterOutputSurfaceNV, (vdpSurface, target, numTextureNames, textureNames), (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames))
GLATTER_FBLOCK(return, GL, GLAPI , GLvdpauSurfaceNV, APIENTRY, glVDPAURegisterVideoSurfaceNV, (vdpSurface, target, numTextureNames, textureNames), (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUSurfaceAccessNV, (surface, access), (GLvdpauSurfaceNV surface, GLenum access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUUnmapSurfacesNV, (numSurface, surfaces), (GLsizei numSurface, const GLvdpauSurfaceNV *surfaces))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVDPAUUnregisterSurfaceNV, (surface), (GLvdpauSurfaceNV surface))
#endif // GL_NV_vdpau_interop
#ifdef GL_NV_vertex_array_range
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushVertexArrayRangeNV, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayRangeNV, (length, pointer), (GLsizei length, const void *pointer))
#endif // GL_NV_vertex_array_range
#ifdef GL_NV_vertex_attrib_integer_64bit
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLi64vNV, (index, pname, params), (GLuint index, GLenum pname, GLint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLui64vNV, (index, pname, params), (GLuint index, GLenum pname, GLuint64EXT *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1i64NV, (index, x), (GLuint index, GLint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64NV, (index, x), (GLuint index, GLuint64EXT x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2i64NV, (index, x, y), (GLuint index, GLint64EXT x, GLint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2ui64NV, (index, x, y), (GLuint index, GLuint64EXT x, GLuint64EXT y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3i64NV, (index, x, y, z), (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3ui64NV, (index, x, y, z), (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4i64NV, (index, x, y, z, w), (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4i64vNV, (index, v), (GLuint index, const GLint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4ui64NV, (index, x, y, z, w), (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4ui64vNV, (index, v), (GLuint index, const GLuint64EXT *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLFormatNV, (index, size, type, stride), (GLuint index, GLint size, GLenum type, GLsizei stride))
#endif // GL_NV_vertex_attrib_integer_64bit
#ifdef GL_NV_vertex_buffer_unified_memory
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferAddressRangeNV, (pname, index, address, length), (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEdgeFlagFormatNV, (stride), (GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegerui64i_vNV, (value, index, result), (GLenum value, GLuint index, GLuint64EXT *result))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalFormatNV, (type, stride), (GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribFormatNV, (index, size, type, normalized, stride), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIFormatNV, (index, size, type, stride), (GLuint index, GLint size, GLenum type, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexFormatNV, (size, type, stride), (GLint size, GLenum type, GLsizei stride))
#endif // GL_NV_vertex_buffer_unified_memory
#ifdef GL_NV_vertex_program
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glAreProgramsResidentNV, (n, programs, residences), (GLsizei n, const GLuint *programs, GLboolean *residences))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindProgramNV, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgramsNV, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glExecuteProgramNV, (target, id, params), (GLenum target, GLuint id, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenProgramsNV, (n, programs), (GLsizei n, GLuint *programs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramParameterdvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramParameterfvNV, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramStringNV, (id, pname, program), (GLuint id, GLenum pname, GLubyte *program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramivNV, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTrackMatrixivNV, (target, address, pname, params), (GLenum target, GLuint address, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribPointervNV, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribdvNV, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribfvNV, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribivNV, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgramNV, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadProgramNV, (target, id, len, program), (GLenum target, GLuint id, GLsizei len, const GLubyte *program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameter4dNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameter4dvNV, (target, index, v), (GLenum target, GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameter4fNV, (target, index, x, y, z, w), (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameter4fvNV, (target, index, v), (GLenum target, GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameters4dvNV, (target, index, count, v), (GLenum target, GLuint index, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameters4fvNV, (target, index, count, v), (GLenum target, GLuint index, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRequestResidentProgramsNV, (n, programs), (GLsizei n, const GLuint *programs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTrackMatrixNV, (target, address, matrix, transform), (GLenum target, GLuint address, GLenum matrix, GLenum transform))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dNV, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fNV, (index, x), (GLuint index, GLfloat x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1sNV, (index, x), (GLuint index, GLshort x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dNV, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fNV, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2sNV, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dNV, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fNV, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3sNV, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dNV, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dvNV, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fNV, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fvNV, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4sNV, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4svNV, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ubNV, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ubvNV, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribPointerNV, (index, fsize, type, stride, pointer), (GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs1dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs1fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs1svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs2dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs2fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs2svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs3dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs3fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs3svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs4dvNV, (index, count, v), (GLuint index, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs4fvNV, (index, count, v), (GLuint index, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs4svNV, (index, count, v), (GLuint index, GLsizei count, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribs4ubvNV, (index, count, v), (GLuint index, GLsizei count, const GLubyte *v))
#endif // GL_NV_vertex_program
#ifdef GL_NV_vertex_program4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIivEXT, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIuivEXT, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1iEXT, (index, x), (GLuint index, GLint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1uiEXT, (index, x), (GLuint index, GLuint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2iEXT, (index, x, y), (GLuint index, GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2uiEXT, (index, x, y), (GLuint index, GLuint x, GLuint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3iEXT, (index, x, y, z), (GLuint index, GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3uiEXT, (index, x, y, z), (GLuint index, GLuint x, GLuint y, GLuint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4bvEXT, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4iEXT, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ivEXT, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4svEXT, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ubvEXT, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4uiEXT, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4uivEXT, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4usvEXT, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIPointerEXT, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
#endif // GL_NV_vertex_program4
#ifdef GL_NV_video_capture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginVideoCaptureNV, (video_capture_slot), (GLuint video_capture_slot))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVideoCaptureStreamBufferNV, (video_capture_slot, stream, frame_region, offset), (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVideoCaptureStreamTextureNV, (video_capture_slot, stream, frame_region, target, texture), (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndVideoCaptureNV, (video_capture_slot), (GLuint video_capture_slot))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoCaptureStreamdvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoCaptureStreamfvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoCaptureStreamivNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVideoCaptureivNV, (video_capture_slot, pname, params), (GLuint video_capture_slot, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glVideoCaptureNV, (video_capture_slot, sequence_num, capture_time), (GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVideoCaptureStreamParameterdvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVideoCaptureStreamParameterfvNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVideoCaptureStreamParameterivNV, (video_capture_slot, stream, pname, params), (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params))
#endif // GL_NV_video_capture
#ifdef GL_NV_viewport_swizzle
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportSwizzleNV, (index, swizzlex, swizzley, swizzlez, swizzlew), (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew))
#endif // GL_NV_viewport_swizzle
#ifdef GL_OES_byte_coordinates
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1bOES, (texture, s), (GLenum texture, GLbyte s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2bOES, (texture, s, t), (GLenum texture, GLbyte s, GLbyte t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3bOES, (texture, s, t, r), (GLenum texture, GLbyte s, GLbyte t, GLbyte r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4bOES, (texture, s, t, r, q), (GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4bvOES, (texture, coords), (GLenum texture, const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1bOES, (s), (GLbyte s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2bOES, (s, t), (GLbyte s, GLbyte t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3bOES, (s, t, r), (GLbyte s, GLbyte t, GLbyte r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4bOES, (s, t, r, q), (GLbyte s, GLbyte t, GLbyte r, GLbyte q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2bOES, (x, y), (GLbyte x, GLbyte y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3bOES, (x, y, z), (GLbyte x, GLbyte y, GLbyte z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3bvOES, (coords), (const GLbyte *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4bOES, (x, y, z, w), (GLbyte x, GLbyte y, GLbyte z, GLbyte w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4bvOES, (coords), (const GLbyte *coords))
#endif // GL_OES_byte_coordinates
#ifdef GL_OES_fixed_point
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAccumxOES, (op, value), (GLenum op, GLfixed value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAlphaFuncxOES, (func, ref), (GLenum func, GLfixed ref))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBitmapxOES, (width, height, xorig, yorig, xmove, ymove, bitmap), (GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendColorxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearAccumxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearColorxOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepthxOES, (depth), (GLfixed depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClipPlanexOES, (plane, equation), (GLenum plane, const GLfixed *equation))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3xOES, (red, green, blue), (GLfixed red, GLfixed green, GLfixed blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3xvOES, (components), (const GLfixed *components))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4xOES, (red, green, blue, alpha), (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4xvOES, (components), (const GLfixed *components))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glConvolutionParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangexOES, (n, f), (GLfixed n, GLfixed f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvalCoord1xOES, (u), (GLfixed u))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvalCoord1xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvalCoord2xOES, (u, v), (GLfixed u, GLfixed v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEvalCoord2xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFeedbackBufferxOES, (n, type, buffer), (GLsizei n, GLenum type, const GLfixed *buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogxvOES, (pname, param), (GLenum pname, const GLfixed *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFrustumxOES, (l, r, b, t, n, f), (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetClipPlanexOES, (plane, equation), (GLenum plane, GLfixed *equation))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetConvolutionParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFixedvOES, (pname, params), (GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetHistogramParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetLightxOES, (light, pname, params), (GLenum light, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMapxvOES, (target, query, v), (GLenum target, GLenum query, GLfixed *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetMaterialxOES, (face, pname, param), (GLenum face, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPixelMapxv, (map, size, values), (GLenum map, GLint size, GLfixed *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexEnvxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexGenxvOES, (coord, pname, params), (GLenum coord, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexLevelParameterxvOES, (target, level, pname, params), (GLenum target, GLint level, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexxOES, (component), (GLfixed component))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIndexxvOES, (component), (const GLfixed *component))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLightModelxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLightModelxvOES, (pname, param), (GLenum pname, const GLfixed *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLightxOES, (light, pname, param), (GLenum light, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLightxvOES, (light, pname, params), (GLenum light, GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLineWidthxOES, (width), (GLfixed width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadMatrixxOES, (m), (const GLfixed *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadTransposeMatrixxOES, (m), (const GLfixed *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMap1xOES, (target, u1, u2, stride, order, points), (GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMap2xOES, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapGrid1xOES, (n, u1, u2), (GLint n, GLfixed u1, GLfixed u2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMapGrid2xOES, (n, u1, u2, v1, v2), (GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMaterialxOES, (face, pname, param), (GLenum face, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMaterialxvOES, (face, pname, param), (GLenum face, GLenum pname, const GLfixed *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultMatrixxOES, (m), (const GLfixed *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultTransposeMatrixxOES, (m), (const GLfixed *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1xOES, (texture, s), (GLenum texture, GLfixed s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2xOES, (texture, s, t), (GLenum texture, GLfixed s, GLfixed t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3xOES, (texture, s, t, r), (GLenum texture, GLfixed s, GLfixed t, GLfixed r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4xOES, (texture, s, t, r, q), (GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4xvOES, (texture, coords), (GLenum texture, const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3xOES, (nx, ny, nz), (GLfixed nx, GLfixed ny, GLfixed nz))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glOrthoxOES, (l, r, b, t, n, f), (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPassThroughxOES, (token), (GLfixed token))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelMapx, (map, size, values), (GLenum map, GLint size, const GLfixed *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelStorex, (pname, param), (GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTransferxOES, (pname, param), (GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelZoomxOES, (xfactor, yfactor), (GLfixed xfactor, GLfixed yfactor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterxvOES, (pname, params), (GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointSizexOES, (size), (GLfixed size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPolygonOffsetxOES, (factor, units), (GLfixed factor, GLfixed units))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrioritizeTexturesxOES, (n, textures, priorities), (GLsizei n, const GLuint *textures, const GLfixed *priorities))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos2xOES, (x, y), (GLfixed x, GLfixed y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos2xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos3xOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos3xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos4xOES, (x, y, z, w), (GLfixed x, GLfixed y, GLfixed z, GLfixed w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRasterPos4xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRectxOES, (x1, y1, x2, y2), (GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRectxvOES, (v1, v2), (const GLfixed *v1, const GLfixed *v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRotatexOES, (angle, x, y, z), (GLfixed angle, GLfixed x, GLfixed y, GLfixed z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScalexOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1xOES, (s), (GLfixed s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord1xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2xOES, (s, t), (GLfixed s, GLfixed t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3xOES, (s, t, r), (GLfixed s, GLfixed t, GLfixed r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord3xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4xOES, (s, t, r, q), (GLfixed s, GLfixed t, GLfixed r, GLfixed q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexEnvxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexEnvxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexGenxOES, (coord, pname, param), (GLenum coord, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexGenxvOES, (coord, pname, params), (GLenum coord, GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterxOES, (target, pname, param), (GLenum target, GLenum pname, GLfixed param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterxvOES, (target, pname, params), (GLenum target, GLenum pname, const GLfixed *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTranslatexOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2xOES, (x), (GLfixed x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex2xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3xOES, (x, y), (GLfixed x, GLfixed y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex3xvOES, (coords), (const GLfixed *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4xOES, (x, y, z), (GLfixed x, GLfixed y, GLfixed z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertex4xvOES, (coords), (const GLfixed *coords))
#endif // GL_OES_fixed_point
#ifdef GL_OES_query_matrix
GLATTER_FBLOCK(return, GL, GLAPI , GLbitfield, APIENTRY, glQueryMatrixxOES, (mantissa, exponent), (GLfixed *mantissa, GLint *exponent))
#endif // GL_OES_query_matrix
#ifdef GL_OES_single_precision
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepthfOES, (depth), (GLclampf depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClipPlanefOES, (plane, equation), (GLenum plane, const GLfloat *equation))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangefOES, (n, f), (GLclampf n, GLclampf f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFrustumfOES, (l, r, b, t, n, f), (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetClipPlanefOES, (plane, equation), (GLenum plane, GLfloat *equation))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glOrthofOES, (l, r, b, t, n, f), (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f))
#endif // GL_OES_single_precision
#ifdef GL_OVR_multiview
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureMultiviewOVR, (target, attachment, texture, level, baseViewIndex, numViews), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews))
#endif // GL_OVR_multiview
#ifdef GL_PGI_misc_hints
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glHintPGI, (target, mode), (GLenum target, GLint mode))
#endif // GL_PGI_misc_hints
#ifdef GL_SGIS_detail_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDetailTexFuncSGIS, (target, n, points), (GLenum target, GLsizei n, const GLfloat *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDetailTexFuncSGIS, (target, points), (GLenum target, GLfloat *points))
#endif // GL_SGIS_detail_texture
#ifdef GL_SGIS_fog_function
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogFuncSGIS, (n, points), (GLsizei n, const GLfloat *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFogFuncSGIS, (points), (GLfloat *points))
#endif // GL_SGIS_fog_function
#ifdef GL_SGIS_multisample
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleMaskSGIS, (value, invert), (GLclampf value, GLboolean invert))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplePatternSGIS, (pattern), (GLenum pattern))
#endif // GL_SGIS_multisample
#ifdef GL_SGIS_pixel_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPixelTexGenParameterfvSGIS, (pname, params), (GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetPixelTexGenParameterivSGIS, (pname, params), (GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTexGenParameterfSGIS, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTexGenParameterfvSGIS, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTexGenParameteriSGIS, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTexGenParameterivSGIS, (pname, params), (GLenum pname, const GLint *params))
#endif // GL_SGIS_pixel_texture
#ifdef GL_SGIS_point_parameters
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfSGIS, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfvSGIS, (pname, params), (GLenum pname, const GLfloat *params))
#endif // GL_SGIS_point_parameters
#ifdef GL_SGIS_sharpen_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSharpenTexFuncSGIS, (target, points), (GLenum target, GLfloat *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSharpenTexFuncSGIS, (target, n, points), (GLenum target, GLsizei n, const GLfloat *points))
#endif // GL_SGIS_sharpen_texture
#ifdef GL_SGIS_texture4D
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage4DSGIS, (target, level, internalformat, width, height, depth, size4d, border, format, type, pixels), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage4DSGIS, (target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels))
#endif // GL_SGIS_texture4D
#ifdef GL_SGIS_texture_color_mask
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureColorMaskSGIS, (red, green, blue, alpha), (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha))
#endif // GL_SGIS_texture_color_mask
#ifdef GL_SGIS_texture_filter4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexFilterFuncSGIS, (target, filter, weights), (GLenum target, GLenum filter, GLfloat *weights))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexFilterFuncSGIS, (target, filter, n, weights), (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights))
#endif // GL_SGIS_texture_filter4
#ifdef GL_SGIX_async
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAsyncMarkerSGIX, (marker), (GLuint marker))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteAsyncMarkersSGIX, (marker, range), (GLuint marker, GLsizei range))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glFinishAsyncSGIX, (markerp), (GLuint *markerp))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGenAsyncMarkersSGIX, (range), (GLsizei range))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsAsyncMarkerSGIX, (marker), (GLuint marker))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glPollAsyncSGIX, (markerp), (GLuint *markerp))
#endif // GL_SGIX_async
#ifdef GL_SGIX_flush_raster
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushRasterSGIX, (), ())
#endif // GL_SGIX_flush_raster
#ifdef GL_SGIX_fragment_lighting
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentColorMaterialSGIX, (face, mode), (GLenum face, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightModelfSGIX, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightModelfvSGIX, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightModeliSGIX, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightModelivSGIX, (pname, params), (GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightfSGIX, (light, pname, param), (GLenum light, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightfvSGIX, (light, pname, params), (GLenum light, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightiSGIX, (light, pname, param), (GLenum light, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentLightivSGIX, (light, pname, params), (GLenum light, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentMaterialfSGIX, (face, pname, param), (GLenum face, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentMaterialfvSGIX, (face, pname, params), (GLenum face, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentMaterialiSGIX, (face, pname, param), (GLenum face, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFragmentMaterialivSGIX, (face, pname, params), (GLenum face, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFragmentLightfvSGIX, (light, pname, params), (GLenum light, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFragmentLightivSGIX, (light, pname, params), (GLenum light, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFragmentMaterialfvSGIX, (face, pname, params), (GLenum face, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFragmentMaterialivSGIX, (face, pname, params), (GLenum face, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLightEnviSGIX, (pname, param), (GLenum pname, GLint param))
#endif // GL_SGIX_fragment_lighting
#ifdef GL_SGIX_framezoom
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFrameZoomSGIX, (factor), (GLint factor))
#endif // GL_SGIX_framezoom
#ifdef GL_SGIX_igloo_interface
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glIglooInterfaceSGIX, (pname, params), (GLenum pname, const void *params))
#endif // GL_SGIX_igloo_interface
#ifdef GL_SGIX_instruments
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetInstrumentsSGIX, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInstrumentsBufferSGIX, (size, buffer), (GLsizei size, GLint *buffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glPollInstrumentsSGIX, (marker_p), (GLint *marker_p))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadInstrumentsSGIX, (marker), (GLint marker))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStartInstrumentsSGIX, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStopInstrumentsSGIX, (marker), (GLint marker))
#endif // GL_SGIX_instruments
#ifdef GL_SGIX_list_priority
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetListParameterfvSGIX, (list, pname, params), (GLuint list, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetListParameterivSGIX, (list, pname, params), (GLuint list, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glListParameterfSGIX, (list, pname, param), (GLuint list, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glListParameterfvSGIX, (list, pname, params), (GLuint list, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glListParameteriSGIX, (list, pname, param), (GLuint list, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glListParameterivSGIX, (list, pname, params), (GLuint list, GLenum pname, const GLint *params))
#endif // GL_SGIX_list_priority
#ifdef GL_SGIX_pixel_texture
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPixelTexGenSGIX, (mode), (GLenum mode))
#endif // GL_SGIX_pixel_texture
#ifdef GL_SGIX_polynomial_ffd
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeformSGIX, (mask), (GLbitfield mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeformationMap3dSGIX, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points), (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeformationMap3fSGIX, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points), (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadIdentityDeformationMapSGIX, (mask), (GLbitfield mask))
#endif // GL_SGIX_polynomial_ffd
#ifdef GL_SGIX_reference_plane
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReferencePlaneSGIX, (equation), (const GLdouble *equation))
#endif // GL_SGIX_reference_plane
#ifdef GL_SGIX_sprite
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSpriteParameterfSGIX, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSpriteParameterfvSGIX, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSpriteParameteriSGIX, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSpriteParameterivSGIX, (pname, params), (GLenum pname, const GLint *params))
#endif // GL_SGIX_sprite
#ifdef GL_SGIX_tag_sample_buffer
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTagSampleBufferSGIX, (), ())
#endif // GL_SGIX_tag_sample_buffer
#ifdef GL_SGI_color_table
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableParameterfvSGI, (target, pname, params), (GLenum target, GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableParameterivSGI, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorTableSGI, (target, internalformat, width, format, type, table), (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyColorTableSGI, (target, internalformat, x, y, width), (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameterfvSGI, (target, pname, params), (GLenum target, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableParameterivSGI, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetColorTableSGI, (target, format, type, table), (GLenum target, GLenum format, GLenum type, void *table))
#endif // GL_SGI_color_table
#ifdef GL_SUNX_constant_data
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFinishTextureSUNX, (), ())
#endif // GL_SUNX_constant_data
#ifdef GL_SUN_global_alpha
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactorbSUN, (factor), (GLbyte factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactordSUN, (factor), (GLdouble factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactorfSUN, (factor), (GLfloat factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactoriSUN, (factor), (GLint factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactorsSUN, (factor), (GLshort factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactorubSUN, (factor), (GLubyte factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactoruiSUN, (factor), (GLuint factor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGlobalAlphaFactorusSUN, (factor), (GLushort factor))
#endif // GL_SUN_global_alpha
#ifdef GL_SUN_mesh_array
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawMeshArraysSUN, (mode, first, count, width), (GLenum mode, GLint first, GLsizei count, GLsizei width))
#endif // GL_SUN_mesh_array
#ifdef GL_SUN_triangle_list
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodePointerSUN, (type, stride, pointer), (GLenum type, GLsizei stride, const void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeubSUN, (code), (GLubyte code))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeubvSUN, (code), (const GLubyte *code))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiSUN, (code), (GLuint code))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuivSUN, (code), (const GLuint *code))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeusSUN, (code), (GLushort code))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeusvSUN, (code), (const GLushort *code))
#endif // GL_SUN_triangle_list
#ifdef GL_SUN_vertex
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3fVertex3fSUN, (r, g, b, x, y, z), (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor3fVertex3fvSUN, (c, v), (const GLfloat *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4fNormal3fVertex3fSUN, (r, g, b, a, nx, ny, nz, x, y, z), (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4fNormal3fVertex3fvSUN, (c, n, v), (const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4ubVertex2fSUN, (r, g, b, a, x, y), (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4ubVertex2fvSUN, (c, v), (const GLubyte *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4ubVertex3fSUN, (r, g, b, a, x, y, z), (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColor4ubVertex3fvSUN, (c, v), (const GLubyte *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3fVertex3fSUN, (nx, ny, nz, x, y, z), (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormal3fVertex3fvSUN, (n, v), (const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor3fVertex3fSUN, (rc, r, g, b, x, y, z), (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor3fVertex3fvSUN, (rc, c, v), (const GLuint *rc, const GLfloat *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor4fNormal3fVertex3fSUN, (rc, r, g, b, a, nx, ny, nz, x, y, z), (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor4fNormal3fVertex3fvSUN, (rc, c, n, v), (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor4ubVertex3fSUN, (rc, r, g, b, a, x, y, z), (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiColor4ubVertex3fvSUN, (rc, c, v), (const GLuint *rc, const GLubyte *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiNormal3fVertex3fSUN, (rc, nx, ny, nz, x, y, z), (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiNormal3fVertex3fvSUN, (rc, n, v), (const GLuint *rc, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, (rc, s, t, r, g, b, a, nx, ny, nz, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, (rc, tc, c, n, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, (rc, s, t, nx, ny, nz, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, (rc, tc, n, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fVertex3fSUN, (rc, s, t, x, y, z), (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiTexCoord2fVertex3fvSUN, (rc, tc, v), (const GLuint *rc, const GLfloat *tc, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiVertex3fSUN, (rc, x, y, z), (GLuint rc, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReplacementCodeuiVertex3fvSUN, (rc, v), (const GLuint *rc, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor3fVertex3fSUN, (s, t, r, g, b, x, y, z), (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor3fVertex3fvSUN, (tc, c, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor4fNormal3fVertex3fSUN, (s, t, r, g, b, a, nx, ny, nz, x, y, z), (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor4fNormal3fVertex3fvSUN, (tc, c, n, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor4ubVertex3fSUN, (s, t, r, g, b, a, x, y, z), (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fColor4ubVertex3fvSUN, (tc, c, v), (const GLfloat *tc, const GLubyte *c, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fNormal3fVertex3fSUN, (s, t, nx, ny, nz, x, y, z), (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fNormal3fVertex3fvSUN, (tc, n, v), (const GLfloat *tc, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fVertex3fSUN, (s, t, x, y, z), (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord2fVertex3fvSUN, (tc, v), (const GLfloat *tc, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4fColor4fNormal3fVertex4fSUN, (s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w), (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4fColor4fNormal3fVertex4fvSUN, (tc, c, n, v), (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4fVertex4fSUN, (s, t, p, q, x, y, z, w), (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoord4fVertex4fvSUN, (tc, v), (const GLfloat *tc, const GLfloat *v))
#endif // GL_SUN_vertex
#ifdef GL_VERSION_1_2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawRangeElements, (mode, start, end, count, type, indices), (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
#endif // GL_VERSION_1_2
#ifdef GL_VERSION_1_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveTexture, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClientActiveTexture, (texture), (GLenum texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage1D, (target, level, internalformat, width, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage2D, (target, level, internalformat, width, height, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexImage3D, (target, level, internalformat, width, height, depth, border, imageSize, data), (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage1D, (target, level, xoffset, width, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage2D, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTexImage, (target, level, img), (GLenum target, GLint level, void *img))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadTransposeMatrixd, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLoadTransposeMatrixf, (m), (const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultTransposeMatrixd, (m), (const GLdouble *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultTransposeMatrixf, (m), (const GLfloat *m))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1d, (target, s), (GLenum target, GLdouble s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1f, (target, s), (GLenum target, GLfloat s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1i, (target, s), (GLenum target, GLint s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1iv, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1s, (target, s), (GLenum target, GLshort s))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord1sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2d, (target, s, t), (GLenum target, GLdouble s, GLdouble t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2f, (target, s, t), (GLenum target, GLfloat s, GLfloat t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2i, (target, s, t), (GLenum target, GLint s, GLint t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2iv, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2s, (target, s, t), (GLenum target, GLshort s, GLshort t))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord2sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3d, (target, s, t, r), (GLenum target, GLdouble s, GLdouble t, GLdouble r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3f, (target, s, t, r), (GLenum target, GLfloat s, GLfloat t, GLfloat r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3i, (target, s, t, r), (GLenum target, GLint s, GLint t, GLint r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3iv, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3s, (target, s, t, r), (GLenum target, GLshort s, GLshort t, GLshort r))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord3sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4d, (target, s, t, r, q), (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4dv, (target, v), (GLenum target, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4f, (target, s, t, r, q), (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4fv, (target, v), (GLenum target, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4i, (target, s, t, r, q), (GLenum target, GLint s, GLint t, GLint r, GLint q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4iv, (target, v), (GLenum target, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4s, (target, s, t, r, q), (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoord4sv, (target, v), (GLenum target, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSampleCoverage, (value, invert), (GLfloat value, GLboolean invert))
#endif // GL_VERSION_1_3
#ifdef GL_VERSION_1_4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendColor, (red, green, blue, alpha), (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquation, (mode), (GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparate, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordPointer, (type, stride, pointer), (GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordd, (coord), (GLdouble coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoorddv, (coord), (const GLdouble *coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordf, (coord), (GLfloat coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFogCoordfv, (coord), (const GLfloat *coord))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArrays, (mode, first, count, drawcount), (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElements, (mode, count, type, indices, drawcount), (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterf, (pname, param), (GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameterfv, (pname, params), (GLenum pname, const GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameteri, (pname, param), (GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPointParameteriv, (pname, params), (GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3b, (red, green, blue), (GLbyte red, GLbyte green, GLbyte blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3bv, (v), (const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3d, (red, green, blue), (GLdouble red, GLdouble green, GLdouble blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3f, (red, green, blue), (GLfloat red, GLfloat green, GLfloat blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3i, (red, green, blue), (GLint red, GLint green, GLint blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3s, (red, green, blue), (GLshort red, GLshort green, GLshort blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ub, (red, green, blue), (GLubyte red, GLubyte green, GLubyte blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ubv, (v), (const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3ui, (red, green, blue), (GLuint red, GLuint green, GLuint blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3uiv, (v), (const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3us, (red, green, blue), (GLushort red, GLushort green, GLushort blue))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColor3usv, (v), (const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorPointer, (size, type, stride, pointer), (GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2d, (x, y), (GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2f, (x, y), (GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2i, (x, y), (GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2s, (x, y), (GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos2sv, (v), (const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3d, (x, y, z), (GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3dv, (v), (const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3f, (x, y, z), (GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3fv, (v), (const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3i, (x, y, z), (GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3iv, (v), (const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3s, (x, y, z), (GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glWindowPos3sv, (v), (const GLshort *v))
#endif // GL_VERSION_1_4
#ifdef GL_VERSION_1_5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginQuery, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffer, (target, buffer), (GLenum target, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferData, (target, size, data, usage), (GLenum target, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteBuffers, (n, buffers), (GLsizei n, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteQueries, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndQuery, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenQueries, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferPointerv, (target, pname, params), (GLenum target, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBufferSubData, (target, offset, size, data), (GLenum target, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectiv, (id, pname, params), (GLuint id, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectuiv, (id, pname, params), (GLuint id, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsBuffer, (buffer), (GLuint buffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsQuery, (id), (GLuint id))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapBuffer, (target, access), (GLenum target, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapBuffer, (target), (GLenum target))
#endif // GL_VERSION_1_5
#ifdef GL_VERSION_2_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glAttachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindAttribLocation, (program, index, name), (GLuint program, GLuint index, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparate, (modeRGB, modeAlpha), (GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompileShader, (shader), (GLuint shader))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateProgram, (), ())
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShader, (type), (GLenum type))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDetachShader, (program, shader), (GLuint program, GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawBuffers, (n, bufs), (GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexAttribArray, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveAttrib, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniform, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetAttachedShaders, (program, maxCount, count, shaders), (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetAttribLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramInfoLog, (program, bufSize, length, infoLog), (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramiv, (program, pname, params), (GLuint program, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderInfoLog, (shader, bufSize, length, infoLog), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderSource, (shader, bufSize, length, source), (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderiv, (shader, pname, params), (GLuint shader, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetUniformLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformfv, (program, location, params), (GLuint program, GLint location, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformiv, (program, location, params), (GLuint program, GLint location, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribPointerv, (index, pname, pointer), (GLuint index, GLenum pname, void **pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribfv, (index, pname, params), (GLuint index, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgram, (program), (GLuint program))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsShader, (shader), (GLuint shader))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glLinkProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderSource, (shader, count, string, length), (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilFuncSeparate, (face, func, ref, mask), (GLenum face, GLenum func, GLint ref, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilMaskSeparate, (face, mask), (GLenum face, GLuint mask))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glStencilOpSeparate, (face, sfail, dpfail, dppass), (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1f, (location, v0), (GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1i, (location, v0), (GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2f, (location, v0, v1), (GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2i, (location, v0, v1), (GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3f, (location, v0, v1, v2), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3i, (location, v0, v1, v2), (GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4f, (location, v0, v1, v2, v3), (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4fv, (location, count, value), (GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4i, (location, v0, v1, v2, v3), (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4iv, (location, count, value), (GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glValidateProgram, (program), (GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1d, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1f, (index, x), (GLuint index, GLfloat x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1s, (index, x), (GLuint index, GLshort x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib1sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2f, (index, x, y), (GLuint index, GLfloat x, GLfloat y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2s, (index, x, y), (GLuint index, GLshort x, GLshort y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib2sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3f, (index, x, y, z), (GLuint index, GLfloat x, GLfloat y, GLfloat z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3s, (index, x, y, z), (GLuint index, GLshort x, GLshort y, GLshort z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib3sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nbv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Niv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nsv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nub, (index, x, y, z, w), (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nuiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4Nusv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4f, (index, x, y, z, w), (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4fv, (index, v), (GLuint index, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4s, (index, x, y, z, w), (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttrib4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribPointer, (index, size, type, normalized, stride, pointer), (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))
#endif // GL_VERSION_2_0
#ifdef GL_VERSION_2_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x4fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x2fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x3fv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
#endif // GL_VERSION_2_1
#ifdef GL_VERSION_3_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginConditionalRender, (id, mode), (GLuint id, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginTransformFeedback, (primitiveMode), (GLenum primitiveMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferBase, (target, index, buffer), (GLenum target, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBufferRange, (target, index, buffer, offset, size), (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragDataLocation, (program, color, name), (GLuint program, GLuint color, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFramebuffer, (target, framebuffer), (GLenum target, GLuint framebuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindRenderbuffer, (target, renderbuffer), (GLenum target, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlitFramebuffer, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckFramebufferStatus, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClampColor, (target, clamp), (GLenum target, GLenum clamp))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferfi, (buffer, drawbuffer, depth, stencil), (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferfv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferuiv, (buffer, drawbuffer, value), (GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorMaski, (index, r, g, b, a), (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteFramebuffers, (n, framebuffers), (GLsizei n, const GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteRenderbuffers, (n, renderbuffers), (GLsizei n, const GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteVertexArrays, (n, arrays), (GLsizei n, const GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnablei, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndConditionalRender, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedBufferRange, (target, offset, length), (GLenum target, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferRenderbuffer, (target, attachment, renderbuffertarget, renderbuffer), (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture1D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture2D, (target, attachment, textarget, texture, level), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTexture3D, (target, attachment, textarget, texture, level, zoffset), (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferTextureLayer, (target, attachment, texture, level, layer), (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateMipmap, (target), (GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetBooleani_v, (target, index, data), (GLenum target, GLuint index, GLboolean *data))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetFragDataLocation, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferAttachmentParameteriv, (target, attachment, pname, params), (GLenum target, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetIntegeri_v, (target, index, data), (GLenum target, GLuint index, GLint *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetRenderbufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , const GLubyte *, APIENTRY, glGetStringi, (name, index), (GLenum name, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackVarying, (program, index, bufSize, length, size, type, name), (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformuiv, (program, location, params), (GLuint program, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIiv, (index, pname, params), (GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribIuiv, (index, pname, params), (GLuint index, GLenum pname, GLuint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsEnabledi, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsFramebuffer, (framebuffer), (GLuint framebuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsRenderbuffer, (renderbuffer), (GLuint renderbuffer))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsVertexArray, (array), (GLuint array))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapBufferRange, (target, offset, length, access), (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorage, (target, internalformat, width, height), (GLenum target, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glRenderbufferStorageMultisample, (target, samples, internalformat, width, height), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIiv, (target, pname, params), (GLenum target, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexParameterIuiv, (target, pname, params), (GLenum target, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackVaryings, (program, count, varyings, bufferMode), (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1ui, (location, v0), (GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2ui, (location, v0, v1), (GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3ui, (location, v0, v1, v2), (GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4ui, (location, v0, v1, v2, v3), (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4uiv, (location, count, value), (GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1i, (index, x), (GLuint index, GLint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1ui, (index, x), (GLuint index, GLuint x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI1uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2i, (index, x, y), (GLuint index, GLint x, GLint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2ui, (index, x, y), (GLuint index, GLuint x, GLuint y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI2uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3i, (index, x, y, z), (GLuint index, GLint x, GLint y, GLint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3ui, (index, x, y, z), (GLuint index, GLuint x, GLuint y, GLuint z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI3uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4bv, (index, v), (GLuint index, const GLbyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4i, (index, x, y, z, w), (GLuint index, GLint x, GLint y, GLint z, GLint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4iv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4sv, (index, v), (GLuint index, const GLshort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ubv, (index, v), (GLuint index, const GLubyte *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4ui, (index, x, y, z, w), (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4uiv, (index, v), (GLuint index, const GLuint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribI4usv, (index, v), (GLuint index, const GLushort *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
#endif // GL_VERSION_3_0
#ifdef GL_VERSION_3_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyBufferSubData, (readTarget, writeTarget, readOffset, writeOffset, size), (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstanced, (mode, first, count, instancecount), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstanced, (mode, count, type, indices, instancecount), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformBlockName, (program, uniformBlockIndex, bufSize, length, uniformBlockName), (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformBlockiv, (program, uniformBlockIndex, pname, params), (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformName, (program, uniformIndex, bufSize, length, uniformName), (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveUniformsiv, (program, uniformCount, uniformIndices, pname, params), (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetUniformBlockIndex, (program, uniformBlockName), (GLuint program, const GLchar *uniformBlockName))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformIndices, (program, uniformCount, uniformNames, uniformIndices), (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPrimitiveRestartIndex, (index), (GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBuffer, (target, internalformat, buffer), (GLenum target, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformBlockBinding, (program, uniformBlockIndex, uniformBlockBinding), (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding))
#endif // GL_VERSION_3_1
#ifdef GL_VERSION_3_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindFragDataLocationIndexed, (program, colorNumber, index, name), (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindSampler, (unit, sampler), (GLuint unit, GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorP3ui, (type, color), (GLenum type, GLuint color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorP3uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorP4ui, (type, color), (GLenum type, GLuint color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glColorP4uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteSamplers, (count, samplers), (GLsizei count, const GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenSamplers, (count, samplers), (GLsizei count, GLuint *samplers))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetFragDataIndex, (program, name), (GLuint program, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjecti64v, (id, pname, params), (GLuint id, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryObjectui64v, (id, pname, params), (GLuint id, GLenum pname, GLuint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterIiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterIuiv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameterfv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetSamplerParameteriv, (sampler, pname, params), (GLuint sampler, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsSampler, (sampler), (GLuint sampler))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP1ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP1uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP2ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP2uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP3ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP3uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP4ui, (texture, type, coords), (GLenum texture, GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiTexCoordP4uiv, (texture, type, coords), (GLenum texture, GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalP3ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNormalP3uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glQueryCounter, (id, target), (GLuint id, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterIiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterIuiv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLuint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterf, (sampler, pname, param), (GLuint sampler, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameterfv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameteri, (sampler, pname, param), (GLuint sampler, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSamplerParameteriv, (sampler, pname, param), (GLuint sampler, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorP3ui, (type, color), (GLenum type, GLuint color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glSecondaryColorP3uiv, (type, color), (GLenum type, const GLuint *color))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP1ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP1uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP2ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP2uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP3ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP3uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP4ui, (type, coords), (GLenum type, GLuint coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexCoordP4uiv, (type, coords), (GLenum type, const GLuint *coords))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribDivisor, (index, divisor), (GLuint index, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP1ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP1uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP2ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP2uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP3ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP3uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP4ui, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribP4uiv, (index, type, normalized, value), (GLuint index, GLenum type, GLboolean normalized, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP2ui, (type, value), (GLenum type, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP2uiv, (type, value), (GLenum type, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP3ui, (type, value), (GLenum type, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP3uiv, (type, value), (GLenum type, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP4ui, (type, value), (GLenum type, GLuint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexP4uiv, (type, value), (GLenum type, const GLuint *value))
#endif // GL_VERSION_3_3
#ifdef GL_VERSION_4_0
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBeginQueryIndexed, (target, index, id), (GLenum target, GLuint index, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTransformFeedback, (target, id), (GLenum target, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationSeparatei, (buf, modeRGB, modeAlpha), (GLuint buf, GLenum modeRGB, GLenum modeAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendEquationi, (buf, mode), (GLuint buf, GLenum mode))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFuncSeparatei, (buf, srcRGB, dstRGB, srcAlpha, dstAlpha), (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlendFunci, (buf, src, dst), (GLuint buf, GLenum src, GLenum dst))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteTransformFeedbacks, (n, ids), (GLsizei n, const GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysIndirect, (mode, indirect), (GLenum mode, const void *indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsIndirect, (mode, type, indirect), (GLenum mode, GLenum type, const void *indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedback, (mode, id), (GLenum mode, GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackStream, (mode, id, stream), (GLenum mode, GLuint id, GLuint stream))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEndQueryIndexed, (target, index), (GLenum target, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineName, (program, shadertype, index, bufsize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineUniformName, (program, shadertype, index, bufsize, length, name), (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveSubroutineUniformiv, (program, shadertype, index, pname, values), (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramStageiv, (program, shadertype, pname, values), (GLuint program, GLenum shadertype, GLenum pname, GLint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryIndexediv, (target, index, pname, params), (GLenum target, GLuint index, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetSubroutineIndex, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetSubroutineUniformLocation, (program, shadertype, name), (GLuint program, GLenum shadertype, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformSubroutineuiv, (shadertype, location, params), (GLenum shadertype, GLint location, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetUniformdv, (program, location, params), (GLuint program, GLint location, GLdouble *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsTransformFeedback, (id), (GLuint id))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMinSampleShading, (value), (GLfloat value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPatchParameterfv, (pname, values), (GLenum pname, const GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPatchParameteri, (pname, value), (GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPauseTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glResumeTransformFeedback, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1d, (location, x), (GLint location, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform1dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2d, (location, x, y), (GLint location, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform2dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3d, (location, x, y, z), (GLint location, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform3dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4d, (location, x, y, z, w), (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniform4dv, (location, count, value), (GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix2x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix3x4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x2dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformMatrix4x3dv, (location, count, transpose, value), (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUniformSubroutinesuiv, (shadertype, count, indices), (GLenum shadertype, GLsizei count, const GLuint *indices))
#endif // GL_VERSION_4_0
#ifdef GL_VERSION_4_1
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glActiveShaderProgram, (pipeline, program), (GLuint pipeline, GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearDepthf, (d), (GLfloat d))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glCreateShaderProgramv, (type, count, strings), (GLenum type, GLsizei count, const GLchar *const*strings))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDeleteProgramPipelines, (n, pipelines), (GLsizei n, const GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangeArrayv, (first, count, v), (GLuint first, GLsizei count, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangeIndexed, (index, n, f), (GLuint index, GLdouble n, GLdouble f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDepthRangef, (n, f), (GLfloat n, GLfloat f))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetDoublei_v, (target, index, data), (GLenum target, GLuint index, GLdouble *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFloati_v, (target, index, data), (GLenum target, GLuint index, GLfloat *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramBinary, (program, bufSize, length, binaryFormat, binary), (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramPipelineInfoLog, (pipeline, bufSize, length, infoLog), (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramPipelineiv, (pipeline, pname, params), (GLuint pipeline, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetShaderPrecisionFormat, (shadertype, precisiontype, range, precision), (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexAttribLdv, (index, pname, params), (GLuint index, GLenum pname, GLdouble *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glIsProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramBinary, (program, binaryFormat, binary, length), (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramParameteri, (program, pname, value), (GLuint program, GLenum pname, GLint value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1d, (program, location, v0), (GLuint program, GLint location, GLdouble v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1f, (program, location, v0), (GLuint program, GLint location, GLfloat v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1i, (program, location, v0), (GLuint program, GLint location, GLint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1ui, (program, location, v0), (GLuint program, GLint location, GLuint v0))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform1uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2d, (program, location, v0, v1), (GLuint program, GLint location, GLdouble v0, GLdouble v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2f, (program, location, v0, v1), (GLuint program, GLint location, GLfloat v0, GLfloat v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2i, (program, location, v0, v1), (GLuint program, GLint location, GLint v0, GLint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2ui, (program, location, v0, v1), (GLuint program, GLint location, GLuint v0, GLuint v1))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform2uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3d, (program, location, v0, v1, v2), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3f, (program, location, v0, v1, v2), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3i, (program, location, v0, v1, v2), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3ui, (program, location, v0, v1, v2), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform3uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4d, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4dv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4f, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4fv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4i, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4iv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4ui, (program, location, v0, v1, v2, v3), (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniform4uiv, (program, location, count, value), (GLuint program, GLint location, GLsizei count, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix2x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix3x4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x2fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3dv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glProgramUniformMatrix4x3fv, (program, location, count, transpose, value), (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReleaseShaderCompiler, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorArrayv, (first, count, v), (GLuint first, GLsizei count, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorIndexed, (index, left, bottom, width, height), (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glScissorIndexedv, (index, v), (GLuint index, const GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderBinary, (count, shaders, binaryformat, binary, length), (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glUseProgramStages, (pipeline, stages, program), (GLuint pipeline, GLbitfield stages, GLuint program))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glValidateProgramPipeline, (pipeline), (GLuint pipeline))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1d, (index, x), (GLuint index, GLdouble x))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL1dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2d, (index, x, y), (GLuint index, GLdouble x, GLdouble y))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL2dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3d, (index, x, y, z), (GLuint index, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL3dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4d, (index, x, y, z, w), (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribL4dv, (index, v), (GLuint index, const GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLPointer, (index, size, type, stride, pointer), (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportArrayv, (first, count, v), (GLuint first, GLsizei count, const GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportIndexedf, (index, x, y, w, h), (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glViewportIndexedfv, (index, v), (GLuint index, const GLfloat *v))
#endif // GL_VERSION_4_1
#ifdef GL_VERSION_4_2
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindImageTexture, (unit, texture, level, layered, layer, access, format), (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawArraysInstancedBaseInstance, (mode, first, count, instancecount, baseinstance), (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseInstance, (mode, count, type, indices, instancecount, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawElementsInstancedBaseVertexBaseInstance, (mode, count, type, indices, instancecount, basevertex, baseinstance), (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackInstanced, (mode, id, instancecount), (GLenum mode, GLuint id, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDrawTransformFeedbackStreamInstanced, (mode, id, stream, instancecount), (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetActiveAtomicCounterBufferiv, (program, bufferIndex, pname, params), (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformativ, (target, internalformat, pname, bufSize, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMemoryBarrier, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage1D, (target, levels, internalformat, width), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage2D, (target, levels, internalformat, width, height), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage3D, (target, levels, internalformat, width, height, depth), (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
#endif // GL_VERSION_4_2
#ifdef GL_VERSION_4_3
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexBuffer, (bindingindex, buffer, offset, stride), (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferData, (target, internalformat, format, type, data), (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearBufferSubData, (target, internalformat, offset, size, format, type, data), (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyImageSubData, (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth), (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageCallback, (callback, userParam), (GLDEBUGPROC callback, const void *userParam))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageControl, (source, type, severity, count, ids, enabled), (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDebugMessageInsert, (source, type, id, severity, length, buf), (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchCompute, (num_groups_x, num_groups_y, num_groups_z), (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDispatchComputeIndirect, (indirect), (GLintptr indirect))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFramebufferParameteri, (target, pname, param), (GLenum target, GLenum pname, GLint param))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetDebugMessageLog, (count, bufSize, sources, types, ids, severities, lengths, messageLog), (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetFramebufferParameteriv, (target, pname, params), (GLenum target, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetInternalformati64v, (target, internalformat, pname, bufSize, params), (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectLabel, (identifier, name, bufSize, length, label), (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetObjectPtrLabel, (ptr, bufSize, length, label), (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramInterfaceiv, (program, programInterface, pname, params), (GLuint program, GLenum programInterface, GLenum pname, GLint *params))
GLATTER_FBLOCK(return, GL, GLAPI , GLuint, APIENTRY, glGetProgramResourceIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetProgramResourceLocation, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(return, GL, GLAPI , GLint, APIENTRY, glGetProgramResourceLocationIndex, (program, programInterface, name), (GLuint program, GLenum programInterface, const GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourceName, (program, programInterface, index, bufSize, length, name), (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetProgramResourceiv, (program, programInterface, index, propCount, props, bufSize, length, params), (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateBufferData, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateBufferSubData, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateFramebuffer, (target, numAttachments, attachments), (GLenum target, GLsizei numAttachments, const GLenum *attachments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateSubFramebuffer, (target, numAttachments, attachments, x, y, width, height), (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateTexImage, (texture, level), (GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawArraysIndirect, (mode, indirect, drawcount, stride), (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMultiDrawElementsIndirect, (mode, type, indirect, drawcount, stride), (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glObjectLabel, (identifier, name, length, label), (GLenum identifier, GLuint name, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glObjectPtrLabel, (ptr, length, label), (const void *ptr, GLsizei length, const GLchar *label))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPopDebugGroup, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glPushDebugGroup, (source, id, length, message), (GLenum source, GLuint id, GLsizei length, const GLchar *message))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glShaderStorageBlockBinding, (program, storageBlockIndex, storageBlockBinding), (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexBufferRange, (target, internalformat, buffer, offset, size), (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage2DMultisample, (target, samples, internalformat, width, height, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTexStorage3DMultisample, (target, samples, internalformat, width, height, depth, fixedsamplelocations), (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureView, (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers), (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribBinding, (attribindex, bindingindex), (GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribFormat, (attribindex, size, type, normalized, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribIFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexAttribLFormat, (attribindex, size, type, relativeoffset), (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexBindingDivisor, (bindingindex, divisor), (GLuint bindingindex, GLuint divisor))
#endif // GL_VERSION_4_3
#ifdef GL_VERSION_4_4
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffersBase, (target, first, count, buffers), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindBuffersRange, (target, first, count, buffers, offsets, sizes), (GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindImageTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindSamplers, (first, count, samplers), (GLuint first, GLsizei count, const GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTextures, (first, count, textures), (GLuint first, GLsizei count, const GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindVertexBuffers, (first, count, buffers, offsets, strides), (GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBufferStorage, (target, size, data, flags), (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearTexImage, (texture, level, format, type, data), (GLuint texture, GLint level, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearTexSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data))
#endif // GL_VERSION_4_4
#ifdef GL_VERSION_4_5
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBindTextureUnit, (unit, texture), (GLuint unit, GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glBlitNamedFramebuffer, (readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glCheckNamedFramebufferStatus, (framebuffer, target), (GLuint framebuffer, GLenum target))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferData, (buffer, internalformat, format, type, data), (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedBufferSubData, (buffer, internalformat, offset, size, format, type, data), (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferfi, (framebuffer, buffer, drawbuffer, depth, stencil), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferfv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClearNamedFramebufferuiv, (framebuffer, buffer, drawbuffer, value), (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glClipControl, (origin, depth), (GLenum origin, GLenum depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage1D, (texture, level, xoffset, width, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCompressedTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyNamedBufferSubData, (readBuffer, writeBuffer, readOffset, writeOffset, size), (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage1D, (texture, level, xoffset, x, y, width), (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage2D, (texture, level, xoffset, yoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCopyTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, x, y, width, height), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateBuffers, (n, buffers), (GLsizei n, GLuint *buffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateFramebuffers, (n, framebuffers), (GLsizei n, GLuint *framebuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateProgramPipelines, (n, pipelines), (GLsizei n, GLuint *pipelines))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateQueries, (target, n, ids), (GLenum target, GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateRenderbuffers, (n, renderbuffers), (GLsizei n, GLuint *renderbuffers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateSamplers, (n, samplers), (GLsizei n, GLuint *samplers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateTextures, (target, n, textures), (GLenum target, GLsizei n, GLuint *textures))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateTransformFeedbacks, (n, ids), (GLsizei n, GLuint *ids))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glCreateVertexArrays, (n, arrays), (GLsizei n, GLuint *arrays))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glDisableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glEnableVertexArrayAttrib, (vaobj, index), (GLuint vaobj, GLuint index))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glFlushMappedNamedBufferRange, (buffer, offset, length), (GLuint buffer, GLintptr offset, GLsizeiptr length))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGenerateTextureMipmap, (texture), (GLuint texture))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTextureImage, (texture, level, bufSize, pixels), (GLuint texture, GLint level, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetCompressedTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(return, GL, GLAPI , GLenum, APIENTRY, glGetGraphicsResetStatus, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameteri64v, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint64 *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferParameteriv, (buffer, pname, params), (GLuint buffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferPointerv, (buffer, pname, params), (GLuint buffer, GLenum pname, void **params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferAttachmentParameteriv, (framebuffer, attachment, pname, params), (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedFramebufferParameteriv, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetNamedRenderbufferParameteriv, (renderbuffer, pname, params), (GLuint renderbuffer, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjecti64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectui64v, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetQueryBufferObjectuiv, (id, buffer, pname, offset), (GLuint id, GLuint buffer, GLenum pname, GLintptr offset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureImage, (texture, level, format, type, bufSize, pixels), (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameterfv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureLevelParameteriv, (texture, level, pname, params), (GLuint texture, GLint level, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameterfv, (texture, pname, params), (GLuint texture, GLenum pname, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureParameteriv, (texture, pname, params), (GLuint texture, GLenum pname, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTextureSubImage, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbacki64_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint64 *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbacki_v, (xfb, pname, index, param), (GLuint xfb, GLenum pname, GLuint index, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetTransformFeedbackiv, (xfb, pname, param), (GLuint xfb, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIndexed64iv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint64 *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayIndexediv, (vaobj, index, pname, param), (GLuint vaobj, GLuint index, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetVertexArrayiv, (vaobj, pname, param), (GLuint vaobj, GLenum pname, GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnColorTable, (target, format, type, bufSize, table), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnCompressedTexImage, (target, lod, bufSize, pixels), (GLenum target, GLint lod, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnConvolutionFilter, (target, format, type, bufSize, image), (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnHistogram, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapdv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapfv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMapiv, (target, query, bufSize, v), (GLenum target, GLenum query, GLsizei bufSize, GLint *v))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnMinmax, (target, reset, format, type, bufSize, values), (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapfv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLfloat *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapuiv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLuint *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPixelMapusv, (map, bufSize, values), (GLenum map, GLsizei bufSize, GLushort *values))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnPolygonStipple, (bufSize, pattern), (GLsizei bufSize, GLubyte *pattern))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnSeparableFilter, (target, format, type, rowBufSize, row, columnBufSize, column, span), (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnTexImage, (target, level, format, type, bufSize, pixels), (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformdv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLdouble *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformfv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLfloat *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glGetnUniformuiv, (program, location, bufSize, params), (GLuint program, GLint location, GLsizei bufSize, GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateNamedFramebufferData, (framebuffer, numAttachments, attachments), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glInvalidateNamedFramebufferSubData, (framebuffer, numAttachments, attachments, x, y, width, height), (GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBuffer, (buffer, access), (GLuint buffer, GLenum access))
GLATTER_FBLOCK(return, GL, GLAPI , void *, APIENTRY, glMapNamedBufferRange, (buffer, offset, length, access), (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glMemoryBarrierByRegion, (barriers), (GLbitfield barriers))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferData, (buffer, size, data, usage), (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferStorage, (buffer, size, data, flags), (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedBufferSubData, (buffer, offset, size, data), (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferDrawBuffer, (framebuffer, buf), (GLuint framebuffer, GLenum buf))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferDrawBuffers, (framebuffer, n, bufs), (GLuint framebuffer, GLsizei n, const GLenum *bufs))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferParameteri, (framebuffer, pname, param), (GLuint framebuffer, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferReadBuffer, (framebuffer, src), (GLuint framebuffer, GLenum src))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferRenderbuffer, (framebuffer, attachment, renderbuffertarget, renderbuffer), (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTexture, (framebuffer, attachment, texture, level), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedFramebufferTextureLayer, (framebuffer, attachment, texture, level, layer), (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorage, (renderbuffer, internalformat, width, height), (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glNamedRenderbufferStorageMultisample, (renderbuffer, samples, internalformat, width, height), (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glReadnPixels, (x, y, width, height, format, type, bufSize, data), (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBarrier, (), ())
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBuffer, (texture, internalformat, buffer), (GLuint texture, GLenum internalformat, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureBufferRange, (texture, internalformat, buffer, offset, size), (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterIuiv, (texture, pname, params), (GLuint texture, GLenum pname, const GLuint *params))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterf, (texture, pname, param), (GLuint texture, GLenum pname, GLfloat param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameterfv, (texture, pname, param), (GLuint texture, GLenum pname, const GLfloat *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameteri, (texture, pname, param), (GLuint texture, GLenum pname, GLint param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureParameteriv, (texture, pname, param), (GLuint texture, GLenum pname, const GLint *param))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage1D, (texture, levels, internalformat, width), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2D, (texture, levels, internalformat, width, height), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage2DMultisample, (texture, samples, internalformat, width, height, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3D, (texture, levels, internalformat, width, height, depth), (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureStorage3DMultisample, (texture, samples, internalformat, width, height, depth, fixedsamplelocations), (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage1D, (texture, level, xoffset, width, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage2D, (texture, level, xoffset, yoffset, width, height, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTextureSubImage3D, (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackBufferBase, (xfb, index, buffer), (GLuint xfb, GLuint index, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glTransformFeedbackBufferRange, (xfb, index, buffer, offset, size), (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size))
GLATTER_FBLOCK(return, GL, GLAPI , GLboolean, APIENTRY, glUnmapNamedBuffer, (buffer), (GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribBinding, (vaobj, attribindex, bindingindex), (GLuint vaobj, GLuint attribindex, GLuint bindingindex))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribFormat, (vaobj, attribindex, size, type, normalized, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribIFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayAttribLFormat, (vaobj, attribindex, size, type, relativeoffset), (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayBindingDivisor, (vaobj, bindingindex, divisor), (GLuint vaobj, GLuint bindingindex, GLuint divisor))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayElementBuffer, (vaobj, buffer), (GLuint vaobj, GLuint buffer))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexBuffer, (vaobj, bindingindex, buffer, offset, stride), (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride))
GLATTER_FBLOCK(, GL, GLAPI , void, APIENTRY, glVertexArrayVertexBuffers, (vaobj, first, count, buffers, offsets, strides), (GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides))
#endif // GL_VERSION_4_5
#endif // __glext_h_
#endif // GLATTER_GL

#ifndef NDEBUG

#ifdef GLATTER_GL

#ifdef __gl2ext_h_
#ifdef GL_AMD_performance_monitor
void glatter_glBeginPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glBeginPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glDeletePerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glEndPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glGenPerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glGenPerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterDataAMD_debug(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterDataAMD, (%u, %s, %d, %p, %p), (unsigned int)monitor, enum_to_string_GL(pname), (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfMonitorCounterDataAMD_ptr(monitor, pname, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterInfoAMD_debug(GLuint group, GLuint counter, GLenum pname, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterInfoAMD, (%u, %u, %s, %p), (unsigned int)group, (unsigned int)counter, enum_to_string_GL(pname), (void*)data)
    glatter_glGetPerfMonitorCounterInfoAMD_ptr(group, counter, pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterStringAMD_debug(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterStringAMD, (%u, %u, %d, %p, %p), (unsigned int)group, (unsigned int)counter, (int)bufSize, (void*)length, (void*)counterString)
    glatter_glGetPerfMonitorCounterStringAMD_ptr(group, counter, bufSize, length, counterString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCountersAMD_debug(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCountersAMD, (%u, %p, %p, %d, %p), (unsigned int)group, (void*)numCounters, (void*)maxActiveCounters, (int)counterSize, (void*)counters)
    glatter_glGetPerfMonitorCountersAMD_ptr(group, numCounters, maxActiveCounters, counterSize, counters);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupStringAMD_debug(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupStringAMD, (%u, %d, %p, %p), (unsigned int)group, (int)bufSize, (void*)length, (void*)groupString)
    glatter_glGetPerfMonitorGroupStringAMD_ptr(group, bufSize, length, groupString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupsAMD_debug(GLint *numGroups, GLsizei groupsSize, GLuint *groups, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupsAMD, (%p, %d, %p), (void*)numGroups, (int)groupsSize, (void*)groups)
    glatter_glGetPerfMonitorGroupsAMD_ptr(numGroups, groupsSize, groups);
    glatter_check_error_GL(file, line);
}
void glatter_glSelectPerfMonitorCountersAMD_debug(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSelectPerfMonitorCountersAMD, (%u, %u, %u, %d, %p), (unsigned int)monitor, (unsigned char)enable, (unsigned int)group, (int)numCounters, (void*)counterList)
    glatter_glSelectPerfMonitorCountersAMD_ptr(monitor, enable, group, numCounters, counterList);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_performance_monitor
#ifdef GL_ANGLE_framebuffer_blit
void glatter_glBlitFramebufferANGLE_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferANGLE, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferANGLE_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
#endif // GL_ANGLE_framebuffer_blit
#ifdef GL_ANGLE_framebuffer_multisample
void glatter_glRenderbufferStorageMultisampleANGLE_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleANGLE, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleANGLE_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_ANGLE_framebuffer_multisample
#ifdef GL_ANGLE_instanced_arrays
void glatter_glDrawArraysInstancedANGLE_debug(GLenum mode, GLint first, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedANGLE, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedANGLE_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedANGLE_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedANGLE, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedANGLE_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribDivisorANGLE_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisorANGLE, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisorANGLE_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_ANGLE_instanced_arrays
#ifdef GL_ANGLE_translated_shader_source
void glatter_glGetTranslatedShaderSourceANGLE_debug(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTranslatedShaderSourceANGLE, (%u, %d, %p, %p), (unsigned int)shader, (int)bufsize, (void*)length, (void*)source)
    glatter_glGetTranslatedShaderSourceANGLE_ptr(shader, bufsize, length, source);
    glatter_check_error_GL(file, line);
}
#endif // GL_ANGLE_translated_shader_source
#ifdef GL_APPLE_copy_texture_levels
void glatter_glCopyTextureLevelsAPPLE_debug(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureLevelsAPPLE, (%u, %u, %d, %d), (unsigned int)destinationTexture, (unsigned int)sourceTexture, (int)sourceBaseLevel, (int)sourceLevelCount)
    glatter_glCopyTextureLevelsAPPLE_ptr(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_copy_texture_levels
#ifdef GL_APPLE_framebuffer_multisample
void glatter_glRenderbufferStorageMultisampleAPPLE_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleAPPLE, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleAPPLE_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glResolveMultisampleFramebufferAPPLE_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResolveMultisampleFramebufferAPPLE, ())
    glatter_glResolveMultisampleFramebufferAPPLE_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_framebuffer_multisample
#ifdef GL_APPLE_sync
GLenum glatter_glClientWaitSyncAPPLE_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSyncAPPLE, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    GLenum rval = glatter_glClientWaitSyncAPPLE_ptr(sync, flags, timeout);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteSyncAPPLE_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSyncAPPLE, (%p), (void*)sync)
    glatter_glDeleteSyncAPPLE_ptr(sync);
    glatter_check_error_GL(file, line);
}
GLsync glatter_glFenceSyncAPPLE_debug(GLenum condition, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFenceSyncAPPLE, (%s, %u), enum_to_string_GL(condition), (unsigned int)flags)
    GLsync rval = glatter_glFenceSyncAPPLE_ptr(condition, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetInteger64vAPPLE_debug(GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64vAPPLE, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetInteger64vAPPLE_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSyncivAPPLE_debug(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSyncivAPPLE, (%p, %s, %d, %p, %p), (void*)sync, enum_to_string_GL(pname), (int)bufSize, (void*)length, (void*)values)
    glatter_glGetSyncivAPPLE_ptr(sync, pname, bufSize, length, values);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsSyncAPPLE_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSyncAPPLE, (%p), (void*)sync)
    GLboolean rval = glatter_glIsSyncAPPLE_ptr(sync);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glWaitSyncAPPLE_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSyncAPPLE, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    glatter_glWaitSyncAPPLE_ptr(sync, flags, timeout);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_sync
#ifdef GL_EXT_base_instance
void glatter_glDrawArraysInstancedBaseInstanceEXT_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedBaseInstanceEXT, (%s, %d, %d, %d, %u), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawArraysInstancedBaseInstanceEXT_ptr(mode, first, count, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseInstanceEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseInstanceEXT, (%s, %d, %s, %p, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseInstanceEXT_ptr(mode, count, type, indices, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertexBaseInstanceEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexBaseInstanceEXT, (%s, %d, %s, %p, %d, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseVertexBaseInstanceEXT_ptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_base_instance
#ifdef GL_EXT_blend_func_extended
void glatter_glBindFragDataLocationEXT_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationEXT, (%u, %u, %p), (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocationEXT_ptr(program, color, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFragDataLocationIndexedEXT_debug(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationIndexedEXT, (%u, %u, %u, %p), (unsigned int)program, (unsigned int)colorNumber, (unsigned int)index, (void*)name)
    glatter_glBindFragDataLocationIndexedEXT_ptr(program, colorNumber, index, name);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataIndexEXT_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataIndexEXT, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataIndexEXT_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocationIndexEXT_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocationIndexEXT, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocationIndexEXT_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_EXT_blend_func_extended
#ifdef GL_EXT_buffer_storage
void glatter_glBufferStorageEXT_debug(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorageEXT, (%s, %td, %p, %u), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glBufferStorageEXT_ptr(target, size, data, flags);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_buffer_storage
#ifdef GL_EXT_clear_texture
void glatter_glClearTexImageEXT_debug(GLuint texture, GLint level, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexImageEXT, (%u, %d, %s, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexImageEXT_ptr(texture, level, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearTexSubImageEXT_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexSubImageEXT, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexSubImageEXT_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_clear_texture
#ifdef GL_EXT_copy_image
void glatter_glCopyImageSubDataEXT_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubDataEXT, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubDataEXT_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_copy_image
#ifdef GL_EXT_debug_label
void glatter_glGetObjectLabelEXT_debug(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabelEXT, (%s, %u, %d, %p, %p), enum_to_string_GL(type), (unsigned int)object, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabelEXT_ptr(type, object, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glLabelObjectEXT_debug(GLenum type, GLuint object, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLabelObjectEXT, (%s, %u, %d, %p), enum_to_string_GL(type), (unsigned int)object, (int)length, (void*)label)
    glatter_glLabelObjectEXT_ptr(type, object, length, label);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
void glatter_glInsertEventMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertEventMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glInsertEventMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
void glatter_glPopGroupMarkerEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopGroupMarkerEXT, ())
    glatter_glPopGroupMarkerEXT_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushGroupMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushGroupMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glPushGroupMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_discard_framebuffer
void glatter_glDiscardFramebufferEXT_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDiscardFramebufferEXT, (%s, %d, %p), enum_to_string_GL(target), (int)numAttachments, (void*)attachments)
    glatter_glDiscardFramebufferEXT_ptr(target, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_discard_framebuffer
#ifdef GL_EXT_disjoint_timer_query
void glatter_glBeginQueryEXT_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQueryEXT_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteQueriesEXT_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueriesEXT, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteQueriesEXT_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQueryEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryEXT, (%s), enum_to_string_GL(target))
    glatter_glEndQueryEXT_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGenQueriesEXT_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueriesEXT, (%d, %p), (int)n, (void*)ids)
    glatter_glGenQueriesEXT_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjecti64vEXT_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64vEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64vEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectivEXT_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectivEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectivEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectui64vEXT_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64vEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64vEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectuivEXT_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuivEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuivEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsQueryEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQueryEXT, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsQueryEXT_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glQueryCounterEXT_debug(GLuint id, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryCounterEXT, (%u, %s), (unsigned int)id, enum_to_string_GL(target))
    glatter_glQueryCounterEXT_ptr(id, target);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_disjoint_timer_query
#ifdef GL_EXT_draw_buffers
void glatter_glDrawBuffersEXT_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersEXT, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffersEXT_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_buffers
#ifdef GL_EXT_draw_buffers_indexed
void glatter_glBlendEquationSeparateiEXT_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateiEXT, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateiEXT_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationiEXT_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationiEXT, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationiEXT_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparateiEXT_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateiEXT, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateiEXT_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunciEXT_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunciEXT, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunciEXT_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaskiEXT_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaskiEXT, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaskiEXT_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableiEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableiEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisableiEXT_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableiEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableiEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnableiEXT_ptr(target, index);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnablediEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnablediEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnablediEXT_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_EXT_draw_buffers_indexed
#ifdef GL_EXT_draw_elements_base_vertex
void glatter_glDrawElementsBaseVertexEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertexEXT, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertexEXT_ptr(mode, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertexEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexEXT, (%s, %d, %s, %p, %d, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertexEXT_ptr(mode, count, type, indices, instancecount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementsBaseVertexEXT_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertexEXT, (%s, %u, %u, %d, %s, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertexEXT_ptr(mode, start, end, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsBaseVertexEXT_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const GLint *basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsBaseVertexEXT, (%s, %p, %s, %p, %d, %p), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount, (void*)basevertex)
    glatter_glMultiDrawElementsBaseVertexEXT_ptr(mode, count, type, indices, primcount, basevertex);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_elements_base_vertex
#ifdef GL_EXT_draw_instanced
void glatter_glDrawArraysInstancedEXT_debug(GLenum mode, GLint start, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedEXT, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)start, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedEXT_ptr(mode, start, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedEXT, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedEXT_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_draw_transform_feedback
void glatter_glDrawTransformFeedbackEXT_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackEXT, (%s, %u), enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedbackEXT_ptr(mode, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackInstancedEXT_debug(GLenum mode, GLuint id, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackInstancedEXT, (%s, %u, %d), enum_to_string_GL(mode), (unsigned int)id, (int)instancecount)
    glatter_glDrawTransformFeedbackInstancedEXT_ptr(mode, id, instancecount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_transform_feedback
#ifdef GL_EXT_geometry_shader
void glatter_glFramebufferTextureEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureEXT, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureEXT_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_geometry_shader
#ifdef GL_EXT_instanced_arrays
void glatter_glVertexAttribDivisorEXT_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisorEXT, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisorEXT_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_instanced_arrays
#ifdef GL_EXT_map_buffer_range
void glatter_glFlushMappedBufferRangeEXT_debug(GLenum target, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRangeEXT, (%s, %td, %td), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedBufferRangeEXT_ptr(target, offset, length);
    glatter_check_error_GL(file, line);
}
void * glatter_glMapBufferRangeEXT_debug(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferRangeEXT, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapBufferRangeEXT_ptr(target, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_EXT_map_buffer_range
#ifdef GL_EXT_multi_draw_arrays
void glatter_glMultiDrawArraysEXT_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysEXT, (%s, %p, %p, %d), enum_to_string_GL(mode), (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawArraysEXT_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsEXT_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsEXT, (%s, %p, %s, %p, %d), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glMultiDrawElementsEXT_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multi_draw_arrays
#ifdef GL_EXT_multi_draw_indirect
void glatter_glMultiDrawArraysIndirectEXT_debug(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectEXT, (%s, %p, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawArraysIndirectEXT_ptr(mode, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectEXT_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectEXT, (%s, %s, %p, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawElementsIndirectEXT_ptr(mode, type, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multi_draw_indirect
#ifdef GL_EXT_multisampled_render_to_texture
void glatter_glFramebufferTexture2DMultisampleEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2DMultisampleEXT, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)samples)
    glatter_glFramebufferTexture2DMultisampleEXT_ptr(target, attachment, textarget, texture, level, samples);
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorageMultisampleEXT_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleEXT, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleEXT_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multisampled_render_to_texture
#ifdef GL_EXT_multiview_draw_buffers
void glatter_glDrawBuffersIndexedEXT_debug(GLint n, const GLenum *location, const GLint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersIndexedEXT, (%d, %p, %p), (int)n, (void*)location, (void*)indices)
    glatter_glDrawBuffersIndexedEXT_ptr(n, location, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegeri_vEXT_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegeri_vEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegeri_vEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glReadBufferIndexedEXT_debug(GLenum src, GLint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadBufferIndexedEXT, (%s, %d), enum_to_string_GL(src), (int)index)
    glatter_glReadBufferIndexedEXT_ptr(src, index);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multiview_draw_buffers
#ifdef GL_EXT_polygon_offset_clamp
void glatter_glPolygonOffsetClampEXT_debug(GLfloat factor, GLfloat units, GLfloat clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetClampEXT, (%f, %f, %f), (float)factor, (float)units, (float)clamp)
    glatter_glPolygonOffsetClampEXT_ptr(factor, units, clamp);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_primitive_bounding_box
void glatter_glPrimitiveBoundingBoxEXT_debug(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveBoundingBoxEXT, (%f, %f, %f, %f, %f, %f, %f, %f), (float)minX, (float)minY, (float)minZ, (float)minW, (float)maxX, (float)maxY, (float)maxZ, (float)maxW)
    glatter_glPrimitiveBoundingBoxEXT_ptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_primitive_bounding_box
#ifdef GL_EXT_raster_multisample
void glatter_glRasterSamplesEXT_debug(GLuint samples, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterSamplesEXT, (%u, %u), (unsigned int)samples, (unsigned char)fixedsamplelocations)
    glatter_glRasterSamplesEXT_ptr(samples, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_robustness
GLenum glatter_glGetGraphicsResetStatusEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatusEXT, ())
    GLenum rval = glatter_glGetGraphicsResetStatusEXT_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetnUniformfvEXT_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfvEXT_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformivEXT_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformivEXT_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixelsEXT_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixelsEXT, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixelsEXT_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_robustness
#ifdef GL_EXT_separate_shader_objects
void glatter_glActiveShaderProgramEXT_debug(GLuint pipeline, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveShaderProgramEXT, (%u, %u), (unsigned int)pipeline, (unsigned int)program)
    glatter_glActiveShaderProgramEXT_ptr(pipeline, program);
    glatter_check_error_GL(file, line);
}
void glatter_glBindProgramPipelineEXT_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramPipelineEXT, (%u), (unsigned int)pipeline)
    glatter_glBindProgramPipelineEXT_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramvEXT_debug(GLenum type, GLsizei count, const GLchar **strings, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramvEXT, (%s, %d, %p), enum_to_string_GL(type), (int)count, (void*)strings)
    GLuint rval = glatter_glCreateShaderProgramvEXT_ptr(type, count, strings);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgramPipelinesEXT_debug(GLsizei n, const GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramPipelinesEXT, (%d, %p), (int)n, (void*)pipelines)
    glatter_glDeleteProgramPipelinesEXT_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramPipelinesEXT_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramPipelinesEXT, (%d, %p), (int)n, (void*)pipelines)
    glatter_glGenProgramPipelinesEXT_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineInfoLogEXT_debug(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineInfoLogEXT, (%u, %d, %p, %p), (unsigned int)pipeline, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramPipelineInfoLogEXT_ptr(pipeline, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineivEXT_debug(GLuint pipeline, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineivEXT, (%u, %s, %p), (unsigned int)pipeline, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramPipelineivEXT_ptr(pipeline, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramPipelineEXT_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramPipelineEXT, (%u), (unsigned int)pipeline)
    GLboolean rval = glatter_glIsProgramPipelineEXT_ptr(pipeline);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramParameteriEXT_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteriEXT, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteriEXT_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fEXT_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fEXT, (%u, %d, %f), (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1fEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1iEXT_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iEXT, (%u, %d, %d), (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1iEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uiEXT_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiEXT, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1uiEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fEXT, (%u, %d, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2fEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iEXT, (%u, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2iEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiEXT, (%u, %d, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2uiEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fEXT, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3fEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iEXT, (%u, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3iEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiEXT, (%u, %d, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3uiEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fEXT, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4fEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iEXT, (%u, %d, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4iEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiEXT, (%u, %d, %u, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4uiEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgramStagesEXT_debug(GLuint pipeline, GLbitfield stages, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramStagesEXT, (%u, %u, %u), (unsigned int)pipeline, (unsigned int)stages, (unsigned int)program)
    glatter_glUseProgramStagesEXT_ptr(pipeline, stages, program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgramPipelineEXT_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramPipelineEXT, (%u), (unsigned int)pipeline)
    glatter_glValidateProgramPipelineEXT_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_shader_pixel_local_storage2
void glatter_glClearPixelLocalStorageuiEXT_debug(GLsizei offset, GLsizei n, const GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearPixelLocalStorageuiEXT, (%d, %d, %p), (int)offset, (int)n, (void*)values)
    glatter_glClearPixelLocalStorageuiEXT_ptr(offset, n, values);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferPixelLocalStorageSizeEXT_debug(GLuint target, GLsizei size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferPixelLocalStorageSizeEXT, (%u, %d), (unsigned int)target, (int)size)
    glatter_glFramebufferPixelLocalStorageSizeEXT_ptr(target, size);
    glatter_check_error_GL(file, line);
}
GLsizei glatter_glGetFramebufferPixelLocalStorageSizeEXT_debug(GLuint target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferPixelLocalStorageSizeEXT, (%u), (unsigned int)target)
    GLsizei rval = glatter_glGetFramebufferPixelLocalStorageSizeEXT_ptr(target);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_EXT_shader_pixel_local_storage2
#ifdef GL_EXT_sparse_texture
void glatter_glTexPageCommitmentEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexPageCommitmentEXT, (%s, %d, %d, %d, %d, %d, %d, %d, %u), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexPageCommitmentEXT_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_sparse_texture
#ifdef GL_EXT_tessellation_shader
void glatter_glPatchParameteriEXT_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteriEXT, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteriEXT_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_tessellation_shader
#ifdef GL_EXT_texture_border_clamp
void glatter_glGetSamplerParameterIivEXT_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIivEXT, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIivEXT_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIuivEXT_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuivEXT, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuivEXT_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuivEXT_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIivEXT_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIivEXT, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIivEXT_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIuivEXT_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuivEXT, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuivEXT_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuivEXT_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_border_clamp
#ifdef GL_EXT_texture_buffer
void glatter_glTexBufferEXT_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferEXT, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferEXT_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBufferRangeEXT_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRangeEXT, (%s, %s, %u, %td, %td), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTexBufferRangeEXT_ptr(target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_buffer
#ifdef GL_EXT_texture_storage
void glatter_glTexStorage1DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage1DEXT, (%s, %d, %s, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTexStorage1DEXT_ptr(target, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DEXT, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2DEXT_ptr(target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3DEXT_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DEXT, (%s, %d, %s, %d, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3DEXT_ptr(target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage1DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1DEXT, (%u, %s, %d, %s, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1DEXT_ptr(texture, target, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DEXT, (%u, %s, %d, %s, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2DEXT_ptr(texture, target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DEXT, (%u, %s, %d, %s, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3DEXT_ptr(texture, target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_storage
#ifdef GL_EXT_texture_view
void glatter_glTextureViewEXT_debug(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureViewEXT, (%u, %s, %u, %s, %u, %u, %u, %u), (unsigned int)texture, enum_to_string_GL(target), (unsigned int)origtexture, enum_to_string_GL(internalformat), (unsigned int)minlevel, (unsigned int)numlevels, (unsigned int)minlayer, (unsigned int)numlayers)
    glatter_glTextureViewEXT_ptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_view
#ifdef GL_EXT_window_rectangles
void glatter_glWindowRectanglesEXT_debug(GLenum mode, GLsizei count, const GLint *box, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowRectanglesEXT, (%s, %d, %p), enum_to_string_GL(mode), (int)count, (void*)box)
    glatter_glWindowRectanglesEXT_ptr(mode, count, box);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_window_rectangles
#ifdef GL_IMG_bindless_texture
GLuint64 glatter_glGetTextureHandleIMG_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleIMG, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleIMG_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleIMG_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleIMG, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleIMG_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramUniformHandleui64IMG_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64IMG, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64IMG_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vIMG_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vIMG, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vIMG_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64IMG_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64IMG, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64IMG_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vIMG_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vIMG, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vIMG_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_IMG_bindless_texture
#ifdef GL_IMG_framebuffer_downsample
void glatter_glFramebufferTexture2DDownsampleIMG_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2DDownsampleIMG, (%s, %s, %s, %u, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)xscale, (int)yscale)
    glatter_glFramebufferTexture2DDownsampleIMG_ptr(target, attachment, textarget, texture, level, xscale, yscale);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureLayerDownsampleIMG_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayerDownsampleIMG, (%s, %s, %u, %d, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer, (int)xscale, (int)yscale)
    glatter_glFramebufferTextureLayerDownsampleIMG_ptr(target, attachment, texture, level, layer, xscale, yscale);
    glatter_check_error_GL(file, line);
}
#endif // GL_IMG_framebuffer_downsample
#ifdef GL_IMG_multisampled_render_to_texture
void glatter_glFramebufferTexture2DMultisampleIMG_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2DMultisampleIMG, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)samples)
    glatter_glFramebufferTexture2DMultisampleIMG_ptr(target, attachment, textarget, texture, level, samples);
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorageMultisampleIMG_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleIMG, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleIMG_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_IMG_multisampled_render_to_texture
#ifdef GL_INTEL_framebuffer_CMAA
void glatter_glApplyFramebufferAttachmentCMAAINTEL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyFramebufferAttachmentCMAAINTEL, ())
    glatter_glApplyFramebufferAttachmentCMAAINTEL_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_performance_query
void glatter_glBeginPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glBeginPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glCreatePerfQueryINTEL_debug(GLuint queryId, GLuint *queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreatePerfQueryINTEL, (%u, %p), (unsigned int)queryId, (void*)queryHandle)
    glatter_glCreatePerfQueryINTEL_ptr(queryId, queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glDeletePerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glEndPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFirstPerfQueryIdINTEL_debug(GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFirstPerfQueryIdINTEL, (%p), (void*)queryId)
    glatter_glGetFirstPerfQueryIdINTEL_ptr(queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNextPerfQueryIdINTEL_debug(GLuint queryId, GLuint *nextQueryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNextPerfQueryIdINTEL, (%u, %p), (unsigned int)queryId, (void*)nextQueryId)
    glatter_glGetNextPerfQueryIdINTEL_ptr(queryId, nextQueryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfCounterInfoINTEL_debug(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfCounterInfoINTEL, (%u, %u, %u, %p, %u, %p, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)counterId, (unsigned int)counterNameLength, (void*)counterName, (unsigned int)counterDescLength, (void*)counterDesc, (void*)counterOffset, (void*)counterDataSize, (void*)counterTypeEnum, (void*)counterDataTypeEnum, (void*)rawCounterMaxValue)
    glatter_glGetPerfCounterInfoINTEL_ptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryDataINTEL_debug(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryDataINTEL, (%u, %u, %d, %p, %p), (unsigned int)queryHandle, (unsigned int)flags, (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfQueryDataINTEL_ptr(queryHandle, flags, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryIdByNameINTEL_debug(GLchar *queryName, GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryIdByNameINTEL, (%p, %p), (void*)queryName, (void*)queryId)
    glatter_glGetPerfQueryIdByNameINTEL_ptr(queryName, queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryInfoINTEL_debug(GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryInfoINTEL, (%u, %u, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)queryNameLength, (void*)queryName, (void*)dataSize, (void*)noCounters, (void*)noInstances, (void*)capsMask)
    glatter_glGetPerfQueryInfoINTEL_ptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
void glatter_glBlendBarrierKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierKHR, ())
    glatter_glBlendBarrierKHR_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_KHR_debug
void glatter_glDebugMessageCallbackKHR_debug(GLDEBUGPROCKHR callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackKHR, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackKHR_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControlKHR_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControlKHR, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControlKHR_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsertKHR_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertKHR, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsertKHR_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLogKHR_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogKHR, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLogKHR_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetObjectLabelKHR_debug(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabelKHR, (%s, %u, %d, %p, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabelKHR_ptr(identifier, name, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectPtrLabelKHR_debug(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectPtrLabelKHR, (%p, %d, %p, %p), (void*)ptr, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectPtrLabelKHR_ptr(ptr, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointervKHR_debug(GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointervKHR, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointervKHR_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectLabelKHR_debug(GLenum identifier, GLuint name, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectLabelKHR, (%s, %u, %d, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)length, (void*)label)
    glatter_glObjectLabelKHR_ptr(identifier, name, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectPtrLabelKHR_debug(const void *ptr, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPtrLabelKHR, (%p, %d, %p), (void*)ptr, (int)length, (void*)label)
    glatter_glObjectPtrLabelKHR_ptr(ptr, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glPopDebugGroupKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopDebugGroupKHR, ())
    glatter_glPopDebugGroupKHR_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushDebugGroupKHR_debug(GLenum source, GLuint id, GLsizei length, const GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushDebugGroupKHR, (%s, %u, %d, %p), enum_to_string_GL(source), (unsigned int)id, (int)length, (void*)message)
    glatter_glPushDebugGroupKHR_ptr(source, id, length, message);
    glatter_check_error_GL(file, line);
}
#endif // GL_KHR_debug
#ifdef GL_KHR_robustness
GLenum glatter_glGetGraphicsResetStatusKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatusKHR, ())
    GLenum rval = glatter_glGetGraphicsResetStatusKHR_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetnUniformfvKHR_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfvKHR, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfvKHR_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformivKHR_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformivKHR, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformivKHR_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuivKHR_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuivKHR, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuivKHR_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixelsKHR_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixelsKHR, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixelsKHR_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_KHR_robustness
#ifdef GL_NV_bindless_texture
GLuint64 glatter_glGetImageHandleNV_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleNV, (%u, %d, %u, %d, %s), (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleNV_ptr(texture, level, layered, layer, format);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureHandleNV_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleNV, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleNV_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleNV_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleNV, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleNV_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsImageHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeImageHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeImageHandleResidentNV_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentNV, (%s, %s), GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentNV_ptr(handle, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64NV_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64NV_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vNV_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64NV_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64NV, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64NV_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vNV_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
void glatter_glBlendBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierNV, ())
    glatter_glBlendBarrierNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glBlendParameteriNV_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glBlendParameteriNV_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_conditional_render
void glatter_glBeginConditionalRenderNV_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNV, (%u, %s), (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRenderNV_ptr(id, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRenderNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNV, ())
    glatter_glEndConditionalRenderNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
void glatter_glSubpixelPrecisionBiasNV_debug(GLuint xbits, GLuint ybits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSubpixelPrecisionBiasNV, (%u, %u), (unsigned int)xbits, (unsigned int)ybits)
    glatter_glSubpixelPrecisionBiasNV_ptr(xbits, ybits);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_pre_snap_triangles
void glatter_glConservativeRasterParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glConservativeRasterParameteriNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_copy_buffer
void glatter_glCopyBufferSubDataNV_debug(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyBufferSubDataNV, (%s, %s, %td, %td, %td), enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyBufferSubDataNV_ptr(readTarget, writeTarget, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_copy_buffer
#ifdef GL_NV_coverage_sample
void glatter_glCoverageMaskNV_debug(GLboolean mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageMaskNV, (%u), (unsigned char)mask)
    glatter_glCoverageMaskNV_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverageOperationNV_debug(GLenum operation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageOperationNV, (%s), enum_to_string_GL(operation))
    glatter_glCoverageOperationNV_ptr(operation);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_coverage_sample
#ifdef GL_NV_draw_buffers
void glatter_glDrawBuffersNV_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersNV, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffersNV_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_draw_buffers
#ifdef GL_NV_draw_instanced
void glatter_glDrawArraysInstancedNV_debug(GLenum mode, GLint first, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedNV, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedNV_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedNV_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedNV, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedNV_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_draw_instanced
#ifdef GL_NV_fence
void glatter_glDeleteFencesNV_debug(GLsizei n, const GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFencesNV, (%d, %p), (int)n, (void*)fences)
    glatter_glDeleteFencesNV_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
void glatter_glFinishFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishFenceNV, (%u), (unsigned int)fence)
    glatter_glFinishFenceNV_ptr(fence);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFencesNV_debug(GLsizei n, GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFencesNV, (%d, %p), (int)n, (void*)fences)
    glatter_glGenFencesNV_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFenceivNV_debug(GLuint fence, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFenceivNV, (%u, %s, %p), (unsigned int)fence, enum_to_string_GL(pname), (void*)params)
    glatter_glGetFenceivNV_ptr(fence, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFenceNV, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glIsFenceNV_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glSetFenceNV_debug(GLuint fence, GLenum condition, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFenceNV, (%u, %s), (unsigned int)fence, enum_to_string_GL(condition))
    glatter_glSetFenceNV_ptr(fence, condition);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glTestFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestFenceNV, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glTestFenceNV_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_NV_fence
#ifdef GL_NV_fragment_coverage_to_color
void glatter_glFragmentCoverageColorNV_debug(GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentCoverageColorNV, (%u), (unsigned int)color)
    glatter_glFragmentCoverageColorNV_ptr(color);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_framebuffer_blit
void glatter_glBlitFramebufferNV_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferNV, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferNV_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_blit
#ifdef GL_NV_framebuffer_mixed_samples
void glatter_glCoverageModulationNV_debug(GLenum components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationNV, (%s), enum_to_string_GL(components))
    glatter_glCoverageModulationNV_ptr(components);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverageModulationTableNV_debug(GLsizei n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationTableNV, (%d, %p), (int)n, (void*)v)
    glatter_glCoverageModulationTableNV_ptr(n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCoverageModulationTableNV_debug(GLsizei bufsize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCoverageModulationTableNV, (%d, %p), (int)bufsize, (void*)v)
    glatter_glGetCoverageModulationTableNV_ptr(bufsize, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_framebuffer_multisample
void glatter_glRenderbufferStorageMultisampleNV_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleNV, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleNV_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_multisample
#ifdef GL_NV_gpu_shader5
void glatter_glGetUniformi64vNV_debug(GLuint program, GLint location, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vNV, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vNV_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64NV_debug(GLuint program, GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64NV_debug(GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1i64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64NV_debug(GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1ui64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_gpu_shader5
#ifdef GL_NV_instanced_arrays
void glatter_glVertexAttribDivisorNV_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisorNV, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisorNV_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_instanced_arrays
#ifdef GL_NV_internalformat_sample_query
void glatter_glGetInternalformatSampleivNV_debug(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformatSampleivNV, (%s, %s, %d, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)samples, enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformatSampleivNV_ptr(target, internalformat, samples, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_non_square_matrices
void glatter_glUniformMatrix2x3fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3fvNV_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3fvNV, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3fvNV_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_non_square_matrices
#ifdef GL_NV_path_rendering
void glatter_glCopyPathNV_debug(GLuint resultPath, GLuint srcPath, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyPathNV, (%u, %u), (unsigned int)resultPath, (unsigned int)srcPath)
    glatter_glCopyPathNV_ptr(resultPath, srcPath);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverFillPathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverStrokePathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePathsNV_debug(GLuint path, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePathsNV, (%u, %d), (unsigned int)path, (int)range)
    glatter_glDeletePathsNV_ptr(path, range);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenPathsNV_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPathsNV, (%d), (int)range)
    GLuint rval = glatter_glGenPathsNV_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathCommandsNV_debug(GLuint path, GLubyte *commands, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCommandsNV, (%u, %p), (unsigned int)path, (void*)commands)
    glatter_glGetPathCommandsNV_ptr(path, commands);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathCoordsNV_debug(GLuint path, GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCoordsNV, (%u, %p), (unsigned int)path, (void*)coords)
    glatter_glGetPathCoordsNV_ptr(path, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathDashArrayNV_debug(GLuint path, GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathDashArrayNV, (%u, %p), (unsigned int)path, (void*)dashArray)
    glatter_glGetPathDashArrayNV_ptr(path, dashArray);
    glatter_check_error_GL(file, line);
}
GLfloat glatter_glGetPathLengthNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathLengthNV, (%u, %d, %d), (unsigned int)path, (int)startSegment, (int)numSegments)
    GLfloat rval = glatter_glGetPathLengthNV_ptr(path, startSegment, numSegments);
    printf("GLATTER: returned %f", (float)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathMetricRangeNV_debug(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricRangeNV, (%u, %u, %d, %d, %p), (unsigned int)metricQueryMask, (unsigned int)firstPathName, (int)numPaths, (int)stride, (void*)metrics)
    glatter_glGetPathMetricRangeNV_ptr(metricQueryMask, firstPathName, numPaths, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathMetricsNV_debug(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricsNV, (%u, %d, %s, %p, %u, %d, %p), (unsigned int)metricQueryMask, (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)stride, (void*)metrics)
    glatter_glGetPathMetricsNV_ptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterfvNV_debug(GLuint path, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterivNV_debug(GLuint path, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathSpacingNV_debug(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathSpacingNV, (%s, %d, %s, %p, %u, %f, %f, %s, %p), enum_to_string_GL(pathListMode), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (float)advanceScale, (float)kerningScale, enum_to_string_GL(transformType), (void*)returnedSpacing)
    glatter_glGetPathSpacingNV_ptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourcefvNV_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourcefvNV, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourcefvNV_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInterpolatePathsNV_debug(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInterpolatePathsNV, (%u, %u, %u, %f), (unsigned int)resultPath, (unsigned int)pathA, (unsigned int)pathB, (float)weight)
    glatter_glInterpolatePathsNV_ptr(resultPath, pathA, pathB, weight);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsPathNV_debug(GLuint path, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPathNV, (%u), (unsigned int)path)
    GLboolean rval = glatter_glIsPathNV_ptr(path);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInFillPathNV_debug(GLuint path, GLuint mask, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInFillPathNV, (%u, %u, %f, %f), (unsigned int)path, (unsigned int)mask, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInFillPathNV_ptr(path, mask, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInStrokePathNV_debug(GLuint path, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInStrokePathNV, (%u, %f, %f), (unsigned int)path, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInStrokePathNV_ptr(path, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMatrixLoad3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoad3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoadTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMultTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCommandsNV_debug(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCommandsNV, (%u, %d, %p, %d, %s, %p), (unsigned int)path, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCommandsNV_ptr(path, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoordsNV_debug(GLuint path, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoordsNV, (%u, %d, %s, %p), (unsigned int)path, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCoordsNV_ptr(path, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoverDepthFuncNV_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoverDepthFuncNV, (%s), enum_to_string_GL(func))
    glatter_glPathCoverDepthFuncNV_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glPathDashArrayNV_debug(GLuint path, GLsizei dashCount, const GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathDashArrayNV, (%u, %d, %p), (unsigned int)path, (int)dashCount, (void*)dashArray)
    glatter_glPathDashArrayNV_ptr(path, dashCount, dashArray);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexArrayNV, (%u, %s, %p, %u, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLenum glatter_glPathGlyphIndexRangeNV_debug(GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2], const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexRangeNV, (%s, %p, %u, %u, %f, %s), enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)pathParameterTemplate, (float)emScale, GET_PRS(baseAndCount))
    GLenum rval = glatter_glPathGlyphIndexRangeNV_ptr(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathGlyphRangeNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphRangeNV, (%u, %s, %p, %u, %u, %d, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyph, (int)numGlyphs, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphRangeNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
void glatter_glPathGlyphsNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphsNV, (%u, %s, %p, %u, %d, %s, %p, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (int)numGlyphs, enum_to_string_GL(type), (void*)charcodes, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphsNV_ptr(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathMemoryGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathMemoryGlyphIndexArrayNV, (%u, %s, %td, %p, %d, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (ptrdiff_t)fontSize, (void*)fontData, (int)faceIndex, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathMemoryGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathParameterfNV_debug(GLuint path, GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfNV, (%u, %s, %f), (unsigned int)path, enum_to_string_GL(pname), (float)value)
    glatter_glPathParameterfNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterfvNV_debug(GLuint path, GLenum pname, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameteriNV_debug(GLuint path, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameteriNV, (%u, %s, %d), (unsigned int)path, enum_to_string_GL(pname), (int)value)
    glatter_glPathParameteriNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterivNV_debug(GLuint path, GLenum pname, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilDepthOffsetNV_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilDepthOffsetNV, (%f, %f), (float)factor, (float)units)
    glatter_glPathStencilDepthOffsetNV_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilFuncNV_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilFuncNV, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glPathStencilFuncNV_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStringNV_debug(GLuint path, GLenum format, GLsizei length, const void *pathString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStringNV, (%u, %s, %d, %p), (unsigned int)path, enum_to_string_GL(format), (int)length, (void*)pathString)
    glatter_glPathStringNV_ptr(path, format, length, pathString);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCommandsNV_debug(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCommandsNV, (%u, %d, %d, %d, %p, %d, %s, %p), (unsigned int)path, (int)commandStart, (int)commandsToDelete, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCommandsNV_ptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCoordsNV_debug(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCoordsNV, (%u, %d, %d, %s, %p), (unsigned int)path, (int)coordStart, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCoordsNV_ptr(path, coordStart, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glPointAlongPathNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointAlongPathNV, (%u, %d, %d, %f, %p, %p, %p, %p), (unsigned int)path, (int)startSegment, (int)numSegments, (float)distance, (void*)x, (void*)y, (void*)tangentX, (void*)tangentY)
    GLboolean rval = glatter_glPointAlongPathNV_ptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramPathFragmentInputGenNV_debug(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramPathFragmentInputGenNV, (%u, %d, %s, %d, %p), (unsigned int)program, (int)location, enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glProgramPathFragmentInputGenNV_ptr(program, location, genMode, components, coeffs);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathNV, (%u, %s, %u), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask)
    glatter_glStencilFillPathNV_ptr(path, fillMode, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathNV, (%u, %d, %u), (unsigned int)path, (int)reference, (unsigned int)mask)
    glatter_glStencilStrokePathNV_ptr(path, reference, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathNV, (%u, %s, %u, %s), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverFillPathNV_ptr(path, fillMode, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathNV, (%u, %d, %u, %s), (unsigned int)path, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverStrokePathNV_ptr(path, reference, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformPathNV_debug(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformPathNV, (%u, %u, %s, %p), (unsigned int)resultPath, (unsigned int)srcPath, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glTransformPathNV_ptr(resultPath, srcPath, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightPathsNV_debug(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPathsNV, (%u, %d, %p, %p), (unsigned int)resultPath, (int)numPaths, (void*)paths, (void*)weights)
    glatter_glWeightPathsNV_ptr(resultPath, numPaths, paths, weights);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_path_rendering
#ifdef GL_NV_polygon_mode
void glatter_glPolygonModeNV_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonModeNV, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glPolygonModeNV_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_polygon_mode
#ifdef GL_NV_read_buffer
void glatter_glReadBufferNV_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadBufferNV, (%s), enum_to_string_GL(mode))
    glatter_glReadBufferNV_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_read_buffer
#ifdef GL_NV_sample_locations
void glatter_glFramebufferSampleLocationsfvNV_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvNV_ptr(target, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferSampleLocationsfvNV_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvNV, (%u, %u, %d, %p), (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvNV_ptr(framebuffer, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glResolveDepthValuesNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResolveDepthValuesNV, ())
    glatter_glResolveDepthValuesNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_sample_locations
#ifdef GL_NV_viewport_array
void glatter_glDepthRangeArrayfvNV_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArrayfvNV, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArrayfvNV_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeIndexedfNV_debug(GLuint index, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexedfNV, (%u, %f, %f), (unsigned int)index, (float)n, (float)f)
    glatter_glDepthRangeIndexedfNV_ptr(index, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableiNV_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableiNV, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisableiNV_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableiNV_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableiNV, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnableiNV_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloati_vNV_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_vNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloati_vNV_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnablediNV_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnablediNV, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnablediNV_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glScissorArrayvNV_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorArrayvNV, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorArrayvNV_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedNV_debug(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedNV, (%u, %d, %d, %d, %d), (unsigned int)index, (int)left, (int)bottom, (int)width, (int)height)
    glatter_glScissorIndexedNV_ptr(index, left, bottom, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedvNV_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glScissorIndexedvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportArrayvNV_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportArrayvNV, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glViewportArrayvNV_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfNV_debug(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfNV, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)w, (float)h)
    glatter_glViewportIndexedfNV_ptr(index, x, y, w, h);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glViewportIndexedfvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_viewport_array
#ifdef GL_NV_viewport_swizzle
void glatter_glViewportSwizzleNV_debug(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportSwizzleNV, (%u, %s, %s, %s, %s), (unsigned int)index, enum_to_string_GL(swizzlex), enum_to_string_GL(swizzley), enum_to_string_GL(swizzlez), enum_to_string_GL(swizzlew))
    glatter_glViewportSwizzleNV_ptr(index, swizzlex, swizzley, swizzlez, swizzlew);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_viewport_swizzle
#ifdef GL_OES_EGL_image
void glatter_glEGLImageTargetRenderbufferStorageOES_debug(GLenum target, GLeglImageOES image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEGLImageTargetRenderbufferStorageOES, (%s, %p), enum_to_string_GL(target), (void*)image)
    glatter_glEGLImageTargetRenderbufferStorageOES_ptr(target, image);
    glatter_check_error_GL(file, line);
}
void glatter_glEGLImageTargetTexture2DOES_debug(GLenum target, GLeglImageOES image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEGLImageTargetTexture2DOES, (%s, %p), enum_to_string_GL(target), (void*)image)
    glatter_glEGLImageTargetTexture2DOES_ptr(target, image);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_EGL_image
#ifdef GL_OES_copy_image
void glatter_glCopyImageSubDataOES_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubDataOES, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubDataOES_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_copy_image
#ifdef GL_OES_draw_buffers_indexed
void glatter_glBlendEquationSeparateiOES_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateiOES, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateiOES_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationiOES_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationiOES, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationiOES_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparateiOES_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateiOES, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateiOES_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunciOES_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunciOES, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunciOES_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaskiOES_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaskiOES, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaskiOES_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableiOES_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableiOES, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisableiOES_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableiOES_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableiOES, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnableiOES_ptr(target, index);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnablediOES_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnablediOES, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnablediOES_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_OES_draw_buffers_indexed
#ifdef GL_OES_draw_elements_base_vertex
void glatter_glDrawElementsBaseVertexOES_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertexOES, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertexOES_ptr(mode, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertexOES_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexOES, (%s, %d, %s, %p, %d, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertexOES_ptr(mode, count, type, indices, instancecount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementsBaseVertexOES_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertexOES, (%s, %u, %u, %d, %s, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertexOES_ptr(mode, start, end, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsBaseVertexOES_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const GLint *basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsBaseVertexOES, (%s, %p, %s, %p, %d, %p), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount, (void*)basevertex)
    glatter_glMultiDrawElementsBaseVertexOES_ptr(mode, count, type, indices, primcount, basevertex);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_draw_elements_base_vertex
#ifdef GL_OES_geometry_shader
void glatter_glFramebufferTextureOES_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureOES, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureOES_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_geometry_shader
#ifdef GL_OES_get_program_binary
void glatter_glGetProgramBinaryOES_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramBinaryOES, (%u, %d, %p, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)binaryFormat, (void*)binary)
    glatter_glGetProgramBinaryOES_ptr(program, bufSize, length, binaryFormat, binary);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramBinaryOES_debug(GLuint program, GLenum binaryFormat, const void *binary, GLint length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBinaryOES, (%u, %s, %p, %d), (unsigned int)program, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glProgramBinaryOES_ptr(program, binaryFormat, binary, length);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_get_program_binary
#ifdef GL_OES_mapbuffer
void glatter_glGetBufferPointervOES_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointervOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointervOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void * glatter_glMapBufferOES_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferOES, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBufferOES_ptr(target, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glUnmapBufferOES_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBufferOES, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBufferOES_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_OES_mapbuffer
#ifdef GL_OES_primitive_bounding_box
void glatter_glPrimitiveBoundingBoxOES_debug(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveBoundingBoxOES, (%f, %f, %f, %f, %f, %f, %f, %f), (float)minX, (float)minY, (float)minZ, (float)minW, (float)maxX, (float)maxY, (float)maxZ, (float)maxW)
    glatter_glPrimitiveBoundingBoxOES_ptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_primitive_bounding_box
#ifdef GL_OES_sample_shading
void glatter_glMinSampleShadingOES_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShadingOES, (%f), (float)value)
    glatter_glMinSampleShadingOES_ptr(value);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_sample_shading
#ifdef GL_OES_tessellation_shader
void glatter_glPatchParameteriOES_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteriOES, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteriOES_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_tessellation_shader
#ifdef GL_OES_texture_3D
void glatter_glCompressedTexImage3DOES_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3DOES, (%s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3DOES_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage3DOES_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3DOES, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage3DOES_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3DOES, (%s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture3DOES_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3DOES, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3DOES_ptr(target, attachment, textarget, texture, level, zoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3DOES_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DOES, (%s, %d, %s, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3DOES_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage3DOES_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3DOES, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_texture_3D
#ifdef GL_OES_texture_border_clamp
void glatter_glGetSamplerParameterIivOES_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIivOES, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIivOES_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIuivOES_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuivOES, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuivOES_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIivOES_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIivOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIivOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuivOES_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuivOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuivOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIivOES_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIivOES, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIivOES_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIuivOES_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuivOES, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuivOES_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIivOES_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIivOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIivOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuivOES_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuivOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuivOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_texture_border_clamp
#ifdef GL_OES_texture_buffer
void glatter_glTexBufferOES_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferOES, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferOES_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBufferRangeOES_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRangeOES, (%s, %s, %u, %td, %td), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTexBufferRangeOES_ptr(target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_texture_buffer
#ifdef GL_OES_texture_storage_multisample_2d_array
void glatter_glTexStorage3DMultisampleOES_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DMultisampleOES, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage3DMultisampleOES_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_texture_storage_multisample_2d_array
#ifdef GL_OES_texture_view
void glatter_glTextureViewOES_debug(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureViewOES, (%u, %s, %u, %s, %u, %u, %u, %u), (unsigned int)texture, enum_to_string_GL(target), (unsigned int)origtexture, enum_to_string_GL(internalformat), (unsigned int)minlevel, (unsigned int)numlevels, (unsigned int)minlayer, (unsigned int)numlayers)
    glatter_glTextureViewOES_ptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_texture_view
#ifdef GL_OES_vertex_array_object
void glatter_glBindVertexArrayOES_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArrayOES, (%u), (unsigned int)array)
    glatter_glBindVertexArrayOES_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexArraysOES_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArraysOES, (%d, %p), (int)n, (void*)arrays)
    glatter_glDeleteVertexArraysOES_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glGenVertexArraysOES_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArraysOES, (%d, %p), (int)n, (void*)arrays)
    glatter_glGenVertexArraysOES_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsVertexArrayOES_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArrayOES, (%u), (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArrayOES_ptr(array);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_OES_vertex_array_object
#ifdef GL_OES_viewport_array
void glatter_glDepthRangeArrayfvOES_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArrayfvOES, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArrayfvOES_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeIndexedfOES_debug(GLuint index, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexedfOES, (%u, %f, %f), (unsigned int)index, (float)n, (float)f)
    glatter_glDepthRangeIndexedfOES_ptr(index, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloati_vOES_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_vOES, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloati_vOES_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorArrayvOES_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorArrayvOES, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorArrayvOES_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedOES_debug(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedOES, (%u, %d, %d, %d, %d), (unsigned int)index, (int)left, (int)bottom, (int)width, (int)height)
    glatter_glScissorIndexedOES_ptr(index, left, bottom, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedvOES_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedvOES, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glScissorIndexedvOES_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportArrayvOES_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportArrayvOES, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glViewportArrayvOES_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfOES_debug(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfOES, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)w, (float)h)
    glatter_glViewportIndexedfOES_ptr(index, x, y, w, h);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfvOES_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfvOES, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glViewportIndexedfvOES_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_viewport_array
#ifdef GL_OVR_multiview
void glatter_glFramebufferTextureMultiviewOVR_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureMultiviewOVR, (%s, %s, %u, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)baseViewIndex, (int)numViews)
    glatter_glFramebufferTextureMultiviewOVR_ptr(target, attachment, texture, level, baseViewIndex, numViews);
    glatter_check_error_GL(file, line);
}
#endif // GL_OVR_multiview
#ifdef GL_OVR_multiview_multisampled_render_to_texture
void glatter_glFramebufferTextureMultisampleMultiviewOVR_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureMultisampleMultiviewOVR, (%s, %s, %u, %d, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)samples, (int)baseViewIndex, (int)numViews)
    glatter_glFramebufferTextureMultisampleMultiviewOVR_ptr(target, attachment, texture, level, samples, baseViewIndex, numViews);
    glatter_check_error_GL(file, line);
}
#endif // GL_OVR_multiview_multisampled_render_to_texture
#ifdef GL_QCOM_alpha_test
void glatter_glAlphaFuncQCOM_debug(GLenum func, GLclampf ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFuncQCOM, (%s, %f), enum_to_string_GL(func), (float)ref)
    glatter_glAlphaFuncQCOM_ptr(func, ref);
    glatter_check_error_GL(file, line);
}
#endif // GL_QCOM_alpha_test
#ifdef GL_QCOM_driver_control
void glatter_glDisableDriverControlQCOM_debug(GLuint driverControl, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableDriverControlQCOM, (%u), (unsigned int)driverControl)
    glatter_glDisableDriverControlQCOM_ptr(driverControl);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableDriverControlQCOM_debug(GLuint driverControl, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableDriverControlQCOM, (%u), (unsigned int)driverControl)
    glatter_glEnableDriverControlQCOM_ptr(driverControl);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDriverControlStringQCOM_debug(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDriverControlStringQCOM, (%u, %d, %p, %p), (unsigned int)driverControl, (int)bufSize, (void*)length, (void*)driverControlString)
    glatter_glGetDriverControlStringQCOM_ptr(driverControl, bufSize, length, driverControlString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDriverControlsQCOM_debug(GLint *num, GLsizei size, GLuint *driverControls, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDriverControlsQCOM, (%p, %d, %p), (void*)num, (int)size, (void*)driverControls)
    glatter_glGetDriverControlsQCOM_ptr(num, size, driverControls);
    glatter_check_error_GL(file, line);
}
#endif // GL_QCOM_driver_control
#ifdef GL_QCOM_extended_get
void glatter_glExtGetBufferPointervQCOM_debug(GLenum target, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetBufferPointervQCOM, (%s, %p), enum_to_string_GL(target), (void*)params)
    glatter_glExtGetBufferPointervQCOM_ptr(target, params);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetBuffersQCOM_debug(GLuint *buffers, GLint maxBuffers, GLint *numBuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetBuffersQCOM, (%p, %d, %p), (void*)buffers, (int)maxBuffers, (void*)numBuffers)
    glatter_glExtGetBuffersQCOM_ptr(buffers, maxBuffers, numBuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetFramebuffersQCOM_debug(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetFramebuffersQCOM, (%p, %d, %p), (void*)framebuffers, (int)maxFramebuffers, (void*)numFramebuffers)
    glatter_glExtGetFramebuffersQCOM_ptr(framebuffers, maxFramebuffers, numFramebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetRenderbuffersQCOM_debug(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetRenderbuffersQCOM, (%p, %d, %p), (void*)renderbuffers, (int)maxRenderbuffers, (void*)numRenderbuffers)
    glatter_glExtGetRenderbuffersQCOM_ptr(renderbuffers, maxRenderbuffers, numRenderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetTexLevelParameterivQCOM_debug(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetTexLevelParameterivQCOM, (%u, %s, %d, %s, %p), (unsigned int)texture, enum_to_string_GL(face), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glExtGetTexLevelParameterivQCOM_ptr(texture, face, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetTexSubImageQCOM_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetTexSubImageQCOM, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)texels)
    glatter_glExtGetTexSubImageQCOM_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetTexturesQCOM_debug(GLuint *textures, GLint maxTextures, GLint *numTextures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetTexturesQCOM, (%p, %d, %p), (void*)textures, (int)maxTextures, (void*)numTextures)
    glatter_glExtGetTexturesQCOM_ptr(textures, maxTextures, numTextures);
    glatter_check_error_GL(file, line);
}
void glatter_glExtTexObjectStateOverrideiQCOM_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtTexObjectStateOverrideiQCOM, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glExtTexObjectStateOverrideiQCOM_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_QCOM_extended_get
#ifdef GL_QCOM_extended_get2
void glatter_glExtGetProgramBinarySourceQCOM_debug(GLuint program, GLenum shadertype, GLchar *source, GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetProgramBinarySourceQCOM, (%u, %s, %p, %p), (unsigned int)program, enum_to_string_GL(shadertype), (void*)source, (void*)length)
    glatter_glExtGetProgramBinarySourceQCOM_ptr(program, shadertype, source, length);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetProgramsQCOM_debug(GLuint *programs, GLint maxPrograms, GLint *numPrograms, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetProgramsQCOM, (%p, %d, %p), (void*)programs, (int)maxPrograms, (void*)numPrograms)
    glatter_glExtGetProgramsQCOM_ptr(programs, maxPrograms, numPrograms);
    glatter_check_error_GL(file, line);
}
void glatter_glExtGetShadersQCOM_debug(GLuint *shaders, GLint maxShaders, GLint *numShaders, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtGetShadersQCOM, (%p, %d, %p), (void*)shaders, (int)maxShaders, (void*)numShaders)
    glatter_glExtGetShadersQCOM_ptr(shaders, maxShaders, numShaders);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glExtIsProgramBinaryQCOM_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtIsProgramBinaryQCOM, (%u), (unsigned int)program)
    GLboolean rval = glatter_glExtIsProgramBinaryQCOM_ptr(program);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_QCOM_extended_get2
#ifdef GL_QCOM_tiled_rendering
void glatter_glEndTilingQCOM_debug(GLbitfield preserveMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTilingQCOM, (%u), (unsigned int)preserveMask)
    glatter_glEndTilingQCOM_ptr(preserveMask);
    glatter_check_error_GL(file, line);
}
void glatter_glStartTilingQCOM_debug(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStartTilingQCOM, (%u, %u, %u, %u, %u), (unsigned int)x, (unsigned int)y, (unsigned int)width, (unsigned int)height, (unsigned int)preserveMask)
    glatter_glStartTilingQCOM_ptr(x, y, width, height, preserveMask);
    glatter_check_error_GL(file, line);
}
#endif // GL_QCOM_tiled_rendering
#endif // __gl2ext_h_

#ifdef __gl32_h_
#ifdef GL_ES_VERSION_2_0
void glatter_glActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTexture, (%s), enum_to_string_GL(texture))
    glatter_glActiveTexture_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glAttachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glAttachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glBindAttribLocation_debug(GLuint program, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocation, (%u, %u, %p), (unsigned int)program, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocation_ptr(program, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBuffer_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBuffer_ptr(target, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFramebuffer_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebuffer_ptr(target, framebuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindRenderbuffer_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbuffer_ptr(target, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTexture_debug(GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTexture, (%s, %u), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindTexture_ptr(target, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquation_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquation, (%s), enum_to_string_GL(mode))
    glatter_glBlendEquation_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparate_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparate, (%s, %s), enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparate_ptr(modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunc_debug(GLenum sfactor, GLenum dfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunc, (%s, %s), enum_to_string_GL(sfactor), enum_to_string_GL(dfactor))
    glatter_glBlendFunc_ptr(sfactor, dfactor);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparate_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparate, (%s, %s, %s, %s), enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparate_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferData_debug(GLenum target, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferData, (%s, %td, %p, %s), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glBufferData_ptr(target, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubData, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glBufferSubData_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckFramebufferStatus_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatus, (%s), enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatus_ptr(target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClear_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClear, (%u), (unsigned int)mask)
    glatter_glClear_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glClearColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glClearColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepthf_debug(GLfloat d, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthf, (%f), (float)d)
    glatter_glClearDepthf_ptr(d);
    glatter_check_error_GL(file, line);
}
void glatter_glClearStencil_debug(GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearStencil, (%d), (int)s)
    glatter_glClearStencil_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMask_debug(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMask, (%u, %u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glColorMask_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glCompileShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShader, (%u), (unsigned int)shader)
    glatter_glCompileShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2D_ptr(target, level, internalformat, width, height, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTexImage2D_ptr(target, level, internalformat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage2D, (%s, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage2D_ptr(target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateProgram_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgram, ())
    GLuint rval = glatter_glCreateProgram_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glCreateShader_debug(GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShader, (%s), enum_to_string_GL(type))
    GLuint rval = glatter_glCreateShader_ptr(type);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glCullFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullFace, (%s), enum_to_string_GL(mode))
    glatter_glCullFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteBuffers_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glDeleteBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteFramebuffers_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgram, (%u), (unsigned int)program)
    glatter_glDeleteProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteRenderbuffers_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteShader, (%u), (unsigned int)shader)
    glatter_glDeleteShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTextures_debug(GLsizei n, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glDeleteTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthFunc_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthFunc, (%s), enum_to_string_GL(func))
    glatter_glDepthFunc_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthMask_debug(GLboolean flag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthMask, (%u), (unsigned char)flag)
    glatter_glDepthMask_ptr(flag);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangef_debug(GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangef, (%f, %f), (float)n, (float)f)
    glatter_glDepthRangef_ptr(n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glDetachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glDetachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDisable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisable, (%s), enum_to_string_GL(cap))
    glatter_glDisable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glDisableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArrays_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArrays, (%s, %d, %d), enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawArrays_ptr(mode, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElements_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElements, (%s, %d, %s, %p), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawElements_ptr(mode, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glEnable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnable, (%s), enum_to_string_GL(cap))
    glatter_glEnable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glEnableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glFinish_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinish, ())
    glatter_glFinish_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFlush_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlush, ())
    glatter_glFlush_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferRenderbuffer_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbuffer, (%s, %s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbuffer_ptr(target, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture2D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2D, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2D_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFrontFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrontFace, (%s), enum_to_string_GL(mode))
    glatter_glFrontFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glGenBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glGenBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glGenFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTextures_debug(GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glGenTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateMipmap_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmap, (%s), enum_to_string_GL(target))
    glatter_glGenerateMipmap_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAttrib_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttrib, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttrib_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniform_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniform, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniform_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetAttachedShaders_debug(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedShaders, (%u, %d, %p, %p), (unsigned int)program, (int)maxCount, (void*)count, (void*)shaders)
    glatter_glGetAttachedShaders_ptr(program, maxCount, count, shaders);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetAttribLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetAttribLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetBooleanv_debug(GLenum pname, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleanv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetBooleanv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glGetError_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetError, ())
    GLenum rval = glatter_glGetError_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFloatv_debug(GLenum pname, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloatv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetFloatv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFramebufferAttachmentParameteriv_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameteriv, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameteriv_ptr(target, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerv_debug(GLenum pname, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetIntegerv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramInfoLog_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInfoLog, (%u, %d, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramInfoLog_ptr(program, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramiv_debug(GLuint program, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramiv, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramiv_ptr(program, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetRenderbufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderInfoLog_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderInfoLog, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetShaderInfoLog_ptr(shader, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderPrecisionFormat_debug(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderPrecisionFormat, (%s, %s, %p, %p), enum_to_string_GL(shadertype), enum_to_string_GL(precisiontype), (void*)range, (void*)precision)
    glatter_glGetShaderPrecisionFormat_ptr(shadertype, precisiontype, range, precision);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderSource_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)source)
    glatter_glGetShaderSource_ptr(shader, bufSize, length, source);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderiv_debug(GLuint shader, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderiv, (%u, %s, %p), (unsigned int)shader, enum_to_string_GL(pname), (void*)params)
    glatter_glGetShaderiv_ptr(shader, pname, params);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetString_debug(GLenum name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetString, (%s), enum_to_string_GL(name))
    const GLubyte * rval = glatter_glGetString_ptr(name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetTexParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetUniformLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetUniformLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformfv_debug(GLuint program, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformfv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformiv_debug(GLuint program, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribPointerv_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointerv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointerv_ptr(index, pname, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribfv_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glHint_debug(GLenum target, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHint, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(mode))
    glatter_glHint_ptr(target, mode);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBuffer, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsBuffer_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsEnabled_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabled, (%s), enum_to_string_GL(cap))
    GLboolean rval = glatter_glIsEnabled_ptr(cap);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsFramebuffer_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebuffer, (%u), (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebuffer_ptr(framebuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgram, (%u), (unsigned int)program)
    GLboolean rval = glatter_glIsProgram_ptr(program);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsRenderbuffer_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbuffer, (%u), (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbuffer_ptr(renderbuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsShader, (%u), (unsigned int)shader)
    GLboolean rval = glatter_glIsShader_ptr(shader);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTexture_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTexture, (%u), (unsigned int)texture)
    GLboolean rval = glatter_glIsTexture_ptr(texture);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLineWidth_debug(GLfloat width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineWidth, (%f), (float)width)
    glatter_glLineWidth_ptr(width);
    glatter_check_error_GL(file, line);
}
void glatter_glLinkProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgram, (%u), (unsigned int)program)
    glatter_glLinkProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStorei_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStorei, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelStorei_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonOffset_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffset, (%f, %f), (float)factor, (float)units)
    glatter_glPolygonOffset_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glReadPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadPixels, (%d, %d, %d, %d, %s, %s, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glReadPixels_ptr(x, y, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glReleaseShaderCompiler_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReleaseShaderCompiler, ())
    glatter_glReleaseShaderCompiler_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorage_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorage, (%s, %s, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorage_ptr(target, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleCoverage_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverage, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleCoverage_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
void glatter_glScissor_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissor, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glScissor_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderBinary_debug(GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderBinary, (%d, %p, %s, %p, %d), (int)count, (void*)shaders, enum_to_string_GL(binaryformat), (void*)binary, (int)length)
    glatter_glShaderBinary_ptr(count, shaders, binaryformat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderSource_debug(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)count, (void*)string, (void*)length)
    glatter_glShaderSource_ptr(shader, count, string, length);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFunc_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFunc, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFunc_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFuncSeparate_debug(GLenum face, GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparate, (%s, %s, %d, %u), enum_to_string_GL(face), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparate_ptr(face, func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMask_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMask, (%u), (unsigned int)mask)
    glatter_glStencilMask_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMaskSeparate_debug(GLenum face, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMaskSeparate, (%s, %u), enum_to_string_GL(face), (unsigned int)mask)
    glatter_glStencilMaskSeparate_ptr(face, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOp_debug(GLenum fail, GLenum zfail, GLenum zpass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOp, (%s, %s, %s), enum_to_string_GL(fail), enum_to_string_GL(zfail), enum_to_string_GL(zpass))
    glatter_glStencilOp_ptr(fail, zfail, zpass);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOpSeparate_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparate, (%s, %s, %s, %s), enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparate_ptr(face, sfail, dpfail, dppass);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage2D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage2D_ptr(target, level, internalformat, width, height, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterf_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterf, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTexParameterf_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1f_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1f, (%d, %f), (int)location, (float)v0)
    glatter_glUniform1f_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i, (%d, %d), (int)location, (int)v0)
    glatter_glUniform1i_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2f_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2f, (%d, %f, %f), (int)location, (float)v0, (float)v1)
    glatter_glUniform2f_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i, (%d, %d, %d), (int)location, (int)v0, (int)v1)
    glatter_glUniform2i_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3f, (%d, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3f_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i, (%d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3i_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4f, (%d, %f, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4f_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i, (%d, %d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4i_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgram, (%u), (unsigned int)program)
    glatter_glUseProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgram, (%u), (unsigned int)program)
    glatter_glValidateProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1f_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1f, (%u, %f), (unsigned int)index, (float)x)
    glatter_glVertexAttrib1f_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2f_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2f, (%u, %f, %f), (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2f_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3f, (%u, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3f_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4f, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4f_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribPointer_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointer, (%u, %d, %s, %u, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointer_ptr(index, size, type, normalized, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glViewport_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewport, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glViewport_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_ES_VERSION_2_0
#ifdef GL_ES_VERSION_3_0
void glatter_glBeginQuery_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQuery, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQuery_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBeginTransformFeedback_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedback, (%s), enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedback_ptr(primitiveMode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferBase_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBase, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBase_ptr(target, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferRange_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRange, (%s, %u, %u, %td, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glBindBufferRange_ptr(target, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glBindSampler_debug(GLuint unit, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSampler, (%u, %u), (unsigned int)unit, (unsigned int)sampler)
    glatter_glBindSampler_ptr(unit, sampler);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTransformFeedback_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedback, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedback_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArray, (%u), (unsigned int)array)
    glatter_glBindVertexArray_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glBlitFramebuffer_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebuffer, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebuffer_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfi_debug(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfi, (%s, %d, %f, %d), enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearBufferfi_ptr(buffer, drawbuffer, depth, stencil);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfv_debug(GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferfv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferiv_debug(GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferuiv_debug(GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferuiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferuiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glClientWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    GLenum rval = glatter_glClientWaitSync_ptr(sync, flags, timeout);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glCompressedTexImage3D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3D, (%s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3D_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyBufferSubData_debug(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyBufferSubData, (%s, %s, %td, %td, %td), enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyBufferSubData_ptr(readTarget, writeTarget, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteQueries_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteSamplers_debug(GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glDeleteSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSync, (%p), (void*)sync)
    glatter_glDeleteSync_ptr(sync);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTransformFeedbacks_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexArrays_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glDeleteVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysInstanced_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstanced, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount)
    glatter_glDrawArraysInstanced_ptr(mode, first, count, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawBuffers_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffers, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffers_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstanced_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstanced, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount)
    glatter_glDrawElementsInstanced_ptr(mode, count, type, indices, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElements_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElements, (%s, %u, %u, %d, %s, %p), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElements_ptr(mode, start, end, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQuery_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQuery, (%s), enum_to_string_GL(target))
    glatter_glEndQuery_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glEndTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedback, ())
    glatter_glEndTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
GLsync glatter_glFenceSync_debug(GLenum condition, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFenceSync, (%s, %u), enum_to_string_GL(condition), (unsigned int)flags)
    GLsync rval = glatter_glFenceSync_ptr(condition, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glFlushMappedBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRange, (%s, %td, %td), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedBufferRange_ptr(target, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureLayer_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayer, (%s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayer_ptr(target, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glGenQueries_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glGenQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGenSamplers_debug(GLsizei count, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glGenSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glGenTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGenVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glGenVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockName_debug(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockName, (%u, %u, %d, %p, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, (int)bufSize, (void*)length, (void*)uniformBlockName)
    glatter_glGetActiveUniformBlockName_ptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockiv_debug(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockiv, (%u, %u, %s, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformBlockiv_ptr(program, uniformBlockIndex, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformsiv_debug(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformsiv, (%u, %d, %p, %s, %p), (unsigned int)program, (int)uniformCount, (void*)uniformIndices, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformsiv_ptr(program, uniformCount, uniformIndices, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteri64v_debug(GLenum target, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteri64v, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteri64v_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferPointerv_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointerv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointerv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetInteger64i_v_debug(GLenum target, GLuint index, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64i_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetInteger64i_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInteger64v_debug(GLenum pname, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64v, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetInteger64v_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegeri_v_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegeri_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegeri_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInternalformativ_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformativ, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformativ_ptr(target, internalformat, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramBinary_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramBinary, (%u, %d, %p, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)binaryFormat, (void*)binary)
    glatter_glGetProgramBinary_ptr(program, bufSize, length, binaryFormat, binary);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectuiv_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuiv, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuiv_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterfv_debug(GLuint sampler, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterfv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameteriv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameteriv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetStringi_debug(GLenum name, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStringi, (%s, %u), enum_to_string_GL(name), (unsigned int)index)
    const GLubyte * rval = glatter_glGetStringi_ptr(name, index);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetSynciv_debug(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSynciv, (%p, %s, %d, %p, %p), (void*)sync, enum_to_string_GL(pname), (int)bufSize, (void*)length, (void*)values)
    glatter_glGetSynciv_ptr(sync, pname, bufSize, length, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackVarying_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVarying, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVarying_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetUniformBlockIndex_debug(GLuint program, const GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBlockIndex, (%u, %p), (unsigned int)program, (void*)uniformBlockName)
    GLuint rval = glatter_glGetUniformBlockIndex_ptr(program, uniformBlockName);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformIndices_debug(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformIndices, (%u, %d, %p, %p), (unsigned int)program, (int)uniformCount, (void*)uniformNames, (void*)uniformIndices)
    glatter_glGetUniformIndices_ptr(program, uniformCount, uniformNames, uniformIndices);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformuiv_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIuiv_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateFramebuffer, (%s, %d, %p), enum_to_string_GL(target), (int)numAttachments, (void*)attachments)
    glatter_glInvalidateFramebuffer_ptr(target, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateSubFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateSubFramebuffer, (%s, %d, %p, %d, %d, %d, %d), enum_to_string_GL(target), (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateSubFramebuffer_ptr(target, numAttachments, attachments, x, y, width, height);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsQuery_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQuery, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsQuery_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsSampler_debug(GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSampler, (%u), (unsigned int)sampler)
    GLboolean rval = glatter_glIsSampler_ptr(sampler);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSync, (%p), (void*)sync)
    GLboolean rval = glatter_glIsSync_ptr(sync);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTransformFeedback_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedback, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedback_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArray, (%u), (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArray_ptr(array);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferRange, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapBufferRange_ptr(target, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPauseTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedback, ())
    glatter_glPauseTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glProgramBinary_debug(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBinary, (%u, %s, %p, %d), (unsigned int)program, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glProgramBinary_ptr(program, binaryFormat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameteri_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteri, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteri_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glReadBuffer_debug(GLenum src, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadBuffer, (%s), enum_to_string_GL(src))
    glatter_glReadBuffer_ptr(src);
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorageMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisample, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisample_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glResumeTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedback, ())
    glatter_glResumeTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterf_debug(GLuint sampler, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterf, (%u, %s, %f), (unsigned int)sampler, enum_to_string_GL(pname), (float)param)
    glatter_glSamplerParameterf_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterfv_debug(GLuint sampler, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterfv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteri_debug(GLuint sampler, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteri, (%u, %s, %d), (unsigned int)sampler, enum_to_string_GL(pname), (int)param)
    glatter_glSamplerParameteri_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteriv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameteriv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3D, (%s, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3D_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2D, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2D_ptr(target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3D, (%s, %d, %s, %d, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3D_ptr(target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackVaryings_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryings, (%u, %d, %p, %s), (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryings_ptr(program, count, varyings, bufferMode);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui, (%d, %u), (int)location, (unsigned int)v0)
    glatter_glUniform1ui_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui, (%d, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2ui_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui, (%d, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3ui_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui, (%d, %u, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4ui_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformBlockBinding_debug(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBlockBinding, (%u, %u, %u), (unsigned int)program, (unsigned int)uniformBlockIndex, (unsigned int)uniformBlockBinding)
    glatter_glUniformBlockBinding_ptr(program, uniformBlockIndex, uniformBlockBinding);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glUnmapBuffer_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBuffer, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBuffer_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVertexAttribDivisor_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisor, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisor_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4i_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4i, (%u, %d, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4i_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ui, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4ui_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointer, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointer_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    glatter_glWaitSync_ptr(sync, flags, timeout);
    glatter_check_error_GL(file, line);
}
#endif // GL_ES_VERSION_3_0
#ifdef GL_ES_VERSION_3_1
void glatter_glActiveShaderProgram_debug(GLuint pipeline, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveShaderProgram, (%u, %u), (unsigned int)pipeline, (unsigned int)program)
    glatter_glActiveShaderProgram_ptr(pipeline, program);
    glatter_check_error_GL(file, line);
}
void glatter_glBindImageTexture_debug(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTexture, (%u, %u, %d, %u, %d, %s, %s), (unsigned int)unit, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), enum_to_string_GL(format))
    glatter_glBindImageTexture_ptr(unit, texture, level, layered, layer, access, format);
    glatter_check_error_GL(file, line);
}
void glatter_glBindProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glBindProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexBuffer_debug(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffer, (%u, %u, %td, %d), (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glBindVertexBuffer_ptr(bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramv_debug(GLenum type, GLsizei count, const GLchar *const*strings, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramv, (%s, %d, %p), enum_to_string_GL(type), (int)count, (void*)strings)
    GLuint rval = glatter_glCreateShaderProgramv_ptr(type, count, strings);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgramPipelines_debug(GLsizei n, const GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glDeleteProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchCompute_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchCompute, (%u, %u, %u), (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z)
    glatter_glDispatchCompute_ptr(num_groups_x, num_groups_y, num_groups_z);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchComputeIndirect_debug(GLintptr indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeIndirect, (%td), (ptrdiff_t)indirect)
    glatter_glDispatchComputeIndirect_ptr(indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysIndirect_debug(GLenum mode, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysIndirect, (%s, %p), enum_to_string_GL(mode), (void*)indirect)
    glatter_glDrawArraysIndirect_ptr(mode, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsIndirect, (%s, %s, %p), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect)
    glatter_glDrawElementsIndirect_ptr(mode, type, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glFramebufferParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glGenProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleani_v_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleani_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleani_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFramebufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultisamplefv_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefv, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefv_ptr(pname, index, val);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramInterfaceiv_debug(GLuint program, GLenum programInterface, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInterfaceiv, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramInterfaceiv_ptr(program, programInterface, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineInfoLog_debug(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineInfoLog, (%u, %d, %p, %p), (unsigned int)pipeline, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramPipelineInfoLog_ptr(pipeline, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineiv_debug(GLuint pipeline, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineiv, (%u, %s, %p), (unsigned int)pipeline, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramPipelineiv_ptr(pipeline, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetProgramResourceIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLuint rval = glatter_glGetProgramResourceIndex_ptr(program, programInterface, name);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocation_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocation, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocation_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetProgramResourceName_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetProgramResourceName_ptr(program, programInterface, index, bufSize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourceiv_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceiv, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourceiv_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameterfv_debug(GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameterfv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameterfv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameteriv_debug(GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameteriv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameteriv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramPipeline, (%u), (unsigned int)pipeline)
    GLboolean rval = glatter_glIsProgramPipeline_ptr(pipeline);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMemoryBarrier_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrier, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrier_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glMemoryBarrierByRegion_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierByRegion, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrierByRegion_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1f_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1f, (%u, %d, %f), (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1f_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i, (%u, %d, %d), (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1i_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1ui_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2f, (%u, %d, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2f_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i, (%u, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2i_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui, (%u, %d, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2ui_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3f, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3f_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i, (%u, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3i_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui, (%u, %d, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3ui_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4f, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4f_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i, (%u, %d, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4i_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui, (%u, %d, %u, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4ui_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleMaski_debug(GLuint maskNumber, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaski, (%u, %u), (unsigned int)maskNumber, (unsigned int)mask)
    glatter_glSampleMaski_ptr(maskNumber, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DMultisample, (%s, %d, %s, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgramStages_debug(GLuint pipeline, GLbitfield stages, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramStages, (%u, %u, %u), (unsigned int)pipeline, (unsigned int)stages, (unsigned int)program)
    glatter_glUseProgramStages_ptr(pipeline, stages, program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glValidateProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribBinding_debug(GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribBinding, (%u, %u), (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexAttribBinding_ptr(attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribFormat_debug(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormat, (%u, %d, %s, %u, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexAttribFormat_ptr(attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormat, (%u, %d, %s, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribIFormat_ptr(attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexBindingDivisor_debug(GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBindingDivisor, (%u, %u), (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexBindingDivisor_ptr(bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_ES_VERSION_3_1
#ifdef GL_ES_VERSION_3_2
void glatter_glBlendBarrier_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrier, ())
    glatter_glBlendBarrier_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparatei_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparatei, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparatei_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationi_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationi, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationi_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparatei_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparatei, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparatei_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunci_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunci, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunci_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaski_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaski, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaski_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyImageSubData_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubData, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubData_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageCallback_debug(GLDEBUGPROC callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallback, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallback_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControl_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControl, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControl_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsert_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsert, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsert_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
void glatter_glDisablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertex, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertex_ptr(mode, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertex, (%s, %d, %s, %p, %d, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertex_ptr(mode, count, type, indices, instancecount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementsBaseVertex_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertex, (%s, %u, %u, %d, %s, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertex_ptr(mode, start, end, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glEnablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLog_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLog, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLog_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLenum glatter_glGetGraphicsResetStatus_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatus, ())
    GLenum rval = glatter_glGetGraphicsResetStatus_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetObjectLabel_debug(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabel, (%s, %u, %d, %p, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabel_ptr(identifier, name, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectPtrLabel_debug(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectPtrLabel, (%p, %d, %p, %p), (void*)ptr, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectPtrLabel_ptr(ptr, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointerv_debug(GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointerv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointerv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIiv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuiv_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformfv_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformiv_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuiv_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabledi_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledi, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledi_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMinSampleShading_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShading, (%f), (float)value)
    glatter_glMinSampleShading_ptr(value);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectLabel_debug(GLenum identifier, GLuint name, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectLabel, (%s, %u, %d, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)length, (void*)label)
    glatter_glObjectLabel_ptr(identifier, name, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectPtrLabel_debug(const void *ptr, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPtrLabel, (%p, %d, %p), (void*)ptr, (int)length, (void*)label)
    glatter_glObjectPtrLabel_ptr(ptr, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glPatchParameteri_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteri, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteri_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPopDebugGroup_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopDebugGroup, ())
    glatter_glPopDebugGroup_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPrimitiveBoundingBox_debug(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveBoundingBox, (%f, %f, %f, %f, %f, %f, %f, %f), (float)minX, (float)minY, (float)minZ, (float)minW, (float)maxX, (float)maxY, (float)maxZ, (float)maxW)
    glatter_glPrimitiveBoundingBox_ptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    glatter_check_error_GL(file, line);
}
void glatter_glPushDebugGroup_debug(GLenum source, GLuint id, GLsizei length, const GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushDebugGroup, (%s, %u, %d, %p), enum_to_string_GL(source), (unsigned int)id, (int)length, (void*)message)
    glatter_glPushDebugGroup_ptr(source, id, length, message);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixels, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixels_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIiv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBuffer_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBuffer, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBuffer_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBufferRange_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRange, (%s, %s, %u, %td, %td), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTexBufferRange_ptr(target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIiv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuiv_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DMultisample, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_ES_VERSION_3_2
#endif // __gl32_h_

#ifdef __gl_h_
void glatter_glAccum_debug(GLenum op, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAccum, (%s, %f), enum_to_string_GL(op), (float)value)
    glatter_glAccum_ptr(op, value);
    glatter_check_error_GL(file, line);
}
void glatter_glAlphaFunc_debug(GLenum func, GLclampf ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFunc, (%s, %f), enum_to_string_GL(func), (float)ref)
    glatter_glAlphaFunc_ptr(func, ref);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glAreTexturesResident_debug(GLsizei n, const GLuint *textures, GLboolean *residences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAreTexturesResident, (%d, %p, %p), (int)n, (void*)textures, (void*)residences)
    GLboolean rval = glatter_glAreTexturesResident_ptr(n, textures, residences);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glArrayElement_debug(GLint i, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glArrayElement, (%d), (int)i)
    glatter_glArrayElement_ptr(i);
    glatter_check_error_GL(file, line);
}
void glatter_glBegin_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBegin, (%s), enum_to_string_GL(mode))
    glatter_glBegin_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTexture_debug(GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTexture, (%s, %u), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindTexture_ptr(target, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glBitmap_debug(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBitmap, (%d, %d, %f, %f, %f, %f, %p), (int)width, (int)height, (float)xorig, (float)yorig, (float)xmove, (float)ymove, (void*)bitmap)
    glatter_glBitmap_ptr(width, height, xorig, yorig, xmove, ymove, bitmap);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunc_debug(GLenum sfactor, GLenum dfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunc, (%s, %s), enum_to_string_GL(sfactor), enum_to_string_GL(dfactor))
    glatter_glBlendFunc_ptr(sfactor, dfactor);
    glatter_check_error_GL(file, line);
}
void glatter_glCallList_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCallList, (%u), (unsigned int)list)
    glatter_glCallList_ptr(list);
    glatter_check_error_GL(file, line);
}
void glatter_glCallLists_debug(GLsizei n, GLenum type, const GLvoid *lists, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCallLists, (%d, %s, %p), (int)n, enum_to_string_GL(type), (void*)lists)
    glatter_glCallLists_ptr(n, type, lists);
    glatter_check_error_GL(file, line);
}
void glatter_glClear_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClear, (%u), (unsigned int)mask)
    glatter_glClear_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glClearAccum_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearAccum, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glClearAccum_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearColor_debug(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glClearColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepth_debug(GLclampd depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepth, (%f), (double)depth)
    glatter_glClearDepth_ptr(depth);
    glatter_check_error_GL(file, line);
}
void glatter_glClearIndex_debug(GLfloat c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearIndex, (%f), (float)c)
    glatter_glClearIndex_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glClearStencil_debug(GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearStencil, (%d), (int)s)
    glatter_glClearStencil_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glClipPlane_debug(GLenum plane, const GLdouble *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipPlane, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glClipPlane_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3b_debug(GLbyte red, GLbyte green, GLbyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3b, (%d, %d, %d), (signed char)red, (signed char)green, (signed char)blue)
    glatter_glColor3b_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3bv_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3bv, (%p), (void*)v)
    glatter_glColor3bv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3d_debug(GLdouble red, GLdouble green, GLdouble blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3d, (%f, %f, %f), (double)red, (double)green, (double)blue)
    glatter_glColor3d_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3dv, (%p), (void*)v)
    glatter_glColor3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3f_debug(GLfloat red, GLfloat green, GLfloat blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3f, (%f, %f, %f), (float)red, (float)green, (float)blue)
    glatter_glColor3f_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3fv, (%p), (void*)v)
    glatter_glColor3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3i_debug(GLint red, GLint green, GLint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3i, (%d, %d, %d), (int)red, (int)green, (int)blue)
    glatter_glColor3i_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3iv, (%p), (void*)v)
    glatter_glColor3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3s_debug(GLshort red, GLshort green, GLshort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3s, (%hi, %hi, %hi), (short)red, (short)green, (short)blue)
    glatter_glColor3s_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3sv, (%p), (void*)v)
    glatter_glColor3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3ub_debug(GLubyte red, GLubyte green, GLubyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3ub, (%u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue)
    glatter_glColor3ub_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3ubv_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3ubv, (%p), (void*)v)
    glatter_glColor3ubv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3ui_debug(GLuint red, GLuint green, GLuint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3ui, (%u, %u, %u), (unsigned int)red, (unsigned int)green, (unsigned int)blue)
    glatter_glColor3ui_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3uiv_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3uiv, (%p), (void*)v)
    glatter_glColor3uiv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3us_debug(GLushort red, GLushort green, GLushort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3us, (%hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glColor3us_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3usv_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3usv, (%p), (void*)v)
    glatter_glColor3usv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4b_debug(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4b, (%d, %d, %d, %d), (signed char)red, (signed char)green, (signed char)blue, (signed char)alpha)
    glatter_glColor4b_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4bv_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4bv, (%p), (void*)v)
    glatter_glColor4bv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4d_debug(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4d, (%f, %f, %f, %f), (double)red, (double)green, (double)blue, (double)alpha)
    glatter_glColor4d_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4dv, (%p), (void*)v)
    glatter_glColor4dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4f_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4f, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glColor4f_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4fv, (%p), (void*)v)
    glatter_glColor4fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4i_debug(GLint red, GLint green, GLint blue, GLint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4i, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glColor4i_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4iv, (%p), (void*)v)
    glatter_glColor4iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4s_debug(GLshort red, GLshort green, GLshort blue, GLshort alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4s, (%hi, %hi, %hi, %hi), (short)red, (short)green, (short)blue, (short)alpha)
    glatter_glColor4s_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4sv, (%p), (void*)v)
    glatter_glColor4sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ub_debug(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ub, (%u, %u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glColor4ub_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ubv_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubv, (%p), (void*)v)
    glatter_glColor4ubv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ui_debug(GLuint red, GLuint green, GLuint blue, GLuint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ui, (%u, %u, %u, %u), (unsigned int)red, (unsigned int)green, (unsigned int)blue, (unsigned int)alpha)
    glatter_glColor4ui_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4uiv_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4uiv, (%p), (void*)v)
    glatter_glColor4uiv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4us_debug(GLushort red, GLushort green, GLushort blue, GLushort alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4us, (%hu, %hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue, (unsigned short)alpha)
    glatter_glColor4us_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4usv_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4usv, (%p), (void*)v)
    glatter_glColor4usv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMask_debug(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMask, (%u, %u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glColorMask_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaterial_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaterial, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glColorMaterial_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glColorPointer_debug(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointer, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glColorPointer_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyPixels, (%d, %d, %d, %d, %s), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(type))
    glatter_glCopyPixels_ptr(x, y, width, height, type);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage1D_debug(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage1D, (%s, %d, %s, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalFormat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTexImage1D_ptr(target, level, internalFormat, x, y, width, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage2D_debug(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalFormat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTexImage2D_ptr(target, level, internalFormat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage1D, (%s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTexSubImage1D_ptr(target, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage2D, (%s, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage2D_ptr(target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCullFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullFace, (%s), enum_to_string_GL(mode))
    glatter_glCullFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteLists_debug(GLuint list, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteLists, (%u, %d), (unsigned int)list, (int)range)
    glatter_glDeleteLists_ptr(list, range);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTextures_debug(GLsizei n, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glDeleteTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthFunc_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthFunc, (%s), enum_to_string_GL(func))
    glatter_glDepthFunc_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthMask_debug(GLboolean flag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthMask, (%u), (unsigned char)flag)
    glatter_glDepthMask_ptr(flag);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRange_debug(GLclampd zNear, GLclampd zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRange, (%f, %f), (double)zNear, (double)zFar)
    glatter_glDepthRange_ptr(zNear, zFar);
    glatter_check_error_GL(file, line);
}
void glatter_glDisable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisable, (%s), enum_to_string_GL(cap))
    glatter_glDisable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableClientState_debug(GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableClientState, (%s), enum_to_string_GL(array))
    glatter_glDisableClientState_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArrays_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArrays, (%s, %d, %d), enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawArrays_ptr(mode, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawBuffer_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffer, (%s), enum_to_string_GL(mode))
    glatter_glDrawBuffer_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElements_debug(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElements, (%s, %d, %s, %p), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawElements_ptr(mode, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawPixels_debug(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawPixels, (%d, %d, %s, %s, %p), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glDrawPixels_ptr(width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlag_debug(GLboolean flag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlag, (%u), (unsigned char)flag)
    glatter_glEdgeFlag_ptr(flag);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlagPointer_debug(GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagPointer, (%d, %p), (int)stride, (void*)pointer)
    glatter_glEdgeFlagPointer_ptr(stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlagv_debug(const GLboolean *flag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagv, (%p), (void*)flag)
    glatter_glEdgeFlagv_ptr(flag);
    glatter_check_error_GL(file, line);
}
void glatter_glEnable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnable, (%s), enum_to_string_GL(cap))
    glatter_glEnable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableClientState_debug(GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableClientState, (%s), enum_to_string_GL(array))
    glatter_glEnableClientState_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glEnd_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnd, ())
    glatter_glEnd_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glEndList_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndList, ())
    glatter_glEndList_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1d_debug(GLdouble u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1d, (%f), (double)u)
    glatter_glEvalCoord1d_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1dv_debug(const GLdouble *u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1dv, (%p), (void*)u)
    glatter_glEvalCoord1dv_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1f_debug(GLfloat u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1f, (%f), (float)u)
    glatter_glEvalCoord1f_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1fv_debug(const GLfloat *u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1fv, (%p), (void*)u)
    glatter_glEvalCoord1fv_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2d_debug(GLdouble u, GLdouble v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2d, (%f, %f), (double)u, (double)v)
    glatter_glEvalCoord2d_ptr(u, v);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2dv_debug(const GLdouble *u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2dv, (%p), (void*)u)
    glatter_glEvalCoord2dv_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2f_debug(GLfloat u, GLfloat v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2f, (%f, %f), (float)u, (float)v)
    glatter_glEvalCoord2f_ptr(u, v);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2fv_debug(const GLfloat *u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2fv, (%p), (void*)u)
    glatter_glEvalCoord2fv_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalMesh1_debug(GLenum mode, GLint i1, GLint i2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalMesh1, (%s, %d, %d), enum_to_string_GL(mode), (int)i1, (int)i2)
    glatter_glEvalMesh1_ptr(mode, i1, i2);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalMesh2_debug(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalMesh2, (%s, %d, %d, %d, %d), enum_to_string_GL(mode), (int)i1, (int)i2, (int)j1, (int)j2)
    glatter_glEvalMesh2_ptr(mode, i1, i2, j1, j2);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalPoint1_debug(GLint i, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalPoint1, (%d), (int)i)
    glatter_glEvalPoint1_ptr(i);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalPoint2_debug(GLint i, GLint j, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalPoint2, (%d, %d), (int)i, (int)j)
    glatter_glEvalPoint2_ptr(i, j);
    glatter_check_error_GL(file, line);
}
void glatter_glFeedbackBuffer_debug(GLsizei size, GLenum type, GLfloat *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFeedbackBuffer, (%d, %s, %p), (int)size, enum_to_string_GL(type), (void*)buffer)
    glatter_glFeedbackBuffer_ptr(size, type, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFinish_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinish, ())
    glatter_glFinish_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFlush_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlush, ())
    glatter_glFlush_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFogf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogf, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glFogf_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFogfv_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogfv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glFogfv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFogi_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogi, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glFogi_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFogiv_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogiv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glFogiv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFrontFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrontFace, (%s), enum_to_string_GL(mode))
    glatter_glFrontFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glFrustum_debug(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrustum, (%f, %f, %f, %f, %f, %f), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glFrustum_ptr(left, right, bottom, top, zNear, zFar);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenLists_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenLists, (%d), (int)range)
    GLuint rval = glatter_glGenLists_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGenTextures_debug(GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glGenTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleanv_debug(GLenum pname, GLboolean *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleanv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBooleanv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetClipPlane_debug(GLenum plane, GLdouble *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetClipPlane, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glGetClipPlane_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoublev_debug(GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublev, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetDoublev_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glGetError_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetError, ())
    GLenum rval = glatter_glGetError_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFloatv_debug(GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloatv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFloatv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerv_debug(GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetIntegerv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLightfv_debug(GLenum light, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLightfv, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetLightfv_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLightiv_debug(GLenum light, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLightiv, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetLightiv_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapdv_debug(GLenum target, GLenum query, GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapdv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(query), (void*)v)
    glatter_glGetMapdv_ptr(target, query, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapfv_debug(GLenum target, GLenum query, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(query), (void*)v)
    glatter_glGetMapfv_ptr(target, query, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapiv_debug(GLenum target, GLenum query, GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(query), (void*)v)
    glatter_glGetMapiv_ptr(target, query, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMaterialfv_debug(GLenum face, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMaterialfv, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMaterialfv_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMaterialiv_debug(GLenum face, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMaterialiv, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMaterialiv_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelMapfv_debug(GLenum map, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelMapfv, (%s, %p), enum_to_string_GL(map), (void*)values)
    glatter_glGetPixelMapfv_ptr(map, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelMapuiv_debug(GLenum map, GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelMapuiv, (%s, %p), enum_to_string_GL(map), (void*)values)
    glatter_glGetPixelMapuiv_ptr(map, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelMapusv_debug(GLenum map, GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelMapusv, (%s, %p), enum_to_string_GL(map), (void*)values)
    glatter_glGetPixelMapusv_ptr(map, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointerv_debug(GLenum pname, GLvoid* *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointerv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointerv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPolygonStipple_debug(GLubyte *mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPolygonStipple, (%p), (void*)mask)
    glatter_glGetPolygonStipple_ptr(mask);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetString_debug(GLenum name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetString, (%s), enum_to_string_GL(name))
    const GLubyte * rval = glatter_glGetString_ptr(name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetTexEnvfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexEnvfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexEnvfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexEnviv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexEnviv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexEnviv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexGendv_debug(GLenum coord, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexGendv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexGendv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexGenfv_debug(GLenum coord, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexGenfv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexGenfv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexGeniv_debug(GLenum coord, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexGeniv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexGeniv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexImage_debug(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexImage, (%s, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetTexImage_ptr(target, level, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameterfv_debug(GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameterfv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameterfv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameteriv_debug(GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameteriv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameteriv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glHint_debug(GLenum target, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHint, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(mode))
    glatter_glHint_ptr(target, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexMask_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexMask, (%u), (unsigned int)mask)
    glatter_glIndexMask_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexPointer_debug(GLenum type, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexPointer, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glIndexPointer_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexd_debug(GLdouble c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexd, (%f), (double)c)
    glatter_glIndexd_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexdv_debug(const GLdouble *c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexdv, (%p), (void*)c)
    glatter_glIndexdv_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexf_debug(GLfloat c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexf, (%f), (float)c)
    glatter_glIndexf_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexfv_debug(const GLfloat *c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexfv, (%p), (void*)c)
    glatter_glIndexfv_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexi_debug(GLint c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexi, (%d), (int)c)
    glatter_glIndexi_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexiv_debug(const GLint *c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexiv, (%p), (void*)c)
    glatter_glIndexiv_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexs_debug(GLshort c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexs, (%hi), (short)c)
    glatter_glIndexs_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexsv_debug(const GLshort *c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexsv, (%p), (void*)c)
    glatter_glIndexsv_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexub_debug(GLubyte c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexub, (%u), (unsigned char)c)
    glatter_glIndexub_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexubv_debug(const GLubyte *c, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexubv, (%p), (void*)c)
    glatter_glIndexubv_ptr(c);
    glatter_check_error_GL(file, line);
}
void glatter_glInitNames_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInitNames, ())
    glatter_glInitNames_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glInterleavedArrays_debug(GLenum format, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInterleavedArrays, (%s, %d, %p), enum_to_string_GL(format), (int)stride, (void*)pointer)
    glatter_glInterleavedArrays_ptr(format, stride, pointer);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabled_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabled, (%s), enum_to_string_GL(cap))
    GLboolean rval = glatter_glIsEnabled_ptr(cap);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsList_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsList, (%u), (unsigned int)list)
    GLboolean rval = glatter_glIsList_ptr(list);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTexture_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTexture, (%u), (unsigned int)texture)
    GLboolean rval = glatter_glIsTexture_ptr(texture);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLightModelf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelf, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glLightModelf_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightModelfv_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelfv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glLightModelfv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLightModeli_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModeli, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glLightModeli_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightModeliv_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModeliv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glLightModeliv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLightf_debug(GLenum light, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightf, (%s, %s, %f), enum_to_string_GL(light), enum_to_string_GL(pname), (float)param)
    glatter_glLightf_ptr(light, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightfv_debug(GLenum light, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightfv, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glLightfv_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLighti_debug(GLenum light, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLighti, (%s, %s, %d), enum_to_string_GL(light), enum_to_string_GL(pname), (int)param)
    glatter_glLighti_ptr(light, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightiv_debug(GLenum light, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightiv, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glLightiv_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLineStipple_debug(GLint factor, GLushort pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineStipple, (%d, %hu), (int)factor, (unsigned short)pattern)
    glatter_glLineStipple_ptr(factor, pattern);
    glatter_check_error_GL(file, line);
}
void glatter_glLineWidth_debug(GLfloat width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineWidth, (%f), (float)width)
    glatter_glLineWidth_ptr(width);
    glatter_check_error_GL(file, line);
}
void glatter_glListBase_debug(GLuint base, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListBase, (%u), (unsigned int)base)
    glatter_glListBase_ptr(base);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadIdentity_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadIdentity, ())
    glatter_glLoadIdentity_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glLoadMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadMatrixd, (%p), (void*)m)
    glatter_glLoadMatrixd_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadMatrixf, (%p), (void*)m)
    glatter_glLoadMatrixf_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadName_debug(GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadName, (%u), (unsigned int)name)
    glatter_glLoadName_ptr(name);
    glatter_check_error_GL(file, line);
}
void glatter_glLogicOp_debug(GLenum opcode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLogicOp, (%s), enum_to_string_GL(opcode))
    glatter_glLogicOp_ptr(opcode);
    glatter_check_error_GL(file, line);
}
void glatter_glMap1d_debug(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap1d, (%s, %f, %f, %d, %d, %p), enum_to_string_GL(target), (double)u1, (double)u2, (int)stride, (int)order, (void*)points)
    glatter_glMap1d_ptr(target, u1, u2, stride, order, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMap1f_debug(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap1f, (%s, %f, %f, %d, %d, %p), enum_to_string_GL(target), (float)u1, (float)u2, (int)stride, (int)order, (void*)points)
    glatter_glMap1f_ptr(target, u1, u2, stride, order, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMap2d_debug(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap2d, (%s, %f, %f, %d, %d, %f, %f, %d, %d, %p), enum_to_string_GL(target), (double)u1, (double)u2, (int)ustride, (int)uorder, (double)v1, (double)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMap2d_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMap2f_debug(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap2f, (%s, %f, %f, %d, %d, %f, %f, %d, %d, %p), enum_to_string_GL(target), (float)u1, (float)u2, (int)ustride, (int)uorder, (float)v1, (float)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMap2f_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid1d_debug(GLint un, GLdouble u1, GLdouble u2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid1d, (%d, %f, %f), (int)un, (double)u1, (double)u2)
    glatter_glMapGrid1d_ptr(un, u1, u2);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid1f_debug(GLint un, GLfloat u1, GLfloat u2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid1f, (%d, %f, %f), (int)un, (float)u1, (float)u2)
    glatter_glMapGrid1f_ptr(un, u1, u2);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid2d_debug(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid2d, (%d, %f, %f, %d, %f, %f), (int)un, (double)u1, (double)u2, (int)vn, (double)v1, (double)v2)
    glatter_glMapGrid2d_ptr(un, u1, u2, vn, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid2f_debug(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid2f, (%d, %f, %f, %d, %f, %f), (int)un, (float)u1, (float)u2, (int)vn, (float)v1, (float)v2)
    glatter_glMapGrid2f_ptr(un, u1, u2, vn, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glMaterialf_debug(GLenum face, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialf, (%s, %s, %f), enum_to_string_GL(face), enum_to_string_GL(pname), (float)param)
    glatter_glMaterialf_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMaterialfv_debug(GLenum face, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialfv, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glMaterialfv_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMateriali_debug(GLenum face, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMateriali, (%s, %s, %d), enum_to_string_GL(face), enum_to_string_GL(pname), (int)param)
    glatter_glMateriali_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMaterialiv_debug(GLenum face, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialiv, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glMaterialiv_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMode_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMode, (%s), enum_to_string_GL(mode))
    glatter_glMatrixMode_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glMultMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultMatrixd, (%p), (void*)m)
    glatter_glMultMatrixd_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultMatrixf, (%p), (void*)m)
    glatter_glMultMatrixf_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glNewList_debug(GLuint list, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNewList, (%u, %s), (unsigned int)list, enum_to_string_GL(mode))
    glatter_glNewList_ptr(list, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3b_debug(GLbyte nx, GLbyte ny, GLbyte nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3b, (%d, %d, %d), (signed char)nx, (signed char)ny, (signed char)nz)
    glatter_glNormal3b_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3bv_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3bv, (%p), (void*)v)
    glatter_glNormal3bv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3d_debug(GLdouble nx, GLdouble ny, GLdouble nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3d, (%f, %f, %f), (double)nx, (double)ny, (double)nz)
    glatter_glNormal3d_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3dv, (%p), (void*)v)
    glatter_glNormal3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3f_debug(GLfloat nx, GLfloat ny, GLfloat nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3f, (%f, %f, %f), (float)nx, (float)ny, (float)nz)
    glatter_glNormal3f_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3fv, (%p), (void*)v)
    glatter_glNormal3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3i_debug(GLint nx, GLint ny, GLint nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3i, (%d, %d, %d), (int)nx, (int)ny, (int)nz)
    glatter_glNormal3i_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3iv, (%p), (void*)v)
    glatter_glNormal3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3s_debug(GLshort nx, GLshort ny, GLshort nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3s, (%hi, %hi, %hi), (short)nx, (short)ny, (short)nz)
    glatter_glNormal3s_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3sv, (%p), (void*)v)
    glatter_glNormal3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalPointer_debug(GLenum type, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointer, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glNormalPointer_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glOrtho_debug(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glOrtho, (%f, %f, %f, %f, %f, %f), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glOrtho_ptr(left, right, bottom, top, zNear, zFar);
    glatter_check_error_GL(file, line);
}
void glatter_glPassThrough_debug(GLfloat token, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPassThrough, (%f), (float)token)
    glatter_glPassThrough_ptr(token);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelMapfv_debug(GLenum map, GLsizei mapsize, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelMapfv, (%s, %d, %p), enum_to_string_GL(map), (int)mapsize, (void*)values)
    glatter_glPixelMapfv_ptr(map, mapsize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelMapuiv_debug(GLenum map, GLsizei mapsize, const GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelMapuiv, (%s, %d, %p), enum_to_string_GL(map), (int)mapsize, (void*)values)
    glatter_glPixelMapuiv_ptr(map, mapsize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelMapusv_debug(GLenum map, GLsizei mapsize, const GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelMapusv, (%s, %d, %p), enum_to_string_GL(map), (int)mapsize, (void*)values)
    glatter_glPixelMapusv_ptr(map, mapsize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStoref_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStoref, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPixelStoref_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStorei_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStorei, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelStorei_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransferf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransferf, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPixelTransferf_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransferi_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransferi, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelTransferi_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelZoom_debug(GLfloat xfactor, GLfloat yfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelZoom, (%f, %f), (float)xfactor, (float)yfactor)
    glatter_glPixelZoom_ptr(xfactor, yfactor);
    glatter_check_error_GL(file, line);
}
void glatter_glPointSize_debug(GLfloat size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointSize, (%f), (float)size)
    glatter_glPointSize_ptr(size);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonMode_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonMode, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glPolygonMode_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonOffset_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffset, (%f, %f), (float)factor, (float)units)
    glatter_glPolygonOffset_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonStipple_debug(const GLubyte *mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonStipple, (%p), (void*)mask)
    glatter_glPolygonStipple_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPopAttrib_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopAttrib, ())
    glatter_glPopAttrib_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPopClientAttrib_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopClientAttrib, ())
    glatter_glPopClientAttrib_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPopMatrix_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopMatrix, ())
    glatter_glPopMatrix_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPopName_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopName, ())
    glatter_glPopName_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPrioritizeTextures_debug(GLsizei n, const GLuint *textures, const GLclampf *priorities, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrioritizeTextures, (%d, %p, %p), (int)n, (void*)textures, (void*)priorities)
    glatter_glPrioritizeTextures_ptr(n, textures, priorities);
    glatter_check_error_GL(file, line);
}
void glatter_glPushAttrib_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushAttrib, (%u), (unsigned int)mask)
    glatter_glPushAttrib_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPushClientAttrib_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushClientAttrib, (%u), (unsigned int)mask)
    glatter_glPushClientAttrib_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPushMatrix_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushMatrix, ())
    glatter_glPushMatrix_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushName_debug(GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushName, (%u), (unsigned int)name)
    glatter_glPushName_ptr(name);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2d_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2d, (%f, %f), (double)x, (double)y)
    glatter_glRasterPos2d_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2dv, (%p), (void*)v)
    glatter_glRasterPos2dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2f_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2f, (%f, %f), (float)x, (float)y)
    glatter_glRasterPos2f_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2fv, (%p), (void*)v)
    glatter_glRasterPos2fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2i_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2i, (%d, %d), (int)x, (int)y)
    glatter_glRasterPos2i_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2iv, (%p), (void*)v)
    glatter_glRasterPos2iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2s_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2s, (%hi, %hi), (short)x, (short)y)
    glatter_glRasterPos2s_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2sv, (%p), (void*)v)
    glatter_glRasterPos2sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3d_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3d, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glRasterPos3d_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3dv, (%p), (void*)v)
    glatter_glRasterPos3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3f_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3f, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glRasterPos3f_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3fv, (%p), (void*)v)
    glatter_glRasterPos3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3i_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3i, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glRasterPos3i_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3iv, (%p), (void*)v)
    glatter_glRasterPos3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3s_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3s, (%hi, %hi, %hi), (short)x, (short)y, (short)z)
    glatter_glRasterPos3s_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3sv, (%p), (void*)v)
    glatter_glRasterPos3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4d_debug(GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4d, (%f, %f, %f, %f), (double)x, (double)y, (double)z, (double)w)
    glatter_glRasterPos4d_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4dv, (%p), (void*)v)
    glatter_glRasterPos4dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4f_debug(GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4f, (%f, %f, %f, %f), (float)x, (float)y, (float)z, (float)w)
    glatter_glRasterPos4f_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4fv, (%p), (void*)v)
    glatter_glRasterPos4fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4i_debug(GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4i, (%d, %d, %d, %d), (int)x, (int)y, (int)z, (int)w)
    glatter_glRasterPos4i_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4iv, (%p), (void*)v)
    glatter_glRasterPos4iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4s_debug(GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4s, (%hi, %hi, %hi, %hi), (short)x, (short)y, (short)z, (short)w)
    glatter_glRasterPos4s_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4sv, (%p), (void*)v)
    glatter_glRasterPos4sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glReadBuffer_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadBuffer, (%s), enum_to_string_GL(mode))
    glatter_glReadBuffer_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glReadPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadPixels, (%d, %d, %d, %d, %s, %s, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glReadPixels_ptr(x, y, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glRectd_debug(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectd, (%f, %f, %f, %f), (double)x1, (double)y1, (double)x2, (double)y2)
    glatter_glRectd_ptr(x1, y1, x2, y2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectdv_debug(const GLdouble *v1, const GLdouble *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectdv, (%p, %p), (void*)v1, (void*)v2)
    glatter_glRectdv_ptr(v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectf_debug(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectf, (%f, %f, %f, %f), (float)x1, (float)y1, (float)x2, (float)y2)
    glatter_glRectf_ptr(x1, y1, x2, y2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectfv_debug(const GLfloat *v1, const GLfloat *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectfv, (%p, %p), (void*)v1, (void*)v2)
    glatter_glRectfv_ptr(v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glRecti_debug(GLint x1, GLint y1, GLint x2, GLint y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRecti, (%d, %d, %d, %d), (int)x1, (int)y1, (int)x2, (int)y2)
    glatter_glRecti_ptr(x1, y1, x2, y2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectiv_debug(const GLint *v1, const GLint *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectiv, (%p, %p), (void*)v1, (void*)v2)
    glatter_glRectiv_ptr(v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glRects_debug(GLshort x1, GLshort y1, GLshort x2, GLshort y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRects, (%hi, %hi, %hi, %hi), (short)x1, (short)y1, (short)x2, (short)y2)
    glatter_glRects_ptr(x1, y1, x2, y2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectsv_debug(const GLshort *v1, const GLshort *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectsv, (%p, %p), (void*)v1, (void*)v2)
    glatter_glRectsv_ptr(v1, v2);
    glatter_check_error_GL(file, line);
}
GLint glatter_glRenderMode_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderMode, (%s), enum_to_string_GL(mode))
    GLint rval = glatter_glRenderMode_ptr(mode);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glRotated_debug(GLdouble angle, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRotated, (%f, %f, %f, %f), (double)angle, (double)x, (double)y, (double)z)
    glatter_glRotated_ptr(angle, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRotatef_debug(GLfloat angle, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRotatef, (%f, %f, %f, %f), (float)angle, (float)x, (float)y, (float)z)
    glatter_glRotatef_ptr(angle, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glScaled_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScaled, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glScaled_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glScalef_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScalef, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glScalef_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glScissor_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissor, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glScissor_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glSelectBuffer_debug(GLsizei size, GLuint *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSelectBuffer, (%d, %p), (int)size, (void*)buffer)
    glatter_glSelectBuffer_ptr(size, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glShadeModel_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShadeModel, (%s), enum_to_string_GL(mode))
    glatter_glShadeModel_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFunc_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFunc, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFunc_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMask_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMask, (%u), (unsigned int)mask)
    glatter_glStencilMask_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOp_debug(GLenum fail, GLenum zfail, GLenum zpass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOp, (%s, %s, %s), enum_to_string_GL(fail), enum_to_string_GL(zfail), enum_to_string_GL(zpass))
    glatter_glStencilOp_ptr(fail, zfail, zpass);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1d_debug(GLdouble s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1d, (%f), (double)s)
    glatter_glTexCoord1d_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1dv, (%p), (void*)v)
    glatter_glTexCoord1dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1f_debug(GLfloat s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1f, (%f), (float)s)
    glatter_glTexCoord1f_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1fv, (%p), (void*)v)
    glatter_glTexCoord1fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1i_debug(GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1i, (%d), (int)s)
    glatter_glTexCoord1i_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1iv, (%p), (void*)v)
    glatter_glTexCoord1iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1s_debug(GLshort s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1s, (%hi), (short)s)
    glatter_glTexCoord1s_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1sv, (%p), (void*)v)
    glatter_glTexCoord1sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2d_debug(GLdouble s, GLdouble t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2d, (%f, %f), (double)s, (double)t)
    glatter_glTexCoord2d_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2dv, (%p), (void*)v)
    glatter_glTexCoord2dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2f_debug(GLfloat s, GLfloat t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2f, (%f, %f), (float)s, (float)t)
    glatter_glTexCoord2f_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fv, (%p), (void*)v)
    glatter_glTexCoord2fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2i_debug(GLint s, GLint t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2i, (%d, %d), (int)s, (int)t)
    glatter_glTexCoord2i_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2iv, (%p), (void*)v)
    glatter_glTexCoord2iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2s_debug(GLshort s, GLshort t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2s, (%hi, %hi), (short)s, (short)t)
    glatter_glTexCoord2s_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2sv, (%p), (void*)v)
    glatter_glTexCoord2sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3d_debug(GLdouble s, GLdouble t, GLdouble r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3d, (%f, %f, %f), (double)s, (double)t, (double)r)
    glatter_glTexCoord3d_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3dv, (%p), (void*)v)
    glatter_glTexCoord3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3f_debug(GLfloat s, GLfloat t, GLfloat r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3f, (%f, %f, %f), (float)s, (float)t, (float)r)
    glatter_glTexCoord3f_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3fv, (%p), (void*)v)
    glatter_glTexCoord3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3i_debug(GLint s, GLint t, GLint r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3i, (%d, %d, %d), (int)s, (int)t, (int)r)
    glatter_glTexCoord3i_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3iv, (%p), (void*)v)
    glatter_glTexCoord3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3s_debug(GLshort s, GLshort t, GLshort r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3s, (%hi, %hi, %hi), (short)s, (short)t, (short)r)
    glatter_glTexCoord3s_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3sv, (%p), (void*)v)
    glatter_glTexCoord3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4d_debug(GLdouble s, GLdouble t, GLdouble r, GLdouble q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4d, (%f, %f, %f, %f), (double)s, (double)t, (double)r, (double)q)
    glatter_glTexCoord4d_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4dv, (%p), (void*)v)
    glatter_glTexCoord4dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4f_debug(GLfloat s, GLfloat t, GLfloat r, GLfloat q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4f, (%f, %f, %f, %f), (float)s, (float)t, (float)r, (float)q)
    glatter_glTexCoord4f_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fv, (%p), (void*)v)
    glatter_glTexCoord4fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4i_debug(GLint s, GLint t, GLint r, GLint q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4i, (%d, %d, %d, %d), (int)s, (int)t, (int)r, (int)q)
    glatter_glTexCoord4i_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4iv, (%p), (void*)v)
    glatter_glTexCoord4iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4s_debug(GLshort s, GLshort t, GLshort r, GLshort q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4s, (%hi, %hi, %hi, %hi), (short)s, (short)t, (short)r, (short)q)
    glatter_glTexCoord4s_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4sv, (%p), (void*)v)
    glatter_glTexCoord4sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordPointer_debug(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointer, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glTexCoordPointer_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnvf_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvf, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTexEnvf_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnvfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexEnvfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnvi_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvi, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexEnvi_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnviv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnviv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexEnviv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGend_debug(GLenum coord, GLenum pname, GLdouble param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGend, (%s, %s, %f), enum_to_string_GL(coord), enum_to_string_GL(pname), (double)param)
    glatter_glTexGend_ptr(coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGendv_debug(GLenum coord, GLenum pname, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGendv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glTexGendv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGenf_debug(GLenum coord, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenf, (%s, %s, %f), enum_to_string_GL(coord), enum_to_string_GL(pname), (float)param)
    glatter_glTexGenf_ptr(coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGenfv_debug(GLenum coord, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenfv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glTexGenfv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGeni_debug(GLenum coord, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGeni, (%s, %s, %d), enum_to_string_GL(coord), enum_to_string_GL(pname), (int)param)
    glatter_glTexGeni_ptr(coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGeniv_debug(GLenum coord, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGeniv, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glTexGeniv_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage1D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage1D, (%s, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage1D_ptr(target, level, internalformat, width, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage2D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage2D_ptr(target, level, internalformat, width, height, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterf_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterf, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTexParameterf_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage1D, (%s, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage1D_ptr(target, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTranslated_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTranslated, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glTranslated_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTranslatef_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTranslatef, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glTranslatef_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2d_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2d, (%f, %f), (double)x, (double)y)
    glatter_glVertex2d_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2dv, (%p), (void*)v)
    glatter_glVertex2dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2f_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2f, (%f, %f), (float)x, (float)y)
    glatter_glVertex2f_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2fv, (%p), (void*)v)
    glatter_glVertex2fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2i_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2i, (%d, %d), (int)x, (int)y)
    glatter_glVertex2i_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2iv, (%p), (void*)v)
    glatter_glVertex2iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2s_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2s, (%hi, %hi), (short)x, (short)y)
    glatter_glVertex2s_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2sv, (%p), (void*)v)
    glatter_glVertex2sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3d_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3d, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glVertex3d_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3dv, (%p), (void*)v)
    glatter_glVertex3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3f_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3f, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glVertex3f_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3fv, (%p), (void*)v)
    glatter_glVertex3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3i_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3i, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glVertex3i_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3iv, (%p), (void*)v)
    glatter_glVertex3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3s_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3s, (%hi, %hi, %hi), (short)x, (short)y, (short)z)
    glatter_glVertex3s_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3sv, (%p), (void*)v)
    glatter_glVertex3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4d_debug(GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4d, (%f, %f, %f, %f), (double)x, (double)y, (double)z, (double)w)
    glatter_glVertex4d_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4dv, (%p), (void*)v)
    glatter_glVertex4dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4f_debug(GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4f, (%f, %f, %f, %f), (float)x, (float)y, (float)z, (float)w)
    glatter_glVertex4f_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4fv, (%p), (void*)v)
    glatter_glVertex4fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4i_debug(GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4i, (%d, %d, %d, %d), (int)x, (int)y, (int)z, (int)w)
    glatter_glVertex4i_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4iv, (%p), (void*)v)
    glatter_glVertex4iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4s_debug(GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4s, (%hi, %hi, %hi, %hi), (short)x, (short)y, (short)z, (short)w)
    glatter_glVertex4s_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4sv, (%p), (void*)v)
    glatter_glVertex4sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexPointer_debug(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointer, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexPointer_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glViewport_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewport, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glViewport_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
#endif // __gl_h_

#ifdef __glcorearb_h_
GLenum glatter_glClientWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    GLenum rval = glatter_glClientWaitSync_ptr(sync, flags, timeout);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSync, (%p), (void*)sync)
    glatter_glDeleteSync_ptr(sync);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertex, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertex_ptr(mode, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertex, (%s, %d, %s, %p, %d, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertex_ptr(mode, count, type, indices, instancecount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementsBaseVertex_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertex, (%s, %u, %u, %d, %s, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertex_ptr(mode, start, end, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
GLsync glatter_glFenceSync_debug(GLenum condition, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFenceSync, (%s, %u), enum_to_string_GL(condition), (unsigned int)flags)
    GLsync rval = glatter_glFenceSync_ptr(condition, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glFramebufferTexture_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteri64v_debug(GLenum target, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteri64v, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteri64v_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInteger64i_v_debug(GLenum target, GLuint index, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64i_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetInteger64i_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInteger64v_debug(GLenum pname, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64v, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetInteger64v_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultisamplefv_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefv, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefv_ptr(pname, index, val);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSynciv_debug(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSynciv, (%p, %s, %d, %p, %p), (void*)sync, enum_to_string_GL(pname), (int)bufSize, (void*)length, (void*)values)
    glatter_glGetSynciv_ptr(sync, pname, bufSize, length, values);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSync, (%p), (void*)sync)
    GLboolean rval = glatter_glIsSync_ptr(sync);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMultiDrawElementsBaseVertex_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsBaseVertex, (%s, %p, %s, %p, %d, %p), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount, (void*)basevertex)
    glatter_glMultiDrawElementsBaseVertex_ptr(mode, count, type, indices, drawcount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glProvokingVertex_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProvokingVertex, (%s), enum_to_string_GL(mode))
    glatter_glProvokingVertex_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleMaski_debug(GLuint maskNumber, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaski, (%u, %u), (unsigned int)maskNumber, (unsigned int)mask)
    glatter_glSampleMaski_ptr(maskNumber, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2DMultisample, (%s, %d, %s, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexImage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DMultisample, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexImage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    glatter_glWaitSync_ptr(sync, flags, timeout);
    glatter_check_error_GL(file, line);
}
#ifdef GL_AMD_performance_monitor
void glatter_glBeginPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glBeginPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glDeletePerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glEndPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glGenPerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glGenPerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterDataAMD_debug(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterDataAMD, (%u, %s, %d, %p, %p), (unsigned int)monitor, enum_to_string_GL(pname), (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfMonitorCounterDataAMD_ptr(monitor, pname, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterInfoAMD_debug(GLuint group, GLuint counter, GLenum pname, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterInfoAMD, (%u, %u, %s, %p), (unsigned int)group, (unsigned int)counter, enum_to_string_GL(pname), (void*)data)
    glatter_glGetPerfMonitorCounterInfoAMD_ptr(group, counter, pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterStringAMD_debug(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterStringAMD, (%u, %u, %d, %p, %p), (unsigned int)group, (unsigned int)counter, (int)bufSize, (void*)length, (void*)counterString)
    glatter_glGetPerfMonitorCounterStringAMD_ptr(group, counter, bufSize, length, counterString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCountersAMD_debug(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCountersAMD, (%u, %p, %p, %d, %p), (unsigned int)group, (void*)numCounters, (void*)maxActiveCounters, (int)counterSize, (void*)counters)
    glatter_glGetPerfMonitorCountersAMD_ptr(group, numCounters, maxActiveCounters, counterSize, counters);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupStringAMD_debug(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupStringAMD, (%u, %d, %p, %p), (unsigned int)group, (int)bufSize, (void*)length, (void*)groupString)
    glatter_glGetPerfMonitorGroupStringAMD_ptr(group, bufSize, length, groupString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupsAMD_debug(GLint *numGroups, GLsizei groupsSize, GLuint *groups, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupsAMD, (%p, %d, %p), (void*)numGroups, (int)groupsSize, (void*)groups)
    glatter_glGetPerfMonitorGroupsAMD_ptr(numGroups, groupsSize, groups);
    glatter_check_error_GL(file, line);
}
void glatter_glSelectPerfMonitorCountersAMD_debug(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSelectPerfMonitorCountersAMD, (%u, %u, %u, %d, %p), (unsigned int)monitor, (unsigned char)enable, (unsigned int)group, (int)numCounters, (void*)counterList)
    glatter_glSelectPerfMonitorCountersAMD_ptr(monitor, enable, group, numCounters, counterList);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_performance_monitor
#ifdef GL_ARB_bindless_texture
GLuint64 glatter_glGetImageHandleARB_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleARB, (%u, %d, %u, %d, %s), (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleARB_ptr(texture, level, layered, layer, format);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureHandleARB_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleARB, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleARB_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleARB_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleARB, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleARB_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetVertexAttribLui64vARB_debug(GLuint index, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLui64vARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLui64vARB_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsImageHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentARB, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentARB_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentARB, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentARB_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeImageHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeImageHandleResidentARB_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentARB, (%s, %s), GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentARB_ptr(handle, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64ARB_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64ARB, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64ARB_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vARB_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64ARB_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64ARB, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64ARB_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64ARB_debug(GLuint index, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64ARB, (%u, %s), (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1ui64ARB_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64vARB_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64vARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1ui64vARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_bindless_texture
#ifdef GL_ARB_cl_event
GLsync glatter_glCreateSyncFromCLeventARB_debug(struct _cl_context *context, struct _cl_event *event, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSyncFromCLeventARB, (%p, %p, %u), (void*)context, (void*)event, (unsigned int)flags)
    GLsync rval = glatter_glCreateSyncFromCLeventARB_ptr(context, event, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_cl_event
#ifdef GL_ARB_compute_variable_group_size
void glatter_glDispatchComputeGroupSizeARB_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeGroupSizeARB, (%u, %u, %u, %u, %u, %u), (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z, (unsigned int)group_size_x, (unsigned int)group_size_y, (unsigned int)group_size_z)
    glatter_glDispatchComputeGroupSizeARB_ptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_compute_variable_group_size
#ifdef GL_ARB_debug_output
void glatter_glDebugMessageCallbackARB_debug(GLDEBUGPROCARB callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackARB, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackARB_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControlARB_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControlARB, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControlARB_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsertARB_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertARB, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsertARB_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLogARB_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogARB, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLogARB_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_debug_output
#ifdef GL_ARB_draw_buffers_blend
void glatter_glBlendEquationSeparateiARB_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateiARB, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateiARB_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationiARB_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationiARB, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationiARB_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparateiARB_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateiARB, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateiARB_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunciARB_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunciARB, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunciARB_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_draw_buffers_blend
#ifdef GL_ARB_indirect_parameters
void glatter_glMultiDrawArraysIndirectCountARB_debug(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectCountARB, (%s, %td, %td, %d, %d), enum_to_string_GL(mode), (ptrdiff_t)indirect, (ptrdiff_t)drawcount, (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawArraysIndirectCountARB_ptr(mode, indirect, drawcount, maxdrawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectCountARB_debug(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectCountARB, (%s, %s, %td, %td, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (ptrdiff_t)indirect, (ptrdiff_t)drawcount, (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawElementsIndirectCountARB_ptr(mode, type, indirect, drawcount, maxdrawcount, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_indirect_parameters
#ifdef GL_ARB_robustness
GLenum glatter_glGetGraphicsResetStatusARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatusARB, ())
    GLenum rval = glatter_glGetGraphicsResetStatusARB_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetnCompressedTexImageARB_debug(GLenum target, GLint lod, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImageARB, (%s, %d, %d, %p), enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)img)
    glatter_glGetnCompressedTexImageARB_ptr(target, lod, bufSize, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnTexImageARB_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImageARB, (%s, %d, %s, %s, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)img)
    glatter_glGetnTexImageARB_ptr(target, level, format, type, bufSize, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformdvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdvARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdvARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformfvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfvARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfvARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformivARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformivARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuivARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuivARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixelsARB_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixelsARB, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixelsARB_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_robustness
#ifdef GL_ARB_sample_shading
void glatter_glMinSampleShadingARB_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShadingARB, (%f), (float)value)
    glatter_glMinSampleShadingARB_ptr(value);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sample_shading
#ifdef GL_ARB_shading_language_include
void glatter_glCompileShaderIncludeARB_debug(GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShaderIncludeARB, (%u, %d, %p, %p), (unsigned int)shader, (int)count, (void*)path, (void*)length)
    glatter_glCompileShaderIncludeARB_ptr(shader, count, path, length);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteNamedStringARB, (%d, %p), (int)namelen, (void*)name)
    glatter_glDeleteNamedStringARB_ptr(namelen, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedStringARB_debug(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringARB, (%d, %p, %d, %p, %p), (int)namelen, (void*)name, (int)bufSize, (void*)stringlen, (void*)string)
    glatter_glGetNamedStringARB_ptr(namelen, name, bufSize, stringlen, string);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedStringivARB_debug(GLint namelen, const GLchar *name, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringivARB, (%d, %p, %s, %p), (int)namelen, (void*)name, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedStringivARB_ptr(namelen, name, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNamedStringARB, (%d, %p), (int)namelen, (void*)name)
    GLboolean rval = glatter_glIsNamedStringARB_ptr(namelen, name);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glNamedStringARB_debug(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedStringARB, (%s, %d, %p, %d, %p), enum_to_string_GL(type), (int)namelen, (void*)name, (int)stringlen, (void*)string)
    glatter_glNamedStringARB_ptr(type, namelen, name, stringlen, string);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_shading_language_include
#ifdef GL_ARB_sparse_buffer
void glatter_glBufferPageCommitmentARB_debug(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferPageCommitmentARB, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glBufferPageCommitmentARB_ptr(target, offset, size, commit);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferPageCommitmentARB_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentARB, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentARB_ptr(buffer, offset, size, commit);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferPageCommitmentEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentEXT, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentEXT_ptr(buffer, offset, size, commit);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sparse_buffer
#ifdef GL_ARB_sparse_texture
void glatter_glTexPageCommitmentARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexPageCommitmentARB, (%s, %d, %d, %d, %d, %d, %d, %d, %u), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexPageCommitmentARB_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sparse_texture
#ifdef GL_EXT_debug_label
void glatter_glGetObjectLabelEXT_debug(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabelEXT, (%s, %u, %d, %p, %p), enum_to_string_GL(type), (unsigned int)object, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabelEXT_ptr(type, object, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glLabelObjectEXT_debug(GLenum type, GLuint object, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLabelObjectEXT, (%s, %u, %d, %p), enum_to_string_GL(type), (unsigned int)object, (int)length, (void*)label)
    glatter_glLabelObjectEXT_ptr(type, object, length, label);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
void glatter_glInsertEventMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertEventMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glInsertEventMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
void glatter_glPopGroupMarkerEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopGroupMarkerEXT, ())
    glatter_glPopGroupMarkerEXT_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushGroupMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushGroupMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glPushGroupMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_draw_instanced
void glatter_glDrawArraysInstancedEXT_debug(GLenum mode, GLint start, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedEXT, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)start, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedEXT_ptr(mode, start, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedEXT, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedEXT_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_polygon_offset_clamp
void glatter_glPolygonOffsetClampEXT_debug(GLfloat factor, GLfloat units, GLfloat clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetClampEXT, (%f, %f, %f), (float)factor, (float)units, (float)clamp)
    glatter_glPolygonOffsetClampEXT_ptr(factor, units, clamp);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_raster_multisample
void glatter_glRasterSamplesEXT_debug(GLuint samples, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterSamplesEXT, (%u, %u), (unsigned int)samples, (unsigned char)fixedsamplelocations)
    glatter_glRasterSamplesEXT_ptr(samples, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_separate_shader_objects
void glatter_glActiveProgramEXT_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveProgramEXT, (%u), (unsigned int)program)
    glatter_glActiveProgramEXT_ptr(program);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramEXT_debug(GLenum type, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramEXT, (%s, %p), enum_to_string_GL(type), (void*)string)
    GLuint rval = glatter_glCreateShaderProgramEXT_ptr(type, string);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glUseShaderProgramEXT_debug(GLenum type, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseShaderProgramEXT, (%s, %u), enum_to_string_GL(type), (unsigned int)program)
    glatter_glUseShaderProgramEXT_ptr(type, program);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_window_rectangles
void glatter_glWindowRectanglesEXT_debug(GLenum mode, GLsizei count, const GLint *box, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowRectanglesEXT, (%s, %d, %p), enum_to_string_GL(mode), (int)count, (void*)box)
    glatter_glWindowRectanglesEXT_ptr(mode, count, box);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_window_rectangles
#ifdef GL_INTEL_framebuffer_CMAA
void glatter_glApplyFramebufferAttachmentCMAAINTEL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyFramebufferAttachmentCMAAINTEL, ())
    glatter_glApplyFramebufferAttachmentCMAAINTEL_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_performance_query
void glatter_glBeginPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glBeginPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glCreatePerfQueryINTEL_debug(GLuint queryId, GLuint *queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreatePerfQueryINTEL, (%u, %p), (unsigned int)queryId, (void*)queryHandle)
    glatter_glCreatePerfQueryINTEL_ptr(queryId, queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glDeletePerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glEndPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFirstPerfQueryIdINTEL_debug(GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFirstPerfQueryIdINTEL, (%p), (void*)queryId)
    glatter_glGetFirstPerfQueryIdINTEL_ptr(queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNextPerfQueryIdINTEL_debug(GLuint queryId, GLuint *nextQueryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNextPerfQueryIdINTEL, (%u, %p), (unsigned int)queryId, (void*)nextQueryId)
    glatter_glGetNextPerfQueryIdINTEL_ptr(queryId, nextQueryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfCounterInfoINTEL_debug(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfCounterInfoINTEL, (%u, %u, %u, %p, %u, %p, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)counterId, (unsigned int)counterNameLength, (void*)counterName, (unsigned int)counterDescLength, (void*)counterDesc, (void*)counterOffset, (void*)counterDataSize, (void*)counterTypeEnum, (void*)counterDataTypeEnum, (void*)rawCounterMaxValue)
    glatter_glGetPerfCounterInfoINTEL_ptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryDataINTEL_debug(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryDataINTEL, (%u, %u, %d, %p, %p), (unsigned int)queryHandle, (unsigned int)flags, (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfQueryDataINTEL_ptr(queryHandle, flags, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryIdByNameINTEL_debug(GLchar *queryName, GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryIdByNameINTEL, (%p, %p), (void*)queryName, (void*)queryId)
    glatter_glGetPerfQueryIdByNameINTEL_ptr(queryName, queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryInfoINTEL_debug(GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryInfoINTEL, (%u, %u, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)queryNameLength, (void*)queryName, (void*)dataSize, (void*)noCounters, (void*)noInstances, (void*)capsMask)
    glatter_glGetPerfQueryInfoINTEL_ptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
void glatter_glBlendBarrierKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierKHR, ())
    glatter_glBlendBarrierKHR_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_NV_bindless_texture
GLuint64 glatter_glGetImageHandleNV_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleNV, (%u, %d, %u, %d, %s), (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleNV_ptr(texture, level, layered, layer, format);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureHandleNV_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleNV, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleNV_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleNV_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleNV, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleNV_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsImageHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeImageHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeImageHandleResidentNV_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentNV, (%s, %s), GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentNV_ptr(handle, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64NV_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64NV_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vNV_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64NV_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64NV, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64NV_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vNV_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
void glatter_glBlendBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierNV, ())
    glatter_glBlendBarrierNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glBlendParameteriNV_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glBlendParameteriNV_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_conditional_render
void glatter_glBeginConditionalRenderNV_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNV, (%u, %s), (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRenderNV_ptr(id, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRenderNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNV, ())
    glatter_glEndConditionalRenderNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
void glatter_glSubpixelPrecisionBiasNV_debug(GLuint xbits, GLuint ybits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSubpixelPrecisionBiasNV, (%u, %u), (unsigned int)xbits, (unsigned int)ybits)
    glatter_glSubpixelPrecisionBiasNV_ptr(xbits, ybits);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_pre_snap_triangles
void glatter_glConservativeRasterParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glConservativeRasterParameteriNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_fragment_coverage_to_color
void glatter_glFragmentCoverageColorNV_debug(GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentCoverageColorNV, (%u), (unsigned int)color)
    glatter_glFragmentCoverageColorNV_ptr(color);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_framebuffer_mixed_samples
void glatter_glCoverageModulationNV_debug(GLenum components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationNV, (%s), enum_to_string_GL(components))
    glatter_glCoverageModulationNV_ptr(components);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverageModulationTableNV_debug(GLsizei n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationTableNV, (%d, %p), (int)n, (void*)v)
    glatter_glCoverageModulationTableNV_ptr(n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCoverageModulationTableNV_debug(GLsizei bufsize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCoverageModulationTableNV, (%d, %p), (int)bufsize, (void*)v)
    glatter_glGetCoverageModulationTableNV_ptr(bufsize, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_gpu_shader5
void glatter_glGetUniformi64vNV_debug(GLuint program, GLint location, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vNV, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vNV_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64NV_debug(GLuint program, GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64NV_debug(GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1i64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64NV_debug(GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1ui64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_gpu_shader5
#ifdef GL_NV_internalformat_sample_query
void glatter_glGetInternalformatSampleivNV_debug(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformatSampleivNV, (%s, %s, %d, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)samples, enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformatSampleivNV_ptr(target, internalformat, samples, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_path_rendering
void glatter_glCopyPathNV_debug(GLuint resultPath, GLuint srcPath, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyPathNV, (%u, %u), (unsigned int)resultPath, (unsigned int)srcPath)
    glatter_glCopyPathNV_ptr(resultPath, srcPath);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverFillPathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverStrokePathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePathsNV_debug(GLuint path, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePathsNV, (%u, %d), (unsigned int)path, (int)range)
    glatter_glDeletePathsNV_ptr(path, range);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenPathsNV_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPathsNV, (%d), (int)range)
    GLuint rval = glatter_glGenPathsNV_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathCommandsNV_debug(GLuint path, GLubyte *commands, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCommandsNV, (%u, %p), (unsigned int)path, (void*)commands)
    glatter_glGetPathCommandsNV_ptr(path, commands);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathCoordsNV_debug(GLuint path, GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCoordsNV, (%u, %p), (unsigned int)path, (void*)coords)
    glatter_glGetPathCoordsNV_ptr(path, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathDashArrayNV_debug(GLuint path, GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathDashArrayNV, (%u, %p), (unsigned int)path, (void*)dashArray)
    glatter_glGetPathDashArrayNV_ptr(path, dashArray);
    glatter_check_error_GL(file, line);
}
GLfloat glatter_glGetPathLengthNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathLengthNV, (%u, %d, %d), (unsigned int)path, (int)startSegment, (int)numSegments)
    GLfloat rval = glatter_glGetPathLengthNV_ptr(path, startSegment, numSegments);
    printf("GLATTER: returned %f", (float)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathMetricRangeNV_debug(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricRangeNV, (%u, %u, %d, %d, %p), (unsigned int)metricQueryMask, (unsigned int)firstPathName, (int)numPaths, (int)stride, (void*)metrics)
    glatter_glGetPathMetricRangeNV_ptr(metricQueryMask, firstPathName, numPaths, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathMetricsNV_debug(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricsNV, (%u, %d, %s, %p, %u, %d, %p), (unsigned int)metricQueryMask, (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)stride, (void*)metrics)
    glatter_glGetPathMetricsNV_ptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterfvNV_debug(GLuint path, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterivNV_debug(GLuint path, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathSpacingNV_debug(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathSpacingNV, (%s, %d, %s, %p, %u, %f, %f, %s, %p), enum_to_string_GL(pathListMode), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (float)advanceScale, (float)kerningScale, enum_to_string_GL(transformType), (void*)returnedSpacing)
    glatter_glGetPathSpacingNV_ptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourcefvNV_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourcefvNV, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourcefvNV_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInterpolatePathsNV_debug(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInterpolatePathsNV, (%u, %u, %u, %f), (unsigned int)resultPath, (unsigned int)pathA, (unsigned int)pathB, (float)weight)
    glatter_glInterpolatePathsNV_ptr(resultPath, pathA, pathB, weight);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsPathNV_debug(GLuint path, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPathNV, (%u), (unsigned int)path)
    GLboolean rval = glatter_glIsPathNV_ptr(path);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInFillPathNV_debug(GLuint path, GLuint mask, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInFillPathNV, (%u, %u, %f, %f), (unsigned int)path, (unsigned int)mask, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInFillPathNV_ptr(path, mask, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInStrokePathNV_debug(GLuint path, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInStrokePathNV, (%u, %f, %f), (unsigned int)path, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInStrokePathNV_ptr(path, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMatrixLoad3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoad3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoadTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMultTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCommandsNV_debug(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCommandsNV, (%u, %d, %p, %d, %s, %p), (unsigned int)path, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCommandsNV_ptr(path, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoordsNV_debug(GLuint path, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoordsNV, (%u, %d, %s, %p), (unsigned int)path, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCoordsNV_ptr(path, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoverDepthFuncNV_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoverDepthFuncNV, (%s), enum_to_string_GL(func))
    glatter_glPathCoverDepthFuncNV_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glPathDashArrayNV_debug(GLuint path, GLsizei dashCount, const GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathDashArrayNV, (%u, %d, %p), (unsigned int)path, (int)dashCount, (void*)dashArray)
    glatter_glPathDashArrayNV_ptr(path, dashCount, dashArray);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexArrayNV, (%u, %s, %p, %u, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLenum glatter_glPathGlyphIndexRangeNV_debug(GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2], const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexRangeNV, (%s, %p, %u, %u, %f, %s), enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)pathParameterTemplate, (float)emScale, GET_PRS(baseAndCount))
    GLenum rval = glatter_glPathGlyphIndexRangeNV_ptr(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathGlyphRangeNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphRangeNV, (%u, %s, %p, %u, %u, %d, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyph, (int)numGlyphs, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphRangeNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
void glatter_glPathGlyphsNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphsNV, (%u, %s, %p, %u, %d, %s, %p, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (int)numGlyphs, enum_to_string_GL(type), (void*)charcodes, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphsNV_ptr(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathMemoryGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathMemoryGlyphIndexArrayNV, (%u, %s, %td, %p, %d, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (ptrdiff_t)fontSize, (void*)fontData, (int)faceIndex, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathMemoryGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathParameterfNV_debug(GLuint path, GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfNV, (%u, %s, %f), (unsigned int)path, enum_to_string_GL(pname), (float)value)
    glatter_glPathParameterfNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterfvNV_debug(GLuint path, GLenum pname, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameteriNV_debug(GLuint path, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameteriNV, (%u, %s, %d), (unsigned int)path, enum_to_string_GL(pname), (int)value)
    glatter_glPathParameteriNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterivNV_debug(GLuint path, GLenum pname, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilDepthOffsetNV_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilDepthOffsetNV, (%f, %f), (float)factor, (float)units)
    glatter_glPathStencilDepthOffsetNV_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilFuncNV_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilFuncNV, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glPathStencilFuncNV_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStringNV_debug(GLuint path, GLenum format, GLsizei length, const void *pathString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStringNV, (%u, %s, %d, %p), (unsigned int)path, enum_to_string_GL(format), (int)length, (void*)pathString)
    glatter_glPathStringNV_ptr(path, format, length, pathString);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCommandsNV_debug(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCommandsNV, (%u, %d, %d, %d, %p, %d, %s, %p), (unsigned int)path, (int)commandStart, (int)commandsToDelete, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCommandsNV_ptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCoordsNV_debug(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCoordsNV, (%u, %d, %d, %s, %p), (unsigned int)path, (int)coordStart, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCoordsNV_ptr(path, coordStart, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glPointAlongPathNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointAlongPathNV, (%u, %d, %d, %f, %p, %p, %p, %p), (unsigned int)path, (int)startSegment, (int)numSegments, (float)distance, (void*)x, (void*)y, (void*)tangentX, (void*)tangentY)
    GLboolean rval = glatter_glPointAlongPathNV_ptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramPathFragmentInputGenNV_debug(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramPathFragmentInputGenNV, (%u, %d, %s, %d, %p), (unsigned int)program, (int)location, enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glProgramPathFragmentInputGenNV_ptr(program, location, genMode, components, coeffs);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathNV, (%u, %s, %u), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask)
    glatter_glStencilFillPathNV_ptr(path, fillMode, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathNV, (%u, %d, %u), (unsigned int)path, (int)reference, (unsigned int)mask)
    glatter_glStencilStrokePathNV_ptr(path, reference, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathNV, (%u, %s, %u, %s), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverFillPathNV_ptr(path, fillMode, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathNV, (%u, %d, %u, %s), (unsigned int)path, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverStrokePathNV_ptr(path, reference, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformPathNV_debug(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformPathNV, (%u, %u, %s, %p), (unsigned int)resultPath, (unsigned int)srcPath, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glTransformPathNV_ptr(resultPath, srcPath, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightPathsNV_debug(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPathsNV, (%u, %d, %p, %p), (unsigned int)resultPath, (int)numPaths, (void*)paths, (void*)weights)
    glatter_glWeightPathsNV_ptr(resultPath, numPaths, paths, weights);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_path_rendering
#ifdef GL_NV_sample_locations
void glatter_glFramebufferSampleLocationsfvNV_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvNV_ptr(target, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferSampleLocationsfvNV_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvNV, (%u, %u, %d, %p), (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvNV_ptr(framebuffer, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glResolveDepthValuesNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResolveDepthValuesNV, ())
    glatter_glResolveDepthValuesNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_sample_locations
#ifdef GL_NV_viewport_swizzle
void glatter_glViewportSwizzleNV_debug(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportSwizzleNV, (%u, %s, %s, %s, %s), (unsigned int)index, enum_to_string_GL(swizzlex), enum_to_string_GL(swizzley), enum_to_string_GL(swizzlez), enum_to_string_GL(swizzlew))
    glatter_glViewportSwizzleNV_ptr(index, swizzlex, swizzley, swizzlez, swizzlew);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_viewport_swizzle
#ifdef GL_OVR_multiview
void glatter_glFramebufferTextureMultiviewOVR_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureMultiviewOVR, (%s, %s, %u, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)baseViewIndex, (int)numViews)
    glatter_glFramebufferTextureMultiviewOVR_ptr(target, attachment, texture, level, baseViewIndex, numViews);
    glatter_check_error_GL(file, line);
}
#endif // GL_OVR_multiview
#ifdef GL_VERSION_1_0
void glatter_glBlendFunc_debug(GLenum sfactor, GLenum dfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunc, (%s, %s), enum_to_string_GL(sfactor), enum_to_string_GL(dfactor))
    glatter_glBlendFunc_ptr(sfactor, dfactor);
    glatter_check_error_GL(file, line);
}
void glatter_glClear_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClear, (%u), (unsigned int)mask)
    glatter_glClear_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glClearColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glClearColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepth_debug(GLdouble depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepth, (%f), (double)depth)
    glatter_glClearDepth_ptr(depth);
    glatter_check_error_GL(file, line);
}
void glatter_glClearStencil_debug(GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearStencil, (%d), (int)s)
    glatter_glClearStencil_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMask_debug(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMask, (%u, %u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glColorMask_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glCullFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullFace, (%s), enum_to_string_GL(mode))
    glatter_glCullFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthFunc_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthFunc, (%s), enum_to_string_GL(func))
    glatter_glDepthFunc_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthMask_debug(GLboolean flag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthMask, (%u), (unsigned char)flag)
    glatter_glDepthMask_ptr(flag);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRange_debug(GLdouble near, GLdouble far, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRange, (%f, %f), (double)near, (double)far)
    glatter_glDepthRange_ptr(near, far);
    glatter_check_error_GL(file, line);
}
void glatter_glDisable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisable, (%s), enum_to_string_GL(cap))
    glatter_glDisable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawBuffer_debug(GLenum buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffer, (%s), enum_to_string_GL(buf))
    glatter_glDrawBuffer_ptr(buf);
    glatter_check_error_GL(file, line);
}
void glatter_glEnable_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnable, (%s), enum_to_string_GL(cap))
    glatter_glEnable_ptr(cap);
    glatter_check_error_GL(file, line);
}
void glatter_glFinish_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinish, ())
    glatter_glFinish_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFlush_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlush, ())
    glatter_glFlush_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFrontFace_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrontFace, (%s), enum_to_string_GL(mode))
    glatter_glFrontFace_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleanv_debug(GLenum pname, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleanv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetBooleanv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoublev_debug(GLenum pname, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublev, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetDoublev_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glGetError_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetError, ())
    GLenum rval = glatter_glGetError_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFloatv_debug(GLenum pname, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloatv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetFloatv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerv_debug(GLenum pname, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerv, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetIntegerv_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetString_debug(GLenum name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetString, (%s), enum_to_string_GL(name))
    const GLubyte * rval = glatter_glGetString_ptr(name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetTexImage_debug(GLenum target, GLint level, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexImage, (%s, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetTexImage_ptr(target, level, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameterfv_debug(GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameterfv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameterfv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameteriv_debug(GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameteriv, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameteriv_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glHint_debug(GLenum target, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHint, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(mode))
    glatter_glHint_ptr(target, mode);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabled_debug(GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabled, (%s), enum_to_string_GL(cap))
    GLboolean rval = glatter_glIsEnabled_ptr(cap);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLineWidth_debug(GLfloat width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineWidth, (%f), (float)width)
    glatter_glLineWidth_ptr(width);
    glatter_check_error_GL(file, line);
}
void glatter_glLogicOp_debug(GLenum opcode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLogicOp, (%s), enum_to_string_GL(opcode))
    glatter_glLogicOp_ptr(opcode);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStoref_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStoref, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPixelStoref_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStorei_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStorei, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelStorei_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointSize_debug(GLfloat size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointSize, (%f), (float)size)
    glatter_glPointSize_ptr(size);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonMode_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonMode, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glPolygonMode_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glReadBuffer_debug(GLenum src, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadBuffer, (%s), enum_to_string_GL(src))
    glatter_glReadBuffer_ptr(src);
    glatter_check_error_GL(file, line);
}
void glatter_glReadPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadPixels, (%d, %d, %d, %d, %s, %s, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glReadPixels_ptr(x, y, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glScissor_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissor, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glScissor_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFunc_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFunc, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFunc_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMask_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMask, (%u), (unsigned int)mask)
    glatter_glStencilMask_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOp_debug(GLenum fail, GLenum zfail, GLenum zpass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOp, (%s, %s, %s), enum_to_string_GL(fail), enum_to_string_GL(zfail), enum_to_string_GL(zpass))
    glatter_glStencilOp_ptr(fail, zfail, zpass);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage1D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage1D, (%s, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage1D_ptr(target, level, internalformat, width, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage2D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage2D_ptr(target, level, internalformat, width, height, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterf_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterf, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTexParameterf_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glViewport_debug(GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewport, (%d, %d, %d, %d), (int)x, (int)y, (int)width, (int)height)
    glatter_glViewport_ptr(x, y, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_0
#ifdef GL_VERSION_1_1
void glatter_glBindTexture_debug(GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTexture, (%s, %u), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindTexture_ptr(target, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage1D_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage1D, (%s, %d, %s, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTexImage1D_ptr(target, level, internalformat, x, y, width, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTexImage2D_ptr(target, level, internalformat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage1D, (%s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTexSubImage1D_ptr(target, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage2D, (%s, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage2D_ptr(target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTextures_debug(GLsizei n, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glDeleteTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArrays_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArrays, (%s, %d, %d), enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawArrays_ptr(mode, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElements_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElements, (%s, %d, %s, %p), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawElements_ptr(mode, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTextures_debug(GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTextures, (%d, %p), (int)n, (void*)textures)
    glatter_glGenTextures_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointerv_debug(GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointerv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointerv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsTexture_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTexture, (%u), (unsigned int)texture)
    GLboolean rval = glatter_glIsTexture_ptr(texture);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPolygonOffset_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffset, (%f, %f), (float)factor, (float)units)
    glatter_glPolygonOffset_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage1D, (%s, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage1D_ptr(target, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_1
#ifdef GL_VERSION_1_2
void glatter_glCopyTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElements_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElements, (%s, %u, %u, %d, %s, %p), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElements_ptr(mode, start, end, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3D, (%s, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3D_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_2
#ifdef GL_VERSION_1_3
void glatter_glActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTexture, (%s), enum_to_string_GL(texture))
    glatter_glActiveTexture_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage1D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage1D, (%s, %d, %s, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage1D_ptr(target, level, internalformat, width, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2D_ptr(target, level, internalformat, width, height, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage3D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3D, (%s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3D_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage1D, (%s, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage1D_ptr(target, level, xoffset, width, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTexImage_debug(GLenum target, GLint level, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTexImage, (%s, %d, %p), enum_to_string_GL(target), (int)level, (void*)img)
    glatter_glGetCompressedTexImage_ptr(target, level, img);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleCoverage_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverage, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleCoverage_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_3
#ifdef GL_VERSION_1_4
void glatter_glBlendColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquation_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquation, (%s), enum_to_string_GL(mode))
    glatter_glBlendEquation_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparate_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparate, (%s, %s, %s, %s), enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparate_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawArrays_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArrays, (%s, %p, %p, %d), enum_to_string_GL(mode), (void*)first, (void*)count, (int)drawcount)
    glatter_glMultiDrawArrays_ptr(mode, first, count, drawcount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElements_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElements, (%s, %p, %s, %p, %d), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount)
    glatter_glMultiDrawElements_ptr(mode, count, type, indices, drawcount);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterf, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterf_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterfv_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameteri_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteri, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPointParameteri_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameteriv_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteriv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameteriv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_4
#ifdef GL_VERSION_1_5
void glatter_glBeginQuery_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQuery, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQuery_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBuffer_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBuffer_ptr(target, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferData_debug(GLenum target, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferData, (%s, %td, %p, %s), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glBufferData_ptr(target, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubData, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glBufferSubData_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteBuffers_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glDeleteBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteQueries_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQuery_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQuery, (%s), enum_to_string_GL(target))
    glatter_glEndQuery_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGenBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glGenBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenQueries_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glGenQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferPointerv_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointerv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointerv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferSubData, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetBufferSubData_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectiv_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectiv, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectiv_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectuiv_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuiv, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuiv_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBuffer, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsBuffer_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsQuery_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQuery, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsQuery_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBuffer_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBuffer, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBuffer_ptr(target, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glUnmapBuffer_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBuffer, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBuffer_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_VERSION_1_5
#ifdef GL_VERSION_2_0
void glatter_glAttachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glAttachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glBindAttribLocation_debug(GLuint program, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocation, (%u, %u, %p), (unsigned int)program, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocation_ptr(program, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparate_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparate, (%s, %s), enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparate_ptr(modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glCompileShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShader, (%u), (unsigned int)shader)
    glatter_glCompileShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateProgram_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgram, ())
    GLuint rval = glatter_glCreateProgram_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glCreateShader_debug(GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShader, (%s), enum_to_string_GL(type))
    GLuint rval = glatter_glCreateShader_ptr(type);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgram, (%u), (unsigned int)program)
    glatter_glDeleteProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteShader, (%u), (unsigned int)shader)
    glatter_glDeleteShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDetachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glDetachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glDisableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawBuffers_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffers, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffers_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glEnableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAttrib_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttrib, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttrib_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniform_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniform, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniform_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetAttachedShaders_debug(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedShaders, (%u, %d, %p, %p), (unsigned int)program, (int)maxCount, (void*)count, (void*)shaders)
    glatter_glGetAttachedShaders_ptr(program, maxCount, count, shaders);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetAttribLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetAttribLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetProgramInfoLog_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInfoLog, (%u, %d, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramInfoLog_ptr(program, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramiv_debug(GLuint program, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramiv, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramiv_ptr(program, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderInfoLog_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderInfoLog, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetShaderInfoLog_ptr(shader, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderSource_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)source)
    glatter_glGetShaderSource_ptr(shader, bufSize, length, source);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderiv_debug(GLuint shader, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderiv, (%u, %s, %p), (unsigned int)shader, enum_to_string_GL(pname), (void*)params)
    glatter_glGetShaderiv_ptr(shader, pname, params);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetUniformLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetUniformLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformfv_debug(GLuint program, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformfv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformiv_debug(GLuint program, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribPointerv_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointerv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointerv_ptr(index, pname, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribfv_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgram, (%u), (unsigned int)program)
    GLboolean rval = glatter_glIsProgram_ptr(program);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsShader, (%u), (unsigned int)shader)
    GLboolean rval = glatter_glIsShader_ptr(shader);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLinkProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgram, (%u), (unsigned int)program)
    glatter_glLinkProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderSource_debug(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)count, (void*)string, (void*)length)
    glatter_glShaderSource_ptr(shader, count, string, length);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFuncSeparate_debug(GLenum face, GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparate, (%s, %s, %d, %u), enum_to_string_GL(face), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparate_ptr(face, func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMaskSeparate_debug(GLenum face, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMaskSeparate, (%s, %u), enum_to_string_GL(face), (unsigned int)mask)
    glatter_glStencilMaskSeparate_ptr(face, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOpSeparate_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparate, (%s, %s, %s, %s), enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparate_ptr(face, sfail, dpfail, dppass);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1f_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1f, (%d, %f), (int)location, (float)v0)
    glatter_glUniform1f_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i, (%d, %d), (int)location, (int)v0)
    glatter_glUniform1i_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2f_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2f, (%d, %f, %f), (int)location, (float)v0, (float)v1)
    glatter_glUniform2f_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i, (%d, %d, %d), (int)location, (int)v0, (int)v1)
    glatter_glUniform2i_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3f, (%d, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3f_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i, (%d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3i_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4f, (%d, %f, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4f_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i, (%d, %d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4i_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgram, (%u), (unsigned int)program)
    glatter_glUseProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgram, (%u), (unsigned int)program)
    glatter_glValidateProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1d, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttrib1d_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1f_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1f, (%u, %f), (unsigned int)index, (float)x)
    glatter_glVertexAttrib1f_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1s_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1s, (%u, %hi), (unsigned int)index, (short)x)
    glatter_glVertexAttrib1s_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2d, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2d_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2f_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2f, (%u, %f, %f), (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2f_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2s_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2s, (%u, %hi, %hi), (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2s_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3d, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3d_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3f, (%u, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3f_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3s_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3s, (%u, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3s_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nbv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nbv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nbv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Niv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Niv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Niv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nsv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nsv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nsv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nub_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nub, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4Nub_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nuiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nuiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nuiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nusv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nusv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nusv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4bv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4bv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4d, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4d_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4f, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4f_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4s_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4s, (%u, %hi, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4s_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4usv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4usv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribPointer_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointer, (%u, %d, %s, %u, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointer_ptr(index, size, type, normalized, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_2_0
#ifdef GL_VERSION_2_1
void glatter_glUniformMatrix2x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_2_1
#ifdef GL_VERSION_3_0
void glatter_glBeginConditionalRender_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRender, (%u, %s), (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRender_ptr(id, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBeginTransformFeedback_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedback, (%s), enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedback_ptr(primitiveMode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferBase_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBase, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBase_ptr(target, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferRange_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRange, (%s, %u, %u, %td, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glBindBufferRange_ptr(target, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFragDataLocation_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocation, (%u, %u, %p), (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocation_ptr(program, color, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFramebuffer_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebuffer_ptr(target, framebuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindRenderbuffer_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbuffer_ptr(target, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArray, (%u), (unsigned int)array)
    glatter_glBindVertexArray_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glBlitFramebuffer_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebuffer, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebuffer_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckFramebufferStatus_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatus, (%s), enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatus_ptr(target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClampColor_debug(GLenum target, GLenum clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClampColor, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(clamp))
    glatter_glClampColor_ptr(target, clamp);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfi_debug(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfi, (%s, %d, %f, %d), enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearBufferfi_ptr(buffer, drawbuffer, depth, stencil);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfv_debug(GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferfv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferiv_debug(GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferuiv_debug(GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferuiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferuiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaski_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaski, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaski_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteFramebuffers_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteRenderbuffers_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexArrays_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glDeleteVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glDisablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRender_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRender, ())
    glatter_glEndConditionalRender_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glEndTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedback, ())
    glatter_glEndTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRange, (%s, %td, %td), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedBufferRange_ptr(target, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferRenderbuffer_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbuffer, (%s, %s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbuffer_ptr(target, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture1D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture1D, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture1D_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture2D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2D, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2D_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture3D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3D, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3D_ptr(target, attachment, textarget, texture, level, zoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureLayer_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayer, (%s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayer_ptr(target, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glGenFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glGenVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateMipmap_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmap, (%s), enum_to_string_GL(target))
    glatter_glGenerateMipmap_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleani_v_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleani_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleani_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFramebufferAttachmentParameteriv_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameteriv, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameteriv_ptr(target, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegeri_v_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegeri_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegeri_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetRenderbufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetStringi_debug(GLenum name, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStringi, (%s, %u), enum_to_string_GL(name), (unsigned int)index)
    const GLubyte * rval = glatter_glGetStringi_ptr(name, index);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetTexParameterIiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuiv_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackVarying_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVarying, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVarying_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformuiv_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIuiv_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabledi_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledi, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledi_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsFramebuffer_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebuffer, (%u), (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebuffer_ptr(framebuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsRenderbuffer_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbuffer, (%u), (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbuffer_ptr(renderbuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArray, (%u), (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArray_ptr(array);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferRange, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapBufferRange_ptr(target, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glRenderbufferStorage_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorage, (%s, %s, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorage_ptr(target, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorageMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisample, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisample_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIiv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuiv_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackVaryings_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryings, (%u, %d, %p, %s), (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryings_ptr(program, count, varyings, bufferMode);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui, (%d, %u), (int)location, (unsigned int)v0)
    glatter_glUniform1ui_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui, (%d, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2ui_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui, (%d, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3ui_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui, (%d, %u, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4ui_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1i_debug(GLuint index, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1i, (%u, %d), (unsigned int)index, (int)x)
    glatter_glVertexAttribI1i_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1ui_debug(GLuint index, GLuint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1ui, (%u, %u), (unsigned int)index, (unsigned int)x)
    glatter_glVertexAttribI1ui_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2i_debug(GLuint index, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2i, (%u, %d, %d), (unsigned int)index, (int)x, (int)y)
    glatter_glVertexAttribI2i_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2ui_debug(GLuint index, GLuint x, GLuint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2ui, (%u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y)
    glatter_glVertexAttribI2ui_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3i_debug(GLuint index, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3i, (%u, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z)
    glatter_glVertexAttribI3i_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3ui, (%u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z)
    glatter_glVertexAttribI3ui_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4bv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4bv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4i_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4i, (%u, %d, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4i_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ui, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4ui_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4usv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4usv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointer, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointer_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_0
#ifdef GL_VERSION_3_1
void glatter_glCopyBufferSubData_debug(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyBufferSubData, (%s, %s, %td, %td, %td), enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyBufferSubData_ptr(readTarget, writeTarget, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysInstanced_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstanced, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount)
    glatter_glDrawArraysInstanced_ptr(mode, first, count, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstanced_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstanced, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount)
    glatter_glDrawElementsInstanced_ptr(mode, count, type, indices, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockName_debug(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockName, (%u, %u, %d, %p, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, (int)bufSize, (void*)length, (void*)uniformBlockName)
    glatter_glGetActiveUniformBlockName_ptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockiv_debug(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockiv, (%u, %u, %s, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformBlockiv_ptr(program, uniformBlockIndex, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformName_debug(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformName, (%u, %u, %d, %p, %p), (unsigned int)program, (unsigned int)uniformIndex, (int)bufSize, (void*)length, (void*)uniformName)
    glatter_glGetActiveUniformName_ptr(program, uniformIndex, bufSize, length, uniformName);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformsiv_debug(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformsiv, (%u, %d, %p, %s, %p), (unsigned int)program, (int)uniformCount, (void*)uniformIndices, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformsiv_ptr(program, uniformCount, uniformIndices, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetUniformBlockIndex_debug(GLuint program, const GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBlockIndex, (%u, %p), (unsigned int)program, (void*)uniformBlockName)
    GLuint rval = glatter_glGetUniformBlockIndex_ptr(program, uniformBlockName);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformIndices_debug(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformIndices, (%u, %d, %p, %p), (unsigned int)program, (int)uniformCount, (void*)uniformNames, (void*)uniformIndices)
    glatter_glGetUniformIndices_ptr(program, uniformCount, uniformNames, uniformIndices);
    glatter_check_error_GL(file, line);
}
void glatter_glPrimitiveRestartIndex_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartIndex, (%u), (unsigned int)index)
    glatter_glPrimitiveRestartIndex_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBuffer_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBuffer, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBuffer_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformBlockBinding_debug(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBlockBinding, (%u, %u, %u), (unsigned int)program, (unsigned int)uniformBlockIndex, (unsigned int)uniformBlockBinding)
    glatter_glUniformBlockBinding_ptr(program, uniformBlockIndex, uniformBlockBinding);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_1
#ifdef GL_VERSION_3_3
void glatter_glBindFragDataLocationIndexed_debug(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationIndexed, (%u, %u, %u, %p), (unsigned int)program, (unsigned int)colorNumber, (unsigned int)index, (void*)name)
    glatter_glBindFragDataLocationIndexed_ptr(program, colorNumber, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindSampler_debug(GLuint unit, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSampler, (%u, %u), (unsigned int)unit, (unsigned int)sampler)
    glatter_glBindSampler_ptr(unit, sampler);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteSamplers_debug(GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glDeleteSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenSamplers_debug(GLsizei count, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glGenSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataIndex_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataIndex, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataIndex_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetQueryObjecti64v_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64v, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64v_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectui64v_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64v, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64v_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIiv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterfv_debug(GLuint sampler, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterfv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameteriv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameteriv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsSampler_debug(GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSampler, (%u), (unsigned int)sampler)
    GLboolean rval = glatter_glIsSampler_ptr(sampler);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glQueryCounter_debug(GLuint id, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryCounter, (%u, %s), (unsigned int)id, enum_to_string_GL(target))
    glatter_glQueryCounter_ptr(id, target);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIiv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterf_debug(GLuint sampler, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterf, (%u, %s, %f), (unsigned int)sampler, enum_to_string_GL(pname), (float)param)
    glatter_glSamplerParameterf_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterfv_debug(GLuint sampler, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterfv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteri_debug(GLuint sampler, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteri, (%u, %s, %d), (unsigned int)sampler, enum_to_string_GL(pname), (int)param)
    glatter_glSamplerParameteri_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteriv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameteriv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribDivisor_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisor, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisor_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP1ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP1ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP1uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP1uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP2ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP2ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP2uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP2uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP3ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP3ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP3uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP3uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP4ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP4ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP4uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP4uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_3
#ifdef GL_VERSION_4_0
void glatter_glBeginQueryIndexed_debug(GLenum target, GLuint index, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryIndexed, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)id)
    glatter_glBeginQueryIndexed_ptr(target, index, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTransformFeedback_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedback, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedback_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparatei_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparatei, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparatei_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationi_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationi, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationi_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparatei_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparatei, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparatei_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunci_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunci, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunci_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTransformFeedbacks_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysIndirect_debug(GLenum mode, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysIndirect, (%s, %p), enum_to_string_GL(mode), (void*)indirect)
    glatter_glDrawArraysIndirect_ptr(mode, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsIndirect, (%s, %s, %p), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect)
    glatter_glDrawElementsIndirect_ptr(mode, type, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedback_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedback, (%s, %u), enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedback_ptr(mode, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackStream_debug(GLenum mode, GLuint id, GLuint stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStream, (%s, %u, %u), enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream)
    glatter_glDrawTransformFeedbackStream_ptr(mode, id, stream);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQueryIndexed_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryIndexed, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEndQueryIndexed_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glGenTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufsize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineName_ptr(program, shadertype, index, bufsize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineUniformName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufsize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineUniformName_ptr(program, shadertype, index, bufsize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineUniformiv_debug(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformiv, (%u, %s, %u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, enum_to_string_GL(pname), (void*)values)
    glatter_glGetActiveSubroutineUniformiv_ptr(program, shadertype, index, pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramStageiv_debug(GLuint program, GLenum shadertype, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStageiv, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), enum_to_string_GL(pname), (void*)values)
    glatter_glGetProgramStageiv_ptr(program, shadertype, pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryIndexediv_debug(GLenum target, GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryIndexediv, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryIndexediv_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetSubroutineIndex_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLuint rval = glatter_glGetSubroutineIndex_ptr(program, shadertype, name);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetSubroutineUniformLocation_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineUniformLocation, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLint rval = glatter_glGetSubroutineUniformLocation_ptr(program, shadertype, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformSubroutineuiv_debug(GLenum shadertype, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformSubroutineuiv, (%s, %d, %p), enum_to_string_GL(shadertype), (int)location, (void*)params)
    glatter_glGetUniformSubroutineuiv_ptr(shadertype, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformdv_debug(GLuint program, GLint location, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformdv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformdv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsTransformFeedback_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedback, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedback_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMinSampleShading_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShading, (%f), (float)value)
    glatter_glMinSampleShading_ptr(value);
    glatter_check_error_GL(file, line);
}
void glatter_glPatchParameterfv_debug(GLenum pname, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameterfv, (%s, %p), enum_to_string_GL(pname), (void*)values)
    glatter_glPatchParameterfv_ptr(pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPatchParameteri_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteri, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteri_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPauseTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedback, ())
    glatter_glPauseTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glResumeTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedback, ())
    glatter_glResumeTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1d_debug(GLint location, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1d, (%d, %f), (int)location, (double)x)
    glatter_glUniform1d_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2d_debug(GLint location, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2d, (%d, %f, %f), (int)location, (double)x, (double)y)
    glatter_glUniform2d_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3d, (%d, %f, %f, %f), (int)location, (double)x, (double)y, (double)z)
    glatter_glUniform3d_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4d, (%d, %f, %f, %f, %f), (int)location, (double)x, (double)y, (double)z, (double)w)
    glatter_glUniform4d_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformSubroutinesuiv_debug(GLenum shadertype, GLsizei count, const GLuint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformSubroutinesuiv, (%s, %d, %p), enum_to_string_GL(shadertype), (int)count, (void*)indices)
    glatter_glUniformSubroutinesuiv_ptr(shadertype, count, indices);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_0
#ifdef GL_VERSION_4_1
void glatter_glActiveShaderProgram_debug(GLuint pipeline, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveShaderProgram, (%u, %u), (unsigned int)pipeline, (unsigned int)program)
    glatter_glActiveShaderProgram_ptr(pipeline, program);
    glatter_check_error_GL(file, line);
}
void glatter_glBindProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glBindProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepthf_debug(GLfloat d, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthf, (%f), (float)d)
    glatter_glClearDepthf_ptr(d);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramv_debug(GLenum type, GLsizei count, const GLchar *const*strings, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramv, (%s, %d, %p), enum_to_string_GL(type), (int)count, (void*)strings)
    GLuint rval = glatter_glCreateShaderProgramv_ptr(type, count, strings);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgramPipelines_debug(GLsizei n, const GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glDeleteProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeArrayv_debug(GLuint first, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeIndexed_debug(GLuint index, GLdouble n, GLdouble f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexed, (%u, %f, %f), (unsigned int)index, (double)n, (double)f)
    glatter_glDepthRangeIndexed_ptr(index, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangef_debug(GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangef, (%f, %f), (float)n, (float)f)
    glatter_glDepthRangef_ptr(n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glGenProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoublei_v_debug(GLenum target, GLuint index, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublei_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetDoublei_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloati_v_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloati_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramBinary_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramBinary, (%u, %d, %p, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)binaryFormat, (void*)binary)
    glatter_glGetProgramBinary_ptr(program, bufSize, length, binaryFormat, binary);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineInfoLog_debug(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineInfoLog, (%u, %d, %p, %p), (unsigned int)pipeline, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramPipelineInfoLog_ptr(pipeline, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineiv_debug(GLuint pipeline, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineiv, (%u, %s, %p), (unsigned int)pipeline, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramPipelineiv_ptr(pipeline, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderPrecisionFormat_debug(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderPrecisionFormat, (%s, %s, %p, %p), enum_to_string_GL(shadertype), enum_to_string_GL(precisiontype), (void*)range, (void*)precision)
    glatter_glGetShaderPrecisionFormat_ptr(shadertype, precisiontype, range, precision);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribLdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLdv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLdv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramPipeline, (%u), (unsigned int)pipeline)
    GLboolean rval = glatter_glIsProgramPipeline_ptr(pipeline);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramBinary_debug(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBinary, (%u, %s, %p, %d), (unsigned int)program, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glProgramBinary_ptr(program, binaryFormat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameteri_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteri, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteri_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1d_debug(GLuint program, GLint location, GLdouble v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1d, (%u, %d, %f), (unsigned int)program, (int)location, (double)v0)
    glatter_glProgramUniform1d_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1f_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1f, (%u, %d, %f), (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1f_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i, (%u, %d, %d), (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1i_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1ui_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2d, (%u, %d, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1)
    glatter_glProgramUniform2d_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2f, (%u, %d, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2f_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i, (%u, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2i_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui, (%u, %d, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2ui_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3d, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2)
    glatter_glProgramUniform3d_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3f, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3f_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i, (%u, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3i_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui, (%u, %d, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3ui_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4d, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2, (double)v3)
    glatter_glProgramUniform4d_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4f, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4f_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i, (%u, %d, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4i_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui, (%u, %d, %u, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4ui_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glReleaseShaderCompiler_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReleaseShaderCompiler, ())
    glatter_glReleaseShaderCompiler_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glScissorArrayv_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexed_debug(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexed, (%u, %d, %d, %d, %d), (unsigned int)index, (int)left, (int)bottom, (int)width, (int)height)
    glatter_glScissorIndexed_ptr(index, left, bottom, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glScissorIndexedv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderBinary_debug(GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderBinary, (%d, %p, %s, %p, %d), (int)count, (void*)shaders, enum_to_string_GL(binaryformat), (void*)binary, (int)length)
    glatter_glShaderBinary_ptr(count, shaders, binaryformat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgramStages_debug(GLuint pipeline, GLbitfield stages, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramStages, (%u, %u, %u), (unsigned int)pipeline, (unsigned int)stages, (unsigned int)program)
    glatter_glUseProgramStages_ptr(pipeline, stages, program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glValidateProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1d, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttribL1d_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2d, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttribL2d_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3d, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttribL3d_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4d, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttribL4d_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLPointer, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribLPointer_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportArrayv_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glViewportArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedf_debug(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedf, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)w, (float)h)
    glatter_glViewportIndexedf_ptr(index, x, y, w, h);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glViewportIndexedfv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_1
#ifdef GL_VERSION_4_2
void glatter_glBindImageTexture_debug(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTexture, (%u, %u, %d, %u, %d, %s, %s), (unsigned int)unit, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), enum_to_string_GL(format))
    glatter_glBindImageTexture_ptr(unit, texture, level, layered, layer, access, format);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysInstancedBaseInstance_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedBaseInstance, (%s, %d, %d, %d, %u), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawArraysInstancedBaseInstance_ptr(mode, first, count, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseInstance, (%s, %d, %s, %p, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseInstance_ptr(mode, count, type, indices, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertexBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexBaseInstance, (%s, %d, %s, %p, %d, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseVertexBaseInstance_ptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackInstanced_debug(GLenum mode, GLuint id, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackInstanced, (%s, %u, %d), enum_to_string_GL(mode), (unsigned int)id, (int)instancecount)
    glatter_glDrawTransformFeedbackInstanced_ptr(mode, id, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackStreamInstanced_debug(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStreamInstanced, (%s, %u, %u, %d), enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream, (int)instancecount)
    glatter_glDrawTransformFeedbackStreamInstanced_ptr(mode, id, stream, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAtomicCounterBufferiv_debug(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAtomicCounterBufferiv, (%u, %u, %s, %p), (unsigned int)program, (unsigned int)bufferIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveAtomicCounterBufferiv_ptr(program, bufferIndex, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInternalformativ_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformativ, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformativ_ptr(target, internalformat, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMemoryBarrier_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrier, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrier_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage1D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage1D, (%s, %d, %s, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTexStorage1D_ptr(target, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2D, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2D_ptr(target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3D, (%s, %d, %s, %d, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3D_ptr(target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_2
#ifdef GL_VERSION_4_3
void glatter_glBindVertexBuffer_debug(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffer, (%u, %u, %td, %d), (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glBindVertexBuffer_ptr(bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferData_debug(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferData, (%s, %s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferData_ptr(target, internalformat, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferSubData_debug(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferSubData, (%s, %s, %td, %td, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (ptrdiff_t)offset, (ptrdiff_t)size, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferSubData_ptr(target, internalformat, offset, size, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyImageSubData_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubData, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubData_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageCallback_debug(GLDEBUGPROC callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallback, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallback_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControl_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControl, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControl_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsert_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsert, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsert_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchCompute_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchCompute, (%u, %u, %u), (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z)
    glatter_glDispatchCompute_ptr(num_groups_x, num_groups_y, num_groups_z);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchComputeIndirect_debug(GLintptr indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeIndirect, (%td), (ptrdiff_t)indirect)
    glatter_glDispatchComputeIndirect_ptr(indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glFramebufferParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLog_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLog, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLog_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFramebufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInternalformati64v_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformati64v, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformati64v_ptr(target, internalformat, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectLabel_debug(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabel, (%s, %u, %d, %p, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabel_ptr(identifier, name, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectPtrLabel_debug(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectPtrLabel, (%p, %d, %p, %p), (void*)ptr, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectPtrLabel_ptr(ptr, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramInterfaceiv_debug(GLuint program, GLenum programInterface, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInterfaceiv, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramInterfaceiv_ptr(program, programInterface, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetProgramResourceIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLuint rval = glatter_glGetProgramResourceIndex_ptr(program, programInterface, name);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocation_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocation, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocation_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocationIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocationIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocationIndex_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetProgramResourceName_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetProgramResourceName_ptr(program, programInterface, index, bufSize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourceiv_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceiv, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourceiv_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateBufferData_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferData, (%u), (unsigned int)buffer)
    glatter_glInvalidateBufferData_ptr(buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferSubData, (%u, %td, %td), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glInvalidateBufferSubData_ptr(buffer, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateFramebuffer, (%s, %d, %p), enum_to_string_GL(target), (int)numAttachments, (void*)attachments)
    glatter_glInvalidateFramebuffer_ptr(target, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateSubFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateSubFramebuffer, (%s, %d, %p, %d, %d, %d, %d), enum_to_string_GL(target), (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateSubFramebuffer_ptr(target, numAttachments, attachments, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateTexImage_debug(GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexImage, (%u, %d), (unsigned int)texture, (int)level)
    glatter_glInvalidateTexImage_ptr(texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexSubImage, (%u, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth)
    glatter_glInvalidateTexSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawArraysIndirect_debug(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirect, (%s, %p, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawArraysIndirect_ptr(mode, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirect, (%s, %s, %p, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawElementsIndirect_ptr(mode, type, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectLabel_debug(GLenum identifier, GLuint name, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectLabel, (%s, %u, %d, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)length, (void*)label)
    glatter_glObjectLabel_ptr(identifier, name, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectPtrLabel_debug(const void *ptr, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPtrLabel, (%p, %d, %p), (void*)ptr, (int)length, (void*)label)
    glatter_glObjectPtrLabel_ptr(ptr, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glPopDebugGroup_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopDebugGroup, ())
    glatter_glPopDebugGroup_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushDebugGroup_debug(GLenum source, GLuint id, GLsizei length, const GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushDebugGroup, (%s, %u, %d, %p), enum_to_string_GL(source), (unsigned int)id, (int)length, (void*)message)
    glatter_glPushDebugGroup_ptr(source, id, length, message);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderStorageBlockBinding_debug(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderStorageBlockBinding, (%u, %u, %u), (unsigned int)program, (unsigned int)storageBlockIndex, (unsigned int)storageBlockBinding)
    glatter_glShaderStorageBlockBinding_ptr(program, storageBlockIndex, storageBlockBinding);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBufferRange_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRange, (%s, %s, %u, %td, %td), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTexBufferRange_ptr(target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DMultisample, (%s, %d, %s, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DMultisample, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureView_debug(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureView, (%u, %s, %u, %s, %u, %u, %u, %u), (unsigned int)texture, enum_to_string_GL(target), (unsigned int)origtexture, enum_to_string_GL(internalformat), (unsigned int)minlevel, (unsigned int)numlevels, (unsigned int)minlayer, (unsigned int)numlayers)
    glatter_glTextureView_ptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribBinding_debug(GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribBinding, (%u, %u), (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexAttribBinding_ptr(attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribFormat_debug(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormat, (%u, %d, %s, %u, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexAttribFormat_ptr(attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormat, (%u, %d, %s, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribIFormat_ptr(attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLFormat, (%u, %d, %s, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribLFormat_ptr(attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexBindingDivisor_debug(GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBindingDivisor, (%u, %u), (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexBindingDivisor_ptr(bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_3
#ifdef GL_VERSION_4_4
void glatter_glBindBuffersBase_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersBase, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers)
    glatter_glBindBuffersBase_ptr(target, first, count, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBuffersRange_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersRange, (%s, %u, %d, %p, %p, %p), enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)sizes)
    glatter_glBindBuffersRange_ptr(target, first, count, buffers, offsets, sizes);
    glatter_check_error_GL(file, line);
}
void glatter_glBindImageTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTextures, (%u, %d, %p), (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindImageTextures_ptr(first, count, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glBindSamplers_debug(GLuint first, GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSamplers, (%u, %d, %p), (unsigned int)first, (int)count, (void*)samplers)
    glatter_glBindSamplers_ptr(first, count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextures, (%u, %d, %p), (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindTextures_ptr(first, count, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexBuffers_debug(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffers, (%u, %d, %p, %p, %p), (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glBindVertexBuffers_ptr(first, count, buffers, offsets, strides);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferStorage_debug(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorage, (%s, %td, %p, %u), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glBufferStorage_ptr(target, size, data, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glClearTexImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexImage, (%u, %d, %s, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexImage_ptr(texture, level, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_4
#ifdef GL_VERSION_4_5
void glatter_glBindTextureUnit_debug(GLuint unit, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureUnit, (%u, %u), (unsigned int)unit, (unsigned int)texture)
    glatter_glBindTextureUnit_ptr(unit, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glBlitNamedFramebuffer_debug(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitNamedFramebuffer, (%u, %u, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (unsigned int)readFramebuffer, (unsigned int)drawFramebuffer, (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitNamedFramebuffer_ptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckNamedFramebufferStatus_debug(GLuint framebuffer, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckNamedFramebufferStatus, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(target))
    GLenum rval = glatter_glCheckNamedFramebufferStatus_ptr(framebuffer, target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClearNamedBufferData_debug(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferData, (%u, %s, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferData_ptr(buffer, internalformat, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedBufferSubData_debug(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferSubData, (%u, %s, %td, %td, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), (ptrdiff_t)offset, (ptrdiff_t)size, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferSubData_ptr(buffer, internalformat, offset, size, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferfi_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfi, (%u, %s, %d, %f, %d), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearNamedFramebufferfi_ptr(framebuffer, buffer, drawbuffer, depth, stencil);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferfv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferfv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferiv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferiv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferuiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferuiv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferuiv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClipControl_debug(GLenum origin, GLenum depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipControl, (%s, %s), enum_to_string_GL(origin), enum_to_string_GL(depth))
    glatter_glClipControl_ptr(origin, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage1D, (%u, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage1D_ptr(texture, level, xoffset, width, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage2D_ptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyNamedBufferSubData_debug(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyNamedBufferSubData, (%u, %u, %td, %td, %td), (unsigned int)readBuffer, (unsigned int)writeBuffer, (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyNamedBufferSubData_ptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage1D, (%u, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTextureSubImage1D_ptr(texture, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage2D_ptr(texture, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glCreateBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glCreateFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glCreateProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateQueries_debug(GLenum target, GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateQueries, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)ids)
    glatter_glCreateQueries_ptr(target, n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glCreateRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateSamplers_debug(GLsizei n, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSamplers, (%d, %p), (int)n, (void*)samplers)
    glatter_glCreateSamplers_ptr(n, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateTextures_debug(GLenum target, GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTextures, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)textures)
    glatter_glCreateTextures_ptr(target, n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glCreateTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glCreateVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayAttrib, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glDisableVertexArrayAttrib_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayAttrib, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glEnableVertexArrayAttrib_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedNamedBufferRange, (%u, %td, %td), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedNamedBufferRange_ptr(buffer, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateTextureMipmap_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateTextureMipmap, (%u), (unsigned int)texture)
    glatter_glGenerateTextureMipmap_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTextureImage_debug(GLuint texture, GLint level, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureImage, (%u, %d, %d, %p), (unsigned int)texture, (int)level, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureImage_ptr(texture, level, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glGetGraphicsResetStatus_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatus, ())
    GLenum rval = glatter_glGetGraphicsResetStatus_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetNamedBufferParameteri64v_debug(GLuint buffer, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteri64v, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteri64v_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferParameteriv_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteriv, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteriv_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferPointerv_debug(GLuint buffer, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferPointerv, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferPointerv_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferSubData, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetNamedBufferSubData_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferAttachmentParameteriv_debug(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferAttachmentParameteriv, (%u, %s, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferAttachmentParameteriv_ptr(framebuffer, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferParameteriv_debug(GLuint framebuffer, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameteriv, (%u, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)param)
    glatter_glGetNamedFramebufferParameteriv_ptr(framebuffer, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedRenderbufferParameteriv_debug(GLuint renderbuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedRenderbufferParameteriv, (%u, %s, %p), (unsigned int)renderbuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedRenderbufferParameteriv_ptr(renderbuffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjecti64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjecti64v, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjecti64v_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectiv, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectiv_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectui64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectui64v, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectui64v_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectuiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectuiv, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectuiv_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureImage, (%u, %d, %s, %s, %d, %p), (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureImage_ptr(texture, level, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameterfv_debug(GLuint texture, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterfv, (%u, %d, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterfv_ptr(texture, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameteriv_debug(GLuint texture, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameteriv, (%u, %d, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameteriv_ptr(texture, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIiv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIuiv_debug(GLuint texture, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIuiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIuiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterfv_debug(GLuint texture, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterfv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterfv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameteriv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameteriv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameteriv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbacki64_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki64_v, (%u, %s, %u, %p), (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki64_v_ptr(xfb, pname, index, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbacki_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki_v, (%u, %s, %u, %p), (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki_v_ptr(xfb, pname, index, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackiv_debug(GLuint xfb, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackiv, (%u, %s, %p), (unsigned int)xfb, enum_to_string_GL(pname), (void*)param)
    glatter_glGetTransformFeedbackiv_ptr(xfb, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIndexed64iv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexed64iv, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexed64iv_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIndexediv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexediv, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexediv_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayiv_debug(GLuint vaobj, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayiv, (%u, %s, %p), (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayiv_ptr(vaobj, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnCompressedTexImage_debug(GLenum target, GLint lod, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImage, (%s, %d, %d, %p), enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)pixels)
    glatter_glGetnCompressedTexImage_ptr(target, lod, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnTexImage_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImage, (%s, %d, %s, %s, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetnTexImage_ptr(target, level, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformdv_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformfv_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformiv_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuiv_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateNamedFramebufferData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferData, (%u, %d, %p), (unsigned int)framebuffer, (int)numAttachments, (void*)attachments)
    glatter_glInvalidateNamedFramebufferData_ptr(framebuffer, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateNamedFramebufferSubData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferSubData, (%u, %d, %p, %d, %d, %d, %d), (unsigned int)framebuffer, (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateNamedFramebufferSubData_ptr(framebuffer, numAttachments, attachments, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void * glatter_glMapNamedBuffer_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBuffer, (%u, %s), (unsigned int)buffer, enum_to_string_GL(access))
    void * rval = glatter_glMapNamedBuffer_ptr(buffer, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferRange, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapNamedBufferRange_ptr(buffer, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMemoryBarrierByRegion_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierByRegion, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrierByRegion_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferData_debug(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferData, (%u, %td, %p, %s), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glNamedBufferData_ptr(buffer, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferStorage_debug(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorage, (%u, %td, %p, %u), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glNamedBufferStorage_ptr(buffer, size, data, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferSubData, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glNamedBufferSubData_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferDrawBuffer_debug(GLuint framebuffer, GLenum buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffer, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(buf))
    glatter_glNamedFramebufferDrawBuffer_ptr(framebuffer, buf);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferDrawBuffers_debug(GLuint framebuffer, GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffers, (%u, %d, %p), (unsigned int)framebuffer, (int)n, (void*)bufs)
    glatter_glNamedFramebufferDrawBuffers_ptr(framebuffer, n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferParameteri_debug(GLuint framebuffer, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferParameteri, (%u, %s, %d), (unsigned int)framebuffer, enum_to_string_GL(pname), (int)param)
    glatter_glNamedFramebufferParameteri_ptr(framebuffer, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferReadBuffer_debug(GLuint framebuffer, GLenum src, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferReadBuffer, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(src))
    glatter_glNamedFramebufferReadBuffer_ptr(framebuffer, src);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferRenderbuffer_debug(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferRenderbuffer, (%u, %s, %s, %u), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glNamedFramebufferRenderbuffer_ptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTexture_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture, (%u, %s, %u, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture_ptr(framebuffer, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTextureLayer_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureLayer, (%u, %s, %u, %d, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glNamedFramebufferTextureLayer_ptr(framebuffer, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorage_debug(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorage, (%u, %s, %d, %d), (unsigned int)renderbuffer, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorage_ptr(renderbuffer, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorageMultisample_debug(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisample, (%u, %d, %s, %d, %d), (unsigned int)renderbuffer, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisample_ptr(renderbuffer, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixels, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixels_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBarrier_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBarrier, ())
    glatter_glTextureBarrier_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBuffer_debug(GLuint texture, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBuffer, (%u, %s, %u), (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTextureBuffer_ptr(texture, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBufferRange_debug(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferRange, (%u, %s, %u, %td, %td), (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTextureBufferRange_ptr(texture, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIiv_debug(GLuint texture, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIuiv_debug(GLuint texture, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIuiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIuiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterf_debug(GLuint texture, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterf, (%u, %s, %f), (unsigned int)texture, enum_to_string_GL(pname), (float)param)
    glatter_glTextureParameterf_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterfv_debug(GLuint texture, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameterfv_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameteri_debug(GLuint texture, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteri, (%u, %s, %d), (unsigned int)texture, enum_to_string_GL(pname), (int)param)
    glatter_glTextureParameteri_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameteriv_debug(GLuint texture, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteriv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameteriv_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage1D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1D, (%u, %d, %s, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1D_ptr(texture, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2D, (%u, %d, %s, %d, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2D_ptr(texture, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DMultisample, (%u, %d, %s, %d, %d, %u), (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage2DMultisample_ptr(texture, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3D, (%u, %d, %s, %d, %d, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3D_ptr(texture, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DMultisample, (%u, %d, %s, %d, %d, %d, %u), (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage3DMultisample_ptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage1D, (%u, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage1D_ptr(texture, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage2D_ptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackBufferBase_debug(GLuint xfb, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferBase, (%u, %u, %u), (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer)
    glatter_glTransformFeedbackBufferBase_ptr(xfb, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackBufferRange_debug(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferRange, (%u, %u, %u, %td, %td), (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTransformFeedbackBufferRange_ptr(xfb, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glUnmapNamedBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapNamedBuffer, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glUnmapNamedBuffer_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVertexArrayAttribBinding_debug(GLuint vaobj, GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribBinding, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexArrayAttribBinding_ptr(vaobj, attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribFormat, (%u, %u, %d, %s, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribFormat_ptr(vaobj, attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribIFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribIFormat, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribIFormat_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribLFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribLFormat, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribLFormat_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayBindingDivisor_debug(GLuint vaobj, GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayBindingDivisor, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexArrayBindingDivisor_ptr(vaobj, bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayElementBuffer_debug(GLuint vaobj, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayElementBuffer, (%u, %u), (unsigned int)vaobj, (unsigned int)buffer)
    glatter_glVertexArrayElementBuffer_ptr(vaobj, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexBuffer_debug(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffer, (%u, %u, %u, %td, %d), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glVertexArrayVertexBuffer_ptr(vaobj, bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexBuffers_debug(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffers, (%u, %u, %d, %p, %p, %p), (unsigned int)vaobj, (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glVertexArrayVertexBuffers_ptr(vaobj, first, count, buffers, offsets, strides);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_5
#endif // __glcorearb_h_

#ifdef __glext_h_
void glatter_glAttachObjectARB_debug(GLhandleARB containerObj, GLhandleARB obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachObjectARB, (%u, %u), (unsigned int)containerObj, (unsigned int)obj)
    glatter_glAttachObjectARB_ptr(containerObj, obj);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glClientWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    GLenum rval = glatter_glClientWaitSync_ptr(sync, flags, timeout);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glCompileShaderARB_debug(GLhandleARB shaderObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShaderARB, (%u), (unsigned int)shaderObj)
    glatter_glCompileShaderARB_ptr(shaderObj);
    glatter_check_error_GL(file, line);
}
GLhandleARB glatter_glCreateProgramObjectARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgramObjectARB, ())
    GLhandleARB rval = glatter_glCreateProgramObjectARB_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLhandleARB glatter_glCreateShaderObjectARB_debug(GLenum shaderType, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderObjectARB, (%s), enum_to_string_GL(shaderType))
    GLhandleARB rval = glatter_glCreateShaderObjectARB_ptr(shaderType);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteObjectARB_debug(GLhandleARB obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteObjectARB, (%u), (unsigned int)obj)
    glatter_glDeleteObjectARB_ptr(obj);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSync, (%p), (void*)sync)
    glatter_glDeleteSync_ptr(sync);
    glatter_check_error_GL(file, line);
}
void glatter_glDetachObjectARB_debug(GLhandleARB containerObj, GLhandleARB attachedObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachObjectARB, (%u, %u), (unsigned int)containerObj, (unsigned int)attachedObj)
    glatter_glDetachObjectARB_ptr(containerObj, attachedObj);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsBaseVertex, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawElementsBaseVertex_ptr(mode, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertex_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertex, (%s, %d, %s, %p, %d, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex)
    glatter_glDrawElementsInstancedBaseVertex_ptr(mode, count, type, indices, instancecount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementsBaseVertex_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsBaseVertex, (%s, %u, %u, %d, %s, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices, (int)basevertex)
    glatter_glDrawRangeElementsBaseVertex_ptr(mode, start, end, count, type, indices, basevertex);
    glatter_check_error_GL(file, line);
}
GLsync glatter_glFenceSync_debug(GLenum condition, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFenceSync, (%s, %u), enum_to_string_GL(condition), (unsigned int)flags)
    GLsync rval = glatter_glFenceSync_ptr(condition, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glFramebufferTexture_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformARB_debug(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformARB, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)programObj, (unsigned int)index, (int)maxLength, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniformARB_ptr(programObj, index, maxLength, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetAttachedObjectsARB_debug(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedObjectsARB, (%u, %d, %p, %p), (unsigned int)containerObj, (int)maxCount, (void*)count, (void*)obj)
    glatter_glGetAttachedObjectsARB_ptr(containerObj, maxCount, count, obj);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteri64v_debug(GLenum target, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteri64v, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteri64v_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLhandleARB glatter_glGetHandleARB_debug(GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHandleARB, (%s), enum_to_string_GL(pname))
    GLhandleARB rval = glatter_glGetHandleARB_ptr(pname);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetInfoLogARB_debug(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInfoLogARB, (%u, %d, %p, %p), (unsigned int)obj, (int)maxLength, (void*)length, (void*)infoLog)
    glatter_glGetInfoLogARB_ptr(obj, maxLength, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInteger64i_v_debug(GLenum target, GLuint index, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64i_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetInteger64i_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInteger64v_debug(GLenum pname, GLint64 *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInteger64v, (%s, %p), enum_to_string_GL(pname), (void*)data)
    glatter_glGetInteger64v_ptr(pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultisamplefv_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefv, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefv_ptr(pname, index, val);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectParameterfvARB_debug(GLhandleARB obj, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterfvARB, (%u, %s, %p), (unsigned int)obj, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterfvARB_ptr(obj, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectParameterivARB_debug(GLhandleARB obj, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterivARB, (%u, %s, %p), (unsigned int)obj, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterivARB_ptr(obj, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderSourceARB_debug(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSourceARB, (%u, %d, %p, %p), (unsigned int)obj, (int)maxLength, (void*)length, (void*)source)
    glatter_glGetShaderSourceARB_ptr(obj, maxLength, length, source);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSynciv_debug(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSynciv, (%p, %s, %d, %p, %p), (void*)sync, enum_to_string_GL(pname), (int)bufSize, (void*)length, (void*)values)
    glatter_glGetSynciv_ptr(sync, pname, bufSize, length, values);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetUniformLocationARB_debug(GLhandleARB programObj, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocationARB, (%u, %p), (unsigned int)programObj, (void*)name)
    GLint rval = glatter_glGetUniformLocationARB_ptr(programObj, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformfvARB_debug(GLhandleARB programObj, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfvARB, (%u, %d, %p), (unsigned int)programObj, (int)location, (void*)params)
    glatter_glGetUniformfvARB_ptr(programObj, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformivARB_debug(GLhandleARB programObj, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformivARB, (%u, %d, %p), (unsigned int)programObj, (int)location, (void*)params)
    glatter_glGetUniformivARB_ptr(programObj, location, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsSync_debug(GLsync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSync, (%p), (void*)sync)
    GLboolean rval = glatter_glIsSync_ptr(sync);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLinkProgramARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgramARB, (%u), (unsigned int)programObj)
    glatter_glLinkProgramARB_ptr(programObj);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsBaseVertex_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsBaseVertex, (%s, %p, %s, %p, %d, %p), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount, (void*)basevertex)
    glatter_glMultiDrawElementsBaseVertex_ptr(mode, count, type, indices, drawcount, basevertex);
    glatter_check_error_GL(file, line);
}
void glatter_glProvokingVertex_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProvokingVertex, (%s), enum_to_string_GL(mode))
    glatter_glProvokingVertex_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleMaski_debug(GLuint maskNumber, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaski, (%u, %u), (unsigned int)maskNumber, (unsigned int)mask)
    glatter_glSampleMaski_ptr(maskNumber, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderSourceARB_debug(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSourceARB, (%u, %d, %p, %p), (unsigned int)shaderObj, (int)count, (void*)string, (void*)length)
    glatter_glShaderSourceARB_ptr(shaderObj, count, string, length);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2DMultisample, (%s, %d, %s, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexImage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DMultisample, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexImage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1fARB_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fARB, (%d, %f), (int)location, (float)v0)
    glatter_glUniform1fARB_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fvARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1fvARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1iARB_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iARB, (%d, %d), (int)location, (int)v0)
    glatter_glUniform1iARB_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ivARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1ivARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2fARB_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fARB, (%d, %f, %f), (int)location, (float)v0, (float)v1)
    glatter_glUniform2fARB_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fvARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2fvARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2iARB_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iARB, (%d, %d, %d), (int)location, (int)v0, (int)v1)
    glatter_glUniform2iARB_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ivARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2ivARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3fARB_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fARB, (%d, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3fARB_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fvARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3fvARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3iARB_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iARB, (%d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3iARB_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ivARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3ivARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4fARB_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fARB, (%d, %f, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4fARB_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4fvARB_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fvARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4fvARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4iARB_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iARB, (%d, %d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4iARB_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ivARB_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ivARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4ivARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fvARB, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fvARB_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fvARB, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fvARB_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4fvARB_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fvARB, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fvARB_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgramObjectARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramObjectARB, (%u), (unsigned int)programObj)
    glatter_glUseProgramObjectARB_ptr(programObj);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgramARB_debug(GLhandleARB programObj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramARB, (%u), (unsigned int)programObj)
    glatter_glValidateProgramARB_ptr(programObj);
    glatter_check_error_GL(file, line);
}
void glatter_glWaitSync_debug(GLsync sync, GLbitfield flags, GLuint64 timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWaitSync, (%p, %u, %s), (void*)sync, (unsigned int)flags, GET_PRS(timeout))
    glatter_glWaitSync_ptr(sync, flags, timeout);
    glatter_check_error_GL(file, line);
}
#ifdef GL_3DFX_tbuffer
void glatter_glTbufferMask3DFX_debug(GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTbufferMask3DFX, (%u), (unsigned int)mask)
    glatter_glTbufferMask3DFX_ptr(mask);
    glatter_check_error_GL(file, line);
}
#endif // GL_3DFX_tbuffer
#ifdef GL_AMD_debug_output
void glatter_glDebugMessageCallbackAMD_debug(GLDEBUGPROCAMD callback, void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackAMD, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackAMD_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageEnableAMD_debug(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageEnableAMD, (%s, %s, %d, %p, %u), enum_to_string_GL(category), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageEnableAMD_ptr(category, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsertAMD_debug(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertAMD, (%s, %s, %u, %d, %p), enum_to_string_GL(category), enum_to_string_GL(severity), (unsigned int)id, (int)length, (void*)buf)
    glatter_glDebugMessageInsertAMD_ptr(category, severity, id, length, buf);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLogAMD_debug(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogAMD, (%u, %d, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufsize, (void*)categories, (void*)severities, (void*)ids, (void*)lengths, (void*)message)
    GLuint rval = glatter_glGetDebugMessageLogAMD_ptr(count, bufsize, categories, severities, ids, lengths, message);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_AMD_debug_output
#ifdef GL_AMD_draw_buffers_blend
void glatter_glBlendEquationIndexedAMD_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationIndexedAMD, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationIndexedAMD_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparateIndexedAMD_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateIndexedAMD, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateIndexedAMD_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncIndexedAMD_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncIndexedAMD, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFuncIndexedAMD_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparateIndexedAMD_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateIndexedAMD, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateIndexedAMD_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_draw_buffers_blend
#ifdef GL_AMD_framebuffer_sample_positions
void glatter_glFramebufferSamplePositionsfvAMD_debug(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSamplePositionsfvAMD, (%s, %u, %u, %p), enum_to_string_GL(target), (unsigned int)numsamples, (unsigned int)pixelindex, (void*)values)
    glatter_glFramebufferSamplePositionsfvAMD_ptr(target, numsamples, pixelindex, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFramebufferParameterfvAMD_debug(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameterfvAMD, (%s, %s, %u, %u, %d, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (unsigned int)numsamples, (unsigned int)pixelindex, (int)size, (void*)values)
    glatter_glGetFramebufferParameterfvAMD_ptr(target, pname, numsamples, pixelindex, size, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferParameterfvAMD_debug(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameterfvAMD, (%u, %s, %u, %u, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(pname), (unsigned int)numsamples, (unsigned int)pixelindex, (int)size, (void*)values)
    glatter_glGetNamedFramebufferParameterfvAMD_ptr(framebuffer, pname, numsamples, pixelindex, size, values);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferSamplePositionsfvAMD_debug(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSamplePositionsfvAMD, (%u, %u, %u, %p), (unsigned int)framebuffer, (unsigned int)numsamples, (unsigned int)pixelindex, (void*)values)
    glatter_glNamedFramebufferSamplePositionsfvAMD_ptr(framebuffer, numsamples, pixelindex, values);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_framebuffer_sample_positions
#ifdef GL_AMD_gpu_shader_int64
void glatter_glGetUniformi64vNV_debug(GLuint program, GLint location, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vNV, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vNV_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformui64vNV_debug(GLuint program, GLint location, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformui64vNV, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformui64vNV_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64NV_debug(GLuint program, GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64NV_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64NV, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64NV_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64NV, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64NV_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64NV_debug(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64vNV_debug(GLuint program, GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64NV_debug(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64NV, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64NV_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64NV_debug(GLint location, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1i64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64NV_debug(GLint location, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64NV, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1ui64NV_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64NV, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64NV_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64NV, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64NV_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64NV_debug(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64vNV_debug(GLint location, GLsizei count, const GLint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64NV_debug(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64NV, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64NV_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_gpu_shader_int64
#ifdef GL_AMD_interleaved_elements
void glatter_glVertexAttribParameteriAMD_debug(GLuint index, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribParameteriAMD, (%u, %s, %d), (unsigned int)index, enum_to_string_GL(pname), (int)param)
    glatter_glVertexAttribParameteriAMD_ptr(index, pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_interleaved_elements
#ifdef GL_AMD_multi_draw_indirect
void glatter_glMultiDrawArraysIndirectAMD_debug(GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectAMD, (%s, %p, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)primcount, (int)stride)
    glatter_glMultiDrawArraysIndirectAMD_ptr(mode, indirect, primcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectAMD_debug(GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectAMD, (%s, %s, %p, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)primcount, (int)stride)
    glatter_glMultiDrawElementsIndirectAMD_ptr(mode, type, indirect, primcount, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_multi_draw_indirect
#ifdef GL_AMD_name_gen_delete
void glatter_glDeleteNamesAMD_debug(GLenum identifier, GLuint num, const GLuint *names, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteNamesAMD, (%s, %u, %p), enum_to_string_GL(identifier), (unsigned int)num, (void*)names)
    glatter_glDeleteNamesAMD_ptr(identifier, num, names);
    glatter_check_error_GL(file, line);
}
void glatter_glGenNamesAMD_debug(GLenum identifier, GLuint num, GLuint *names, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenNamesAMD, (%s, %u, %p), enum_to_string_GL(identifier), (unsigned int)num, (void*)names)
    glatter_glGenNamesAMD_ptr(identifier, num, names);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsNameAMD_debug(GLenum identifier, GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNameAMD, (%s, %u), enum_to_string_GL(identifier), (unsigned int)name)
    GLboolean rval = glatter_glIsNameAMD_ptr(identifier, name);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_AMD_name_gen_delete
#ifdef GL_AMD_occlusion_query_event
void glatter_glQueryObjectParameteruiAMD_debug(GLenum target, GLuint id, GLenum pname, GLuint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryObjectParameteruiAMD, (%s, %u, %s, %u), enum_to_string_GL(target), (unsigned int)id, enum_to_string_GL(pname), (unsigned int)param)
    glatter_glQueryObjectParameteruiAMD_ptr(target, id, pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_occlusion_query_event
#ifdef GL_AMD_performance_monitor
void glatter_glBeginPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glBeginPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glDeletePerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfMonitorAMD_debug(GLuint monitor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfMonitorAMD, (%u), (unsigned int)monitor)
    glatter_glEndPerfMonitorAMD_ptr(monitor);
    glatter_check_error_GL(file, line);
}
void glatter_glGenPerfMonitorsAMD_debug(GLsizei n, GLuint *monitors, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPerfMonitorsAMD, (%d, %p), (int)n, (void*)monitors)
    glatter_glGenPerfMonitorsAMD_ptr(n, monitors);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterDataAMD_debug(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterDataAMD, (%u, %s, %d, %p, %p), (unsigned int)monitor, enum_to_string_GL(pname), (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfMonitorCounterDataAMD_ptr(monitor, pname, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterInfoAMD_debug(GLuint group, GLuint counter, GLenum pname, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterInfoAMD, (%u, %u, %s, %p), (unsigned int)group, (unsigned int)counter, enum_to_string_GL(pname), (void*)data)
    glatter_glGetPerfMonitorCounterInfoAMD_ptr(group, counter, pname, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCounterStringAMD_debug(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCounterStringAMD, (%u, %u, %d, %p, %p), (unsigned int)group, (unsigned int)counter, (int)bufSize, (void*)length, (void*)counterString)
    glatter_glGetPerfMonitorCounterStringAMD_ptr(group, counter, bufSize, length, counterString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorCountersAMD_debug(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorCountersAMD, (%u, %p, %p, %d, %p), (unsigned int)group, (void*)numCounters, (void*)maxActiveCounters, (int)counterSize, (void*)counters)
    glatter_glGetPerfMonitorCountersAMD_ptr(group, numCounters, maxActiveCounters, counterSize, counters);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupStringAMD_debug(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupStringAMD, (%u, %d, %p, %p), (unsigned int)group, (int)bufSize, (void*)length, (void*)groupString)
    glatter_glGetPerfMonitorGroupStringAMD_ptr(group, bufSize, length, groupString);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfMonitorGroupsAMD_debug(GLint *numGroups, GLsizei groupsSize, GLuint *groups, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfMonitorGroupsAMD, (%p, %d, %p), (void*)numGroups, (int)groupsSize, (void*)groups)
    glatter_glGetPerfMonitorGroupsAMD_ptr(numGroups, groupsSize, groups);
    glatter_check_error_GL(file, line);
}
void glatter_glSelectPerfMonitorCountersAMD_debug(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSelectPerfMonitorCountersAMD, (%u, %u, %u, %d, %p), (unsigned int)monitor, (unsigned char)enable, (unsigned int)group, (int)numCounters, (void*)counterList)
    glatter_glSelectPerfMonitorCountersAMD_ptr(monitor, enable, group, numCounters, counterList);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_performance_monitor
#ifdef GL_AMD_sample_positions
void glatter_glSetMultisamplefvAMD_debug(GLenum pname, GLuint index, const GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetMultisamplefvAMD, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glSetMultisamplefvAMD_ptr(pname, index, val);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_sample_positions
#ifdef GL_AMD_sparse_texture
void glatter_glTexStorageSparseAMD_debug(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorageSparseAMD, (%s, %s, %d, %d, %d, %d, %u), enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (int)layers, (unsigned int)flags)
    glatter_glTexStorageSparseAMD_ptr(target, internalFormat, width, height, depth, layers, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorageSparseAMD_debug(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorageSparseAMD, (%u, %s, %s, %d, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, (int)height, (int)depth, (int)layers, (unsigned int)flags)
    glatter_glTextureStorageSparseAMD_ptr(texture, target, internalFormat, width, height, depth, layers, flags);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_sparse_texture
#ifdef GL_AMD_stencil_operation_extended
void glatter_glStencilOpValueAMD_debug(GLenum face, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpValueAMD, (%s, %u), enum_to_string_GL(face), (unsigned int)value)
    glatter_glStencilOpValueAMD_ptr(face, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_stencil_operation_extended
#ifdef GL_AMD_vertex_shader_tessellator
void glatter_glTessellationFactorAMD_debug(GLfloat factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTessellationFactorAMD, (%f), (float)factor)
    glatter_glTessellationFactorAMD_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glTessellationModeAMD_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTessellationModeAMD, (%s), enum_to_string_GL(mode))
    glatter_glTessellationModeAMD_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_AMD_vertex_shader_tessellator
#ifdef GL_APPLE_element_array
void glatter_glDrawElementArrayAPPLE_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementArrayAPPLE, (%s, %d, %d), enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawElementArrayAPPLE_ptr(mode, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementArrayAPPLE_debug(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementArrayAPPLE, (%s, %u, %u, %d, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)first, (int)count)
    glatter_glDrawRangeElementArrayAPPLE_ptr(mode, start, end, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glElementPointerAPPLE_debug(GLenum type, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glElementPointerAPPLE, (%s, %p), enum_to_string_GL(type), (void*)pointer)
    glatter_glElementPointerAPPLE_ptr(type, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementArrayAPPLE_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementArrayAPPLE, (%s, %p, %p, %d), enum_to_string_GL(mode), (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawElementArrayAPPLE_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawRangeElementArrayAPPLE_debug(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawRangeElementArrayAPPLE, (%s, %u, %u, %p, %p, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawRangeElementArrayAPPLE_ptr(mode, start, end, first, count, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_element_array
#ifdef GL_APPLE_fence
void glatter_glDeleteFencesAPPLE_debug(GLsizei n, const GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFencesAPPLE, (%d, %p), (int)n, (void*)fences)
    glatter_glDeleteFencesAPPLE_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
void glatter_glFinishFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishFenceAPPLE, (%u), (unsigned int)fence)
    glatter_glFinishFenceAPPLE_ptr(fence);
    glatter_check_error_GL(file, line);
}
void glatter_glFinishObjectAPPLE_debug(GLenum object, GLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishObjectAPPLE, (%s, %d), enum_to_string_GL(object), (int)name)
    glatter_glFinishObjectAPPLE_ptr(object, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFencesAPPLE_debug(GLsizei n, GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFencesAPPLE, (%d, %p), (int)n, (void*)fences)
    glatter_glGenFencesAPPLE_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFenceAPPLE, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glIsFenceAPPLE_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glSetFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFenceAPPLE, (%u), (unsigned int)fence)
    glatter_glSetFenceAPPLE_ptr(fence);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glTestFenceAPPLE_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestFenceAPPLE, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glTestFenceAPPLE_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glTestObjectAPPLE_debug(GLenum object, GLuint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestObjectAPPLE, (%s, %u), enum_to_string_GL(object), (unsigned int)name)
    GLboolean rval = glatter_glTestObjectAPPLE_ptr(object, name);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_APPLE_fence
#ifdef GL_APPLE_flush_buffer_range
void glatter_glBufferParameteriAPPLE_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferParameteriAPPLE, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glBufferParameteriAPPLE_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedBufferRangeAPPLE_debug(GLenum target, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRangeAPPLE, (%s, %td, %td), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glFlushMappedBufferRangeAPPLE_ptr(target, offset, size);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_flush_buffer_range
#ifdef GL_APPLE_object_purgeable
void glatter_glGetObjectParameterivAPPLE_debug(GLenum objectType, GLuint name, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectParameterivAPPLE, (%s, %u, %s, %p), enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectParameterivAPPLE_ptr(objectType, name, pname, params);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glObjectPurgeableAPPLE_debug(GLenum objectType, GLuint name, GLenum option, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPurgeableAPPLE, (%s, %u, %s), enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(option))
    GLenum rval = glatter_glObjectPurgeableAPPLE_ptr(objectType, name, option);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLenum glatter_glObjectUnpurgeableAPPLE_debug(GLenum objectType, GLuint name, GLenum option, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectUnpurgeableAPPLE, (%s, %u, %s), enum_to_string_GL(objectType), (unsigned int)name, enum_to_string_GL(option))
    GLenum rval = glatter_glObjectUnpurgeableAPPLE_ptr(objectType, name, option);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_APPLE_object_purgeable
#ifdef GL_APPLE_texture_range
void glatter_glGetTexParameterPointervAPPLE_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterPointervAPPLE, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterPointervAPPLE_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureRangeAPPLE_debug(GLenum target, GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureRangeAPPLE, (%s, %d, %p), enum_to_string_GL(target), (int)length, (void*)pointer)
    glatter_glTextureRangeAPPLE_ptr(target, length, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_texture_range
#ifdef GL_APPLE_vertex_array_object
void glatter_glBindVertexArrayAPPLE_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArrayAPPLE, (%u), (unsigned int)array)
    glatter_glBindVertexArrayAPPLE_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexArraysAPPLE_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArraysAPPLE, (%d, %p), (int)n, (void*)arrays)
    glatter_glDeleteVertexArraysAPPLE_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glGenVertexArraysAPPLE_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArraysAPPLE, (%d, %p), (int)n, (void*)arrays)
    glatter_glGenVertexArraysAPPLE_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsVertexArrayAPPLE_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArrayAPPLE, (%u), (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArrayAPPLE_ptr(array);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_APPLE_vertex_array_object
#ifdef GL_APPLE_vertex_array_range
void glatter_glFlushVertexArrayRangeAPPLE_debug(GLsizei length, void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushVertexArrayRangeAPPLE, (%d, %p), (int)length, (void*)pointer)
    glatter_glFlushVertexArrayRangeAPPLE_ptr(length, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayParameteriAPPLE_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayParameteriAPPLE, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glVertexArrayParameteriAPPLE_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayRangeAPPLE_debug(GLsizei length, void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayRangeAPPLE, (%d, %p), (int)length, (void*)pointer)
    glatter_glVertexArrayRangeAPPLE_ptr(length, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_vertex_array_range
#ifdef GL_APPLE_vertex_program_evaluators
void glatter_glDisableVertexAttribAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribAPPLE, (%u, %s), (unsigned int)index, enum_to_string_GL(pname))
    glatter_glDisableVertexAttribAPPLE_ptr(index, pname);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexAttribAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribAPPLE, (%u, %s), (unsigned int)index, enum_to_string_GL(pname))
    glatter_glEnableVertexAttribAPPLE_ptr(index, pname);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsVertexAttribEnabledAPPLE_debug(GLuint index, GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexAttribEnabledAPPLE, (%u, %s), (unsigned int)index, enum_to_string_GL(pname))
    GLboolean rval = glatter_glIsVertexAttribEnabledAPPLE_ptr(index, pname);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMapVertexAttrib1dAPPLE_debug(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib1dAPPLE, (%u, %u, %f, %f, %d, %d, %p), (unsigned int)index, (unsigned int)size, (double)u1, (double)u2, (int)stride, (int)order, (void*)points)
    glatter_glMapVertexAttrib1dAPPLE_ptr(index, size, u1, u2, stride, order, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapVertexAttrib1fAPPLE_debug(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib1fAPPLE, (%u, %u, %f, %f, %d, %d, %p), (unsigned int)index, (unsigned int)size, (float)u1, (float)u2, (int)stride, (int)order, (void*)points)
    glatter_glMapVertexAttrib1fAPPLE_ptr(index, size, u1, u2, stride, order, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapVertexAttrib2dAPPLE_debug(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib2dAPPLE, (%u, %u, %f, %f, %d, %d, %f, %f, %d, %d, %p), (unsigned int)index, (unsigned int)size, (double)u1, (double)u2, (int)ustride, (int)uorder, (double)v1, (double)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMapVertexAttrib2dAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapVertexAttrib2fAPPLE_debug(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapVertexAttrib2fAPPLE, (%u, %u, %f, %f, %d, %d, %f, %f, %d, %d, %p), (unsigned int)index, (unsigned int)size, (float)u1, (float)u2, (int)ustride, (int)uorder, (float)v1, (float)v2, (int)vstride, (int)vorder, (void*)points)
    glatter_glMapVertexAttrib2fAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    glatter_check_error_GL(file, line);
}
#endif // GL_APPLE_vertex_program_evaluators
#ifdef GL_ARB_ES3_2_compatibility
void glatter_glPrimitiveBoundingBoxARB_debug(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveBoundingBoxARB, (%f, %f, %f, %f, %f, %f, %f, %f), (float)minX, (float)minY, (float)minZ, (float)minW, (float)maxX, (float)maxY, (float)maxZ, (float)maxW)
    glatter_glPrimitiveBoundingBoxARB_ptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_ES3_2_compatibility
#ifdef GL_ARB_bindless_texture
GLuint64 glatter_glGetImageHandleARB_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleARB, (%u, %d, %u, %d, %s), (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleARB_ptr(texture, level, layered, layer, format);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureHandleARB_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleARB, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleARB_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleARB_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleARB, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleARB_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetVertexAttribLui64vARB_debug(GLuint index, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLui64vARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLui64vARB_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsImageHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentARB, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentARB_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentARB, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentARB_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeImageHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeImageHandleResidentARB_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentARB, (%s, %s), GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentARB_ptr(handle, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleNonResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleResidentARB_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentARB, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleResidentARB_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64ARB_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64ARB, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64ARB_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vARB_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64ARB_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64ARB, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64ARB_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64ARB_debug(GLuint index, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64ARB, (%u, %s), (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1ui64ARB_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64vARB_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64vARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1ui64vARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_bindless_texture
#ifdef GL_ARB_cl_event
GLsync glatter_glCreateSyncFromCLeventARB_debug(struct _cl_context *context, struct _cl_event *event, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSyncFromCLeventARB, (%p, %p, %u), (void*)context, (void*)event, (unsigned int)flags)
    GLsync rval = glatter_glCreateSyncFromCLeventARB_ptr(context, event, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_cl_event
#ifdef GL_ARB_color_buffer_float
void glatter_glClampColorARB_debug(GLenum target, GLenum clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClampColorARB, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(clamp))
    glatter_glClampColorARB_ptr(target, clamp);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_color_buffer_float
#ifdef GL_ARB_compute_variable_group_size
void glatter_glDispatchComputeGroupSizeARB_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeGroupSizeARB, (%u, %u, %u, %u, %u, %u), (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z, (unsigned int)group_size_x, (unsigned int)group_size_y, (unsigned int)group_size_z)
    glatter_glDispatchComputeGroupSizeARB_ptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_compute_variable_group_size
#ifdef GL_ARB_debug_output
void glatter_glDebugMessageCallbackARB_debug(GLDEBUGPROCARB callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallbackARB, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallbackARB_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControlARB_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControlARB, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControlARB_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsertARB_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsertARB, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsertARB_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLogARB_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLogARB, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLogARB_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_debug_output
#ifdef GL_ARB_draw_buffers
void glatter_glDrawBuffersARB_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersARB, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffersARB_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_draw_buffers
#ifdef GL_ARB_draw_buffers_blend
void glatter_glBlendEquationSeparateiARB_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateiARB, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateiARB_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationiARB_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationiARB, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationiARB_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparateiARB_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateiARB, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparateiARB_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunciARB_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunciARB, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunciARB_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_draw_buffers_blend
#ifdef GL_ARB_draw_instanced
void glatter_glDrawArraysInstancedARB_debug(GLenum mode, GLint first, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedARB, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedARB_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedARB_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedARB, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedARB_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_draw_instanced
#ifdef GL_ARB_fragment_program
void glatter_glBindProgramARB_debug(GLenum target, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramARB, (%s, %u), enum_to_string_GL(target), (unsigned int)program)
    glatter_glBindProgramARB_ptr(target, program);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteProgramsARB_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramsARB, (%d, %p), (int)n, (void*)programs)
    glatter_glDeleteProgramsARB_ptr(n, programs);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramsARB_debug(GLsizei n, GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramsARB, (%d, %p), (int)n, (void*)programs)
    glatter_glGenProgramsARB_ptr(n, programs);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramEnvParameterdvARB_debug(GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterdvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterdvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramEnvParameterfvARB_debug(GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterfvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterfvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramLocalParameterdvARB_debug(GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterdvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterdvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramLocalParameterfvARB_debug(GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterfvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterfvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramStringARB_debug(GLenum target, GLenum pname, void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStringARB, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)string)
    glatter_glGetProgramStringARB_ptr(target, pname, string);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramivARB, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramivARB_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramARB_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramARB, (%u), (unsigned int)program)
    GLboolean rval = glatter_glIsProgramARB_ptr(program);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramEnvParameter4dARB_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4dARB, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramEnvParameter4dARB_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameter4dvARB_debug(GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4dvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameter4dvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameter4fARB_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4fARB, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramEnvParameter4fARB_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameter4fvARB_debug(GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameter4fvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameter4fvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameter4dARB_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4dARB, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramLocalParameter4dARB_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameter4dvARB_debug(GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4dvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameter4dvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameter4fARB_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4fARB, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramLocalParameter4fARB_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameter4fvARB_debug(GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameter4fvARB, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameter4fvARB_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramStringARB_debug(GLenum target, GLenum format, GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramStringARB, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(format), (int)len, (void*)string)
    glatter_glProgramStringARB_ptr(target, format, len, string);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_fragment_program
#ifdef GL_ARB_geometry_shader4
void glatter_glFramebufferTextureARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureARB, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureARB_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureFaceARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureFaceARB, (%s, %s, %u, %d, %s), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glFramebufferTextureFaceARB_ptr(target, attachment, texture, level, face);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureLayerARB_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayerARB, (%s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayerARB_ptr(target, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameteriARB_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteriARB, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteriARB_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_geometry_shader4
#ifdef GL_ARB_gpu_shader_int64
void glatter_glGetUniformi64vARB_debug(GLuint program, GLint location, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformi64vARB, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformi64vARB_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformui64vARB_debug(GLuint program, GLint location, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformui64vARB, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformui64vARB_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformi64vARB_debug(GLuint program, GLint location, GLsizei bufSize, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformi64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformi64vARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformui64vARB_debug(GLuint program, GLint location, GLsizei bufSize, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformui64vARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64ARB_debug(GLuint program, GLint location, GLint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64ARB, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1i64ARB_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1i64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64ARB_debug(GLuint program, GLint location, GLuint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64ARB, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(x))
    glatter_glProgramUniform1ui64ARB_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ui64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64ARB, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2i64ARB_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2i64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64ARB, (%u, %d, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glProgramUniform2ui64ARB_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ui64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64ARB, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3i64ARB_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3i64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64ARB, (%u, %d, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glProgramUniform3ui64ARB_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ui64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64ARB_debug(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64ARB, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4i64ARB_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i64vARB_debug(GLuint program, GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4i64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64ARB_debug(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64ARB, (%u, %d, %s, %s, %s, %s), (unsigned int)program, (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glProgramUniform4ui64ARB_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui64vARB_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui64vARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ui64vARB_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64ARB_debug(GLint location, GLint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64ARB, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1i64ARB_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1i64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64ARB_debug(GLint location, GLuint64 x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64ARB, (%d, %s), (int)location, GET_PRS(x))
    glatter_glUniform1ui64ARB_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1ui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64ARB_debug(GLint location, GLint64 x, GLint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64ARB, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2i64ARB_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2i64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64ARB, (%d, %s, %s), (int)location, GET_PRS(x), GET_PRS(y))
    glatter_glUniform2ui64ARB_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2ui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64ARB_debug(GLint location, GLint64 x, GLint64 y, GLint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64ARB, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3i64ARB_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3i64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64ARB, (%d, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glUniform3ui64ARB_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3ui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64ARB_debug(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64ARB, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4i64ARB_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i64vARB_debug(GLint location, GLsizei count, const GLint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4i64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64ARB_debug(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64ARB, (%d, %s, %s, %s, %s), (int)location, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glUniform4ui64ARB_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui64vARB_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui64vARB, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4ui64vARB_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_gpu_shader_int64
#ifdef GL_ARB_imaging
void glatter_glColorSubTable_debug(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorSubTable, (%s, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)start, (int)count, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glColorSubTable_ptr(target, start, count, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glColorTable_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTable, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTable_ptr(target, internalformat, width, format, type, table);
    glatter_check_error_GL(file, line);
}
void glatter_glColorTableParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glColorTableParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionFilter1D_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter1D, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter1D_ptr(target, internalformat, width, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionFilter2D_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter2D, (%s, %s, %d, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter2D_ptr(target, internalformat, width, height, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterf_debug(GLenum target, GLenum pname, GLfloat params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterf, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)params)
    glatter_glConvolutionParameterf_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterfv_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameteri_debug(GLenum target, GLenum pname, GLint params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)params)
    glatter_glConvolutionParameteri_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameteriv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyColorSubTable_debug(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorSubTable, (%s, %d, %d, %d, %d), enum_to_string_GL(target), (int)start, (int)x, (int)y, (int)width)
    glatter_glCopyColorSubTable_ptr(target, start, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyColorTable_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorTable, (%s, %s, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyColorTable_ptr(target, internalformat, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyConvolutionFilter1D_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter1D, (%s, %s, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyConvolutionFilter1D_ptr(target, internalformat, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyConvolutionFilter2D_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter2D, (%s, %s, %d, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyConvolutionFilter2D_ptr(target, internalformat, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTable_debug(GLenum target, GLenum format, GLenum type, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTable, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glGetColorTable_ptr(target, format, type, table);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionFilter_debug(GLenum target, GLenum format, GLenum type, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionFilter, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glGetConvolutionFilter_ptr(target, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogram_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogram, (%s, %u, %s, %s, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetHistogram_ptr(target, reset, format, type, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogramParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogramParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmax_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmax, (%s, %u, %s, %s, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetMinmax_ptr(target, reset, format, type, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmaxParameterfv_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterfv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterfv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmaxParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSeparableFilter_debug(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSeparableFilter, (%s, %s, %s, %p, %p, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column, (void*)span)
    glatter_glGetSeparableFilter_ptr(target, format, type, row, column, span);
    glatter_check_error_GL(file, line);
}
void glatter_glHistogram_debug(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHistogram, (%s, %d, %s, %u), enum_to_string_GL(target), (int)width, enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glHistogram_ptr(target, width, internalformat, sink);
    glatter_check_error_GL(file, line);
}
void glatter_glMinmax_debug(GLenum target, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinmax, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glMinmax_ptr(target, internalformat, sink);
    glatter_check_error_GL(file, line);
}
void glatter_glResetHistogram_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetHistogram, (%s), enum_to_string_GL(target))
    glatter_glResetHistogram_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glResetMinmax_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetMinmax, (%s), enum_to_string_GL(target))
    glatter_glResetMinmax_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glSeparableFilter2D_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSeparableFilter2D, (%s, %s, %d, %d, %s, %s, %p, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column)
    glatter_glSeparableFilter2D_ptr(target, internalformat, width, height, format, type, row, column);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_imaging
#ifdef GL_ARB_indirect_parameters
void glatter_glMultiDrawArraysIndirectCountARB_debug(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectCountARB, (%s, %td, %td, %d, %d), enum_to_string_GL(mode), (ptrdiff_t)indirect, (ptrdiff_t)drawcount, (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawArraysIndirectCountARB_ptr(mode, indirect, drawcount, maxdrawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectCountARB_debug(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectCountARB, (%s, %s, %td, %td, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (ptrdiff_t)indirect, (ptrdiff_t)drawcount, (int)maxdrawcount, (int)stride)
    glatter_glMultiDrawElementsIndirectCountARB_ptr(mode, type, indirect, drawcount, maxdrawcount, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_indirect_parameters
#ifdef GL_ARB_instanced_arrays
void glatter_glVertexAttribDivisorARB_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisorARB, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisorARB_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_instanced_arrays
#ifdef GL_ARB_matrix_palette
void glatter_glCurrentPaletteMatrixARB_debug(GLint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCurrentPaletteMatrixARB, (%d), (int)index)
    glatter_glCurrentPaletteMatrixARB_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixIndexPointerARB_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexPointerARB, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glMatrixIndexPointerARB_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixIndexubvARB_debug(GLint size, const GLubyte *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexubvARB, (%d, %p), (int)size, (void*)indices)
    glatter_glMatrixIndexubvARB_ptr(size, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixIndexuivARB_debug(GLint size, const GLuint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexuivARB, (%d, %p), (int)size, (void*)indices)
    glatter_glMatrixIndexuivARB_ptr(size, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixIndexusvARB_debug(GLint size, const GLushort *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixIndexusvARB, (%d, %p), (int)size, (void*)indices)
    glatter_glMatrixIndexusvARB_ptr(size, indices);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_matrix_palette
#ifdef GL_ARB_multisample
void glatter_glSampleCoverageARB_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverageARB, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleCoverageARB_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_multisample
#ifdef GL_ARB_multitexture
void glatter_glActiveTextureARB_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTextureARB, (%s), enum_to_string_GL(texture))
    glatter_glActiveTextureARB_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glClientActiveTextureARB_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveTextureARB, (%s), enum_to_string_GL(texture))
    glatter_glClientActiveTextureARB_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1dARB_debug(GLenum target, GLdouble s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dARB, (%s, %f), enum_to_string_GL(target), (double)s)
    glatter_glMultiTexCoord1dARB_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1dvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1fARB_debug(GLenum target, GLfloat s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fARB, (%s, %f), enum_to_string_GL(target), (float)s)
    glatter_glMultiTexCoord1fARB_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1fvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1iARB_debug(GLenum target, GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1iARB, (%s, %d), enum_to_string_GL(target), (int)s)
    glatter_glMultiTexCoord1iARB_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1ivARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1ivARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1sARB_debug(GLenum target, GLshort s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1sARB, (%s, %hi), enum_to_string_GL(target), (short)s)
    glatter_glMultiTexCoord1sARB_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1svARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1svARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2dARB_debug(GLenum target, GLdouble s, GLdouble t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dARB, (%s, %f, %f), enum_to_string_GL(target), (double)s, (double)t)
    glatter_glMultiTexCoord2dARB_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2dvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2fARB_debug(GLenum target, GLfloat s, GLfloat t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fARB, (%s, %f, %f), enum_to_string_GL(target), (float)s, (float)t)
    glatter_glMultiTexCoord2fARB_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2fvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2iARB_debug(GLenum target, GLint s, GLint t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2iARB, (%s, %d, %d), enum_to_string_GL(target), (int)s, (int)t)
    glatter_glMultiTexCoord2iARB_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2ivARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2ivARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2sARB_debug(GLenum target, GLshort s, GLshort t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2sARB, (%s, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t)
    glatter_glMultiTexCoord2sARB_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2svARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2svARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3dARB_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dARB, (%s, %f, %f, %f), enum_to_string_GL(target), (double)s, (double)t, (double)r)
    glatter_glMultiTexCoord3dARB_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3dvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3fARB_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fARB, (%s, %f, %f, %f), enum_to_string_GL(target), (float)s, (float)t, (float)r)
    glatter_glMultiTexCoord3fARB_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3fvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3iARB_debug(GLenum target, GLint s, GLint t, GLint r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3iARB, (%s, %d, %d, %d), enum_to_string_GL(target), (int)s, (int)t, (int)r)
    glatter_glMultiTexCoord3iARB_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3ivARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3ivARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3sARB_debug(GLenum target, GLshort s, GLshort t, GLshort r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3sARB, (%s, %hi, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t, (short)r)
    glatter_glMultiTexCoord3sARB_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3svARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3svARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4dARB_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dARB, (%s, %f, %f, %f, %f), enum_to_string_GL(target), (double)s, (double)t, (double)r, (double)q)
    glatter_glMultiTexCoord4dARB_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4dvARB_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4dvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4fARB_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fARB, (%s, %f, %f, %f, %f), enum_to_string_GL(target), (float)s, (float)t, (float)r, (float)q)
    glatter_glMultiTexCoord4fARB_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4fvARB_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fvARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4fvARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4iARB_debug(GLenum target, GLint s, GLint t, GLint r, GLint q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4iARB, (%s, %d, %d, %d, %d), enum_to_string_GL(target), (int)s, (int)t, (int)r, (int)q)
    glatter_glMultiTexCoord4iARB_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4ivARB_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4ivARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4ivARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4sARB_debug(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4sARB, (%s, %hi, %hi, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t, (short)r, (short)q)
    glatter_glMultiTexCoord4sARB_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4svARB_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4svARB, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4svARB_ptr(target, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_multitexture
#ifdef GL_ARB_occlusion_query
void glatter_glBeginQueryARB_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryARB, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQueryARB_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteQueriesARB_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueriesARB, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteQueriesARB_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQueryARB_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryARB, (%s), enum_to_string_GL(target))
    glatter_glEndQueryARB_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGenQueriesARB_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueriesARB, (%d, %p), (int)n, (void*)ids)
    glatter_glGenQueriesARB_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectivARB_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectivARB, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectivARB_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectuivARB_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuivARB, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuivARB_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryivARB, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryivARB_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsQueryARB_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQueryARB, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsQueryARB_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_occlusion_query
#ifdef GL_ARB_parallel_shader_compile
void glatter_glMaxShaderCompilerThreadsARB_debug(GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaxShaderCompilerThreadsARB, (%u), (unsigned int)count)
    glatter_glMaxShaderCompilerThreadsARB_ptr(count);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_parallel_shader_compile
#ifdef GL_ARB_point_parameters
void glatter_glPointParameterfARB_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfARB, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfARB_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterfvARB_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvARB, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvARB_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_point_parameters
#ifdef GL_ARB_robustness
GLenum glatter_glGetGraphicsResetStatusARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatusARB, ())
    GLenum rval = glatter_glGetGraphicsResetStatusARB_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetnColorTableARB_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnColorTableARB, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)table)
    glatter_glGetnColorTableARB_ptr(target, format, type, bufSize, table);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnCompressedTexImageARB_debug(GLenum target, GLint lod, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImageARB, (%s, %d, %d, %p), enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)img)
    glatter_glGetnCompressedTexImageARB_ptr(target, lod, bufSize, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnConvolutionFilterARB_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnConvolutionFilterARB, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)image)
    glatter_glGetnConvolutionFilterARB_ptr(target, format, type, bufSize, image);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnHistogramARB_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnHistogramARB, (%s, %u, %s, %s, %d, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnHistogramARB_ptr(target, reset, format, type, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapdvARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapdvARB, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapdvARB_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapfvARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapfvARB, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapfvARB_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapivARB_debug(GLenum target, GLenum query, GLsizei bufSize, GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapivARB, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapivARB_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMinmaxARB_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMinmaxARB, (%s, %u, %s, %s, %d, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnMinmaxARB_ptr(target, reset, format, type, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapfvARB_debug(GLenum map, GLsizei bufSize, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapfvARB, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapfvARB_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapuivARB_debug(GLenum map, GLsizei bufSize, GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapuivARB, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapuivARB_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapusvARB_debug(GLenum map, GLsizei bufSize, GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapusvARB, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapusvARB_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPolygonStippleARB_debug(GLsizei bufSize, GLubyte *pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPolygonStippleARB, (%d, %p), (int)bufSize, (void*)pattern)
    glatter_glGetnPolygonStippleARB_ptr(bufSize, pattern);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnSeparableFilterARB_debug(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnSeparableFilterARB, (%s, %s, %s, %d, %p, %d, %p, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)rowBufSize, (void*)row, (int)columnBufSize, (void*)column, (void*)span)
    glatter_glGetnSeparableFilterARB_ptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnTexImageARB_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImageARB, (%s, %d, %s, %s, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)img)
    glatter_glGetnTexImageARB_ptr(target, level, format, type, bufSize, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformdvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdvARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdvARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformfvARB_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfvARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfvARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformivARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformivARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuivARB_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuivARB, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuivARB_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixelsARB_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixelsARB, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixelsARB_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_robustness
#ifdef GL_ARB_sample_locations
void glatter_glEvaluateDepthValuesARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvaluateDepthValuesARB, ())
    glatter_glEvaluateDepthValuesARB_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferSampleLocationsfvARB_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvARB, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvARB_ptr(target, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferSampleLocationsfvARB_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvARB, (%u, %u, %d, %p), (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvARB_ptr(framebuffer, start, count, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sample_locations
#ifdef GL_ARB_sample_shading
void glatter_glMinSampleShadingARB_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShadingARB, (%f), (float)value)
    glatter_glMinSampleShadingARB_ptr(value);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sample_shading
#ifdef GL_ARB_shading_language_include
void glatter_glCompileShaderIncludeARB_debug(GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShaderIncludeARB, (%u, %d, %p, %p), (unsigned int)shader, (int)count, (void*)path, (void*)length)
    glatter_glCompileShaderIncludeARB_ptr(shader, count, path, length);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteNamedStringARB, (%d, %p), (int)namelen, (void*)name)
    glatter_glDeleteNamedStringARB_ptr(namelen, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedStringARB_debug(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringARB, (%d, %p, %d, %p, %p), (int)namelen, (void*)name, (int)bufSize, (void*)stringlen, (void*)string)
    glatter_glGetNamedStringARB_ptr(namelen, name, bufSize, stringlen, string);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedStringivARB_debug(GLint namelen, const GLchar *name, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedStringivARB, (%d, %p, %s, %p), (int)namelen, (void*)name, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedStringivARB_ptr(namelen, name, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsNamedStringARB_debug(GLint namelen, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNamedStringARB, (%d, %p), (int)namelen, (void*)name)
    GLboolean rval = glatter_glIsNamedStringARB_ptr(namelen, name);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glNamedStringARB_debug(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedStringARB, (%s, %d, %p, %d, %p), enum_to_string_GL(type), (int)namelen, (void*)name, (int)stringlen, (void*)string)
    glatter_glNamedStringARB_ptr(type, namelen, name, stringlen, string);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_shading_language_include
#ifdef GL_ARB_sparse_buffer
void glatter_glBufferPageCommitmentARB_debug(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferPageCommitmentARB, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glBufferPageCommitmentARB_ptr(target, offset, size, commit);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferPageCommitmentARB_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentARB, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentARB_ptr(buffer, offset, size, commit);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferPageCommitmentEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferPageCommitmentEXT, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (unsigned char)commit)
    glatter_glNamedBufferPageCommitmentEXT_ptr(buffer, offset, size, commit);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sparse_buffer
#ifdef GL_ARB_sparse_texture
void glatter_glTexPageCommitmentARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexPageCommitmentARB, (%s, %d, %d, %d, %d, %d, %d, %d, %u), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexPageCommitmentARB_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_sparse_texture
#ifdef GL_ARB_texture_buffer_object
void glatter_glTexBufferARB_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferARB, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferARB_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_texture_buffer_object
#ifdef GL_ARB_texture_compression
void glatter_glCompressedTexImage1DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage1DARB, (%s, %d, %s, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage1DARB_ptr(target, level, internalformat, width, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage2DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2DARB, (%s, %d, %s, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2DARB_ptr(target, level, internalformat, width, height, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage3DARB_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3DARB, (%s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3DARB_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage1DARB_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage1DARB, (%s, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage1DARB_ptr(target, level, xoffset, width, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage2DARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2DARB, (%s, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2DARB_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage3DARB_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3DARB, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3DARB_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTexImageARB_debug(GLenum target, GLint level, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTexImageARB, (%s, %d, %p), enum_to_string_GL(target), (int)level, (void*)img)
    glatter_glGetCompressedTexImageARB_ptr(target, level, img);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_texture_compression
#ifdef GL_ARB_transpose_matrix
void glatter_glLoadTransposeMatrixdARB_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixdARB, (%p), (void*)m)
    glatter_glLoadTransposeMatrixdARB_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadTransposeMatrixfARB_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixfARB, (%p), (void*)m)
    glatter_glLoadTransposeMatrixfARB_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultTransposeMatrixdARB_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixdARB, (%p), (void*)m)
    glatter_glMultTransposeMatrixdARB_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultTransposeMatrixfARB_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixfARB, (%p), (void*)m)
    glatter_glMultTransposeMatrixfARB_ptr(m);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_transpose_matrix
#ifdef GL_ARB_vertex_blend
void glatter_glVertexBlendARB_debug(GLint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendARB, (%d), (int)count)
    glatter_glVertexBlendARB_ptr(count);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightPointerARB_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPointerARB, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glWeightPointerARB_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightbvARB_debug(GLint size, const GLbyte *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightbvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightbvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightdvARB_debug(GLint size, const GLdouble *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightdvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightdvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightfvARB_debug(GLint size, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightfvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightfvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightivARB_debug(GLint size, const GLint *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightivARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightivARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightsvARB_debug(GLint size, const GLshort *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightsvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightsvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightubvARB_debug(GLint size, const GLubyte *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightubvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightubvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightuivARB_debug(GLint size, const GLuint *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightuivARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightuivARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightusvARB_debug(GLint size, const GLushort *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightusvARB, (%d, %p), (int)size, (void*)weights)
    glatter_glWeightusvARB_ptr(size, weights);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_vertex_blend
#ifdef GL_ARB_vertex_buffer_object
void glatter_glBindBufferARB_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferARB, (%s, %u), enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBufferARB_ptr(target, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferDataARB_debug(GLenum target, GLsizeiptrARB size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferDataARB, (%s, %td, %p, %s), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glBufferDataARB_ptr(target, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferSubDataARB_debug(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubDataARB, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glBufferSubDataARB_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteBuffersARB_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffersARB, (%d, %p), (int)n, (void*)buffers)
    glatter_glDeleteBuffersARB_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenBuffersARB_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffersARB, (%d, %p), (int)n, (void*)buffers)
    glatter_glGenBuffersARB_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameterivARB_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameterivARB, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameterivARB_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferPointervARB_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointervARB, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointervARB_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferSubDataARB_debug(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferSubDataARB, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetBufferSubDataARB_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsBufferARB_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBufferARB, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsBufferARB_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBufferARB_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferARB, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBufferARB_ptr(target, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glUnmapBufferARB_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBufferARB, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBufferARB_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_vertex_buffer_object
#ifdef GL_ARB_vertex_program
void glatter_glDisableVertexAttribArrayARB_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArrayARB, (%u), (unsigned int)index)
    glatter_glDisableVertexAttribArrayARB_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexAttribArrayARB_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArrayARB, (%u), (unsigned int)index)
    glatter_glEnableVertexAttribArrayARB_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribPointervARB_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointervARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointervARB_ptr(index, pname, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribdvARB_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdvARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdvARB_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribfvARB_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfvARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfvARB_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribivARB_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribivARB, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribivARB_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dARB_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dARB, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttrib1dARB_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fARB_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fARB, (%u, %f), (unsigned int)index, (float)x)
    glatter_glVertexAttrib1fARB_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1sARB_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sARB, (%u, %hi), (unsigned int)index, (short)x)
    glatter_glVertexAttrib1sARB_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1svARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1svARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dARB_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dARB, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2dARB_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fARB_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fARB, (%u, %f, %f), (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2fARB_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2sARB_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sARB, (%u, %hi, %hi), (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2sARB_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2svARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2svARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dARB_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dARB, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3dARB_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fARB_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fARB, (%u, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3fARB_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3sARB_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sARB, (%u, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3sARB_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3svARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3svARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NbvARB_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NbvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NbvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NivARB_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NivARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NivARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NsvARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NsvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NsvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NubARB_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NubARB, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4NubARB_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NubvARB_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NubvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NubvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NuivARB_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NuivARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NuivARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4NusvARB_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4NusvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4NusvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4bvARB_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4bvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4bvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dARB_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dARB, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4dARB_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dvARB_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fARB_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fARB, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4fARB_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fvARB_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ivARB_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ivARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ivARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4sARB_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sARB, (%u, %hi, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4sARB_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4svARB_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4svARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4svARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ubvARB_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4uivARB_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4uivARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4uivARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4usvARB_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4usvARB, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4usvARB_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribPointerARB_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointerARB, (%u, %d, %s, %u, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointerARB_ptr(index, size, type, normalized, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_vertex_program
#ifdef GL_ARB_vertex_shader
void glatter_glBindAttribLocationARB_debug(GLhandleARB programObj, GLuint index, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocationARB, (%u, %u, %p), (unsigned int)programObj, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocationARB_ptr(programObj, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAttribARB_debug(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttribARB, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)programObj, (unsigned int)index, (int)maxLength, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttribARB_ptr(programObj, index, maxLength, length, size, type, name);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetAttribLocationARB_debug(GLhandleARB programObj, const GLcharARB *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocationARB, (%u, %p), (unsigned int)programObj, (void*)name)
    GLint rval = glatter_glGetAttribLocationARB_ptr(programObj, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_ARB_vertex_shader
#ifdef GL_ARB_window_pos
void glatter_glWindowPos2dARB_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dARB, (%f, %f), (double)x, (double)y)
    glatter_glWindowPos2dARB_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2dvARB_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dvARB, (%p), (void*)v)
    glatter_glWindowPos2dvARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2fARB_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fARB, (%f, %f), (float)x, (float)y)
    glatter_glWindowPos2fARB_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2fvARB_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fvARB, (%p), (void*)v)
    glatter_glWindowPos2fvARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2iARB_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iARB, (%d, %d), (int)x, (int)y)
    glatter_glWindowPos2iARB_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2ivARB_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2ivARB, (%p), (void*)v)
    glatter_glWindowPos2ivARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2sARB_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sARB, (%hi, %hi), (short)x, (short)y)
    glatter_glWindowPos2sARB_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2svARB_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2svARB, (%p), (void*)v)
    glatter_glWindowPos2svARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3dARB_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dARB, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glWindowPos3dARB_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3dvARB_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dvARB, (%p), (void*)v)
    glatter_glWindowPos3dvARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3fARB_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fARB, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glWindowPos3fARB_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3fvARB_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fvARB, (%p), (void*)v)
    glatter_glWindowPos3fvARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3iARB_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iARB, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glWindowPos3iARB_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3ivARB_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3ivARB, (%p), (void*)v)
    glatter_glWindowPos3ivARB_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3sARB_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sARB, (%hi, %hi, %hi), (short)x, (short)y, (short)z)
    glatter_glWindowPos3sARB_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3svARB_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3svARB, (%p), (void*)v)
    glatter_glWindowPos3svARB_ptr(v);
    glatter_check_error_GL(file, line);
}
#endif // GL_ARB_window_pos
#ifdef GL_ATI_draw_buffers
void glatter_glDrawBuffersATI_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffersATI, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffersATI_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_draw_buffers
#ifdef GL_ATI_element_array
void glatter_glDrawElementArrayATI_debug(GLenum mode, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementArrayATI, (%s, %d), enum_to_string_GL(mode), (int)count)
    glatter_glDrawElementArrayATI_ptr(mode, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElementArrayATI_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementArrayATI, (%s, %u, %u, %d), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count)
    glatter_glDrawRangeElementArrayATI_ptr(mode, start, end, count);
    glatter_check_error_GL(file, line);
}
void glatter_glElementPointerATI_debug(GLenum type, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glElementPointerATI, (%s, %p), enum_to_string_GL(type), (void*)pointer)
    glatter_glElementPointerATI_ptr(type, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_element_array
#ifdef GL_ATI_envmap_bumpmap
void glatter_glGetTexBumpParameterfvATI_debug(GLenum pname, GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexBumpParameterfvATI, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glGetTexBumpParameterfvATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexBumpParameterivATI_debug(GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexBumpParameterivATI, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glGetTexBumpParameterivATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBumpParameterfvATI_debug(GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBumpParameterfvATI, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glTexBumpParameterfvATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBumpParameterivATI_debug(GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBumpParameterivATI, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glTexBumpParameterivATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_envmap_bumpmap
#ifdef GL_ATI_fragment_shader
void glatter_glAlphaFragmentOp1ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp1ATI, (%s, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod)
    glatter_glAlphaFragmentOp1ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glAlphaFragmentOp2ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp2ATI, (%s, %u, %u, %u, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod)
    glatter_glAlphaFragmentOp2ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glAlphaFragmentOp3ATI_debug(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFragmentOp3ATI, (%s, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod, (unsigned int)arg3, (unsigned int)arg3Rep, (unsigned int)arg3Mod)
    glatter_glAlphaFragmentOp3ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glBeginFragmentShaderATI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginFragmentShaderATI, ())
    glatter_glBeginFragmentShaderATI_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glBindFragmentShaderATI_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragmentShaderATI, (%u), (unsigned int)id)
    glatter_glBindFragmentShaderATI_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glColorFragmentOp1ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp1ATI, (%s, %u, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod)
    glatter_glColorFragmentOp1ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glColorFragmentOp2ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp2ATI, (%s, %u, %u, %u, %u, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod)
    glatter_glColorFragmentOp2ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glColorFragmentOp3ATI_debug(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFragmentOp3ATI, (%s, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)dst, (unsigned int)dstMask, (unsigned int)dstMod, (unsigned int)arg1, (unsigned int)arg1Rep, (unsigned int)arg1Mod, (unsigned int)arg2, (unsigned int)arg2Rep, (unsigned int)arg2Mod, (unsigned int)arg3, (unsigned int)arg3Rep, (unsigned int)arg3Mod)
    glatter_glColorFragmentOp3ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteFragmentShaderATI_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFragmentShaderATI, (%u), (unsigned int)id)
    glatter_glDeleteFragmentShaderATI_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glEndFragmentShaderATI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndFragmentShaderATI, ())
    glatter_glEndFragmentShaderATI_ptr();
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenFragmentShadersATI_debug(GLuint range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFragmentShadersATI, (%u), (unsigned int)range)
    GLuint rval = glatter_glGenFragmentShadersATI_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPassTexCoordATI_debug(GLuint dst, GLuint coord, GLenum swizzle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPassTexCoordATI, (%u, %u, %s), (unsigned int)dst, (unsigned int)coord, enum_to_string_GL(swizzle))
    glatter_glPassTexCoordATI_ptr(dst, coord, swizzle);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleMapATI_debug(GLuint dst, GLuint interp, GLenum swizzle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMapATI, (%u, %u, %s), (unsigned int)dst, (unsigned int)interp, enum_to_string_GL(swizzle))
    glatter_glSampleMapATI_ptr(dst, interp, swizzle);
    glatter_check_error_GL(file, line);
}
void glatter_glSetFragmentShaderConstantATI_debug(GLuint dst, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFragmentShaderConstantATI, (%u, %p), (unsigned int)dst, (void*)value)
    glatter_glSetFragmentShaderConstantATI_ptr(dst, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_fragment_shader
#ifdef GL_ATI_map_object_buffer
void * glatter_glMapObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapObjectBufferATI, (%u), (unsigned int)buffer)
    void * rval = glatter_glMapObjectBufferATI_ptr(buffer);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glUnmapObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapObjectBufferATI, (%u), (unsigned int)buffer)
    glatter_glUnmapObjectBufferATI_ptr(buffer);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_map_object_buffer
#ifdef GL_ATI_pn_triangles
void glatter_glPNTrianglesfATI_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPNTrianglesfATI, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPNTrianglesfATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPNTrianglesiATI_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPNTrianglesiATI, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPNTrianglesiATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_pn_triangles
#ifdef GL_ATI_separate_stencil
void glatter_glStencilFuncSeparateATI_debug(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparateATI, (%s, %s, %d, %u), enum_to_string_GL(frontfunc), enum_to_string_GL(backfunc), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparateATI_ptr(frontfunc, backfunc, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOpSeparateATI_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparateATI, (%s, %s, %s, %s), enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparateATI_ptr(face, sfail, dpfail, dppass);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_separate_stencil
#ifdef GL_ATI_vertex_array_object
void glatter_glArrayObjectATI_debug(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glArrayObjectATI, (%s, %d, %s, %d, %u, %u), enum_to_string_GL(array), (int)size, enum_to_string_GL(type), (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glArrayObjectATI_ptr(array, size, type, stride, buffer, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glFreeObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFreeObjectBufferATI, (%u), (unsigned int)buffer)
    glatter_glFreeObjectBufferATI_ptr(buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetArrayObjectfvATI_debug(GLenum array, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetArrayObjectfvATI, (%s, %s, %p), enum_to_string_GL(array), enum_to_string_GL(pname), (void*)params)
    glatter_glGetArrayObjectfvATI_ptr(array, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetArrayObjectivATI_debug(GLenum array, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetArrayObjectivATI, (%s, %s, %p), enum_to_string_GL(array), enum_to_string_GL(pname), (void*)params)
    glatter_glGetArrayObjectivATI_ptr(array, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectBufferfvATI_debug(GLuint buffer, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectBufferfvATI, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectBufferfvATI_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectBufferivATI_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectBufferivATI, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetObjectBufferivATI_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantArrayObjectfvATI_debug(GLuint id, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantArrayObjectfvATI, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVariantArrayObjectfvATI_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantArrayObjectivATI_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantArrayObjectivATI, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVariantArrayObjectivATI_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsObjectBufferATI_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsObjectBufferATI, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsObjectBufferATI_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glNewObjectBufferATI_debug(GLsizei size, const void *pointer, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNewObjectBufferATI, (%d, %p, %s), (int)size, (void*)pointer, enum_to_string_GL(usage))
    GLuint rval = glatter_glNewObjectBufferATI_ptr(size, pointer, usage);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glUpdateObjectBufferATI_debug(GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUpdateObjectBufferATI, (%u, %u, %d, %p, %s), (unsigned int)buffer, (unsigned int)offset, (int)size, (void*)pointer, enum_to_string_GL(preserve))
    glatter_glUpdateObjectBufferATI_ptr(buffer, offset, size, pointer, preserve);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantArrayObjectATI_debug(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantArrayObjectATI, (%u, %s, %d, %u, %u), (unsigned int)id, enum_to_string_GL(type), (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glVariantArrayObjectATI_ptr(id, type, stride, buffer, offset);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_vertex_array_object
#ifdef GL_ATI_vertex_attrib_array_object
void glatter_glGetVertexAttribArrayObjectfvATI_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribArrayObjectfvATI, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribArrayObjectfvATI_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribArrayObjectivATI_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribArrayObjectivATI, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribArrayObjectivATI_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribArrayObjectATI_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribArrayObjectATI, (%u, %d, %s, %u, %d, %u, %u), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (unsigned int)buffer, (unsigned int)offset)
    glatter_glVertexAttribArrayObjectATI_ptr(index, size, type, normalized, stride, buffer, offset);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_vertex_attrib_array_object
#ifdef GL_ATI_vertex_streams
void glatter_glClientActiveVertexStreamATI_debug(GLenum stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveVertexStreamATI, (%s), enum_to_string_GL(stream))
    glatter_glClientActiveVertexStreamATI_ptr(stream);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3bATI_debug(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3bATI, (%s, %d, %d, %d), enum_to_string_GL(stream), (signed char)nx, (signed char)ny, (signed char)nz)
    glatter_glNormalStream3bATI_ptr(stream, nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3bvATI_debug(GLenum stream, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3bvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3bvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3dATI_debug(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3dATI, (%s, %f, %f, %f), enum_to_string_GL(stream), (double)nx, (double)ny, (double)nz)
    glatter_glNormalStream3dATI_ptr(stream, nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3dvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3dvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3fATI_debug(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3fATI, (%s, %f, %f, %f), enum_to_string_GL(stream), (float)nx, (float)ny, (float)nz)
    glatter_glNormalStream3fATI_ptr(stream, nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3fvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3fvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3iATI_debug(GLenum stream, GLint nx, GLint ny, GLint nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3iATI, (%s, %d, %d, %d), enum_to_string_GL(stream), (int)nx, (int)ny, (int)nz)
    glatter_glNormalStream3iATI_ptr(stream, nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3ivATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3ivATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3sATI_debug(GLenum stream, GLshort nx, GLshort ny, GLshort nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3sATI, (%s, %hi, %hi, %hi), enum_to_string_GL(stream), (short)nx, (short)ny, (short)nz)
    glatter_glNormalStream3sATI_ptr(stream, nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalStream3svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalStream3svATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glNormalStream3svATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexBlendEnvfATI_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendEnvfATI, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glVertexBlendEnvfATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexBlendEnviATI_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBlendEnviATI, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glVertexBlendEnviATI_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1dATI_debug(GLenum stream, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1dATI, (%s, %f), enum_to_string_GL(stream), (double)x)
    glatter_glVertexStream1dATI_ptr(stream, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1dvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1dvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1fATI_debug(GLenum stream, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1fATI, (%s, %f), enum_to_string_GL(stream), (float)x)
    glatter_glVertexStream1fATI_ptr(stream, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1fvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1fvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1iATI_debug(GLenum stream, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1iATI, (%s, %d), enum_to_string_GL(stream), (int)x)
    glatter_glVertexStream1iATI_ptr(stream, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1ivATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1ivATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1sATI_debug(GLenum stream, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1sATI, (%s, %hi), enum_to_string_GL(stream), (short)x)
    glatter_glVertexStream1sATI_ptr(stream, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream1svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream1svATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream1svATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2dATI_debug(GLenum stream, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2dATI, (%s, %f, %f), enum_to_string_GL(stream), (double)x, (double)y)
    glatter_glVertexStream2dATI_ptr(stream, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2dvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2dvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2fATI_debug(GLenum stream, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2fATI, (%s, %f, %f), enum_to_string_GL(stream), (float)x, (float)y)
    glatter_glVertexStream2fATI_ptr(stream, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2fvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2fvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2iATI_debug(GLenum stream, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2iATI, (%s, %d, %d), enum_to_string_GL(stream), (int)x, (int)y)
    glatter_glVertexStream2iATI_ptr(stream, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2ivATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2ivATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2sATI_debug(GLenum stream, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2sATI, (%s, %hi, %hi), enum_to_string_GL(stream), (short)x, (short)y)
    glatter_glVertexStream2sATI_ptr(stream, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream2svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream2svATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream2svATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3dATI_debug(GLenum stream, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3dATI, (%s, %f, %f, %f), enum_to_string_GL(stream), (double)x, (double)y, (double)z)
    glatter_glVertexStream3dATI_ptr(stream, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3dvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3dvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3fATI_debug(GLenum stream, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3fATI, (%s, %f, %f, %f), enum_to_string_GL(stream), (float)x, (float)y, (float)z)
    glatter_glVertexStream3fATI_ptr(stream, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3fvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3fvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3iATI_debug(GLenum stream, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3iATI, (%s, %d, %d, %d), enum_to_string_GL(stream), (int)x, (int)y, (int)z)
    glatter_glVertexStream3iATI_ptr(stream, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3ivATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3ivATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3sATI_debug(GLenum stream, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3sATI, (%s, %hi, %hi, %hi), enum_to_string_GL(stream), (short)x, (short)y, (short)z)
    glatter_glVertexStream3sATI_ptr(stream, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream3svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream3svATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream3svATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4dATI_debug(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4dATI, (%s, %f, %f, %f, %f), enum_to_string_GL(stream), (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexStream4dATI_ptr(stream, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4dvATI_debug(GLenum stream, const GLdouble *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4dvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4dvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4fATI_debug(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4fATI, (%s, %f, %f, %f, %f), enum_to_string_GL(stream), (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexStream4fATI_ptr(stream, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4fvATI_debug(GLenum stream, const GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4fvATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4fvATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4iATI_debug(GLenum stream, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4iATI, (%s, %d, %d, %d, %d), enum_to_string_GL(stream), (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexStream4iATI_ptr(stream, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4ivATI_debug(GLenum stream, const GLint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4ivATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4ivATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4sATI_debug(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4sATI, (%s, %hi, %hi, %hi, %hi), enum_to_string_GL(stream), (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexStream4sATI_ptr(stream, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexStream4svATI_debug(GLenum stream, const GLshort *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexStream4svATI, (%s, %p), enum_to_string_GL(stream), (void*)coords)
    glatter_glVertexStream4svATI_ptr(stream, coords);
    glatter_check_error_GL(file, line);
}
#endif // GL_ATI_vertex_streams
#ifdef GL_EXT_bindable_uniform
GLint glatter_glGetUniformBufferSizeEXT_debug(GLuint program, GLint location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBufferSizeEXT, (%u, %d), (unsigned int)program, (int)location)
    GLint rval = glatter_glGetUniformBufferSizeEXT_ptr(program, location);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLintptr glatter_glGetUniformOffsetEXT_debug(GLuint program, GLint location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformOffsetEXT, (%u, %d), (unsigned int)program, (int)location)
    GLintptr rval = glatter_glGetUniformOffsetEXT_ptr(program, location);
    printf("GLATTER: returned %td", (ptrdiff_t)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glUniformBufferEXT_debug(GLuint program, GLint location, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBufferEXT, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)buffer)
    glatter_glUniformBufferEXT_ptr(program, location, buffer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_bindable_uniform
#ifdef GL_EXT_blend_color
void glatter_glBlendColorEXT_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColorEXT, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColorEXT_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_blend_color
#ifdef GL_EXT_blend_equation_separate
void glatter_glBlendEquationSeparateEXT_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparateEXT, (%s, %s), enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparateEXT_ptr(modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_blend_equation_separate
#ifdef GL_EXT_blend_func_separate
void glatter_glBlendFuncSeparateEXT_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateEXT, (%s, %s, %s, %s), enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparateEXT_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_blend_func_separate
#ifdef GL_EXT_blend_minmax
void glatter_glBlendEquationEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationEXT, (%s), enum_to_string_GL(mode))
    glatter_glBlendEquationEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_blend_minmax
#ifdef GL_EXT_color_subtable
void glatter_glColorSubTableEXT_debug(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorSubTableEXT, (%s, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)start, (int)count, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glColorSubTableEXT_ptr(target, start, count, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyColorSubTableEXT_debug(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorSubTableEXT, (%s, %d, %d, %d, %d), enum_to_string_GL(target), (int)start, (int)x, (int)y, (int)width)
    glatter_glCopyColorSubTableEXT_ptr(target, start, x, y, width);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_color_subtable
#ifdef GL_EXT_compiled_vertex_array
void glatter_glLockArraysEXT_debug(GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLockArraysEXT, (%d, %d), (int)first, (int)count)
    glatter_glLockArraysEXT_ptr(first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glUnlockArraysEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnlockArraysEXT, ())
    glatter_glUnlockArraysEXT_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_compiled_vertex_array
#ifdef GL_EXT_convolution
void glatter_glConvolutionFilter1DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter1DEXT, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter1DEXT_ptr(target, internalformat, width, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionFilter2DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionFilter2DEXT, (%s, %s, %d, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glConvolutionFilter2DEXT_ptr(target, internalformat, width, height, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterfEXT_debug(GLenum target, GLenum pname, GLfloat params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfEXT, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)params)
    glatter_glConvolutionParameterfEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterfvEXT_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameteriEXT_debug(GLenum target, GLenum pname, GLint params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameteriEXT, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)params)
    glatter_glConvolutionParameteriEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyConvolutionFilter1DEXT_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter1DEXT, (%s, %s, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyConvolutionFilter1DEXT_ptr(target, internalformat, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyConvolutionFilter2DEXT_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyConvolutionFilter2DEXT, (%s, %s, %d, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyConvolutionFilter2DEXT_ptr(target, internalformat, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionFilterEXT_debug(GLenum target, GLenum format, GLenum type, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionFilterEXT, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)image)
    glatter_glGetConvolutionFilterEXT_ptr(target, format, type, image);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSeparableFilterEXT_debug(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSeparableFilterEXT, (%s, %s, %s, %p, %p, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column, (void*)span)
    glatter_glGetSeparableFilterEXT_ptr(target, format, type, row, column, span);
    glatter_check_error_GL(file, line);
}
void glatter_glSeparableFilter2DEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSeparableFilter2DEXT, (%s, %s, %d, %d, %s, %s, %p, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)row, (void*)column)
    glatter_glSeparableFilter2DEXT_ptr(target, internalformat, width, height, format, type, row, column);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_convolution
#ifdef GL_EXT_coordinate_frame
void glatter_glBinormal3bEXT_debug(GLbyte bx, GLbyte by, GLbyte bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3bEXT, (%d, %d, %d), (signed char)bx, (signed char)by, (signed char)bz)
    glatter_glBinormal3bEXT_ptr(bx, by, bz);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3bvEXT, (%p), (void*)v)
    glatter_glBinormal3bvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3dEXT_debug(GLdouble bx, GLdouble by, GLdouble bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3dEXT, (%f, %f, %f), (double)bx, (double)by, (double)bz)
    glatter_glBinormal3dEXT_ptr(bx, by, bz);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3dvEXT, (%p), (void*)v)
    glatter_glBinormal3dvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3fEXT_debug(GLfloat bx, GLfloat by, GLfloat bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3fEXT, (%f, %f, %f), (float)bx, (float)by, (float)bz)
    glatter_glBinormal3fEXT_ptr(bx, by, bz);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3fvEXT, (%p), (void*)v)
    glatter_glBinormal3fvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3iEXT_debug(GLint bx, GLint by, GLint bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3iEXT, (%d, %d, %d), (int)bx, (int)by, (int)bz)
    glatter_glBinormal3iEXT_ptr(bx, by, bz);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3ivEXT, (%p), (void*)v)
    glatter_glBinormal3ivEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3sEXT_debug(GLshort bx, GLshort by, GLshort bz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3sEXT, (%hi, %hi, %hi), (short)bx, (short)by, (short)bz)
    glatter_glBinormal3sEXT_ptr(bx, by, bz);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormal3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormal3svEXT, (%p), (void*)v)
    glatter_glBinormal3svEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glBinormalPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBinormalPointerEXT, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glBinormalPointerEXT_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3bEXT_debug(GLbyte tx, GLbyte ty, GLbyte tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3bEXT, (%d, %d, %d), (signed char)tx, (signed char)ty, (signed char)tz)
    glatter_glTangent3bEXT_ptr(tx, ty, tz);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3bvEXT, (%p), (void*)v)
    glatter_glTangent3bvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3dEXT_debug(GLdouble tx, GLdouble ty, GLdouble tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3dEXT, (%f, %f, %f), (double)tx, (double)ty, (double)tz)
    glatter_glTangent3dEXT_ptr(tx, ty, tz);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3dvEXT, (%p), (void*)v)
    glatter_glTangent3dvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3fEXT_debug(GLfloat tx, GLfloat ty, GLfloat tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3fEXT, (%f, %f, %f), (float)tx, (float)ty, (float)tz)
    glatter_glTangent3fEXT_ptr(tx, ty, tz);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3fvEXT, (%p), (void*)v)
    glatter_glTangent3fvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3iEXT_debug(GLint tx, GLint ty, GLint tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3iEXT, (%d, %d, %d), (int)tx, (int)ty, (int)tz)
    glatter_glTangent3iEXT_ptr(tx, ty, tz);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3ivEXT, (%p), (void*)v)
    glatter_glTangent3ivEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3sEXT_debug(GLshort tx, GLshort ty, GLshort tz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3sEXT, (%hi, %hi, %hi), (short)tx, (short)ty, (short)tz)
    glatter_glTangent3sEXT_ptr(tx, ty, tz);
    glatter_check_error_GL(file, line);
}
void glatter_glTangent3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangent3svEXT, (%p), (void*)v)
    glatter_glTangent3svEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTangentPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTangentPointerEXT, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glTangentPointerEXT_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_coordinate_frame
#ifdef GL_EXT_copy_texture
void glatter_glCopyTexImage1DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage1DEXT, (%s, %d, %s, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTexImage1DEXT_ptr(target, level, internalformat, x, y, width, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexImage2DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexImage2DEXT, (%s, %d, %s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTexImage2DEXT_ptr(target, level, internalformat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage1DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage1DEXT, (%s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTexSubImage1DEXT_ptr(target, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage2DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage2DEXT, (%s, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage2DEXT_ptr(target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTexSubImage3DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3DEXT, (%s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3DEXT_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_copy_texture
#ifdef GL_EXT_cull_vertex
void glatter_glCullParameterdvEXT_debug(GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullParameterdvEXT, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glCullParameterdvEXT_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glCullParameterfvEXT_debug(GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCullParameterfvEXT, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glCullParameterfvEXT_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_cull_vertex
#ifdef GL_EXT_debug_label
void glatter_glGetObjectLabelEXT_debug(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabelEXT, (%s, %u, %d, %p, %p), enum_to_string_GL(type), (unsigned int)object, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabelEXT_ptr(type, object, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glLabelObjectEXT_debug(GLenum type, GLuint object, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLabelObjectEXT, (%s, %u, %d, %p), enum_to_string_GL(type), (unsigned int)object, (int)length, (void*)label)
    glatter_glLabelObjectEXT_ptr(type, object, length, label);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_label
#ifdef GL_EXT_debug_marker
void glatter_glInsertEventMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertEventMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glInsertEventMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
void glatter_glPopGroupMarkerEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopGroupMarkerEXT, ())
    glatter_glPopGroupMarkerEXT_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushGroupMarkerEXT_debug(GLsizei length, const GLchar *marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushGroupMarkerEXT, (%d, %p), (int)length, (void*)marker)
    glatter_glPushGroupMarkerEXT_ptr(length, marker);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_debug_marker
#ifdef GL_EXT_depth_bounds_test
void glatter_glDepthBoundsEXT_debug(GLclampd zmin, GLclampd zmax, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthBoundsEXT, (%f, %f), (double)zmin, (double)zmax)
    glatter_glDepthBoundsEXT_ptr(zmin, zmax);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_depth_bounds_test
#ifdef GL_EXT_direct_state_access
void glatter_glBindMultiTextureEXT_debug(GLenum texunit, GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindMultiTextureEXT, (%s, %s, %u), enum_to_string_GL(texunit), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindMultiTextureEXT_ptr(texunit, target, texture);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckNamedFramebufferStatusEXT_debug(GLuint framebuffer, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckNamedFramebufferStatusEXT, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(target))
    GLenum rval = glatter_glCheckNamedFramebufferStatusEXT_ptr(framebuffer, target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClearNamedBufferDataEXT_debug(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferDataEXT, (%u, %s, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferDataEXT_ptr(buffer, internalformat, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedBufferSubDataEXT_debug(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferSubDataEXT, (%u, %s, %td, %td, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), (ptrdiff_t)offset, (ptrdiff_t)size, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferSubDataEXT_ptr(buffer, internalformat, offset, size, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClientAttribDefaultEXT_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientAttribDefaultEXT, (%u), (unsigned int)mask)
    glatter_glClientAttribDefaultEXT_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage1DEXT, (%s, %s, %d, %s, %d, %d, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, width, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage2DEXT, (%s, %s, %d, %s, %d, %d, %d, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexImage3DEXT, (%s, %s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexImage3DEXT_ptr(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage1DEXT, (%s, %s, %d, %d, %d, %s, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, width, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage2DEXT, (%s, %s, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedMultiTexSubImage3DEXT, (%s, %s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage1DEXT, (%u, %s, %d, %s, %d, %d, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage1DEXT_ptr(texture, target, level, internalformat, width, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage2DEXT, (%u, %s, %d, %s, %d, %d, %d, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage2DEXT_ptr(texture, target, level, internalformat, width, height, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureImage3DEXT, (%u, %s, %d, %s, %d, %d, %d, %d, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)bits)
    glatter_glCompressedTextureImage3DEXT_ptr(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage1DEXT, (%u, %s, %d, %d, %d, %s, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage1DEXT_ptr(texture, target, level, xoffset, width, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage2DEXT, (%u, %s, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage3DEXT, (%u, %s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)bits)
    glatter_glCompressedTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexImage1DEXT, (%s, %s, %d, %s, %d, %d, %d, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, x, y, width, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexImage2DEXT, (%s, %s, %d, %s, %d, %d, %d, %d, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage1DEXT, (%s, %s, %d, %d, %d, %d, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage2DEXT, (%s, %s, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyMultiTexSubImage3DEXT, (%s, %s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureImage1DEXT, (%u, %s, %d, %s, %d, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)border)
    glatter_glCopyTextureImage1DEXT_ptr(texture, target, level, internalformat, x, y, width, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureImage2DEXT, (%u, %s, %d, %s, %d, %d, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)x, (int)y, (int)width, (int)height, (int)border)
    glatter_glCopyTextureImage2DEXT_ptr(texture, target, level, internalformat, x, y, width, height, border);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage1DEXT, (%u, %s, %d, %d, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTextureSubImage1DEXT_ptr(texture, target, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage2DEXT, (%u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage3DEXT, (%u, %s, %d, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableClientStateIndexedEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableClientStateIndexedEXT, (%s, %u), enum_to_string_GL(array), (unsigned int)index)
    glatter_glDisableClientStateIndexedEXT_ptr(array, index);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableClientStateiEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableClientStateiEXT, (%s, %u), enum_to_string_GL(array), (unsigned int)index)
    glatter_glDisableClientStateiEXT_ptr(array, index);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableIndexedEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisableIndexedEXT_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexArrayAttribEXT_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayAttribEXT, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glDisableVertexArrayAttribEXT_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexArrayEXT_debug(GLuint vaobj, GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayEXT, (%u, %s), (unsigned int)vaobj, enum_to_string_GL(array))
    glatter_glDisableVertexArrayEXT_ptr(vaobj, array);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableClientStateIndexedEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableClientStateIndexedEXT, (%s, %u), enum_to_string_GL(array), (unsigned int)index)
    glatter_glEnableClientStateIndexedEXT_ptr(array, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableClientStateiEXT_debug(GLenum array, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableClientStateiEXT, (%s, %u), enum_to_string_GL(array), (unsigned int)index)
    glatter_glEnableClientStateiEXT_ptr(array, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableIndexedEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnableIndexedEXT_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexArrayAttribEXT_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayAttribEXT, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glEnableVertexArrayAttribEXT_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexArrayEXT_debug(GLuint vaobj, GLenum array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayEXT, (%u, %s), (unsigned int)vaobj, enum_to_string_GL(array))
    glatter_glEnableVertexArrayEXT_ptr(vaobj, array);
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedNamedBufferRangeEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedNamedBufferRangeEXT, (%u, %td, %td), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedNamedBufferRangeEXT_ptr(buffer, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferDrawBufferEXT_debug(GLuint framebuffer, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferDrawBufferEXT, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(mode))
    glatter_glFramebufferDrawBufferEXT_ptr(framebuffer, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferDrawBuffersEXT_debug(GLuint framebuffer, GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferDrawBuffersEXT, (%u, %d, %p), (unsigned int)framebuffer, (int)n, (void*)bufs)
    glatter_glFramebufferDrawBuffersEXT_ptr(framebuffer, n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferReadBufferEXT_debug(GLuint framebuffer, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferReadBufferEXT, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(mode))
    glatter_glFramebufferReadBufferEXT_ptr(framebuffer, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateMultiTexMipmapEXT_debug(GLenum texunit, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMultiTexMipmapEXT, (%s, %s), enum_to_string_GL(texunit), enum_to_string_GL(target))
    glatter_glGenerateMultiTexMipmapEXT_ptr(texunit, target);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateTextureMipmapEXT_debug(GLuint texture, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateTextureMipmapEXT, (%u, %s), (unsigned int)texture, enum_to_string_GL(target))
    glatter_glGenerateTextureMipmapEXT_ptr(texture, target);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleanIndexedvEXT_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleanIndexedvEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleanIndexedvEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedMultiTexImageEXT_debug(GLenum texunit, GLenum target, GLint lod, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedMultiTexImageEXT, (%s, %s, %d, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)lod, (void*)img)
    glatter_glGetCompressedMultiTexImageEXT_ptr(texunit, target, lod, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTextureImageEXT_debug(GLuint texture, GLenum target, GLint lod, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureImageEXT, (%u, %s, %d, %p), (unsigned int)texture, enum_to_string_GL(target), (int)lod, (void*)img)
    glatter_glGetCompressedTextureImageEXT_ptr(texture, target, lod, img);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoubleIndexedvEXT_debug(GLenum target, GLuint index, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoubleIndexedvEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetDoubleIndexedvEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoublei_vEXT_debug(GLenum pname, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublei_vEXT, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetDoublei_vEXT_ptr(pname, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloatIndexedvEXT_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloatIndexedvEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloatIndexedvEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloati_vEXT_debug(GLenum pname, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_vEXT, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetFloati_vEXT_ptr(pname, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFramebufferParameterivEXT_debug(GLuint framebuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameterivEXT, (%u, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameterivEXT_ptr(framebuffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerIndexedvEXT_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerIndexedvEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegerIndexedvEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexEnvfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexEnvfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexEnvfvEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexEnvivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexEnvivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexEnvivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexGendvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGendvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGendvEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexGenfvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGenfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGenfvEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexGenivEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexGenivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexGenivEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexImageEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexImageEXT, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetMultiTexImageEXT_ptr(texunit, target, level, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexLevelParameterfvEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexLevelParameterfvEXT, (%s, %s, %d, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexLevelParameterfvEXT_ptr(texunit, target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexLevelParameterivEXT_debug(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexLevelParameterivEXT, (%s, %s, %d, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexLevelParameterivEXT_ptr(texunit, target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexParameterIivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterIivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterIivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexParameterIuivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterIuivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterIuivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexParameterfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterfvEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMultiTexParameterivEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultiTexParameterivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMultiTexParameterivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferParameterivEXT_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameterivEXT, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameterivEXT_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferPointervEXT_debug(GLuint buffer, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferPointervEXT, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferPointervEXT_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferSubDataEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferSubDataEXT, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetNamedBufferSubDataEXT_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferAttachmentParameterivEXT_debug(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferAttachmentParameterivEXT, (%u, %s, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferAttachmentParameterivEXT_ptr(framebuffer, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferParameterivEXT_debug(GLuint framebuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameterivEXT, (%u, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferParameterivEXT_ptr(framebuffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramLocalParameterIivEXT_debug(GLuint program, GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterIivEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterIivEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramLocalParameterIuivEXT_debug(GLuint program, GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterIuivEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterIuivEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramLocalParameterdvEXT_debug(GLuint program, GLenum target, GLuint index, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterdvEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterdvEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramLocalParameterfvEXT_debug(GLuint program, GLenum target, GLuint index, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramLocalParameterfvEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetNamedProgramLocalParameterfvEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramStringEXT_debug(GLuint program, GLenum target, GLenum pname, void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramStringEXT, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)string)
    glatter_glGetNamedProgramStringEXT_ptr(program, target, pname, string);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedProgramivEXT_debug(GLuint program, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedProgramivEXT, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedProgramivEXT_ptr(program, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedRenderbufferParameterivEXT_debug(GLuint renderbuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedRenderbufferParameterivEXT, (%u, %s, %p), (unsigned int)renderbuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedRenderbufferParameterivEXT_ptr(renderbuffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointerIndexedvEXT_debug(GLenum target, GLuint index, void **data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointerIndexedvEXT, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetPointerIndexedvEXT_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointeri_vEXT_debug(GLenum pname, GLuint index, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointeri_vEXT, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)params)
    glatter_glGetPointeri_vEXT_ptr(pname, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureImageEXT_debug(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureImageEXT, (%u, %s, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glGetTextureImageEXT_ptr(texture, target, level, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameterfvEXT_debug(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterfvEXT, (%u, %s, %d, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterfvEXT_ptr(texture, target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameterivEXT_debug(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterivEXT, (%u, %s, %d, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterivEXT_ptr(texture, target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIuivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIuivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIuivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterfvEXT_debug(GLuint texture, GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterfvEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterfvEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterivEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIntegeri_vEXT_debug(GLuint vaobj, GLuint index, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIntegeri_vEXT, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIntegeri_vEXT_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIntegervEXT_debug(GLuint vaobj, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIntegervEXT, (%u, %s, %p), (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIntegervEXT_ptr(vaobj, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayPointeri_vEXT_debug(GLuint vaobj, GLuint index, GLenum pname, void **param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayPointeri_vEXT, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayPointeri_vEXT_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayPointervEXT_debug(GLuint vaobj, GLenum pname, void **param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayPointervEXT, (%u, %s, %p), (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayPointervEXT_ptr(vaobj, pname, param);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabledIndexedEXT_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledIndexedEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledIndexedEXT_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapNamedBufferEXT_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferEXT, (%u, %s), (unsigned int)buffer, enum_to_string_GL(access))
    void * rval = glatter_glMapNamedBufferEXT_ptr(buffer, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapNamedBufferRangeEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferRangeEXT, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapNamedBufferRangeEXT_ptr(buffer, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMatrixFrustumEXT_debug(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixFrustumEXT, (%s, %f, %f, %f, %f, %f, %f), enum_to_string_GL(mode), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glMatrixFrustumEXT_ptr(mode, left, right, bottom, top, zNear, zFar);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadIdentityEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadIdentityEXT, (%s), enum_to_string_GL(mode))
    glatter_glMatrixLoadIdentityEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadTransposedEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTransposedEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadTransposedEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadTransposefEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTransposefEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadTransposefEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoaddEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoaddEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoaddEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadfEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadfEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixLoadfEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultTransposedEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTransposedEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultTransposedEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultTransposefEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTransposefEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultTransposefEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultdEXT_debug(GLenum mode, const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultdEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultdEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultfEXT_debug(GLenum mode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultfEXT, (%s, %p), enum_to_string_GL(mode), (void*)m)
    glatter_glMatrixMultfEXT_ptr(mode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixOrthoEXT_debug(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixOrthoEXT, (%s, %f, %f, %f, %f, %f, %f), enum_to_string_GL(mode), (double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar)
    glatter_glMatrixOrthoEXT_ptr(mode, left, right, bottom, top, zNear, zFar);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixPopEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixPopEXT, (%s), enum_to_string_GL(mode))
    glatter_glMatrixPopEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixPushEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixPushEXT, (%s), enum_to_string_GL(mode))
    glatter_glMatrixPushEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixRotatedEXT_debug(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixRotatedEXT, (%s, %f, %f, %f, %f), enum_to_string_GL(mode), (double)angle, (double)x, (double)y, (double)z)
    glatter_glMatrixRotatedEXT_ptr(mode, angle, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixRotatefEXT_debug(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixRotatefEXT, (%s, %f, %f, %f, %f), enum_to_string_GL(mode), (float)angle, (float)x, (float)y, (float)z)
    glatter_glMatrixRotatefEXT_ptr(mode, angle, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixScaledEXT_debug(GLenum mode, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixScaledEXT, (%s, %f, %f, %f), enum_to_string_GL(mode), (double)x, (double)y, (double)z)
    glatter_glMatrixScaledEXT_ptr(mode, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixScalefEXT_debug(GLenum mode, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixScalefEXT, (%s, %f, %f, %f), enum_to_string_GL(mode), (float)x, (float)y, (float)z)
    glatter_glMatrixScalefEXT_ptr(mode, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixTranslatedEXT_debug(GLenum mode, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixTranslatedEXT, (%s, %f, %f, %f), enum_to_string_GL(mode), (double)x, (double)y, (double)z)
    glatter_glMatrixTranslatedEXT_ptr(mode, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixTranslatefEXT_debug(GLenum mode, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixTranslatefEXT, (%s, %f, %f, %f), enum_to_string_GL(mode), (float)x, (float)y, (float)z)
    glatter_glMatrixTranslatefEXT_ptr(mode, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexBufferEXT_debug(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexBufferEXT, (%s, %s, %s, %u), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glMultiTexBufferEXT_ptr(texunit, target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordPointerEXT_debug(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordPointerEXT, (%s, %d, %s, %d, %p), enum_to_string_GL(texunit), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glMultiTexCoordPointerEXT_ptr(texunit, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexEnvfEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvfEXT, (%s, %s, %s, %f), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexEnvfEXT_ptr(texunit, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexEnvfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexEnvfvEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexEnviEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnviEXT, (%s, %s, %s, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexEnviEXT_ptr(texunit, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexEnvivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexEnvivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexEnvivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGendEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLdouble param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGendEXT, (%s, %s, %s, %f), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (double)param)
    glatter_glMultiTexGendEXT_ptr(texunit, coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGendvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGendvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGendvEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGenfEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenfEXT, (%s, %s, %s, %f), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexGenfEXT_ptr(texunit, coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGenfvEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGenfvEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGeniEXT_debug(GLenum texunit, GLenum coord, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGeniEXT, (%s, %s, %s, %d), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexGeniEXT_ptr(texunit, coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexGenivEXT_debug(GLenum texunit, GLenum coord, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexGenivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexGenivEXT_ptr(texunit, coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage1DEXT, (%s, %s, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, width, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage2DEXT, (%s, %s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, width, height, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexImage3DEXT, (%s, %s, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexImage3DEXT_ptr(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameterIivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterIivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterIivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameterIuivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterIuivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterIuivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameterfEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterfEXT, (%s, %s, %s, %f), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glMultiTexParameterfEXT_ptr(texunit, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameterfvEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterfvEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterfvEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameteriEXT_debug(GLenum texunit, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameteriEXT, (%s, %s, %s, %d), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glMultiTexParameteriEXT_ptr(texunit, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexParameterivEXT_debug(GLenum texunit, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexParameterivEXT, (%s, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMultiTexParameterivEXT_ptr(texunit, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexRenderbufferEXT_debug(GLenum texunit, GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexRenderbufferEXT, (%s, %s, %u), enum_to_string_GL(texunit), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glMultiTexRenderbufferEXT_ptr(texunit, target, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexSubImage1DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage1DEXT, (%s, %s, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexSubImage2DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage2DEXT, (%s, %s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexSubImage3DEXT_debug(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexSubImage3DEXT, (%s, %s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(texunit), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferDataEXT_debug(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferDataEXT, (%u, %td, %p, %s), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glNamedBufferDataEXT_ptr(buffer, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferStorageEXT_debug(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorageEXT, (%u, %td, %p, %u), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glNamedBufferStorageEXT_ptr(buffer, size, data, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferSubDataEXT_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferSubDataEXT, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glNamedBufferSubDataEXT_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedCopyBufferSubDataEXT_debug(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedCopyBufferSubDataEXT, (%u, %u, %td, %td, %td), (unsigned int)readBuffer, (unsigned int)writeBuffer, (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glNamedCopyBufferSubDataEXT_ptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferParameteriEXT_debug(GLuint framebuffer, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferParameteriEXT, (%u, %s, %d), (unsigned int)framebuffer, enum_to_string_GL(pname), (int)param)
    glatter_glNamedFramebufferParameteriEXT_ptr(framebuffer, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferRenderbufferEXT_debug(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferRenderbufferEXT, (%u, %s, %s, %u), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glNamedFramebufferRenderbufferEXT_ptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTexture1DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture1DEXT, (%u, %s, %s, %u, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture1DEXT_ptr(framebuffer, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTexture2DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture2DEXT, (%u, %s, %s, %u, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture2DEXT_ptr(framebuffer, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTexture3DEXT_debug(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture3DEXT, (%u, %s, %s, %u, %d, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glNamedFramebufferTexture3DEXT_ptr(framebuffer, attachment, textarget, texture, level, zoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTextureEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureEXT, (%u, %s, %u, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTextureEXT_ptr(framebuffer, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTextureFaceEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureFaceEXT, (%u, %s, %u, %d, %s), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glNamedFramebufferTextureFaceEXT_ptr(framebuffer, attachment, texture, level, face);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTextureLayerEXT_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureLayerEXT, (%u, %s, %u, %d, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glNamedFramebufferTextureLayerEXT_ptr(framebuffer, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameter4dEXT_debug(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4dEXT, (%u, %s, %u, %f, %f, %f, %f), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glNamedProgramLocalParameter4dEXT_ptr(program, target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameter4dvEXT_debug(GLuint program, GLenum target, GLuint index, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4dvEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameter4dvEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameter4fEXT_debug(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4fEXT, (%u, %s, %u, %f, %f, %f, %f), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glNamedProgramLocalParameter4fEXT_ptr(program, target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameter4fvEXT_debug(GLuint program, GLenum target, GLuint index, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameter4fvEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameter4fvEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameterI4iEXT_debug(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4iEXT, (%u, %s, %u, %d, %d, %d, %d), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glNamedProgramLocalParameterI4iEXT_ptr(program, target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameterI4ivEXT_debug(GLuint program, GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4ivEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameterI4ivEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameterI4uiEXT_debug(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4uiEXT, (%u, %s, %u, %u, %u, %u, %u), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glNamedProgramLocalParameterI4uiEXT_ptr(program, target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameterI4uivEXT_debug(GLuint program, GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameterI4uivEXT, (%u, %s, %u, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glNamedProgramLocalParameterI4uivEXT_ptr(program, target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParameters4fvEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParameters4fvEXT, (%u, %s, %u, %d, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParameters4fvEXT_ptr(program, target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParametersI4ivEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParametersI4ivEXT, (%u, %s, %u, %d, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParametersI4ivEXT_ptr(program, target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramLocalParametersI4uivEXT_debug(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramLocalParametersI4uivEXT, (%u, %s, %u, %d, %p), (unsigned int)program, enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glNamedProgramLocalParametersI4uivEXT_ptr(program, target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedProgramStringEXT_debug(GLuint program, GLenum target, GLenum format, GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedProgramStringEXT, (%u, %s, %s, %d, %p), (unsigned int)program, enum_to_string_GL(target), enum_to_string_GL(format), (int)len, (void*)string)
    glatter_glNamedProgramStringEXT_ptr(program, target, format, len, string);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorageEXT_debug(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageEXT, (%u, %s, %d, %d), (unsigned int)renderbuffer, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageEXT_ptr(renderbuffer, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorageMultisampleCoverageEXT_debug(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisampleCoverageEXT, (%u, %d, %d, %s, %d, %d), (unsigned int)renderbuffer, (int)coverageSamples, (int)colorSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisampleCoverageEXT_ptr(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorageMultisampleEXT_debug(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisampleEXT, (%u, %d, %s, %d, %d), (unsigned int)renderbuffer, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisampleEXT_ptr(renderbuffer, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1dEXT_debug(GLuint program, GLint location, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dEXT, (%u, %d, %f), (unsigned int)program, (int)location, (double)x)
    glatter_glProgramUniform1dEXT_ptr(program, location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1dvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fEXT_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fEXT, (%u, %d, %f), (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1fEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1iEXT_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iEXT, (%u, %d, %d), (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1iEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uiEXT_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiEXT, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1uiEXT_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dEXT, (%u, %d, %f, %f), (unsigned int)program, (int)location, (double)x, (double)y)
    glatter_glProgramUniform2dEXT_ptr(program, location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2dvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fEXT, (%u, %d, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2fEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iEXT, (%u, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2iEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiEXT, (%u, %d, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2uiEXT_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dEXT, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (double)x, (double)y, (double)z)
    glatter_glProgramUniform3dEXT_ptr(program, location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3dvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fEXT, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3fEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iEXT, (%u, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3iEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiEXT, (%u, %d, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3uiEXT_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4dEXT_debug(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dEXT, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramUniform4dEXT_ptr(program, location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4dvEXT_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4dvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fEXT_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fEXT, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4fEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fvEXT_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fvEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fvEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4iEXT_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iEXT, (%u, %d, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4iEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ivEXT_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4ivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uiEXT_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiEXT, (%u, %d, %u, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4uiEXT_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uivEXT_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uivEXT, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uivEXT_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3dvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3dvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3dvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3fvEXT_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fvEXT, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fvEXT_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPushClientAttribDefaultEXT_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushClientAttribDefaultEXT, (%u), (unsigned int)mask)
    glatter_glPushClientAttribDefaultEXT_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBufferEXT_debug(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferEXT, (%u, %s, %s, %u), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTextureBufferEXT_ptr(texture, target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBufferRangeEXT_debug(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferRangeEXT, (%u, %s, %s, %u, %td, %td), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTextureBufferRangeEXT_ptr(texture, target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage1DEXT, (%u, %s, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage1DEXT_ptr(texture, target, level, internalformat, width, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DEXT, (%u, %s, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage2DEXT_ptr(texture, target, level, internalformat, width, height, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DEXT, (%u, %s, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureImage3DEXT_ptr(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexturePageCommitmentEXT_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexturePageCommitmentEXT, (%u, %d, %d, %d, %d, %d, %d, %d, %u), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (unsigned char)commit)
    glatter_glTexturePageCommitmentEXT_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIuivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIuivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIuivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterfEXT_debug(GLuint texture, GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfEXT, (%u, %s, %s, %f), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glTextureParameterfEXT_ptr(texture, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterfvEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfvEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterfvEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameteriEXT_debug(GLuint texture, GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteriEXT, (%u, %s, %s, %d), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTextureParameteriEXT_ptr(texture, target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterivEXT_debug(GLuint texture, GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterivEXT, (%u, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterivEXT_ptr(texture, target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureRenderbufferEXT_debug(GLuint texture, GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureRenderbufferEXT, (%u, %s, %u), (unsigned int)texture, enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glTextureRenderbufferEXT_ptr(texture, target, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage1DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1DEXT, (%u, %s, %d, %s, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1DEXT_ptr(texture, target, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DEXT, (%u, %s, %d, %s, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2DEXT_ptr(texture, target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2DMultisampleEXT_debug(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DMultisampleEXT, (%u, %s, %d, %s, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage2DMultisampleEXT_ptr(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3DEXT_debug(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DEXT, (%u, %s, %d, %s, %d, %d, %d), (unsigned int)texture, enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3DEXT_ptr(texture, target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3DMultisampleEXT_debug(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DMultisampleEXT, (%u, %s, %d, %s, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage3DMultisampleEXT_ptr(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage1DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage1DEXT, (%u, %s, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage1DEXT_ptr(texture, target, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage2DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage2DEXT, (%u, %s, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage3DEXT_debug(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage3DEXT, (%u, %s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glUnmapNamedBufferEXT_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapNamedBufferEXT, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glUnmapNamedBufferEXT_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVertexArrayBindVertexBufferEXT_debug(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayBindVertexBufferEXT, (%u, %u, %u, %td, %d), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glVertexArrayBindVertexBufferEXT_ptr(vaobj, bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayColorOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayColorOffsetEXT, (%u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayColorOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayEdgeFlagOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayEdgeFlagOffsetEXT, (%u, %u, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayEdgeFlagOffsetEXT_ptr(vaobj, buffer, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayFogCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayFogCoordOffsetEXT, (%u, %u, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayFogCoordOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayIndexOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayIndexOffsetEXT, (%u, %u, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayIndexOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayMultiTexCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayMultiTexCoordOffsetEXT, (%u, %u, %s, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(texunit), (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayMultiTexCoordOffsetEXT_ptr(vaobj, buffer, texunit, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayNormalOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayNormalOffsetEXT, (%u, %u, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayNormalOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArraySecondaryColorOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArraySecondaryColorOffsetEXT, (%u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArraySecondaryColorOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayTexCoordOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayTexCoordOffsetEXT, (%u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayTexCoordOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribBindingEXT_debug(GLuint vaobj, GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribBindingEXT, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexArrayVertexAttribBindingEXT_ptr(vaobj, attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribDivisorEXT_debug(GLuint vaobj, GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribDivisorEXT, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexArrayVertexAttribDivisorEXT_ptr(vaobj, index, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribFormatEXT, (%u, %u, %d, %s, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribFormatEXT_ptr(vaobj, attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribIFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribIFormatEXT, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribIFormatEXT_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribIOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribIOffsetEXT, (%u, %u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayVertexAttribIOffsetEXT_ptr(vaobj, buffer, index, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribLFormatEXT_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribLFormatEXT, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayVertexAttribLFormatEXT_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribLOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribLOffsetEXT, (%u, %u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayVertexAttribLOffsetEXT_ptr(vaobj, buffer, index, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexAttribOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexAttribOffsetEXT, (%u, %u, %u, %d, %s, %u, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayVertexAttribOffsetEXT_ptr(vaobj, buffer, index, size, type, normalized, stride, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexBindingDivisorEXT_debug(GLuint vaobj, GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBindingDivisorEXT, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexArrayVertexBindingDivisorEXT_ptr(vaobj, bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexOffsetEXT_debug(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexOffsetEXT, (%u, %u, %d, %s, %d, %td), (unsigned int)vaobj, (unsigned int)buffer, (int)size, enum_to_string_GL(type), (int)stride, (ptrdiff_t)offset)
    glatter_glVertexArrayVertexOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_direct_state_access
#ifdef GL_EXT_draw_buffers2
void glatter_glColorMaskIndexedEXT_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaskIndexedEXT, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaskIndexedEXT_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_buffers2
#ifdef GL_EXT_draw_instanced
void glatter_glDrawArraysInstancedEXT_debug(GLenum mode, GLint start, GLsizei count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedEXT, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)start, (int)count, (int)primcount)
    glatter_glDrawArraysInstancedEXT_ptr(mode, start, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedEXT_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedEXT, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glDrawElementsInstancedEXT_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_instanced
#ifdef GL_EXT_draw_range_elements
void glatter_glDrawRangeElementsEXT_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElementsEXT, (%s, %u, %u, %d, %s, %p), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElementsEXT_ptr(mode, start, end, count, type, indices);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_draw_range_elements
#ifdef GL_EXT_fog_coord
void glatter_glFogCoordPointerEXT_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointerEXT, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glFogCoordPointerEXT_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoorddEXT_debug(GLdouble coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddEXT, (%f), (double)coord)
    glatter_glFogCoorddEXT_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoorddvEXT_debug(const GLdouble *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddvEXT, (%p), (void*)coord)
    glatter_glFogCoorddvEXT_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordfEXT_debug(GLfloat coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfEXT, (%f), (float)coord)
    glatter_glFogCoordfEXT_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordfvEXT_debug(const GLfloat *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfvEXT, (%p), (void*)coord)
    glatter_glFogCoordfvEXT_ptr(coord);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_fog_coord
#ifdef GL_EXT_framebuffer_blit
void glatter_glBlitFramebufferEXT_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebufferEXT, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebufferEXT_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_framebuffer_blit
#ifdef GL_EXT_framebuffer_multisample
void glatter_glRenderbufferStorageMultisampleEXT_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleEXT, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleEXT_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_framebuffer_multisample
#ifdef GL_EXT_framebuffer_object
void glatter_glBindFramebufferEXT_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebufferEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebufferEXT_ptr(target, framebuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindRenderbufferEXT_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbufferEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbufferEXT_ptr(target, renderbuffer);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckFramebufferStatusEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatusEXT, (%s), enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatusEXT_ptr(target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteFramebuffersEXT_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffersEXT, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffersEXT_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteRenderbuffersEXT_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffersEXT, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffersEXT_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferRenderbufferEXT_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbufferEXT, (%s, %s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbufferEXT_ptr(target, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture1DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture1DEXT, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture1DEXT_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture2DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2DEXT, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2DEXT_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture3DEXT_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3DEXT, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3DEXT_ptr(target, attachment, textarget, texture, level, zoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFramebuffersEXT_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffersEXT, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glGenFramebuffersEXT_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenRenderbuffersEXT_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffersEXT, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffersEXT_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateMipmapEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmapEXT, (%s), enum_to_string_GL(target))
    glatter_glGenerateMipmapEXT_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFramebufferAttachmentParameterivEXT_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameterivEXT, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameterivEXT_ptr(target, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetRenderbufferParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsFramebufferEXT_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebufferEXT, (%u), (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebufferEXT_ptr(framebuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsRenderbufferEXT_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbufferEXT, (%u), (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbufferEXT_ptr(renderbuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glRenderbufferStorageEXT_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageEXT, (%s, %s, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageEXT_ptr(target, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_framebuffer_object
#ifdef GL_EXT_geometry_shader4
void glatter_glProgramParameteriEXT_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteriEXT, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteriEXT_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_geometry_shader4
#ifdef GL_EXT_gpu_program_parameters
void glatter_glProgramEnvParameters4fvEXT_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameters4fvEXT, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParameters4fvEXT_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameters4fvEXT_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameters4fvEXT, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParameters4fvEXT_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_gpu_program_parameters
#ifdef GL_EXT_gpu_shader4
void glatter_glBindFragDataLocationEXT_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationEXT, (%u, %u, %p), (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocationEXT_ptr(program, color, name);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataLocationEXT_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocationEXT, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocationEXT_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformuivEXT_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuivEXT, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuivEXT_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1uiEXT_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiEXT, (%d, %u), (int)location, (unsigned int)v0)
    glatter_glUniform1uiEXT_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uivEXT, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1uivEXT_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2uiEXT_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiEXT, (%d, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2uiEXT_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uivEXT, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2uivEXT_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3uiEXT_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiEXT, (%d, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3uiEXT_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uivEXT, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3uivEXT_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4uiEXT_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiEXT, (%d, %u, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4uiEXT_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4uivEXT_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uivEXT, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4uivEXT_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_gpu_shader4
#ifdef GL_EXT_histogram
void glatter_glGetHistogramEXT_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramEXT, (%s, %u, %s, %s, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetHistogramEXT_ptr(target, reset, format, type, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogramParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogramParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmaxEXT_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxEXT, (%s, %u, %s, %s, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (void*)values)
    glatter_glGetMinmaxEXT_ptr(target, reset, format, type, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmaxParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMinmaxParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMinmaxParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMinmaxParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glHistogramEXT_debug(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHistogramEXT, (%s, %d, %s, %u), enum_to_string_GL(target), (int)width, enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glHistogramEXT_ptr(target, width, internalformat, sink);
    glatter_check_error_GL(file, line);
}
void glatter_glMinmaxEXT_debug(GLenum target, GLenum internalformat, GLboolean sink, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinmaxEXT, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned char)sink)
    glatter_glMinmaxEXT_ptr(target, internalformat, sink);
    glatter_check_error_GL(file, line);
}
void glatter_glResetHistogramEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetHistogramEXT, (%s), enum_to_string_GL(target))
    glatter_glResetHistogramEXT_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glResetMinmaxEXT_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResetMinmaxEXT, (%s), enum_to_string_GL(target))
    glatter_glResetMinmaxEXT_ptr(target);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_histogram
#ifdef GL_EXT_index_func
void glatter_glIndexFuncEXT_debug(GLenum func, GLclampf ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexFuncEXT, (%s, %f), enum_to_string_GL(func), (float)ref)
    glatter_glIndexFuncEXT_ptr(func, ref);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_index_func
#ifdef GL_EXT_index_material
void glatter_glIndexMaterialEXT_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexMaterialEXT, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glIndexMaterialEXT_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_index_material
#ifdef GL_EXT_light_texture
void glatter_glApplyTextureEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyTextureEXT, (%s), enum_to_string_GL(mode))
    glatter_glApplyTextureEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureLightEXT_debug(GLenum pname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureLightEXT, (%s), enum_to_string_GL(pname))
    glatter_glTextureLightEXT_ptr(pname);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureMaterialEXT_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureMaterialEXT, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glTextureMaterialEXT_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_light_texture
#ifdef GL_EXT_multi_draw_arrays
void glatter_glMultiDrawArraysEXT_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysEXT, (%s, %p, %p, %d), enum_to_string_GL(mode), (void*)first, (void*)count, (int)primcount)
    glatter_glMultiDrawArraysEXT_ptr(mode, first, count, primcount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsEXT_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsEXT, (%s, %p, %s, %p, %d), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount)
    glatter_glMultiDrawElementsEXT_ptr(mode, count, type, indices, primcount);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multi_draw_arrays
#ifdef GL_EXT_multisample
void glatter_glSampleMaskEXT_debug(GLclampf value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskEXT, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleMaskEXT_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplePatternEXT_debug(GLenum pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplePatternEXT, (%s), enum_to_string_GL(pattern))
    glatter_glSamplePatternEXT_ptr(pattern);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_multisample
#ifdef GL_EXT_paletted_texture
void glatter_glColorTableEXT_debug(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableEXT, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalFormat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTableEXT_ptr(target, internalFormat, width, format, type, table);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableEXT_debug(GLenum target, GLenum format, GLenum type, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableEXT, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glGetColorTableEXT_ptr(target, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_paletted_texture
#ifdef GL_EXT_pixel_transform
void glatter_glGetPixelTransformParameterfvEXT_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTransformParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTransformParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelTransformParameterivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTransformParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTransformParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransformParameterfEXT_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterfEXT, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glPixelTransformParameterfEXT_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransformParameterfvEXT_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterfvEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTransformParameterfvEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransformParameteriEXT_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameteriEXT, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glPixelTransformParameteriEXT_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransformParameterivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransformParameterivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTransformParameterivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_pixel_transform
#ifdef GL_EXT_point_parameters
void glatter_glPointParameterfEXT_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfEXT, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfEXT_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterfvEXT_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvEXT, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvEXT_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_point_parameters
#ifdef GL_EXT_polygon_offset
void glatter_glPolygonOffsetEXT_debug(GLfloat factor, GLfloat bias, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetEXT, (%f, %f), (float)factor, (float)bias)
    glatter_glPolygonOffsetEXT_ptr(factor, bias);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_polygon_offset
#ifdef GL_EXT_polygon_offset_clamp
void glatter_glPolygonOffsetClampEXT_debug(GLfloat factor, GLfloat units, GLfloat clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetClampEXT, (%f, %f, %f), (float)factor, (float)units, (float)clamp)
    glatter_glPolygonOffsetClampEXT_ptr(factor, units, clamp);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_polygon_offset_clamp
#ifdef GL_EXT_provoking_vertex
void glatter_glProvokingVertexEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProvokingVertexEXT, (%s), enum_to_string_GL(mode))
    glatter_glProvokingVertexEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_provoking_vertex
#ifdef GL_EXT_raster_multisample
void glatter_glRasterSamplesEXT_debug(GLuint samples, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterSamplesEXT, (%u, %u), (unsigned int)samples, (unsigned char)fixedsamplelocations)
    glatter_glRasterSamplesEXT_ptr(samples, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_raster_multisample
#ifdef GL_EXT_secondary_color
void glatter_glSecondaryColor3bEXT_debug(GLbyte red, GLbyte green, GLbyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bEXT, (%d, %d, %d), (signed char)red, (signed char)green, (signed char)blue)
    glatter_glSecondaryColor3bEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3bvEXT_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bvEXT, (%p), (void*)v)
    glatter_glSecondaryColor3bvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3dEXT_debug(GLdouble red, GLdouble green, GLdouble blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dEXT, (%f, %f, %f), (double)red, (double)green, (double)blue)
    glatter_glSecondaryColor3dEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3dvEXT_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dvEXT, (%p), (void*)v)
    glatter_glSecondaryColor3dvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3fEXT_debug(GLfloat red, GLfloat green, GLfloat blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fEXT, (%f, %f, %f), (float)red, (float)green, (float)blue)
    glatter_glSecondaryColor3fEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3fvEXT_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fvEXT, (%p), (void*)v)
    glatter_glSecondaryColor3fvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3iEXT_debug(GLint red, GLint green, GLint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3iEXT, (%d, %d, %d), (int)red, (int)green, (int)blue)
    glatter_glSecondaryColor3iEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ivEXT_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ivEXT, (%p), (void*)v)
    glatter_glSecondaryColor3ivEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3sEXT_debug(GLshort red, GLshort green, GLshort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3sEXT, (%hi, %hi, %hi), (short)red, (short)green, (short)blue)
    glatter_glSecondaryColor3sEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3svEXT_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3svEXT, (%p), (void*)v)
    glatter_glSecondaryColor3svEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ubEXT_debug(GLubyte red, GLubyte green, GLubyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubEXT, (%u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue)
    glatter_glSecondaryColor3ubEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ubvEXT_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubvEXT, (%p), (void*)v)
    glatter_glSecondaryColor3ubvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3uiEXT_debug(GLuint red, GLuint green, GLuint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uiEXT, (%u, %u, %u), (unsigned int)red, (unsigned int)green, (unsigned int)blue)
    glatter_glSecondaryColor3uiEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3uivEXT_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uivEXT, (%p), (void*)v)
    glatter_glSecondaryColor3uivEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3usEXT_debug(GLushort red, GLushort green, GLushort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usEXT, (%hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3usEXT_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3usvEXT_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usvEXT, (%p), (void*)v)
    glatter_glSecondaryColor3usvEXT_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorPointerEXT_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointerEXT, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glSecondaryColorPointerEXT_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_secondary_color
#ifdef GL_EXT_separate_shader_objects
void glatter_glActiveProgramEXT_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveProgramEXT, (%u), (unsigned int)program)
    glatter_glActiveProgramEXT_ptr(program);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramEXT_debug(GLenum type, const GLchar *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramEXT, (%s, %p), enum_to_string_GL(type), (void*)string)
    GLuint rval = glatter_glCreateShaderProgramEXT_ptr(type, string);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glUseShaderProgramEXT_debug(GLenum type, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseShaderProgramEXT, (%s, %u), enum_to_string_GL(type), (unsigned int)program)
    glatter_glUseShaderProgramEXT_ptr(type, program);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_separate_shader_objects
#ifdef GL_EXT_shader_image_load_store
void glatter_glBindImageTextureEXT_debug(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTextureEXT, (%u, %u, %d, %u, %d, %s, %d), (unsigned int)index, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), (int)format)
    glatter_glBindImageTextureEXT_ptr(index, texture, level, layered, layer, access, format);
    glatter_check_error_GL(file, line);
}
void glatter_glMemoryBarrierEXT_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierEXT, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrierEXT_ptr(barriers);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_shader_image_load_store
#ifdef GL_EXT_stencil_clear_tag
void glatter_glStencilClearTagEXT_debug(GLsizei stencilTagBits, GLuint stencilClearTag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilClearTagEXT, (%d, %u), (int)stencilTagBits, (unsigned int)stencilClearTag)
    glatter_glStencilClearTagEXT_ptr(stencilTagBits, stencilClearTag);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_stencil_clear_tag
#ifdef GL_EXT_stencil_two_side
void glatter_glActiveStencilFaceEXT_debug(GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveStencilFaceEXT, (%s), enum_to_string_GL(face))
    glatter_glActiveStencilFaceEXT_ptr(face);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_stencil_two_side
#ifdef GL_EXT_subtexture
void glatter_glTexSubImage1DEXT_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage1DEXT, (%s, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage1DEXT_ptr(target, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage2DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage2DEXT, (%s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage2DEXT_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_subtexture
#ifdef GL_EXT_texture3D
void glatter_glTexImage3DEXT_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DEXT, (%s, %d, %s, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3DEXT_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage3DEXT_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3DEXT, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3DEXT_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture3D
#ifdef GL_EXT_texture_array
void glatter_glFramebufferTextureLayerEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayerEXT, (%s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayerEXT_ptr(target, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_array
#ifdef GL_EXT_texture_buffer_object
void glatter_glTexBufferEXT_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferEXT, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBufferEXT_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_buffer_object
#ifdef GL_EXT_texture_integer
void glatter_glClearColorIiEXT_debug(GLint red, GLint green, GLint blue, GLint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorIiEXT, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glClearColorIiEXT_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearColorIuiEXT_debug(GLuint red, GLuint green, GLuint blue, GLuint alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorIuiEXT, (%u, %u, %u, %u), (unsigned int)red, (unsigned int)green, (unsigned int)blue, (unsigned int)alpha)
    glatter_glClearColorIuiEXT_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIivEXT_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuivEXT_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIivEXT_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuivEXT_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuivEXT, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuivEXT_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_integer
#ifdef GL_EXT_texture_object
GLboolean glatter_glAreTexturesResidentEXT_debug(GLsizei n, const GLuint *textures, GLboolean *residences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAreTexturesResidentEXT, (%d, %p, %p), (int)n, (void*)textures, (void*)residences)
    GLboolean rval = glatter_glAreTexturesResidentEXT_ptr(n, textures, residences);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glBindTextureEXT_debug(GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureEXT, (%s, %u), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindTextureEXT_ptr(target, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTexturesEXT_debug(GLsizei n, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTexturesEXT, (%d, %p), (int)n, (void*)textures)
    glatter_glDeleteTexturesEXT_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTexturesEXT_debug(GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTexturesEXT, (%d, %p), (int)n, (void*)textures)
    glatter_glGenTexturesEXT_ptr(n, textures);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsTextureEXT_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureEXT, (%u), (unsigned int)texture)
    GLboolean rval = glatter_glIsTextureEXT_ptr(texture);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPrioritizeTexturesEXT_debug(GLsizei n, const GLuint *textures, const GLclampf *priorities, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrioritizeTexturesEXT, (%d, %p, %p), (int)n, (void*)textures, (void*)priorities)
    glatter_glPrioritizeTexturesEXT_ptr(n, textures, priorities);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_object
#ifdef GL_EXT_texture_perturb_normal
void glatter_glTextureNormalEXT_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureNormalEXT, (%s), enum_to_string_GL(mode))
    glatter_glTextureNormalEXT_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_texture_perturb_normal
#ifdef GL_EXT_timer_query
void glatter_glGetQueryObjecti64vEXT_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64vEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64vEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectui64vEXT_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64vEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64vEXT_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_timer_query
#ifdef GL_EXT_transform_feedback
void glatter_glBeginTransformFeedbackEXT_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedbackEXT, (%s), enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedbackEXT_ptr(primitiveMode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferBaseEXT_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBaseEXT, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBaseEXT_ptr(target, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferOffsetEXT_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferOffsetEXT, (%s, %u, %u, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset)
    glatter_glBindBufferOffsetEXT_ptr(target, index, buffer, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferRangeEXT_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRangeEXT, (%s, %u, %u, %td, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glBindBufferRangeEXT_ptr(target, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glEndTransformFeedbackEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedbackEXT, ())
    glatter_glEndTransformFeedbackEXT_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackVaryingEXT_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVaryingEXT, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVaryingEXT_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackVaryingsEXT_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryingsEXT, (%u, %d, %p, %s), (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryingsEXT_ptr(program, count, varyings, bufferMode);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_transform_feedback
#ifdef GL_EXT_vertex_array
void glatter_glArrayElementEXT_debug(GLint i, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glArrayElementEXT, (%d), (int)i)
    glatter_glArrayElementEXT_ptr(i);
    glatter_check_error_GL(file, line);
}
void glatter_glColorPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointerEXT, (%d, %s, %d, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glColorPointerEXT_ptr(size, type, stride, count, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysEXT_debug(GLenum mode, GLint first, GLsizei count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysEXT, (%s, %d, %d), enum_to_string_GL(mode), (int)first, (int)count)
    glatter_glDrawArraysEXT_ptr(mode, first, count);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlagPointerEXT_debug(GLsizei stride, GLsizei count, const GLboolean *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagPointerEXT, (%d, %d, %p), (int)stride, (int)count, (void*)pointer)
    glatter_glEdgeFlagPointerEXT_ptr(stride, count, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPointervEXT_debug(GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPointervEXT, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPointervEXT_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexPointerEXT_debug(GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexPointerEXT, (%s, %d, %d, %p), enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glIndexPointerEXT_ptr(type, stride, count, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalPointerEXT_debug(GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointerEXT, (%s, %d, %d, %p), enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glNormalPointerEXT_ptr(type, stride, count, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointerEXT, (%d, %s, %d, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glTexCoordPointerEXT_ptr(size, type, stride, count, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexPointerEXT_debug(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointerEXT, (%d, %s, %d, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (int)count, (void*)pointer)
    glatter_glVertexPointerEXT_ptr(size, type, stride, count, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_vertex_array
#ifdef GL_EXT_vertex_attrib_64bit
void glatter_glGetVertexAttribLdvEXT_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLdvEXT, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLdvEXT_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1dEXT_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dEXT, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttribL1dEXT_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1dvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2dEXT_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dEXT, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttribL2dEXT_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2dvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3dEXT_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dEXT, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttribL3dEXT_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3dvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4dEXT_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dEXT, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttribL4dEXT_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4dvEXT_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4dvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLPointerEXT_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLPointerEXT, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribLPointerEXT_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_vertex_attrib_64bit
#ifdef GL_EXT_vertex_shader
void glatter_glBeginVertexShaderEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginVertexShaderEXT, ())
    glatter_glBeginVertexShaderEXT_ptr();
    glatter_check_error_GL(file, line);
}
GLuint glatter_glBindLightParameterEXT_debug(GLenum light, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindLightParameterEXT, (%s, %s), enum_to_string_GL(light), enum_to_string_GL(value))
    GLuint rval = glatter_glBindLightParameterEXT_ptr(light, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glBindMaterialParameterEXT_debug(GLenum face, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindMaterialParameterEXT, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(value))
    GLuint rval = glatter_glBindMaterialParameterEXT_ptr(face, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glBindParameterEXT_debug(GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindParameterEXT, (%s), enum_to_string_GL(value))
    GLuint rval = glatter_glBindParameterEXT_ptr(value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glBindTexGenParameterEXT_debug(GLenum unit, GLenum coord, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTexGenParameterEXT, (%s, %s, %s), enum_to_string_GL(unit), enum_to_string_GL(coord), enum_to_string_GL(value))
    GLuint rval = glatter_glBindTexGenParameterEXT_ptr(unit, coord, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glBindTextureUnitParameterEXT_debug(GLenum unit, GLenum value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureUnitParameterEXT, (%s, %s), enum_to_string_GL(unit), enum_to_string_GL(value))
    GLuint rval = glatter_glBindTextureUnitParameterEXT_ptr(unit, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glBindVertexShaderEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexShaderEXT, (%u), (unsigned int)id)
    glatter_glBindVertexShaderEXT_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexShaderEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexShaderEXT, (%u), (unsigned int)id)
    glatter_glDeleteVertexShaderEXT_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVariantClientStateEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVariantClientStateEXT, (%u), (unsigned int)id)
    glatter_glDisableVariantClientStateEXT_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVariantClientStateEXT_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVariantClientStateEXT, (%u), (unsigned int)id)
    glatter_glEnableVariantClientStateEXT_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glEndVertexShaderEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndVertexShaderEXT, ())
    glatter_glEndVertexShaderEXT_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glExtractComponentEXT_debug(GLuint res, GLuint src, GLuint num, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExtractComponentEXT, (%u, %u, %u), (unsigned int)res, (unsigned int)src, (unsigned int)num)
    glatter_glExtractComponentEXT_ptr(res, src, num);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenSymbolsEXT_debug(GLenum datatype, GLenum storagetype, GLenum range, GLuint components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSymbolsEXT, (%s, %s, %s, %u), enum_to_string_GL(datatype), enum_to_string_GL(storagetype), enum_to_string_GL(range), (unsigned int)components)
    GLuint rval = glatter_glGenSymbolsEXT_ptr(datatype, storagetype, range, components);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glGenVertexShadersEXT_debug(GLuint range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexShadersEXT, (%u), (unsigned int)range)
    GLuint rval = glatter_glGenVertexShadersEXT_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetInvariantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantBooleanvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantBooleanvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInvariantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantFloatvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantFloatvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInvariantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInvariantIntegervEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetInvariantIntegervEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLocalConstantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantBooleanvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantBooleanvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLocalConstantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantFloatvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantFloatvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLocalConstantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLocalConstantIntegervEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetLocalConstantIntegervEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantBooleanvEXT_debug(GLuint id, GLenum value, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantBooleanvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantBooleanvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantFloatvEXT_debug(GLuint id, GLenum value, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantFloatvEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantFloatvEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantIntegervEXT_debug(GLuint id, GLenum value, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantIntegervEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantIntegervEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVariantPointervEXT_debug(GLuint id, GLenum value, void **data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVariantPointervEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(value), (void*)data)
    glatter_glGetVariantPointervEXT_ptr(id, value, data);
    glatter_check_error_GL(file, line);
}
void glatter_glInsertComponentEXT_debug(GLuint res, GLuint src, GLuint num, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInsertComponentEXT, (%u, %u, %u), (unsigned int)res, (unsigned int)src, (unsigned int)num)
    glatter_glInsertComponentEXT_ptr(res, src, num);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsVariantEnabledEXT_debug(GLuint id, GLenum cap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVariantEnabledEXT, (%u, %s), (unsigned int)id, enum_to_string_GL(cap))
    GLboolean rval = glatter_glIsVariantEnabledEXT_ptr(id, cap);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glSetInvariantEXT_debug(GLuint id, GLenum type, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetInvariantEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(type), (void*)addr)
    glatter_glSetInvariantEXT_ptr(id, type, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glSetLocalConstantEXT_debug(GLuint id, GLenum type, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetLocalConstantEXT, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(type), (void*)addr)
    glatter_glSetLocalConstantEXT_ptr(id, type, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderOp1EXT_debug(GLenum op, GLuint res, GLuint arg1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp1EXT, (%s, %u, %u), enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1)
    glatter_glShaderOp1EXT_ptr(op, res, arg1);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderOp2EXT_debug(GLenum op, GLuint res, GLuint arg1, GLuint arg2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp2EXT, (%s, %u, %u, %u), enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1, (unsigned int)arg2)
    glatter_glShaderOp2EXT_ptr(op, res, arg1, arg2);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderOp3EXT_debug(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderOp3EXT, (%s, %u, %u, %u, %u), enum_to_string_GL(op), (unsigned int)res, (unsigned int)arg1, (unsigned int)arg2, (unsigned int)arg3)
    glatter_glShaderOp3EXT_ptr(op, res, arg1, arg2, arg3);
    glatter_check_error_GL(file, line);
}
void glatter_glSwizzleEXT_debug(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSwizzleEXT, (%u, %u, %s, %s, %s, %s), (unsigned int)res, (unsigned int)in, enum_to_string_GL(outX), enum_to_string_GL(outY), enum_to_string_GL(outZ), enum_to_string_GL(outW))
    glatter_glSwizzleEXT_ptr(res, in, outX, outY, outZ, outW);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantPointerEXT_debug(GLuint id, GLenum type, GLuint stride, const void *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantPointerEXT, (%u, %s, %u, %p), (unsigned int)id, enum_to_string_GL(type), (unsigned int)stride, (void*)addr)
    glatter_glVariantPointerEXT_ptr(id, type, stride, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantbvEXT_debug(GLuint id, const GLbyte *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantbvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantbvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantdvEXT_debug(GLuint id, const GLdouble *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantdvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantdvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantfvEXT_debug(GLuint id, const GLfloat *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantfvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantfvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantivEXT_debug(GLuint id, const GLint *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantivEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantivEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantsvEXT_debug(GLuint id, const GLshort *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantsvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantsvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantubvEXT_debug(GLuint id, const GLubyte *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantubvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantubvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantuivEXT_debug(GLuint id, const GLuint *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantuivEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantuivEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glVariantusvEXT_debug(GLuint id, const GLushort *addr, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVariantusvEXT, (%u, %p), (unsigned int)id, (void*)addr)
    glatter_glVariantusvEXT_ptr(id, addr);
    glatter_check_error_GL(file, line);
}
void glatter_glWriteMaskEXT_debug(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWriteMaskEXT, (%u, %u, %s, %s, %s, %s), (unsigned int)res, (unsigned int)in, enum_to_string_GL(outX), enum_to_string_GL(outY), enum_to_string_GL(outZ), enum_to_string_GL(outW))
    glatter_glWriteMaskEXT_ptr(res, in, outX, outY, outZ, outW);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_vertex_shader
#ifdef GL_EXT_vertex_weighting
void glatter_glVertexWeightPointerEXT_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightPointerEXT, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexWeightPointerEXT_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexWeightfEXT_debug(GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightfEXT, (%f), (float)weight)
    glatter_glVertexWeightfEXT_ptr(weight);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexWeightfvEXT_debug(const GLfloat *weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeightfvEXT, (%p), (void*)weight)
    glatter_glVertexWeightfvEXT_ptr(weight);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_vertex_weighting
#ifdef GL_EXT_window_rectangles
void glatter_glWindowRectanglesEXT_debug(GLenum mode, GLsizei count, const GLint *box, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowRectanglesEXT, (%s, %d, %p), enum_to_string_GL(mode), (int)count, (void*)box)
    glatter_glWindowRectanglesEXT_ptr(mode, count, box);
    glatter_check_error_GL(file, line);
}
#endif // GL_EXT_window_rectangles
#ifdef GL_EXT_x11_sync_object
GLsync glatter_glImportSyncEXT_debug(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImportSyncEXT, (%s, %td, %u), enum_to_string_GL(external_sync_type), (ptrdiff_t)external_sync, (unsigned int)flags)
    GLsync rval = glatter_glImportSyncEXT_ptr(external_sync_type, external_sync, flags);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_EXT_x11_sync_object
#ifdef GL_GREMEDY_frame_terminator
void glatter_glFrameTerminatorGREMEDY_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrameTerminatorGREMEDY, ())
    glatter_glFrameTerminatorGREMEDY_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_GREMEDY_frame_terminator
#ifdef GL_GREMEDY_string_marker
void glatter_glStringMarkerGREMEDY_debug(GLsizei len, const void *string, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStringMarkerGREMEDY, (%d, %p), (int)len, (void*)string)
    glatter_glStringMarkerGREMEDY_ptr(len, string);
    glatter_check_error_GL(file, line);
}
#endif // GL_GREMEDY_string_marker
#ifdef GL_HP_image_transform
void glatter_glGetImageTransformParameterfvHP_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageTransformParameterfvHP, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetImageTransformParameterfvHP_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetImageTransformParameterivHP_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageTransformParameterivHP, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetImageTransformParameterivHP_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glImageTransformParameterfHP_debug(GLenum target, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterfHP, (%s, %s, %f), enum_to_string_GL(target), enum_to_string_GL(pname), (float)param)
    glatter_glImageTransformParameterfHP_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glImageTransformParameterfvHP_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterfvHP, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glImageTransformParameterfvHP_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glImageTransformParameteriHP_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameteriHP, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glImageTransformParameteriHP_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glImageTransformParameterivHP_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glImageTransformParameterivHP, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glImageTransformParameterivHP_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_HP_image_transform
#ifdef GL_IBM_multimode_draw_arrays
void glatter_glMultiModeDrawArraysIBM_debug(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiModeDrawArraysIBM, (%p, %p, %p, %d, %d), (void*)mode, (void*)first, (void*)count, (int)primcount, (int)modestride)
    glatter_glMultiModeDrawArraysIBM_ptr(mode, first, count, primcount, modestride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiModeDrawElementsIBM_debug(const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiModeDrawElementsIBM, (%p, %p, %s, %p, %d, %d), (void*)mode, (void*)count, enum_to_string_GL(type), (void*)indices, (int)primcount, (int)modestride)
    glatter_glMultiModeDrawElementsIBM_ptr(mode, count, type, indices, primcount, modestride);
    glatter_check_error_GL(file, line);
}
#endif // GL_IBM_multimode_draw_arrays
#ifdef GL_IBM_static_data
void glatter_glFlushStaticDataIBM_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushStaticDataIBM, (%s), enum_to_string_GL(target))
    glatter_glFlushStaticDataIBM_ptr(target);
    glatter_check_error_GL(file, line);
}
#endif // GL_IBM_static_data
#ifdef GL_IBM_vertex_array_lists
void glatter_glColorPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointerListIBM, (%d, %s, %d, %p, %d), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glColorPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlagPointerListIBM_debug(GLint stride, const GLboolean **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagPointerListIBM, (%d, %p, %d), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glEdgeFlagPointerListIBM_ptr(stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointerListIBM, (%s, %d, %p, %d), enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glFogCoordPointerListIBM_ptr(type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexPointerListIBM, (%s, %d, %p, %d), enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glIndexPointerListIBM_ptr(type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalPointerListIBM_debug(GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointerListIBM, (%s, %d, %p, %d), enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glNormalPointerListIBM_ptr(type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointerListIBM, (%d, %s, %d, %p, %d), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glSecondaryColorPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointerListIBM, (%d, %s, %d, %p, %d), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glTexCoordPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexPointerListIBM_debug(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointerListIBM, (%d, %s, %d, %p, %d), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer, (int)ptrstride)
    glatter_glVertexPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
    glatter_check_error_GL(file, line);
}
#endif // GL_IBM_vertex_array_lists
#ifdef GL_INGR_blend_func_separate
void glatter_glBlendFuncSeparateINGR_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparateINGR, (%s, %s, %s, %s), enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparateINGR_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_INGR_blend_func_separate
#ifdef GL_INTEL_framebuffer_CMAA
void glatter_glApplyFramebufferAttachmentCMAAINTEL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glApplyFramebufferAttachmentCMAAINTEL, ())
    glatter_glApplyFramebufferAttachmentCMAAINTEL_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_map_texture
void * glatter_glMapTexture2DINTEL_debug(GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapTexture2DINTEL, (%u, %d, %u, %p, %p), (unsigned int)texture, (int)level, (unsigned int)access, (void*)stride, (void*)layout)
    void * rval = glatter_glMapTexture2DINTEL_ptr(texture, level, access, stride, layout);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glSyncTextureINTEL_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSyncTextureINTEL, (%u), (unsigned int)texture)
    glatter_glSyncTextureINTEL_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glUnmapTexture2DINTEL_debug(GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapTexture2DINTEL, (%u, %d), (unsigned int)texture, (int)level)
    glatter_glUnmapTexture2DINTEL_ptr(texture, level);
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_map_texture
#ifdef GL_INTEL_parallel_arrays
void glatter_glColorPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorPointervINTEL, (%d, %s, %p), (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glColorPointervINTEL_ptr(size, type, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalPointervINTEL_debug(GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalPointervINTEL, (%s, %p), enum_to_string_GL(type), (void*)pointer)
    glatter_glNormalPointervINTEL_ptr(type, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordPointervINTEL, (%d, %s, %p), (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glTexCoordPointervINTEL_ptr(size, type, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexPointervINTEL_debug(GLint size, GLenum type, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexPointervINTEL, (%d, %s, %p), (int)size, enum_to_string_GL(type), (void*)pointer)
    glatter_glVertexPointervINTEL_ptr(size, type, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_parallel_arrays
#ifdef GL_INTEL_performance_query
void glatter_glBeginPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glBeginPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glCreatePerfQueryINTEL_debug(GLuint queryId, GLuint *queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreatePerfQueryINTEL, (%u, %p), (unsigned int)queryId, (void*)queryHandle)
    glatter_glCreatePerfQueryINTEL_ptr(queryId, queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glDeletePerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glEndPerfQueryINTEL_debug(GLuint queryHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndPerfQueryINTEL, (%u), (unsigned int)queryHandle)
    glatter_glEndPerfQueryINTEL_ptr(queryHandle);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFirstPerfQueryIdINTEL_debug(GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFirstPerfQueryIdINTEL, (%p), (void*)queryId)
    glatter_glGetFirstPerfQueryIdINTEL_ptr(queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNextPerfQueryIdINTEL_debug(GLuint queryId, GLuint *nextQueryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNextPerfQueryIdINTEL, (%u, %p), (unsigned int)queryId, (void*)nextQueryId)
    glatter_glGetNextPerfQueryIdINTEL_ptr(queryId, nextQueryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfCounterInfoINTEL_debug(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfCounterInfoINTEL, (%u, %u, %u, %p, %u, %p, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)counterId, (unsigned int)counterNameLength, (void*)counterName, (unsigned int)counterDescLength, (void*)counterDesc, (void*)counterOffset, (void*)counterDataSize, (void*)counterTypeEnum, (void*)counterDataTypeEnum, (void*)rawCounterMaxValue)
    glatter_glGetPerfCounterInfoINTEL_ptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryDataINTEL_debug(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *data, GLuint *bytesWritten, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryDataINTEL, (%u, %u, %d, %p, %p), (unsigned int)queryHandle, (unsigned int)flags, (int)dataSize, (void*)data, (void*)bytesWritten)
    glatter_glGetPerfQueryDataINTEL_ptr(queryHandle, flags, dataSize, data, bytesWritten);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryIdByNameINTEL_debug(GLchar *queryName, GLuint *queryId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryIdByNameINTEL, (%p, %p), (void*)queryName, (void*)queryId)
    glatter_glGetPerfQueryIdByNameINTEL_ptr(queryName, queryId);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPerfQueryInfoINTEL_debug(GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPerfQueryInfoINTEL, (%u, %u, %p, %p, %p, %p, %p), (unsigned int)queryId, (unsigned int)queryNameLength, (void*)queryName, (void*)dataSize, (void*)noCounters, (void*)noInstances, (void*)capsMask)
    glatter_glGetPerfQueryInfoINTEL_ptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    glatter_check_error_GL(file, line);
}
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
void glatter_glBlendBarrierKHR_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierKHR, ())
    glatter_glBlendBarrierKHR_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_MESA_resize_buffers
void glatter_glResizeBuffersMESA_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResizeBuffersMESA, ())
    glatter_glResizeBuffersMESA_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_MESA_resize_buffers
#ifdef GL_MESA_window_pos
void glatter_glWindowPos2dMESA_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dMESA, (%f, %f), (double)x, (double)y)
    glatter_glWindowPos2dMESA_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dvMESA, (%p), (void*)v)
    glatter_glWindowPos2dvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2fMESA_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fMESA, (%f, %f), (float)x, (float)y)
    glatter_glWindowPos2fMESA_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fvMESA, (%p), (void*)v)
    glatter_glWindowPos2fvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2iMESA_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iMESA, (%d, %d), (int)x, (int)y)
    glatter_glWindowPos2iMESA_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2ivMESA, (%p), (void*)v)
    glatter_glWindowPos2ivMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2sMESA_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sMESA, (%hi, %hi), (short)x, (short)y)
    glatter_glWindowPos2sMESA_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2svMESA, (%p), (void*)v)
    glatter_glWindowPos2svMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3dMESA_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dMESA, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glWindowPos3dMESA_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dvMESA, (%p), (void*)v)
    glatter_glWindowPos3dvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3fMESA_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fMESA, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glWindowPos3fMESA_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fvMESA, (%p), (void*)v)
    glatter_glWindowPos3fvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3iMESA_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iMESA, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glWindowPos3iMESA_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3ivMESA, (%p), (void*)v)
    glatter_glWindowPos3ivMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3sMESA_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sMESA, (%hi, %hi, %hi), (short)x, (short)y, (short)z)
    glatter_glWindowPos3sMESA_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3svMESA, (%p), (void*)v)
    glatter_glWindowPos3svMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4dMESA_debug(GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4dMESA, (%f, %f, %f, %f), (double)x, (double)y, (double)z, (double)w)
    glatter_glWindowPos4dMESA_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4dvMESA_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4dvMESA, (%p), (void*)v)
    glatter_glWindowPos4dvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4fMESA_debug(GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4fMESA, (%f, %f, %f, %f), (float)x, (float)y, (float)z, (float)w)
    glatter_glWindowPos4fMESA_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4fvMESA_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4fvMESA, (%p), (void*)v)
    glatter_glWindowPos4fvMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4iMESA_debug(GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4iMESA, (%d, %d, %d, %d), (int)x, (int)y, (int)z, (int)w)
    glatter_glWindowPos4iMESA_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4ivMESA_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4ivMESA, (%p), (void*)v)
    glatter_glWindowPos4ivMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4sMESA_debug(GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4sMESA, (%hi, %hi, %hi, %hi), (short)x, (short)y, (short)z, (short)w)
    glatter_glWindowPos4sMESA_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos4svMESA_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos4svMESA, (%p), (void*)v)
    glatter_glWindowPos4svMESA_ptr(v);
    glatter_check_error_GL(file, line);
}
#endif // GL_MESA_window_pos
#ifdef GL_NVX_conditional_render
void glatter_glBeginConditionalRenderNVX_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNVX, (%u), (unsigned int)id)
    glatter_glBeginConditionalRenderNVX_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRenderNVX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNVX, ())
    glatter_glEndConditionalRenderNVX_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NVX_conditional_render
#ifdef GL_NV_bindless_multi_draw_indirect
void glatter_glMultiDrawArraysIndirectBindlessNV_debug(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectBindlessNV, (%s, %p, %d, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)drawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawArraysIndirectBindlessNV_ptr(mode, indirect, drawCount, stride, vertexBufferCount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectBindlessNV_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectBindlessNV, (%s, %s, %p, %d, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawElementsIndirectBindlessNV_ptr(mode, type, indirect, drawCount, stride, vertexBufferCount);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_bindless_multi_draw_indirect
#ifdef GL_NV_bindless_multi_draw_indirect_count
void glatter_glMultiDrawArraysIndirectBindlessCountNV_debug(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirectBindlessCountNV, (%s, %p, %d, %d, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)drawCount, (int)maxDrawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawArraysIndirectBindlessCountNV_ptr(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirectBindlessCountNV_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirectBindlessCountNV, (%s, %s, %p, %d, %d, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawCount, (int)maxDrawCount, (int)stride, (int)vertexBufferCount)
    glatter_glMultiDrawElementsIndirectBindlessCountNV_ptr(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_bindless_multi_draw_indirect_count
#ifdef GL_NV_bindless_texture
GLuint64 glatter_glGetImageHandleNV_debug(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetImageHandleNV, (%u, %d, %u, %d, %s), (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(format))
    GLuint64 rval = glatter_glGetImageHandleNV_ptr(texture, level, layered, layer, format);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureHandleNV_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureHandleNV, (%u), (unsigned int)texture)
    GLuint64 rval = glatter_glGetTextureHandleNV_ptr(texture);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint64 glatter_glGetTextureSamplerHandleNV_debug(GLuint texture, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSamplerHandleNV, (%u, %u), (unsigned int)texture, (unsigned int)sampler)
    GLuint64 rval = glatter_glGetTextureSamplerHandleNV_ptr(texture, sampler);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsImageHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsImageHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsImageHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTextureHandleResidentNV, (%s), GET_PRS(handle))
    GLboolean rval = glatter_glIsTextureHandleResidentNV_ptr(handle);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeImageHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeImageHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeImageHandleResidentNV_debug(GLuint64 handle, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeImageHandleResidentNV, (%s, %s), GET_PRS(handle), enum_to_string_GL(access))
    glatter_glMakeImageHandleResidentNV_ptr(handle, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleNonResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleNonResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleNonResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeTextureHandleResidentNV_debug(GLuint64 handle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeTextureHandleResidentNV, (%s), GET_PRS(handle))
    glatter_glMakeTextureHandleResidentNV_ptr(handle);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64NV_debug(GLuint program, GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformHandleui64NV_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformHandleui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64 *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformHandleui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)values)
    glatter_glProgramUniformHandleui64vNV_ptr(program, location, count, values);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64NV_debug(GLint location, GLuint64 value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64NV, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformHandleui64NV_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformHandleui64vNV_debug(GLint location, GLsizei count, const GLuint64 *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformHandleui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformHandleui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
void glatter_glBlendBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendBarrierNV, ())
    glatter_glBlendBarrierNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glBlendParameteriNV_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glBlendParameteriNV_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_clip_space_w_scaling
void glatter_glViewportPositionWScaleNV_debug(GLuint index, GLfloat xcoeff, GLfloat ycoeff, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportPositionWScaleNV, (%u, %f, %f), (unsigned int)index, (float)xcoeff, (float)ycoeff)
    glatter_glViewportPositionWScaleNV_ptr(index, xcoeff, ycoeff);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_clip_space_w_scaling
#ifdef GL_NV_command_list
void glatter_glCallCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCallCommandListNV, (%u), (unsigned int)list)
    glatter_glCallCommandListNV_ptr(list);
    glatter_check_error_GL(file, line);
}
void glatter_glCommandListSegmentsNV_debug(GLuint list, GLuint segments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCommandListSegmentsNV, (%u, %u), (unsigned int)list, (unsigned int)segments)
    glatter_glCommandListSegmentsNV_ptr(list, segments);
    glatter_check_error_GL(file, line);
}
void glatter_glCompileCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileCommandListNV, (%u), (unsigned int)list)
    glatter_glCompileCommandListNV_ptr(list);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateCommandListsNV_debug(GLsizei n, GLuint *lists, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateCommandListsNV, (%d, %p), (int)n, (void*)lists)
    glatter_glCreateCommandListsNV_ptr(n, lists);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateStatesNV_debug(GLsizei n, GLuint *states, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateStatesNV, (%d, %p), (int)n, (void*)states)
    glatter_glCreateStatesNV_ptr(n, states);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteCommandListsNV_debug(GLsizei n, const GLuint *lists, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteCommandListsNV, (%d, %p), (int)n, (void*)lists)
    glatter_glDeleteCommandListsNV_ptr(n, lists);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteStatesNV_debug(GLsizei n, const GLuint *states, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteStatesNV, (%d, %p), (int)n, (void*)states)
    glatter_glDeleteStatesNV_ptr(n, states);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawCommandsAddressNV_debug(GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsAddressNV, (%s, %p, %p, %u), enum_to_string_GL(primitiveMode), (void*)indirects, (void*)sizes, (unsigned int)count)
    glatter_glDrawCommandsAddressNV_ptr(primitiveMode, indirects, sizes, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawCommandsNV_debug(GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsNV, (%s, %u, %p, %p, %u), enum_to_string_GL(primitiveMode), (unsigned int)buffer, (void*)indirects, (void*)sizes, (unsigned int)count)
    glatter_glDrawCommandsNV_ptr(primitiveMode, buffer, indirects, sizes, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawCommandsStatesAddressNV_debug(const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsStatesAddressNV, (%p, %p, %p, %p, %u), (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glDrawCommandsStatesAddressNV_ptr(indirects, sizes, states, fbos, count);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawCommandsStatesNV_debug(GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawCommandsStatesNV, (%u, %p, %p, %p, %p, %u), (unsigned int)buffer, (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glDrawCommandsStatesNV_ptr(buffer, indirects, sizes, states, fbos, count);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetCommandHeaderNV_debug(GLenum tokenID, GLuint size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCommandHeaderNV, (%s, %u), enum_to_string_GL(tokenID), (unsigned int)size)
    GLuint rval = glatter_glGetCommandHeaderNV_ptr(tokenID, size);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLushort glatter_glGetStageIndexNV_debug(GLenum shadertype, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStageIndexNV, (%s), enum_to_string_GL(shadertype))
    GLushort rval = glatter_glGetStageIndexNV_ptr(shadertype);
    printf("GLATTER: returned %hu", (unsigned short)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsCommandListNV_debug(GLuint list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsCommandListNV, (%u), (unsigned int)list)
    GLboolean rval = glatter_glIsCommandListNV_ptr(list);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsStateNV_debug(GLuint state, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsStateNV, (%u), (unsigned int)state)
    GLboolean rval = glatter_glIsStateNV_ptr(state);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glListDrawCommandsStatesClientNV_debug(GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListDrawCommandsStatesClientNV, (%u, %u, %p, %p, %p, %p, %u), (unsigned int)list, (unsigned int)segment, (void*)indirects, (void*)sizes, (void*)states, (void*)fbos, (unsigned int)count)
    glatter_glListDrawCommandsStatesClientNV_ptr(list, segment, indirects, sizes, states, fbos, count);
    glatter_check_error_GL(file, line);
}
void glatter_glStateCaptureNV_debug(GLuint state, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStateCaptureNV, (%u, %s), (unsigned int)state, enum_to_string_GL(mode))
    glatter_glStateCaptureNV_ptr(state, mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_command_list
#ifdef GL_NV_conditional_render
void glatter_glBeginConditionalRenderNV_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRenderNV, (%u, %s), (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRenderNV_ptr(id, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRenderNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRenderNV, ())
    glatter_glEndConditionalRenderNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
void glatter_glSubpixelPrecisionBiasNV_debug(GLuint xbits, GLuint ybits, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSubpixelPrecisionBiasNV, (%u, %u), (unsigned int)xbits, (unsigned int)ybits)
    glatter_glSubpixelPrecisionBiasNV_ptr(xbits, ybits);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_dilate
void glatter_glConservativeRasterParameterfNV_debug(GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameterfNV, (%s, %f), enum_to_string_GL(pname), (float)value)
    glatter_glConservativeRasterParameterfNV_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster_dilate
#ifdef GL_NV_conservative_raster_pre_snap_triangles
void glatter_glConservativeRasterParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConservativeRasterParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glConservativeRasterParameteriNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_copy_image
void glatter_glCopyImageSubDataNV_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubDataNV, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    glatter_glCopyImageSubDataNV_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_copy_image
#ifdef GL_NV_depth_buffer_float
void glatter_glClearDepthdNV_debug(GLdouble depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthdNV, (%f), (double)depth)
    glatter_glClearDepthdNV_ptr(depth);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthBoundsdNV_debug(GLdouble zmin, GLdouble zmax, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthBoundsdNV, (%f, %f), (double)zmin, (double)zmax)
    glatter_glDepthBoundsdNV_ptr(zmin, zmax);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangedNV_debug(GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangedNV, (%f, %f), (double)zNear, (double)zFar)
    glatter_glDepthRangedNV_ptr(zNear, zFar);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_depth_buffer_float
#ifdef GL_NV_draw_texture
void glatter_glDrawTextureNV_debug(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTextureNV, (%u, %u, %f, %f, %f, %f, %f, %f, %f, %f, %f), (unsigned int)texture, (unsigned int)sampler, (float)x0, (float)y0, (float)x1, (float)y1, (float)z, (float)s0, (float)t0, (float)s1, (float)t1)
    glatter_glDrawTextureNV_ptr(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_draw_texture
#ifdef GL_NV_evaluators
void glatter_glEvalMapsNV_debug(GLenum target, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalMapsNV, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(mode))
    glatter_glEvalMapsNV_ptr(target, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapAttribParameterfvNV_debug(GLenum target, GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapAttribParameterfvNV, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapAttribParameterfvNV_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapAttribParameterivNV_debug(GLenum target, GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapAttribParameterivNV, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapAttribParameterivNV_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapControlPointsNV_debug(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapControlPointsNV, (%s, %u, %s, %d, %d, %u, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(type), (int)ustride, (int)vstride, (unsigned char)packed, (void*)points)
    glatter_glGetMapControlPointsNV_ptr(target, index, type, ustride, vstride, packed, points);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapParameterfvNV_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapParameterfvNV, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapParameterfvNV_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapParameterivNV_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapParameterivNV, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetMapParameterivNV_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMapControlPointsNV_debug(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapControlPointsNV, (%s, %u, %s, %d, %d, %d, %d, %u, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(type), (int)ustride, (int)vstride, (int)uorder, (int)vorder, (unsigned char)packed, (void*)points)
    glatter_glMapControlPointsNV_ptr(target, index, type, ustride, vstride, uorder, vorder, packed, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapParameterfvNV_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapParameterfvNV, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMapParameterfvNV_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMapParameterivNV_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapParameterivNV, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glMapParameterivNV_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_evaluators
#ifdef GL_NV_explicit_multisample
void glatter_glGetMultisamplefvNV_debug(GLenum pname, GLuint index, GLfloat *val, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMultisamplefvNV, (%s, %u, %p), enum_to_string_GL(pname), (unsigned int)index, (void*)val)
    glatter_glGetMultisamplefvNV_ptr(pname, index, val);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleMaskIndexedNV_debug(GLuint index, GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskIndexedNV, (%u, %u), (unsigned int)index, (unsigned int)mask)
    glatter_glSampleMaskIndexedNV_ptr(index, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glTexRenderbufferNV_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexRenderbufferNV, (%s, %u), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glTexRenderbufferNV_ptr(target, renderbuffer);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_explicit_multisample
#ifdef GL_NV_fence
void glatter_glDeleteFencesNV_debug(GLsizei n, const GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFencesNV, (%d, %p), (int)n, (void*)fences)
    glatter_glDeleteFencesNV_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
void glatter_glFinishFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishFenceNV, (%u), (unsigned int)fence)
    glatter_glFinishFenceNV_ptr(fence);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFencesNV_debug(GLsizei n, GLuint *fences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFencesNV, (%d, %p), (int)n, (void*)fences)
    glatter_glGenFencesNV_ptr(n, fences);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFenceivNV_debug(GLuint fence, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFenceivNV, (%u, %s, %p), (unsigned int)fence, enum_to_string_GL(pname), (void*)params)
    glatter_glGetFenceivNV_ptr(fence, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFenceNV, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glIsFenceNV_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glSetFenceNV_debug(GLuint fence, GLenum condition, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSetFenceNV, (%u, %s), (unsigned int)fence, enum_to_string_GL(condition))
    glatter_glSetFenceNV_ptr(fence, condition);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glTestFenceNV_debug(GLuint fence, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTestFenceNV, (%u), (unsigned int)fence)
    GLboolean rval = glatter_glTestFenceNV_ptr(fence);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_NV_fence
#ifdef GL_NV_fragment_coverage_to_color
void glatter_glFragmentCoverageColorNV_debug(GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentCoverageColorNV, (%u), (unsigned int)color)
    glatter_glFragmentCoverageColorNV_ptr(color);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_fragment_program
void glatter_glGetProgramNamedParameterdvNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramNamedParameterdvNV, (%u, %d, %p, %p), (unsigned int)id, (int)len, (void*)name, (void*)params)
    glatter_glGetProgramNamedParameterdvNV_ptr(id, len, name, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramNamedParameterfvNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramNamedParameterfvNV, (%u, %d, %p, %p), (unsigned int)id, (int)len, (void*)name, (void*)params)
    glatter_glGetProgramNamedParameterfvNV_ptr(id, len, name, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramNamedParameter4dNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4dNV, (%u, %d, %p, %f, %f, %f, %f), (unsigned int)id, (int)len, (void*)name, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramNamedParameter4dNV_ptr(id, len, name, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramNamedParameter4dvNV_debug(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4dvNV, (%u, %d, %p, %p), (unsigned int)id, (int)len, (void*)name, (void*)v)
    glatter_glProgramNamedParameter4dvNV_ptr(id, len, name, v);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramNamedParameter4fNV_debug(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4fNV, (%u, %d, %p, %f, %f, %f, %f), (unsigned int)id, (int)len, (void*)name, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramNamedParameter4fNV_ptr(id, len, name, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramNamedParameter4fvNV_debug(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramNamedParameter4fvNV, (%u, %d, %p, %p), (unsigned int)id, (int)len, (void*)name, (void*)v)
    glatter_glProgramNamedParameter4fvNV_ptr(id, len, name, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_fragment_program
#ifdef GL_NV_framebuffer_mixed_samples
void glatter_glCoverageModulationNV_debug(GLenum components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationNV, (%s), enum_to_string_GL(components))
    glatter_glCoverageModulationNV_ptr(components);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverageModulationTableNV_debug(GLsizei n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverageModulationTableNV, (%d, %p), (int)n, (void*)v)
    glatter_glCoverageModulationTableNV_ptr(n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCoverageModulationTableNV_debug(GLsizei bufsize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCoverageModulationTableNV, (%d, %p), (int)bufsize, (void*)v)
    glatter_glGetCoverageModulationTableNV_ptr(bufsize, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_framebuffer_multisample_coverage
void glatter_glRenderbufferStorageMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisampleCoverageNV, (%s, %d, %d, %s, %d, %d), enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_framebuffer_multisample_coverage
#ifdef GL_NV_geometry_program4
void glatter_glFramebufferTextureEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureEXT, (%s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glFramebufferTextureEXT_ptr(target, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureFaceEXT_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureFaceEXT, (%s, %s, %u, %d, %s), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, enum_to_string_GL(face))
    glatter_glFramebufferTextureFaceEXT_ptr(target, attachment, texture, level, face);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramVertexLimitNV_debug(GLenum target, GLint limit, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramVertexLimitNV, (%s, %d), enum_to_string_GL(target), (int)limit)
    glatter_glProgramVertexLimitNV_ptr(target, limit);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_geometry_program4
#ifdef GL_NV_gpu_program4
void glatter_glGetProgramEnvParameterIivNV_debug(GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterIivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterIivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramEnvParameterIuivNV_debug(GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramEnvParameterIuivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramEnvParameterIuivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramLocalParameterIivNV_debug(GLenum target, GLuint index, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterIivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterIivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramLocalParameterIuivNV_debug(GLenum target, GLuint index, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramLocalParameterIuivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glGetProgramLocalParameterIuivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameterI4iNV_debug(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4iNV, (%s, %u, %d, %d, %d, %d), enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glProgramEnvParameterI4iNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameterI4ivNV_debug(GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4ivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameterI4ivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameterI4uiNV_debug(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4uiNV, (%s, %u, %u, %u, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glProgramEnvParameterI4uiNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParameterI4uivNV_debug(GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParameterI4uivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramEnvParameterI4uivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParametersI4ivNV_debug(GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParametersI4ivNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParametersI4ivNV_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramEnvParametersI4uivNV_debug(GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramEnvParametersI4uivNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramEnvParametersI4uivNV_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameterI4iNV_debug(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4iNV, (%s, %u, %d, %d, %d, %d), enum_to_string_GL(target), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glProgramLocalParameterI4iNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameterI4ivNV_debug(GLenum target, GLuint index, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4ivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameterI4ivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameterI4uiNV_debug(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4uiNV, (%s, %u, %u, %u, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glProgramLocalParameterI4uiNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParameterI4uivNV_debug(GLenum target, GLuint index, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParameterI4uivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)params)
    glatter_glProgramLocalParameterI4uivNV_ptr(target, index, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParametersI4ivNV_debug(GLenum target, GLuint index, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParametersI4ivNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParametersI4ivNV_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramLocalParametersI4uivNV_debug(GLenum target, GLuint index, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramLocalParametersI4uivNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)params)
    glatter_glProgramLocalParametersI4uivNV_ptr(target, index, count, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_gpu_program4
#ifdef GL_NV_gpu_program5
void glatter_glGetProgramSubroutineParameteruivNV_debug(GLenum target, GLuint index, GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramSubroutineParameteruivNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)param)
    glatter_glGetProgramSubroutineParameteruivNV_ptr(target, index, param);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramSubroutineParametersuivNV_debug(GLenum target, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramSubroutineParametersuivNV, (%s, %d, %p), enum_to_string_GL(target), (int)count, (void*)params)
    glatter_glProgramSubroutineParametersuivNV_ptr(target, count, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_gpu_program5
#ifdef GL_NV_half_float
void glatter_glColor3hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3hNV, (%hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glColor3hNV_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3hvNV, (%p), (void*)v)
    glatter_glColor3hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4hNV, (%hu, %hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue, (unsigned short)alpha)
    glatter_glColor4hNV_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4hvNV, (%p), (void*)v)
    glatter_glColor4hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordhNV_debug(GLhalfNV fog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordhNV, (%hu), (unsigned short)fog)
    glatter_glFogCoordhNV_ptr(fog);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordhvNV_debug(const GLhalfNV *fog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordhvNV, (%p), (void*)fog)
    glatter_glFogCoordhvNV_ptr(fog);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1hNV_debug(GLenum target, GLhalfNV s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1hNV, (%s, %hu), enum_to_string_GL(target), (unsigned short)s)
    glatter_glMultiTexCoord1hNV_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1hvNV, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1hvNV_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2hNV, (%s, %hu, %hu), enum_to_string_GL(target), (unsigned short)s, (unsigned short)t)
    glatter_glMultiTexCoord2hNV_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2hvNV, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2hvNV_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3hNV, (%s, %hu, %hu, %hu), enum_to_string_GL(target), (unsigned short)s, (unsigned short)t, (unsigned short)r)
    glatter_glMultiTexCoord3hNV_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3hvNV, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3hvNV_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4hNV_debug(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4hNV, (%s, %hu, %hu, %hu, %hu), enum_to_string_GL(target), (unsigned short)s, (unsigned short)t, (unsigned short)r, (unsigned short)q)
    glatter_glMultiTexCoord4hNV_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4hvNV_debug(GLenum target, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4hvNV, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4hvNV_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3hNV_debug(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3hNV, (%hu, %hu, %hu), (unsigned short)nx, (unsigned short)ny, (unsigned short)nz)
    glatter_glNormal3hNV_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3hvNV, (%p), (void*)v)
    glatter_glNormal3hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3hNV_debug(GLhalfNV red, GLhalfNV green, GLhalfNV blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3hNV, (%hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3hNV_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3hvNV, (%p), (void*)v)
    glatter_glSecondaryColor3hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1hNV_debug(GLhalfNV s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1hNV, (%hu), (unsigned short)s)
    glatter_glTexCoord1hNV_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1hvNV, (%p), (void*)v)
    glatter_glTexCoord1hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2hNV_debug(GLhalfNV s, GLhalfNV t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2hNV, (%hu, %hu), (unsigned short)s, (unsigned short)t)
    glatter_glTexCoord2hNV_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2hvNV, (%p), (void*)v)
    glatter_glTexCoord2hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3hNV_debug(GLhalfNV s, GLhalfNV t, GLhalfNV r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3hNV, (%hu, %hu, %hu), (unsigned short)s, (unsigned short)t, (unsigned short)r)
    glatter_glTexCoord3hNV_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3hvNV, (%p), (void*)v)
    glatter_glTexCoord3hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4hNV_debug(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4hNV, (%hu, %hu, %hu, %hu), (unsigned short)s, (unsigned short)t, (unsigned short)r, (unsigned short)q)
    glatter_glTexCoord4hNV_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4hvNV, (%p), (void*)v)
    glatter_glTexCoord4hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2hNV_debug(GLhalfNV x, GLhalfNV y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2hNV, (%hu, %hu), (unsigned short)x, (unsigned short)y)
    glatter_glVertex2hNV_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2hvNV, (%p), (void*)v)
    glatter_glVertex2hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3hNV_debug(GLhalfNV x, GLhalfNV y, GLhalfNV z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3hNV, (%hu, %hu, %hu), (unsigned short)x, (unsigned short)y, (unsigned short)z)
    glatter_glVertex3hNV_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3hvNV, (%p), (void*)v)
    glatter_glVertex3hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4hNV_debug(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4hNV, (%hu, %hu, %hu, %hu), (unsigned short)x, (unsigned short)y, (unsigned short)z, (unsigned short)w)
    glatter_glVertex4hNV_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4hvNV_debug(const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4hvNV, (%p), (void*)v)
    glatter_glVertex4hvNV_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1hNV_debug(GLuint index, GLhalfNV x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1hNV, (%u, %hu), (unsigned int)index, (unsigned short)x)
    glatter_glVertexAttrib1hNV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1hvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1hvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2hNV, (%u, %hu, %hu), (unsigned int)index, (unsigned short)x, (unsigned short)y)
    glatter_glVertexAttrib2hNV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2hvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2hvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3hNV, (%u, %hu, %hu, %hu), (unsigned int)index, (unsigned short)x, (unsigned short)y, (unsigned short)z)
    glatter_glVertexAttrib3hNV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3hvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3hvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4hNV_debug(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4hNV, (%u, %hu, %hu, %hu, %hu), (unsigned int)index, (unsigned short)x, (unsigned short)y, (unsigned short)z, (unsigned short)w)
    glatter_glVertexAttrib4hNV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4hvNV_debug(GLuint index, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4hvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4hvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs1hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1hvNV, (%u, %d, %p), (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs1hvNV_ptr(index, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs2hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2hvNV, (%u, %d, %p), (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs2hvNV_ptr(index, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs3hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3hvNV, (%u, %d, %p), (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs3hvNV_ptr(index, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs4hvNV_debug(GLuint index, GLsizei n, const GLhalfNV *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4hvNV, (%u, %d, %p), (unsigned int)index, (int)n, (void*)v)
    glatter_glVertexAttribs4hvNV_ptr(index, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexWeighthNV_debug(GLhalfNV weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeighthNV, (%hu), (unsigned short)weight)
    glatter_glVertexWeighthNV_ptr(weight);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexWeighthvNV_debug(const GLhalfNV *weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexWeighthvNV, (%p), (void*)weight)
    glatter_glVertexWeighthvNV_ptr(weight);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_half_float
#ifdef GL_NV_internalformat_sample_query
void glatter_glGetInternalformatSampleivNV_debug(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformatSampleivNV, (%s, %s, %d, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)samples, enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformatSampleivNV_ptr(target, internalformat, samples, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_occlusion_query
void glatter_glBeginOcclusionQueryNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginOcclusionQueryNV, (%u), (unsigned int)id)
    glatter_glBeginOcclusionQueryNV_ptr(id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteOcclusionQueriesNV_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteOcclusionQueriesNV, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteOcclusionQueriesNV_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glEndOcclusionQueryNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndOcclusionQueryNV, ())
    glatter_glEndOcclusionQueryNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glGenOcclusionQueriesNV_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenOcclusionQueriesNV, (%d, %p), (int)n, (void*)ids)
    glatter_glGenOcclusionQueriesNV_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetOcclusionQueryivNV_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetOcclusionQueryivNV, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetOcclusionQueryivNV_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetOcclusionQueryuivNV_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetOcclusionQueryuivNV, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetOcclusionQueryuivNV_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsOcclusionQueryNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsOcclusionQueryNV, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsOcclusionQueryNV_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_NV_occlusion_query
#ifdef GL_NV_parameter_buffer_object
void glatter_glProgramBufferParametersIivNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersIivNV, (%s, %u, %u, %d, %p), enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersIivNV_ptr(target, bindingIndex, wordIndex, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramBufferParametersIuivNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersIuivNV, (%s, %u, %u, %d, %p), enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersIuivNV_ptr(target, bindingIndex, wordIndex, count, params);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramBufferParametersfvNV_debug(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBufferParametersfvNV, (%s, %u, %u, %d, %p), enum_to_string_GL(target), (unsigned int)bindingIndex, (unsigned int)wordIndex, (int)count, (void*)params)
    glatter_glProgramBufferParametersfvNV_ptr(target, bindingIndex, wordIndex, count, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_parameter_buffer_object
#ifdef GL_NV_path_rendering
void glatter_glCopyPathNV_debug(GLuint resultPath, GLuint srcPath, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyPathNV, (%u, %u), (unsigned int)resultPath, (unsigned int)srcPath)
    glatter_glCopyPathNV_ptr(resultPath, srcPath);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverFillPathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverFillPathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverFillPathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathInstancedNV, (%d, %s, %p, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glCoverStrokePathNV_debug(GLuint path, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCoverStrokePathNV, (%u, %s), (unsigned int)path, enum_to_string_GL(coverMode))
    glatter_glCoverStrokePathNV_ptr(path, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glDeletePathsNV_debug(GLuint path, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeletePathsNV, (%u, %d), (unsigned int)path, (int)range)
    glatter_glDeletePathsNV_ptr(path, range);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGenPathsNV_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenPathsNV, (%d), (int)range)
    GLuint rval = glatter_glGenPathsNV_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathColorGenfvNV_debug(GLenum color, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathColorGenfvNV, (%s, %s, %p), enum_to_string_GL(color), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathColorGenfvNV_ptr(color, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathColorGenivNV_debug(GLenum color, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathColorGenivNV, (%s, %s, %p), enum_to_string_GL(color), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathColorGenivNV_ptr(color, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathCommandsNV_debug(GLuint path, GLubyte *commands, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCommandsNV, (%u, %p), (unsigned int)path, (void*)commands)
    glatter_glGetPathCommandsNV_ptr(path, commands);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathCoordsNV_debug(GLuint path, GLfloat *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathCoordsNV, (%u, %p), (unsigned int)path, (void*)coords)
    glatter_glGetPathCoordsNV_ptr(path, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathDashArrayNV_debug(GLuint path, GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathDashArrayNV, (%u, %p), (unsigned int)path, (void*)dashArray)
    glatter_glGetPathDashArrayNV_ptr(path, dashArray);
    glatter_check_error_GL(file, line);
}
GLfloat glatter_glGetPathLengthNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathLengthNV, (%u, %d, %d), (unsigned int)path, (int)startSegment, (int)numSegments)
    GLfloat rval = glatter_glGetPathLengthNV_ptr(path, startSegment, numSegments);
    printf("GLATTER: returned %f", (float)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetPathMetricRangeNV_debug(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricRangeNV, (%u, %u, %d, %d, %p), (unsigned int)metricQueryMask, (unsigned int)firstPathName, (int)numPaths, (int)stride, (void*)metrics)
    glatter_glGetPathMetricRangeNV_ptr(metricQueryMask, firstPathName, numPaths, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathMetricsNV_debug(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathMetricsNV, (%u, %d, %s, %p, %u, %d, %p), (unsigned int)metricQueryMask, (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)stride, (void*)metrics)
    glatter_glGetPathMetricsNV_ptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterfvNV_debug(GLuint path, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathParameterivNV_debug(GLuint path, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathSpacingNV_debug(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathSpacingNV, (%s, %d, %s, %p, %u, %f, %f, %s, %p), enum_to_string_GL(pathListMode), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (float)advanceScale, (float)kerningScale, enum_to_string_GL(transformType), (void*)returnedSpacing)
    glatter_glGetPathSpacingNV_ptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathTexGenfvNV_debug(GLenum texCoordSet, GLenum pname, GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathTexGenfvNV, (%s, %s, %p), enum_to_string_GL(texCoordSet), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathTexGenfvNV_ptr(texCoordSet, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPathTexGenivNV_debug(GLenum texCoordSet, GLenum pname, GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPathTexGenivNV, (%s, %s, %p), enum_to_string_GL(texCoordSet), enum_to_string_GL(pname), (void*)value)
    glatter_glGetPathTexGenivNV_ptr(texCoordSet, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourcefvNV_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourcefvNV, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourcefvNV_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInterpolatePathsNV_debug(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInterpolatePathsNV, (%u, %u, %u, %f), (unsigned int)resultPath, (unsigned int)pathA, (unsigned int)pathB, (float)weight)
    glatter_glInterpolatePathsNV_ptr(resultPath, pathA, pathB, weight);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsPathNV_debug(GLuint path, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPathNV, (%u), (unsigned int)path)
    GLboolean rval = glatter_glIsPathNV_ptr(path);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInFillPathNV_debug(GLuint path, GLuint mask, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInFillPathNV, (%u, %u, %f, %f), (unsigned int)path, (unsigned int)mask, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInFillPathNV_ptr(path, mask, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsPointInStrokePathNV_debug(GLuint path, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsPointInStrokePathNV, (%u, %f, %f), (unsigned int)path, (float)x, (float)y)
    GLboolean rval = glatter_glIsPointInStrokePathNV_ptr(path, x, y);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMatrixLoad3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoad3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoad3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoad3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixLoadTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixLoadTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixLoadTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x2fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x2fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x2fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMult3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMult3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMult3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glMatrixMultTranspose3x3fNV_debug(GLenum matrixMode, const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMatrixMultTranspose3x3fNV, (%s, %p), enum_to_string_GL(matrixMode), (void*)m)
    glatter_glMatrixMultTranspose3x3fNV_ptr(matrixMode, m);
    glatter_check_error_GL(file, line);
}
void glatter_glPathColorGenNV_debug(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathColorGenNV, (%s, %s, %s, %p), enum_to_string_GL(color), enum_to_string_GL(genMode), enum_to_string_GL(colorFormat), (void*)coeffs)
    glatter_glPathColorGenNV_ptr(color, genMode, colorFormat, coeffs);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCommandsNV_debug(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCommandsNV, (%u, %d, %p, %d, %s, %p), (unsigned int)path, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCommandsNV_ptr(path, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoordsNV_debug(GLuint path, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoordsNV, (%u, %d, %s, %p), (unsigned int)path, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathCoordsNV_ptr(path, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathCoverDepthFuncNV_debug(GLenum func, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathCoverDepthFuncNV, (%s), enum_to_string_GL(func))
    glatter_glPathCoverDepthFuncNV_ptr(func);
    glatter_check_error_GL(file, line);
}
void glatter_glPathDashArrayNV_debug(GLuint path, GLsizei dashCount, const GLfloat *dashArray, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathDashArrayNV, (%u, %d, %p), (unsigned int)path, (int)dashCount, (void*)dashArray)
    glatter_glPathDashArrayNV_ptr(path, dashCount, dashArray);
    glatter_check_error_GL(file, line);
}
void glatter_glPathFogGenNV_debug(GLenum genMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathFogGenNV, (%s), enum_to_string_GL(genMode))
    glatter_glPathFogGenNV_ptr(genMode);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexArrayNV, (%u, %s, %p, %u, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
GLenum glatter_glPathGlyphIndexRangeNV_debug(GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2], const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphIndexRangeNV, (%s, %p, %u, %u, %f, %s), enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)pathParameterTemplate, (float)emScale, GET_PRS(baseAndCount))
    GLenum rval = glatter_glPathGlyphIndexRangeNV_ptr(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathGlyphRangeNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphRangeNV, (%u, %s, %p, %u, %u, %d, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (unsigned int)firstGlyph, (int)numGlyphs, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphRangeNV_ptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
void glatter_glPathGlyphsNV_debug(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathGlyphsNV, (%u, %s, %p, %u, %d, %s, %p, %s, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (void*)fontName, (unsigned int)fontStyle, (int)numGlyphs, enum_to_string_GL(type), (void*)charcodes, enum_to_string_GL(handleMissingGlyphs), (unsigned int)pathParameterTemplate, (float)emScale)
    glatter_glPathGlyphsNV_ptr(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glPathMemoryGlyphIndexArrayNV_debug(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathMemoryGlyphIndexArrayNV, (%u, %s, %td, %p, %d, %u, %d, %u, %f), (unsigned int)firstPathName, enum_to_string_GL(fontTarget), (ptrdiff_t)fontSize, (void*)fontData, (int)faceIndex, (unsigned int)firstGlyphIndex, (int)numGlyphs, (unsigned int)pathParameterTemplate, (float)emScale)
    GLenum rval = glatter_glPathMemoryGlyphIndexArrayNV_ptr(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPathParameterfNV_debug(GLuint path, GLenum pname, GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfNV, (%u, %s, %f), (unsigned int)path, enum_to_string_GL(pname), (float)value)
    glatter_glPathParameterfNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterfvNV_debug(GLuint path, GLenum pname, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterfvNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterfvNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameteriNV_debug(GLuint path, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameteriNV, (%u, %s, %d), (unsigned int)path, enum_to_string_GL(pname), (int)value)
    glatter_glPathParameteriNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathParameterivNV_debug(GLuint path, GLenum pname, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathParameterivNV, (%u, %s, %p), (unsigned int)path, enum_to_string_GL(pname), (void*)value)
    glatter_glPathParameterivNV_ptr(path, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilDepthOffsetNV_debug(GLfloat factor, GLfloat units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilDepthOffsetNV, (%f, %f), (float)factor, (float)units)
    glatter_glPathStencilDepthOffsetNV_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStencilFuncNV_debug(GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStencilFuncNV, (%s, %d, %u), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glPathStencilFuncNV_ptr(func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glPathStringNV_debug(GLuint path, GLenum format, GLsizei length, const void *pathString, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathStringNV, (%u, %s, %d, %p), (unsigned int)path, enum_to_string_GL(format), (int)length, (void*)pathString)
    glatter_glPathStringNV_ptr(path, format, length, pathString);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCommandsNV_debug(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCommandsNV, (%u, %d, %d, %d, %p, %d, %s, %p), (unsigned int)path, (int)commandStart, (int)commandsToDelete, (int)numCommands, (void*)commands, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCommandsNV_ptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathSubCoordsNV_debug(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathSubCoordsNV, (%u, %d, %d, %s, %p), (unsigned int)path, (int)coordStart, (int)numCoords, enum_to_string_GL(coordType), (void*)coords)
    glatter_glPathSubCoordsNV_ptr(path, coordStart, numCoords, coordType, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glPathTexGenNV_debug(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPathTexGenNV, (%s, %s, %d, %p), enum_to_string_GL(texCoordSet), enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glPathTexGenNV_ptr(texCoordSet, genMode, components, coeffs);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glPointAlongPathNV_debug(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointAlongPathNV, (%u, %d, %d, %f, %p, %p, %p, %p), (unsigned int)path, (int)startSegment, (int)numSegments, (float)distance, (void*)x, (void*)y, (void*)tangentX, (void*)tangentY)
    GLboolean rval = glatter_glPointAlongPathNV_ptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramPathFragmentInputGenNV_debug(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramPathFragmentInputGenNV, (%u, %d, %s, %d, %p), (unsigned int)program, (int)location, enum_to_string_GL(genMode), (int)components, (void*)coeffs)
    glatter_glProgramPathFragmentInputGenNV_ptr(program, location, genMode, components, coeffs);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFillPathNV, (%u, %s, %u), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask)
    glatter_glStencilFillPathNV_ptr(path, fillMode, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilStrokePathNV, (%u, %d, %u), (unsigned int)path, (int)reference, (unsigned int)mask)
    glatter_glStencilStrokePathNV_ptr(path, reference, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathInstancedNV, (%d, %s, %p, %u, %s, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverFillPathNV_debug(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverFillPathNV, (%u, %s, %u, %s), (unsigned int)path, enum_to_string_GL(fillMode), (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverFillPathNV_ptr(path, fillMode, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathInstancedNV_debug(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathInstancedNV, (%d, %s, %p, %u, %d, %u, %s, %s, %p), (int)numPaths, enum_to_string_GL(pathNameType), (void*)paths, (unsigned int)pathBase, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode), enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glStencilThenCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilThenCoverStrokePathNV_debug(GLuint path, GLint reference, GLuint mask, GLenum coverMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilThenCoverStrokePathNV, (%u, %d, %u, %s), (unsigned int)path, (int)reference, (unsigned int)mask, enum_to_string_GL(coverMode))
    glatter_glStencilThenCoverStrokePathNV_ptr(path, reference, mask, coverMode);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformPathNV_debug(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformPathNV, (%u, %u, %s, %p), (unsigned int)resultPath, (unsigned int)srcPath, enum_to_string_GL(transformType), (void*)transformValues)
    glatter_glTransformPathNV_ptr(resultPath, srcPath, transformType, transformValues);
    glatter_check_error_GL(file, line);
}
void glatter_glWeightPathsNV_debug(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWeightPathsNV, (%u, %d, %p, %p), (unsigned int)resultPath, (int)numPaths, (void*)paths, (void*)weights)
    glatter_glWeightPathsNV_ptr(resultPath, numPaths, paths, weights);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_path_rendering
#ifdef GL_NV_pixel_data_range
void glatter_glFlushPixelDataRangeNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushPixelDataRangeNV, (%s), enum_to_string_GL(target))
    glatter_glFlushPixelDataRangeNV_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelDataRangeNV_debug(GLenum target, GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelDataRangeNV, (%s, %d, %p), enum_to_string_GL(target), (int)length, (void*)pointer)
    glatter_glPixelDataRangeNV_ptr(target, length, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_pixel_data_range
#ifdef GL_NV_point_sprite
void glatter_glPointParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPointParameteriNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterivNV_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterivNV, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterivNV_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_point_sprite
#ifdef GL_NV_present_video
void glatter_glGetVideoi64vNV_debug(GLuint video_slot, GLenum pname, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoi64vNV, (%u, %s, %p), (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoi64vNV_ptr(video_slot, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoivNV_debug(GLuint video_slot, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoivNV, (%u, %s, %p), (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoivNV_ptr(video_slot, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoui64vNV_debug(GLuint video_slot, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoui64vNV, (%u, %s, %p), (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoui64vNV_ptr(video_slot, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideouivNV_debug(GLuint video_slot, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideouivNV, (%u, %s, %p), (unsigned int)video_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideouivNV_ptr(video_slot, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPresentFrameDualFillNV_debug(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPresentFrameDualFillNV, (%u, %s, %u, %u, %s, %s, %u, %s, %u, %s, %u, %s, %u), (unsigned int)video_slot, GET_PRS(minPresentTime), (unsigned int)beginPresentTimeId, (unsigned int)presentDurationId, enum_to_string_GL(type), enum_to_string_GL(target0), (unsigned int)fill0, enum_to_string_GL(target1), (unsigned int)fill1, enum_to_string_GL(target2), (unsigned int)fill2, enum_to_string_GL(target3), (unsigned int)fill3)
    glatter_glPresentFrameDualFillNV_ptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    glatter_check_error_GL(file, line);
}
void glatter_glPresentFrameKeyedNV_debug(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPresentFrameKeyedNV, (%u, %s, %u, %u, %s, %s, %u, %u, %s, %u, %u), (unsigned int)video_slot, GET_PRS(minPresentTime), (unsigned int)beginPresentTimeId, (unsigned int)presentDurationId, enum_to_string_GL(type), enum_to_string_GL(target0), (unsigned int)fill0, (unsigned int)key0, enum_to_string_GL(target1), (unsigned int)fill1, (unsigned int)key1)
    glatter_glPresentFrameKeyedNV_ptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_present_video
#ifdef GL_NV_primitive_restart
void glatter_glPrimitiveRestartIndexNV_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartIndexNV, (%u), (unsigned int)index)
    glatter_glPrimitiveRestartIndexNV_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glPrimitiveRestartNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartNV, ())
    glatter_glPrimitiveRestartNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_primitive_restart
#ifdef GL_NV_register_combiners
void glatter_glCombinerInputNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerInputNV, (%s, %s, %s, %s, %s, %s), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(input), enum_to_string_GL(mapping), enum_to_string_GL(componentUsage))
    glatter_glCombinerInputNV_ptr(stage, portion, variable, input, mapping, componentUsage);
    glatter_check_error_GL(file, line);
}
void glatter_glCombinerOutputNV_debug(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerOutputNV, (%s, %s, %s, %s, %s, %s, %s, %u, %u, %u), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(abOutput), enum_to_string_GL(cdOutput), enum_to_string_GL(sumOutput), enum_to_string_GL(scale), enum_to_string_GL(bias), (unsigned char)abDotProduct, (unsigned char)cdDotProduct, (unsigned char)muxSum)
    glatter_glCombinerOutputNV_ptr(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    glatter_check_error_GL(file, line);
}
void glatter_glCombinerParameterfNV_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterfNV, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glCombinerParameterfNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glCombinerParameterfvNV_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterfvNV, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerParameterfvNV_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glCombinerParameteriNV_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameteriNV, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glCombinerParameteriNV_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glCombinerParameterivNV_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerParameterivNV, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerParameterivNV_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFinalCombinerInputNV_debug(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinalCombinerInputNV, (%s, %s, %s, %s), enum_to_string_GL(variable), enum_to_string_GL(input), enum_to_string_GL(mapping), enum_to_string_GL(componentUsage))
    glatter_glFinalCombinerInputNV_ptr(variable, input, mapping, componentUsage);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCombinerInputParameterfvNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerInputParameterfvNV, (%s, %s, %s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerInputParameterfvNV_ptr(stage, portion, variable, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCombinerInputParameterivNV_debug(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerInputParameterivNV, (%s, %s, %s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerInputParameterivNV_ptr(stage, portion, variable, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCombinerOutputParameterfvNV_debug(GLenum stage, GLenum portion, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerOutputParameterfvNV, (%s, %s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerOutputParameterfvNV_ptr(stage, portion, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCombinerOutputParameterivNV_debug(GLenum stage, GLenum portion, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerOutputParameterivNV, (%s, %s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(portion), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerOutputParameterivNV_ptr(stage, portion, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFinalCombinerInputParameterfvNV_debug(GLenum variable, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFinalCombinerInputParameterfvNV, (%s, %s, %p), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFinalCombinerInputParameterfvNV_ptr(variable, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFinalCombinerInputParameterivNV_debug(GLenum variable, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFinalCombinerInputParameterivNV, (%s, %s, %p), enum_to_string_GL(variable), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFinalCombinerInputParameterivNV_ptr(variable, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_register_combiners
#ifdef GL_NV_register_combiners2
void glatter_glCombinerStageParameterfvNV_debug(GLenum stage, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCombinerStageParameterfvNV, (%s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(pname), (void*)params)
    glatter_glCombinerStageParameterfvNV_ptr(stage, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCombinerStageParameterfvNV_debug(GLenum stage, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCombinerStageParameterfvNV, (%s, %s, %p), enum_to_string_GL(stage), enum_to_string_GL(pname), (void*)params)
    glatter_glGetCombinerStageParameterfvNV_ptr(stage, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_register_combiners2
#ifdef GL_NV_sample_locations
void glatter_glFramebufferSampleLocationsfvNV_debug(GLenum target, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferSampleLocationsfvNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)start, (int)count, (void*)v)
    glatter_glFramebufferSampleLocationsfvNV_ptr(target, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferSampleLocationsfvNV_debug(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferSampleLocationsfvNV, (%u, %u, %d, %p), (unsigned int)framebuffer, (unsigned int)start, (int)count, (void*)v)
    glatter_glNamedFramebufferSampleLocationsfvNV_ptr(framebuffer, start, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glResolveDepthValuesNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResolveDepthValuesNV, ())
    glatter_glResolveDepthValuesNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_sample_locations
#ifdef GL_NV_shader_buffer_load
void glatter_glGetBufferParameterui64vNV_debug(GLenum target, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameterui64vNV, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameterui64vNV_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerui64vNV_debug(GLenum value, GLuint64EXT *result, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerui64vNV, (%s, %p), enum_to_string_GL(value), (void*)result)
    glatter_glGetIntegerui64vNV_ptr(value, result);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferParameterui64vNV_debug(GLuint buffer, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameterui64vNV, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameterui64vNV_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsBufferResidentNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBufferResidentNV, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glIsBufferResidentNV_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsNamedBufferResidentNV_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsNamedBufferResidentNV, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsNamedBufferResidentNV_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMakeBufferNonResidentNV_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeBufferNonResidentNV, (%s), enum_to_string_GL(target))
    glatter_glMakeBufferNonResidentNV_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeBufferResidentNV_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeBufferResidentNV, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(access))
    glatter_glMakeBufferResidentNV_ptr(target, access);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeNamedBufferNonResidentNV_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeNamedBufferNonResidentNV, (%u), (unsigned int)buffer)
    glatter_glMakeNamedBufferNonResidentNV_ptr(buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glMakeNamedBufferResidentNV_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMakeNamedBufferResidentNV, (%u, %s), (unsigned int)buffer, enum_to_string_GL(access))
    glatter_glMakeNamedBufferResidentNV_ptr(buffer, access);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformui64NV_debug(GLuint program, GLint location, GLuint64EXT value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformui64NV, (%u, %d, %s), (unsigned int)program, (int)location, GET_PRS(value))
    glatter_glProgramUniformui64NV_ptr(program, location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformui64vNV_debug(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformui64vNV, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniformui64vNV_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformui64NV_debug(GLint location, GLuint64EXT value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformui64NV, (%d, %s), (int)location, GET_PRS(value))
    glatter_glUniformui64NV_ptr(location, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformui64vNV_debug(GLint location, GLsizei count, const GLuint64EXT *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformui64vNV, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniformui64vNV_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_shader_buffer_load
#ifdef GL_NV_texture_barrier
void glatter_glTextureBarrierNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBarrierNV, ())
    glatter_glTextureBarrierNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_texture_barrier
#ifdef GL_NV_texture_multisample
void glatter_glTexImage2DMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage2DMultisampleCoverageNV, (%s, %d, %d, %d, %d, %d, %u), enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTexImage2DMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3DMultisampleCoverageNV_debug(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3DMultisampleCoverageNV, (%s, %d, %d, %d, %d, %d, %d, %u), enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTexImage3DMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage2DMultisampleCoverageNV_debug(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DMultisampleCoverageNV, (%u, %s, %d, %d, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage2DMultisampleCoverageNV_ptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage2DMultisampleNV_debug(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage2DMultisampleNV, (%u, %s, %d, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)samples, (int)internalFormat, (int)width, (int)height, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage2DMultisampleNV_ptr(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage3DMultisampleCoverageNV_debug(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DMultisampleCoverageNV, (%u, %s, %d, %d, %d, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)coverageSamples, (int)colorSamples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage3DMultisampleCoverageNV_ptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureImage3DMultisampleNV_debug(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureImage3DMultisampleNV, (%u, %s, %d, %d, %d, %d, %d, %u), (unsigned int)texture, enum_to_string_GL(target), (int)samples, (int)internalFormat, (int)width, (int)height, (int)depth, (unsigned char)fixedSampleLocations)
    glatter_glTextureImage3DMultisampleNV_ptr(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_texture_multisample
#ifdef GL_NV_transform_feedback
void glatter_glActiveVaryingNV_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveVaryingNV, (%u, %p), (unsigned int)program, (void*)name)
    glatter_glActiveVaryingNV_ptr(program, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBeginTransformFeedbackNV_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedbackNV, (%s), enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedbackNV_ptr(primitiveMode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferBaseNV_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBaseNV, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBaseNV_ptr(target, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferOffsetNV_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferOffsetNV, (%s, %u, %u, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset)
    glatter_glBindBufferOffsetNV_ptr(target, index, buffer, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferRangeNV_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRangeNV, (%s, %u, %u, %td, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glBindBufferRangeNV_ptr(target, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glEndTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedbackNV, ())
    glatter_glEndTransformFeedbackNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveVaryingNV_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveVaryingNV, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveVaryingNV_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackVaryingNV_debug(GLuint program, GLuint index, GLint *location, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVaryingNV, (%u, %u, %p), (unsigned int)program, (unsigned int)index, (void*)location)
    glatter_glGetTransformFeedbackVaryingNV_ptr(program, index, location);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetVaryingLocationNV_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVaryingLocationNV, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetVaryingLocationNV_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glTransformFeedbackAttribsNV_debug(GLsizei count, const GLint *attribs, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackAttribsNV, (%d, %p, %s), (int)count, (void*)attribs, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackAttribsNV_ptr(count, attribs, bufferMode);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackStreamAttribsNV_debug(GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackStreamAttribsNV, (%d, %p, %d, %p, %s), (int)count, (void*)attribs, (int)nbuffers, (void*)bufstreams, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackStreamAttribsNV_ptr(count, attribs, nbuffers, bufstreams, bufferMode);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackVaryingsNV_debug(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryingsNV, (%u, %d, %p, %s), (unsigned int)program, (int)count, (void*)locations, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryingsNV_ptr(program, count, locations, bufferMode);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_transform_feedback
#ifdef GL_NV_transform_feedback2
void glatter_glBindTransformFeedbackNV_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedbackNV, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedbackNV_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTransformFeedbacksNV_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacksNV, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacksNV_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackNV_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackNV, (%s, %u), enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedbackNV_ptr(mode, id);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTransformFeedbacksNV_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacksNV, (%d, %p), (int)n, (void*)ids)
    glatter_glGenTransformFeedbacksNV_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsTransformFeedbackNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedbackNV, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedbackNV_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glPauseTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedbackNV, ())
    glatter_glPauseTransformFeedbackNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glResumeTransformFeedbackNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedbackNV, ())
    glatter_glResumeTransformFeedbackNV_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_transform_feedback2
#ifdef GL_NV_vdpau_interop
void glatter_glVDPAUFiniNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUFiniNV, ())
    glatter_glVDPAUFiniNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glVDPAUGetSurfaceivNV_debug(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUGetSurfaceivNV, (%td, %s, %d, %p, %p), (ptrdiff_t)surface, enum_to_string_GL(pname), (int)bufSize, (void*)length, (void*)values)
    glatter_glVDPAUGetSurfaceivNV_ptr(surface, pname, bufSize, length, values);
    glatter_check_error_GL(file, line);
}
void glatter_glVDPAUInitNV_debug(const void *vdpDevice, const void *getProcAddress, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUInitNV, (%p, %p), (void*)vdpDevice, (void*)getProcAddress)
    glatter_glVDPAUInitNV_ptr(vdpDevice, getProcAddress);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glVDPAUIsSurfaceNV_debug(GLvdpauSurfaceNV surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUIsSurfaceNV, (%td), (ptrdiff_t)surface)
    GLboolean rval = glatter_glVDPAUIsSurfaceNV_ptr(surface);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVDPAUMapSurfacesNV_debug(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUMapSurfacesNV, (%d, %p), (int)numSurfaces, (void*)surfaces)
    glatter_glVDPAUMapSurfacesNV_ptr(numSurfaces, surfaces);
    glatter_check_error_GL(file, line);
}
GLvdpauSurfaceNV glatter_glVDPAURegisterOutputSurfaceNV_debug(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAURegisterOutputSurfaceNV, (%p, %s, %d, %p), (void*)vdpSurface, enum_to_string_GL(target), (int)numTextureNames, (void*)textureNames)
    GLvdpauSurfaceNV rval = glatter_glVDPAURegisterOutputSurfaceNV_ptr(vdpSurface, target, numTextureNames, textureNames);
    printf("GLATTER: returned %td", (ptrdiff_t)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLvdpauSurfaceNV glatter_glVDPAURegisterVideoSurfaceNV_debug(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAURegisterVideoSurfaceNV, (%p, %s, %d, %p), (void*)vdpSurface, enum_to_string_GL(target), (int)numTextureNames, (void*)textureNames)
    GLvdpauSurfaceNV rval = glatter_glVDPAURegisterVideoSurfaceNV_ptr(vdpSurface, target, numTextureNames, textureNames);
    printf("GLATTER: returned %td", (ptrdiff_t)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVDPAUSurfaceAccessNV_debug(GLvdpauSurfaceNV surface, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUSurfaceAccessNV, (%td, %s), (ptrdiff_t)surface, enum_to_string_GL(access))
    glatter_glVDPAUSurfaceAccessNV_ptr(surface, access);
    glatter_check_error_GL(file, line);
}
void glatter_glVDPAUUnmapSurfacesNV_debug(GLsizei numSurface, const GLvdpauSurfaceNV *surfaces, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUUnmapSurfacesNV, (%d, %p), (int)numSurface, (void*)surfaces)
    glatter_glVDPAUUnmapSurfacesNV_ptr(numSurface, surfaces);
    glatter_check_error_GL(file, line);
}
void glatter_glVDPAUUnregisterSurfaceNV_debug(GLvdpauSurfaceNV surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVDPAUUnregisterSurfaceNV, (%td), (ptrdiff_t)surface)
    glatter_glVDPAUUnregisterSurfaceNV_ptr(surface);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vdpau_interop
#ifdef GL_NV_vertex_array_range
void glatter_glFlushVertexArrayRangeNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushVertexArrayRangeNV, ())
    glatter_glFlushVertexArrayRangeNV_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayRangeNV_debug(GLsizei length, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayRangeNV, (%d, %p), (int)length, (void*)pointer)
    glatter_glVertexArrayRangeNV_ptr(length, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vertex_array_range
#ifdef GL_NV_vertex_attrib_integer_64bit
void glatter_glGetVertexAttribLi64vNV_debug(GLuint index, GLenum pname, GLint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLi64vNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLi64vNV_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribLui64vNV_debug(GLuint index, GLenum pname, GLuint64EXT *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLui64vNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLui64vNV_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1i64NV_debug(GLuint index, GLint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1i64NV, (%u, %s), (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1i64NV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1i64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1i64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64NV_debug(GLuint index, GLuint64EXT x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64NV, (%u, %s), (unsigned int)index, GET_PRS(x))
    glatter_glVertexAttribL1ui64NV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1ui64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1ui64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2i64NV, (%u, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y))
    glatter_glVertexAttribL2i64NV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2i64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2i64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2ui64NV, (%u, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y))
    glatter_glVertexAttribL2ui64NV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2ui64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2ui64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3i64NV, (%u, %s, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glVertexAttribL3i64NV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3i64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3i64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3ui64NV, (%u, %s, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z))
    glatter_glVertexAttribL3ui64NV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3ui64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3ui64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4i64NV_debug(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4i64NV, (%u, %s, %s, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glVertexAttribL4i64NV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4i64vNV_debug(GLuint index, const GLint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4i64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4i64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4ui64NV_debug(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4ui64NV, (%u, %s, %s, %s, %s), (unsigned int)index, GET_PRS(x), GET_PRS(y), GET_PRS(z), GET_PRS(w))
    glatter_glVertexAttribL4ui64NV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4ui64vNV_debug(GLuint index, const GLuint64EXT *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4ui64vNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4ui64vNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLFormatNV_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLFormatNV, (%u, %d, %s, %d), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexAttribLFormatNV_ptr(index, size, type, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vertex_attrib_integer_64bit
#ifdef GL_NV_vertex_buffer_unified_memory
void glatter_glBufferAddressRangeNV_debug(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferAddressRangeNV, (%s, %u, %s, %td), enum_to_string_GL(pname), (unsigned int)index, GET_PRS(address), (ptrdiff_t)length)
    glatter_glBufferAddressRangeNV_ptr(pname, index, address, length);
    glatter_check_error_GL(file, line);
}
void glatter_glColorFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorFormatNV, (%d, %s, %d), (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glColorFormatNV_ptr(size, type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glEdgeFlagFormatNV_debug(GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEdgeFlagFormatNV, (%d), (int)stride)
    glatter_glEdgeFlagFormatNV_ptr(stride);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordFormatNV, (%s, %d), enum_to_string_GL(type), (int)stride)
    glatter_glFogCoordFormatNV_ptr(type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegerui64i_vNV_debug(GLenum value, GLuint index, GLuint64EXT *result, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegerui64i_vNV, (%s, %u, %p), enum_to_string_GL(value), (unsigned int)index, (void*)result)
    glatter_glGetIntegerui64i_vNV_ptr(value, index, result);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexFormatNV, (%s, %d), enum_to_string_GL(type), (int)stride)
    glatter_glIndexFormatNV_ptr(type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalFormatNV_debug(GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalFormatNV, (%s, %d), enum_to_string_GL(type), (int)stride)
    glatter_glNormalFormatNV_ptr(type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorFormatNV, (%d, %s, %d), (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glSecondaryColorFormatNV_ptr(size, type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordFormatNV, (%d, %s, %d), (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glTexCoordFormatNV_ptr(size, type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribFormatNV_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormatNV, (%u, %d, %s, %u, %d), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride)
    glatter_glVertexAttribFormatNV_ptr(index, size, type, normalized, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIFormatNV_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormatNV, (%u, %d, %s, %d), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexAttribIFormatNV_ptr(index, size, type, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexFormatNV_debug(GLint size, GLenum type, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexFormatNV, (%d, %s, %d), (int)size, enum_to_string_GL(type), (int)stride)
    glatter_glVertexFormatNV_ptr(size, type, stride);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vertex_buffer_unified_memory
#ifdef GL_NV_vertex_program
GLboolean glatter_glAreProgramsResidentNV_debug(GLsizei n, const GLuint *programs, GLboolean *residences, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAreProgramsResidentNV, (%d, %p, %p), (int)n, (void*)programs, (void*)residences)
    GLboolean rval = glatter_glAreProgramsResidentNV_ptr(n, programs, residences);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glBindProgramNV_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramNV, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindProgramNV_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteProgramsNV_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramsNV, (%d, %p), (int)n, (void*)programs)
    glatter_glDeleteProgramsNV_ptr(n, programs);
    glatter_check_error_GL(file, line);
}
void glatter_glExecuteProgramNV_debug(GLenum target, GLuint id, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glExecuteProgramNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)id, (void*)params)
    glatter_glExecuteProgramNV_ptr(target, id, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramsNV_debug(GLsizei n, GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramsNV, (%d, %p), (int)n, (void*)programs)
    glatter_glGenProgramsNV_ptr(n, programs);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramParameterdvNV_debug(GLenum target, GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramParameterdvNV, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramParameterdvNV_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramParameterfvNV_debug(GLenum target, GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramParameterfvNV, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramParameterfvNV_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramStringNV_debug(GLuint id, GLenum pname, GLubyte *program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStringNV, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)program)
    glatter_glGetProgramStringNV_ptr(id, pname, program);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramivNV_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramivNV, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramivNV_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTrackMatrixivNV_debug(GLenum target, GLuint address, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTrackMatrixivNV, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)address, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTrackMatrixivNV_ptr(target, address, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribPointervNV_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointervNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointervNV_ptr(index, pname, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribdvNV_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdvNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdvNV_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribfvNV_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfvNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfvNV_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribivNV_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribivNV, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribivNV_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramNV_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramNV, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsProgramNV_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLoadProgramNV_debug(GLenum target, GLuint id, GLsizei len, const GLubyte *program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadProgramNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)id, (int)len, (void*)program)
    glatter_glLoadProgramNV_ptr(target, id, len, program);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameter4dNV_debug(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4dNV, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glProgramParameter4dNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameter4dvNV_debug(GLenum target, GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4dvNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)v)
    glatter_glProgramParameter4dvNV_ptr(target, index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameter4fNV_debug(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4fNV, (%s, %u, %f, %f, %f, %f), enum_to_string_GL(target), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glProgramParameter4fNV_ptr(target, index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameter4fvNV_debug(GLenum target, GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameter4fvNV, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)v)
    glatter_glProgramParameter4fvNV_ptr(target, index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameters4dvNV_debug(GLenum target, GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameters4dvNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)v)
    glatter_glProgramParameters4dvNV_ptr(target, index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameters4fvNV_debug(GLenum target, GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameters4fvNV, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)index, (int)count, (void*)v)
    glatter_glProgramParameters4fvNV_ptr(target, index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glRequestResidentProgramsNV_debug(GLsizei n, const GLuint *programs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRequestResidentProgramsNV, (%d, %p), (int)n, (void*)programs)
    glatter_glRequestResidentProgramsNV_ptr(n, programs);
    glatter_check_error_GL(file, line);
}
void glatter_glTrackMatrixNV_debug(GLenum target, GLuint address, GLenum matrix, GLenum transform, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTrackMatrixNV, (%s, %u, %s, %s), enum_to_string_GL(target), (unsigned int)address, enum_to_string_GL(matrix), enum_to_string_GL(transform))
    glatter_glTrackMatrixNV_ptr(target, address, matrix, transform);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dNV_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dNV, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttrib1dNV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fNV_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fNV, (%u, %f), (unsigned int)index, (float)x)
    glatter_glVertexAttrib1fNV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1sNV_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sNV, (%u, %hi), (unsigned int)index, (short)x)
    glatter_glVertexAttrib1sNV_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1svNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1svNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dNV_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dNV, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2dNV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fNV_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fNV, (%u, %f, %f), (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2fNV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2sNV_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sNV, (%u, %hi, %hi), (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2sNV_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2svNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2svNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dNV_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dNV, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3dNV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fNV_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fNV, (%u, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3fNV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3sNV_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sNV, (%u, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3sNV_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3svNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3svNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dNV_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dNV, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4dNV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dvNV_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fNV_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fNV, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4fNV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fvNV_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4sNV_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sNV, (%u, %hi, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4sNV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4svNV_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4svNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4svNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ubNV_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubNV, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4ubNV_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ubvNV_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubvNV, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubvNV_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribPointerNV_debug(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointerNV, (%u, %d, %s, %d, %p), (unsigned int)index, (int)fsize, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribPointerNV_ptr(index, fsize, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs1dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1dvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1dvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs1fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1fvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1fvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs1svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs1svNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs1svNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs2dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2dvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2dvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs2fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2fvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2fvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs2svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs2svNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs2svNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs3dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3dvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3dvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs3fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3fvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3fvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs3svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs3svNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs3svNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs4dvNV_debug(GLuint index, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4dvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4dvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs4fvNV_debug(GLuint index, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4fvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4fvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs4svNV_debug(GLuint index, GLsizei count, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4svNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4svNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribs4ubvNV_debug(GLuint index, GLsizei count, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribs4ubvNV, (%u, %d, %p), (unsigned int)index, (int)count, (void*)v)
    glatter_glVertexAttribs4ubvNV_ptr(index, count, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vertex_program
#ifdef GL_NV_vertex_program4
void glatter_glGetVertexAttribIivEXT_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIivEXT, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIivEXT_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIuivEXT_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuivEXT, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuivEXT_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1iEXT_debug(GLuint index, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1iEXT, (%u, %d), (unsigned int)index, (int)x)
    glatter_glVertexAttribI1iEXT_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1ivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1ivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1uiEXT_debug(GLuint index, GLuint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uiEXT, (%u, %u), (unsigned int)index, (unsigned int)x)
    glatter_glVertexAttribI1uiEXT_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1uivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2iEXT_debug(GLuint index, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2iEXT, (%u, %d, %d), (unsigned int)index, (int)x, (int)y)
    glatter_glVertexAttribI2iEXT_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2ivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2ivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2uiEXT_debug(GLuint index, GLuint x, GLuint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uiEXT, (%u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y)
    glatter_glVertexAttribI2uiEXT_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2uivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3iEXT_debug(GLuint index, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3iEXT, (%u, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z)
    glatter_glVertexAttribI3iEXT_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3ivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3ivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3uiEXT_debug(GLuint index, GLuint x, GLuint y, GLuint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uiEXT, (%u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z)
    glatter_glVertexAttribI3uiEXT_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3uivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4bvEXT_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4bvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4bvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4iEXT_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iEXT, (%u, %d, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4iEXT_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ivEXT_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4svEXT_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4svEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4svEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ubvEXT_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ubvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ubvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4uiEXT_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiEXT, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4uiEXT_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4uivEXT_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uivEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uivEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4usvEXT_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4usvEXT, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4usvEXT_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIPointerEXT_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointerEXT, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointerEXT_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_vertex_program4
#ifdef GL_NV_video_capture
void glatter_glBeginVideoCaptureNV_debug(GLuint video_capture_slot, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginVideoCaptureNV, (%u), (unsigned int)video_capture_slot)
    glatter_glBeginVideoCaptureNV_ptr(video_capture_slot);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVideoCaptureStreamBufferNV_debug(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVideoCaptureStreamBufferNV, (%u, %u, %s, %td), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(frame_region), (ptrdiff_t)offset)
    glatter_glBindVideoCaptureStreamBufferNV_ptr(video_capture_slot, stream, frame_region, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVideoCaptureStreamTextureNV_debug(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVideoCaptureStreamTextureNV, (%u, %u, %s, %s, %u), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(frame_region), enum_to_string_GL(target), (unsigned int)texture)
    glatter_glBindVideoCaptureStreamTextureNV_ptr(video_capture_slot, stream, frame_region, target, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glEndVideoCaptureNV_debug(GLuint video_capture_slot, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndVideoCaptureNV, (%u), (unsigned int)video_capture_slot)
    glatter_glEndVideoCaptureNV_ptr(video_capture_slot);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoCaptureStreamdvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamdvNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamdvNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoCaptureStreamfvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamfvNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamfvNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoCaptureStreamivNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureStreamivNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureStreamivNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVideoCaptureivNV_debug(GLuint video_capture_slot, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVideoCaptureivNV, (%u, %s, %p), (unsigned int)video_capture_slot, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVideoCaptureivNV_ptr(video_capture_slot, pname, params);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glVideoCaptureNV_debug(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureNV, (%u, %p, %p), (unsigned int)video_capture_slot, (void*)sequence_num, (void*)capture_time)
    GLenum rval = glatter_glVideoCaptureNV_ptr(video_capture_slot, sequence_num, capture_time);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVideoCaptureStreamParameterdvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterdvNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterdvNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVideoCaptureStreamParameterfvNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterfvNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterfvNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glVideoCaptureStreamParameterivNV_debug(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVideoCaptureStreamParameterivNV, (%u, %u, %s, %p), (unsigned int)video_capture_slot, (unsigned int)stream, enum_to_string_GL(pname), (void*)params)
    glatter_glVideoCaptureStreamParameterivNV_ptr(video_capture_slot, stream, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_video_capture
#ifdef GL_NV_viewport_swizzle
void glatter_glViewportSwizzleNV_debug(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportSwizzleNV, (%u, %s, %s, %s, %s), (unsigned int)index, enum_to_string_GL(swizzlex), enum_to_string_GL(swizzley), enum_to_string_GL(swizzlez), enum_to_string_GL(swizzlew))
    glatter_glViewportSwizzleNV_ptr(index, swizzlex, swizzley, swizzlez, swizzlew);
    glatter_check_error_GL(file, line);
}
#endif // GL_NV_viewport_swizzle
#ifdef GL_OES_byte_coordinates
void glatter_glMultiTexCoord1bOES_debug(GLenum texture, GLbyte s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1bOES, (%s, %d), enum_to_string_GL(texture), (signed char)s)
    glatter_glMultiTexCoord1bOES_ptr(texture, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1bvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord1bvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2bOES_debug(GLenum texture, GLbyte s, GLbyte t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2bOES, (%s, %d, %d), enum_to_string_GL(texture), (signed char)s, (signed char)t)
    glatter_glMultiTexCoord2bOES_ptr(texture, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2bvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord2bvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3bOES_debug(GLenum texture, GLbyte s, GLbyte t, GLbyte r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3bOES, (%s, %d, %d, %d), enum_to_string_GL(texture), (signed char)s, (signed char)t, (signed char)r)
    glatter_glMultiTexCoord3bOES_ptr(texture, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3bvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord3bvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4bOES_debug(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4bOES, (%s, %d, %d, %d, %d), enum_to_string_GL(texture), (signed char)s, (signed char)t, (signed char)r, (signed char)q)
    glatter_glMultiTexCoord4bOES_ptr(texture, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4bvOES_debug(GLenum texture, const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4bvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord4bvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1bOES_debug(GLbyte s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1bOES, (%d), (signed char)s)
    glatter_glTexCoord1bOES_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1bvOES, (%p), (void*)coords)
    glatter_glTexCoord1bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2bOES_debug(GLbyte s, GLbyte t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2bOES, (%d, %d), (signed char)s, (signed char)t)
    glatter_glTexCoord2bOES_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2bvOES, (%p), (void*)coords)
    glatter_glTexCoord2bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3bOES_debug(GLbyte s, GLbyte t, GLbyte r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3bOES, (%d, %d, %d), (signed char)s, (signed char)t, (signed char)r)
    glatter_glTexCoord3bOES_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3bvOES, (%p), (void*)coords)
    glatter_glTexCoord3bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4bOES_debug(GLbyte s, GLbyte t, GLbyte r, GLbyte q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4bOES, (%d, %d, %d, %d), (signed char)s, (signed char)t, (signed char)r, (signed char)q)
    glatter_glTexCoord4bOES_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4bvOES, (%p), (void*)coords)
    glatter_glTexCoord4bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2bOES_debug(GLbyte x, GLbyte y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2bOES, (%d, %d), (signed char)x, (signed char)y)
    glatter_glVertex2bOES_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2bvOES, (%p), (void*)coords)
    glatter_glVertex2bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3bOES_debug(GLbyte x, GLbyte y, GLbyte z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3bOES, (%d, %d, %d), (signed char)x, (signed char)y, (signed char)z)
    glatter_glVertex3bOES_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3bvOES, (%p), (void*)coords)
    glatter_glVertex3bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4bOES_debug(GLbyte x, GLbyte y, GLbyte z, GLbyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4bOES, (%d, %d, %d, %d), (signed char)x, (signed char)y, (signed char)z, (signed char)w)
    glatter_glVertex4bOES_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4bvOES_debug(const GLbyte *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4bvOES, (%p), (void*)coords)
    glatter_glVertex4bvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_byte_coordinates
#ifdef GL_OES_fixed_point
void glatter_glAccumxOES_debug(GLenum op, GLfixed value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAccumxOES, (%s, %d), enum_to_string_GL(op), (int)value)
    glatter_glAccumxOES_ptr(op, value);
    glatter_check_error_GL(file, line);
}
void glatter_glAlphaFuncxOES_debug(GLenum func, GLfixed ref, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAlphaFuncxOES, (%s, %d), enum_to_string_GL(func), (int)ref)
    glatter_glAlphaFuncxOES_ptr(func, ref);
    glatter_check_error_GL(file, line);
}
void glatter_glBitmapxOES_debug(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBitmapxOES, (%d, %d, %d, %d, %d, %d, %p), (int)width, (int)height, (int)xorig, (int)yorig, (int)xmove, (int)ymove, (void*)bitmap)
    glatter_glBitmapxOES_ptr(width, height, xorig, yorig, xmove, ymove, bitmap);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendColorxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColorxOES, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glBlendColorxOES_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearAccumxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearAccumxOES, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glClearAccumxOES_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearColorxOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearColorxOES, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glClearColorxOES_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepthxOES_debug(GLfixed depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthxOES, (%d), (int)depth)
    glatter_glClearDepthxOES_ptr(depth);
    glatter_check_error_GL(file, line);
}
void glatter_glClipPlanexOES_debug(GLenum plane, const GLfixed *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipPlanexOES, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glClipPlanexOES_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3xOES_debug(GLfixed red, GLfixed green, GLfixed blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3xOES, (%d, %d, %d), (int)red, (int)green, (int)blue)
    glatter_glColor3xOES_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3xvOES_debug(const GLfixed *components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3xvOES, (%p), (void*)components)
    glatter_glColor3xvOES_ptr(components);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4xOES_debug(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4xOES, (%d, %d, %d, %d), (int)red, (int)green, (int)blue, (int)alpha)
    glatter_glColor4xOES_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4xvOES_debug(const GLfixed *components, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4xvOES, (%p), (void*)components)
    glatter_glColor4xvOES_ptr(components);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterxOES, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glConvolutionParameterxOES_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glConvolutionParameterxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glConvolutionParameterxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glConvolutionParameterxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangexOES_debug(GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangexOES, (%d, %d), (int)n, (int)f)
    glatter_glDepthRangexOES_ptr(n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1xOES_debug(GLfixed u, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1xOES, (%d), (int)u)
    glatter_glEvalCoord1xOES_ptr(u);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord1xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord1xvOES, (%p), (void*)coords)
    glatter_glEvalCoord1xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2xOES_debug(GLfixed u, GLfixed v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2xOES, (%d, %d), (int)u, (int)v)
    glatter_glEvalCoord2xOES_ptr(u, v);
    glatter_check_error_GL(file, line);
}
void glatter_glEvalCoord2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEvalCoord2xvOES, (%p), (void*)coords)
    glatter_glEvalCoord2xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glFeedbackBufferxOES_debug(GLsizei n, GLenum type, const GLfixed *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFeedbackBufferxOES, (%d, %s, %p), (int)n, enum_to_string_GL(type), (void*)buffer)
    glatter_glFeedbackBufferxOES_ptr(n, type, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFogxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogxOES, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glFogxOES_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFogxvOES_debug(GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogxvOES, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glFogxvOES_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFrustumxOES_debug(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrustumxOES, (%d, %d, %d, %d, %d, %d), (int)l, (int)r, (int)b, (int)t, (int)n, (int)f)
    glatter_glFrustumxOES_ptr(l, r, b, t, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glGetClipPlanexOES_debug(GLenum plane, GLfixed *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetClipPlanexOES, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glGetClipPlanexOES_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glGetConvolutionParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetConvolutionParameterxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetConvolutionParameterxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFixedvOES_debug(GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFixedvOES, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFixedvOES_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetHistogramParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetHistogramParameterxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetHistogramParameterxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetLightxOES_debug(GLenum light, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetLightxOES, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetLightxOES_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMapxvOES_debug(GLenum target, GLenum query, GLfixed *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMapxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(query), (void*)v)
    glatter_glGetMapxvOES_ptr(target, query, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetMaterialxOES_debug(GLenum face, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetMaterialxOES, (%s, %s, %d), enum_to_string_GL(face), enum_to_string_GL(pname), (int)param)
    glatter_glGetMaterialxOES_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelMapxv_debug(GLenum map, GLint size, GLfixed *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelMapxv, (%s, %d, %p), enum_to_string_GL(map), (int)size, (void*)values)
    glatter_glGetPixelMapxv_ptr(map, size, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexEnvxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexEnvxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexEnvxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexGenxvOES_debug(GLenum coord, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexGenxvOES, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexGenxvOES_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexLevelParameterxvOES_debug(GLenum target, GLint level, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexLevelParameterxvOES, (%s, %d, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexLevelParameterxvOES_ptr(target, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterxvOES_debug(GLenum target, GLenum pname, GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexxOES_debug(GLfixed component, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexxOES, (%d), (int)component)
    glatter_glIndexxOES_ptr(component);
    glatter_check_error_GL(file, line);
}
void glatter_glIndexxvOES_debug(const GLfixed *component, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIndexxvOES, (%p), (void*)component)
    glatter_glIndexxvOES_ptr(component);
    glatter_check_error_GL(file, line);
}
void glatter_glLightModelxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelxOES, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glLightModelxOES_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightModelxvOES_debug(GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightModelxvOES, (%s, %p), enum_to_string_GL(pname), (void*)param)
    glatter_glLightModelxvOES_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightxOES_debug(GLenum light, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightxOES, (%s, %s, %d), enum_to_string_GL(light), enum_to_string_GL(pname), (int)param)
    glatter_glLightxOES_ptr(light, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glLightxvOES_debug(GLenum light, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightxvOES, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glLightxvOES_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLineWidthxOES_debug(GLfixed width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLineWidthxOES, (%d), (int)width)
    glatter_glLineWidthxOES_ptr(width);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadMatrixxOES, (%p), (void*)m)
    glatter_glLoadMatrixxOES_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadTransposeMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixxOES, (%p), (void*)m)
    glatter_glLoadTransposeMatrixxOES_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMap1xOES_debug(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap1xOES, (%s, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)u1, (int)u2, (int)stride, (int)order, (int)points)
    glatter_glMap1xOES_ptr(target, u1, u2, stride, order, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMap2xOES_debug(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMap2xOES, (%s, %d, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)u1, (int)u2, (int)ustride, (int)uorder, (int)v1, (int)v2, (int)vstride, (int)vorder, (int)points)
    glatter_glMap2xOES_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid1xOES_debug(GLint n, GLfixed u1, GLfixed u2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid1xOES, (%d, %d, %d), (int)n, (int)u1, (int)u2)
    glatter_glMapGrid1xOES_ptr(n, u1, u2);
    glatter_check_error_GL(file, line);
}
void glatter_glMapGrid2xOES_debug(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapGrid2xOES, (%d, %d, %d, %d, %d), (int)n, (int)u1, (int)u2, (int)v1, (int)v2)
    glatter_glMapGrid2xOES_ptr(n, u1, u2, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glMaterialxOES_debug(GLenum face, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialxOES, (%s, %s, %d), enum_to_string_GL(face), enum_to_string_GL(pname), (int)param)
    glatter_glMaterialxOES_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMaterialxvOES_debug(GLenum face, GLenum pname, const GLfixed *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMaterialxvOES, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)param)
    glatter_glMaterialxvOES_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glMultMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultMatrixxOES, (%p), (void*)m)
    glatter_glMultMatrixxOES_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultTransposeMatrixxOES_debug(const GLfixed *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixxOES, (%p), (void*)m)
    glatter_glMultTransposeMatrixxOES_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1xOES_debug(GLenum texture, GLfixed s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1xOES, (%s, %d), enum_to_string_GL(texture), (int)s)
    glatter_glMultiTexCoord1xOES_ptr(texture, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1xvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord1xvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2xOES_debug(GLenum texture, GLfixed s, GLfixed t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2xOES, (%s, %d, %d), enum_to_string_GL(texture), (int)s, (int)t)
    glatter_glMultiTexCoord2xOES_ptr(texture, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2xvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord2xvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3xOES_debug(GLenum texture, GLfixed s, GLfixed t, GLfixed r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3xOES, (%s, %d, %d, %d), enum_to_string_GL(texture), (int)s, (int)t, (int)r)
    glatter_glMultiTexCoord3xOES_ptr(texture, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3xvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord3xvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4xOES_debug(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4xOES, (%s, %d, %d, %d, %d), enum_to_string_GL(texture), (int)s, (int)t, (int)r, (int)q)
    glatter_glMultiTexCoord4xOES_ptr(texture, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4xvOES_debug(GLenum texture, const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4xvOES, (%s, %p), enum_to_string_GL(texture), (void*)coords)
    glatter_glMultiTexCoord4xvOES_ptr(texture, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3xOES_debug(GLfixed nx, GLfixed ny, GLfixed nz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3xOES, (%d, %d, %d), (int)nx, (int)ny, (int)nz)
    glatter_glNormal3xOES_ptr(nx, ny, nz);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3xvOES, (%p), (void*)coords)
    glatter_glNormal3xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glOrthoxOES_debug(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glOrthoxOES, (%d, %d, %d, %d, %d, %d), (int)l, (int)r, (int)b, (int)t, (int)n, (int)f)
    glatter_glOrthoxOES_ptr(l, r, b, t, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glPassThroughxOES_debug(GLfixed token, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPassThroughxOES, (%d), (int)token)
    glatter_glPassThroughxOES_ptr(token);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelMapx_debug(GLenum map, GLint size, const GLfixed *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelMapx, (%s, %d, %p), enum_to_string_GL(map), (int)size, (void*)values)
    glatter_glPixelMapx_ptr(map, size, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelStorex_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelStorex, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelStorex_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTransferxOES_debug(GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTransferxOES, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelTransferxOES_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelZoomxOES_debug(GLfixed xfactor, GLfixed yfactor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelZoomxOES, (%d, %d), (int)xfactor, (int)yfactor)
    glatter_glPixelZoomxOES_ptr(xfactor, yfactor);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterxvOES_debug(GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterxvOES, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterxvOES_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPointSizexOES_debug(GLfixed size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointSizexOES, (%d), (int)size)
    glatter_glPointSizexOES_ptr(size);
    glatter_check_error_GL(file, line);
}
void glatter_glPolygonOffsetxOES_debug(GLfixed factor, GLfixed units, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPolygonOffsetxOES, (%d, %d), (int)factor, (int)units)
    glatter_glPolygonOffsetxOES_ptr(factor, units);
    glatter_check_error_GL(file, line);
}
void glatter_glPrioritizeTexturesxOES_debug(GLsizei n, const GLuint *textures, const GLfixed *priorities, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrioritizeTexturesxOES, (%d, %p, %p), (int)n, (void*)textures, (void*)priorities)
    glatter_glPrioritizeTexturesxOES_ptr(n, textures, priorities);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2xOES_debug(GLfixed x, GLfixed y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2xOES, (%d, %d), (int)x, (int)y)
    glatter_glRasterPos2xOES_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos2xvOES, (%p), (void*)coords)
    glatter_glRasterPos2xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3xOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3xOES, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glRasterPos3xOES_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos3xvOES, (%p), (void*)coords)
    glatter_glRasterPos3xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4xOES_debug(GLfixed x, GLfixed y, GLfixed z, GLfixed w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4xOES, (%d, %d, %d, %d), (int)x, (int)y, (int)z, (int)w)
    glatter_glRasterPos4xOES_ptr(x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glRasterPos4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRasterPos4xvOES, (%p), (void*)coords)
    glatter_glRasterPos4xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glRectxOES_debug(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectxOES, (%d, %d, %d, %d), (int)x1, (int)y1, (int)x2, (int)y2)
    glatter_glRectxOES_ptr(x1, y1, x2, y2);
    glatter_check_error_GL(file, line);
}
void glatter_glRectxvOES_debug(const GLfixed *v1, const GLfixed *v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRectxvOES, (%p, %p), (void*)v1, (void*)v2)
    glatter_glRectxvOES_ptr(v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glRotatexOES_debug(GLfixed angle, GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRotatexOES, (%d, %d, %d, %d), (int)angle, (int)x, (int)y, (int)z)
    glatter_glRotatexOES_ptr(angle, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glScalexOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScalexOES, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glScalexOES_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1xOES_debug(GLfixed s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1xOES, (%d), (int)s)
    glatter_glTexCoord1xOES_ptr(s);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord1xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord1xvOES, (%p), (void*)coords)
    glatter_glTexCoord1xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2xOES_debug(GLfixed s, GLfixed t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2xOES, (%d, %d), (int)s, (int)t)
    glatter_glTexCoord2xOES_ptr(s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2xvOES, (%p), (void*)coords)
    glatter_glTexCoord2xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3xOES_debug(GLfixed s, GLfixed t, GLfixed r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3xOES, (%d, %d, %d), (int)s, (int)t, (int)r)
    glatter_glTexCoord3xOES_ptr(s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord3xvOES, (%p), (void*)coords)
    glatter_glTexCoord3xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4xOES_debug(GLfixed s, GLfixed t, GLfixed r, GLfixed q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4xOES, (%d, %d, %d, %d), (int)s, (int)t, (int)r, (int)q)
    glatter_glTexCoord4xOES_ptr(s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4xvOES, (%p), (void*)coords)
    glatter_glTexCoord4xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnvxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvxOES, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexEnvxOES_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexEnvxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexEnvxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexEnvxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGenxOES_debug(GLenum coord, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenxOES, (%s, %s, %d), enum_to_string_GL(coord), enum_to_string_GL(pname), (int)param)
    glatter_glTexGenxOES_ptr(coord, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexGenxvOES_debug(GLenum coord, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexGenxvOES, (%s, %s, %p), enum_to_string_GL(coord), enum_to_string_GL(pname), (void*)params)
    glatter_glTexGenxvOES_ptr(coord, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterxOES_debug(GLenum target, GLenum pname, GLfixed param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterxOES, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glTexParameterxOES_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterxvOES_debug(GLenum target, GLenum pname, const GLfixed *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterxvOES, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterxvOES_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTranslatexOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTranslatexOES, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glTranslatexOES_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2xOES_debug(GLfixed x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2xOES, (%d), (int)x)
    glatter_glVertex2xOES_ptr(x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex2xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex2xvOES, (%p), (void*)coords)
    glatter_glVertex2xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3xOES_debug(GLfixed x, GLfixed y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3xOES, (%d, %d), (int)x, (int)y)
    glatter_glVertex3xOES_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex3xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex3xvOES, (%p), (void*)coords)
    glatter_glVertex3xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4xOES_debug(GLfixed x, GLfixed y, GLfixed z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4xOES, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glVertex4xOES_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertex4xvOES_debug(const GLfixed *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertex4xvOES, (%p), (void*)coords)
    glatter_glVertex4xvOES_ptr(coords);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_fixed_point
#ifdef GL_OES_query_matrix
GLbitfield glatter_glQueryMatrixxOES_debug(GLfixed *mantissa, GLint *exponent, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryMatrixxOES, (%p, %p), (void*)mantissa, (void*)exponent)
    GLbitfield rval = glatter_glQueryMatrixxOES_ptr(mantissa, exponent);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_OES_query_matrix
#ifdef GL_OES_single_precision
void glatter_glClearDepthfOES_debug(GLclampf depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthfOES, (%f), (float)depth)
    glatter_glClearDepthfOES_ptr(depth);
    glatter_check_error_GL(file, line);
}
void glatter_glClipPlanefOES_debug(GLenum plane, const GLfloat *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipPlanefOES, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glClipPlanefOES_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangefOES_debug(GLclampf n, GLclampf f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangefOES, (%f, %f), (float)n, (float)f)
    glatter_glDepthRangefOES_ptr(n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glFrustumfOES_debug(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrustumfOES, (%f, %f, %f, %f, %f, %f), (float)l, (float)r, (float)b, (float)t, (float)n, (float)f)
    glatter_glFrustumfOES_ptr(l, r, b, t, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glGetClipPlanefOES_debug(GLenum plane, GLfloat *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetClipPlanefOES, (%s, %p), enum_to_string_GL(plane), (void*)equation)
    glatter_glGetClipPlanefOES_ptr(plane, equation);
    glatter_check_error_GL(file, line);
}
void glatter_glOrthofOES_debug(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glOrthofOES, (%f, %f, %f, %f, %f, %f), (float)l, (float)r, (float)b, (float)t, (float)n, (float)f)
    glatter_glOrthofOES_ptr(l, r, b, t, n, f);
    glatter_check_error_GL(file, line);
}
#endif // GL_OES_single_precision
#ifdef GL_OVR_multiview
void glatter_glFramebufferTextureMultiviewOVR_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureMultiviewOVR, (%s, %s, %u, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)baseViewIndex, (int)numViews)
    glatter_glFramebufferTextureMultiviewOVR_ptr(target, attachment, texture, level, baseViewIndex, numViews);
    glatter_check_error_GL(file, line);
}
#endif // GL_OVR_multiview
#ifdef GL_PGI_misc_hints
void glatter_glHintPGI_debug(GLenum target, GLint mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glHintPGI, (%s, %d), enum_to_string_GL(target), (int)mode)
    glatter_glHintPGI_ptr(target, mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_PGI_misc_hints
#ifdef GL_SGIS_detail_texture
void glatter_glDetailTexFuncSGIS_debug(GLenum target, GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetailTexFuncSGIS, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)points)
    glatter_glDetailTexFuncSGIS_ptr(target, n, points);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDetailTexFuncSGIS_debug(GLenum target, GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDetailTexFuncSGIS, (%s, %p), enum_to_string_GL(target), (void*)points)
    glatter_glGetDetailTexFuncSGIS_ptr(target, points);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_detail_texture
#ifdef GL_SGIS_fog_function
void glatter_glFogFuncSGIS_debug(GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogFuncSGIS, (%d, %p), (int)n, (void*)points)
    glatter_glFogFuncSGIS_ptr(n, points);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFogFuncSGIS_debug(GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFogFuncSGIS, (%p), (void*)points)
    glatter_glGetFogFuncSGIS_ptr(points);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_fog_function
#ifdef GL_SGIS_multisample
void glatter_glSampleMaskSGIS_debug(GLclampf value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleMaskSGIS, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleMaskSGIS_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplePatternSGIS_debug(GLenum pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplePatternSGIS, (%s), enum_to_string_GL(pattern))
    glatter_glSamplePatternSGIS_ptr(pattern);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_multisample
#ifdef GL_SGIS_pixel_texture
void glatter_glGetPixelTexGenParameterfvSGIS_debug(GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTexGenParameterfvSGIS, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTexGenParameterfvSGIS_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetPixelTexGenParameterivSGIS_debug(GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetPixelTexGenParameterivSGIS, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glGetPixelTexGenParameterivSGIS_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTexGenParameterfSGIS_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterfSGIS, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPixelTexGenParameterfSGIS_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTexGenParameterfvSGIS_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterfvSGIS, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTexGenParameterfvSGIS_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTexGenParameteriSGIS_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameteriSGIS, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPixelTexGenParameteriSGIS_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPixelTexGenParameterivSGIS_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenParameterivSGIS, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPixelTexGenParameterivSGIS_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_pixel_texture
#ifdef GL_SGIS_point_parameters
void glatter_glPointParameterfSGIS_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfSGIS, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterfSGIS_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterfvSGIS_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfvSGIS, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfvSGIS_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_point_parameters
#ifdef GL_SGIS_sharpen_texture
void glatter_glGetSharpenTexFuncSGIS_debug(GLenum target, GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSharpenTexFuncSGIS, (%s, %p), enum_to_string_GL(target), (void*)points)
    glatter_glGetSharpenTexFuncSGIS_ptr(target, points);
    glatter_check_error_GL(file, line);
}
void glatter_glSharpenTexFuncSGIS_debug(GLenum target, GLsizei n, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSharpenTexFuncSGIS, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)points)
    glatter_glSharpenTexFuncSGIS_ptr(target, n, points);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_sharpen_texture
#ifdef GL_SGIS_texture4D
void glatter_glTexImage4DSGIS_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage4DSGIS, (%s, %d, %s, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)size4d, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage4DSGIS_ptr(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage4DSGIS_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage4DSGIS, (%s, %d, %d, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)woffset, (int)width, (int)height, (int)depth, (int)size4d, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage4DSGIS_ptr(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_texture4D
#ifdef GL_SGIS_texture_color_mask
void glatter_glTextureColorMaskSGIS_debug(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureColorMaskSGIS, (%u, %u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue, (unsigned char)alpha)
    glatter_glTextureColorMaskSGIS_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_texture_color_mask
#ifdef GL_SGIS_texture_filter4
void glatter_glGetTexFilterFuncSGIS_debug(GLenum target, GLenum filter, GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexFilterFuncSGIS, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(filter), (void*)weights)
    glatter_glGetTexFilterFuncSGIS_ptr(target, filter, weights);
    glatter_check_error_GL(file, line);
}
void glatter_glTexFilterFuncSGIS_debug(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexFilterFuncSGIS, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(filter), (int)n, (void*)weights)
    glatter_glTexFilterFuncSGIS_ptr(target, filter, n, weights);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIS_texture_filter4
#ifdef GL_SGIX_async
void glatter_glAsyncMarkerSGIX_debug(GLuint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAsyncMarkerSGIX, (%u), (unsigned int)marker)
    glatter_glAsyncMarkerSGIX_ptr(marker);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteAsyncMarkersSGIX_debug(GLuint marker, GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteAsyncMarkersSGIX, (%u, %d), (unsigned int)marker, (int)range)
    glatter_glDeleteAsyncMarkersSGIX_ptr(marker, range);
    glatter_check_error_GL(file, line);
}
GLint glatter_glFinishAsyncSGIX_debug(GLuint *markerp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishAsyncSGIX, (%p), (void*)markerp)
    GLint rval = glatter_glFinishAsyncSGIX_ptr(markerp);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glGenAsyncMarkersSGIX_debug(GLsizei range, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenAsyncMarkersSGIX, (%d), (int)range)
    GLuint rval = glatter_glGenAsyncMarkersSGIX_ptr(range);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsAsyncMarkerSGIX_debug(GLuint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsAsyncMarkerSGIX, (%u), (unsigned int)marker)
    GLboolean rval = glatter_glIsAsyncMarkerSGIX_ptr(marker);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glPollAsyncSGIX_debug(GLuint *markerp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPollAsyncSGIX, (%p), (void*)markerp)
    GLint rval = glatter_glPollAsyncSGIX_ptr(markerp);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_SGIX_async
#ifdef GL_SGIX_flush_raster
void glatter_glFlushRasterSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushRasterSGIX, ())
    glatter_glFlushRasterSGIX_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_flush_raster
#ifdef GL_SGIX_fragment_lighting
void glatter_glFragmentColorMaterialSGIX_debug(GLenum face, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentColorMaterialSGIX, (%s, %s), enum_to_string_GL(face), enum_to_string_GL(mode))
    glatter_glFragmentColorMaterialSGIX_ptr(face, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightModelfSGIX_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelfSGIX, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glFragmentLightModelfSGIX_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightModelfvSGIX_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelfvSGIX, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightModelfvSGIX_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightModeliSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModeliSGIX, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glFragmentLightModeliSGIX_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightModelivSGIX_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightModelivSGIX, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightModelivSGIX_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightfSGIX_debug(GLenum light, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightfSGIX, (%s, %s, %f), enum_to_string_GL(light), enum_to_string_GL(pname), (float)param)
    glatter_glFragmentLightfSGIX_ptr(light, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightfvSGIX_debug(GLenum light, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightfvSGIX, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightfvSGIX_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightiSGIX_debug(GLenum light, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightiSGIX, (%s, %s, %d), enum_to_string_GL(light), enum_to_string_GL(pname), (int)param)
    glatter_glFragmentLightiSGIX_ptr(light, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentLightivSGIX_debug(GLenum light, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentLightivSGIX, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentLightivSGIX_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentMaterialfSGIX_debug(GLenum face, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialfSGIX, (%s, %s, %f), enum_to_string_GL(face), enum_to_string_GL(pname), (float)param)
    glatter_glFragmentMaterialfSGIX_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentMaterialfvSGIX_debug(GLenum face, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialfvSGIX, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentMaterialfvSGIX_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentMaterialiSGIX_debug(GLenum face, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialiSGIX, (%s, %s, %d), enum_to_string_GL(face), enum_to_string_GL(pname), (int)param)
    glatter_glFragmentMaterialiSGIX_ptr(face, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glFragmentMaterialivSGIX_debug(GLenum face, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFragmentMaterialivSGIX, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glFragmentMaterialivSGIX_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFragmentLightfvSGIX_debug(GLenum light, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentLightfvSGIX, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentLightfvSGIX_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFragmentLightivSGIX_debug(GLenum light, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentLightivSGIX, (%s, %s, %p), enum_to_string_GL(light), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentLightivSGIX_ptr(light, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFragmentMaterialfvSGIX_debug(GLenum face, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentMaterialfvSGIX, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentMaterialfvSGIX_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFragmentMaterialivSGIX_debug(GLenum face, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragmentMaterialivSGIX, (%s, %s, %p), enum_to_string_GL(face), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFragmentMaterialivSGIX_ptr(face, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glLightEnviSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLightEnviSGIX, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glLightEnviSGIX_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_fragment_lighting
#ifdef GL_SGIX_framezoom
void glatter_glFrameZoomSGIX_debug(GLint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFrameZoomSGIX, (%d), (int)factor)
    glatter_glFrameZoomSGIX_ptr(factor);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_framezoom
#ifdef GL_SGIX_igloo_interface
void glatter_glIglooInterfaceSGIX_debug(GLenum pname, const void *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIglooInterfaceSGIX, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glIglooInterfaceSGIX_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_igloo_interface
#ifdef GL_SGIX_instruments
GLint glatter_glGetInstrumentsSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInstrumentsSGIX, ())
    GLint rval = glatter_glGetInstrumentsSGIX_ptr();
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glInstrumentsBufferSGIX_debug(GLsizei size, GLint *buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInstrumentsBufferSGIX, (%d, %p), (int)size, (void*)buffer)
    glatter_glInstrumentsBufferSGIX_ptr(size, buffer);
    glatter_check_error_GL(file, line);
}
GLint glatter_glPollInstrumentsSGIX_debug(GLint *marker_p, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPollInstrumentsSGIX, (%p), (void*)marker_p)
    GLint rval = glatter_glPollInstrumentsSGIX_ptr(marker_p);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glReadInstrumentsSGIX_debug(GLint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadInstrumentsSGIX, (%d), (int)marker)
    glatter_glReadInstrumentsSGIX_ptr(marker);
    glatter_check_error_GL(file, line);
}
void glatter_glStartInstrumentsSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStartInstrumentsSGIX, ())
    glatter_glStartInstrumentsSGIX_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glStopInstrumentsSGIX_debug(GLint marker, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStopInstrumentsSGIX, (%d), (int)marker)
    glatter_glStopInstrumentsSGIX_ptr(marker);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_instruments
#ifdef GL_SGIX_list_priority
void glatter_glGetListParameterfvSGIX_debug(GLuint list, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetListParameterfvSGIX, (%u, %s, %p), (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glGetListParameterfvSGIX_ptr(list, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetListParameterivSGIX_debug(GLuint list, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetListParameterivSGIX, (%u, %s, %p), (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glGetListParameterivSGIX_ptr(list, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glListParameterfSGIX_debug(GLuint list, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterfSGIX, (%u, %s, %f), (unsigned int)list, enum_to_string_GL(pname), (float)param)
    glatter_glListParameterfSGIX_ptr(list, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glListParameterfvSGIX_debug(GLuint list, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterfvSGIX, (%u, %s, %p), (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glListParameterfvSGIX_ptr(list, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glListParameteriSGIX_debug(GLuint list, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameteriSGIX, (%u, %s, %d), (unsigned int)list, enum_to_string_GL(pname), (int)param)
    glatter_glListParameteriSGIX_ptr(list, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glListParameterivSGIX_debug(GLuint list, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glListParameterivSGIX, (%u, %s, %p), (unsigned int)list, enum_to_string_GL(pname), (void*)params)
    glatter_glListParameterivSGIX_ptr(list, pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_list_priority
#ifdef GL_SGIX_pixel_texture
void glatter_glPixelTexGenSGIX_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPixelTexGenSGIX, (%s), enum_to_string_GL(mode))
    glatter_glPixelTexGenSGIX_ptr(mode);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_pixel_texture
#ifdef GL_SGIX_polynomial_ffd
void glatter_glDeformSGIX_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformSGIX, (%u), (unsigned int)mask)
    glatter_glDeformSGIX_ptr(mask);
    glatter_check_error_GL(file, line);
}
void glatter_glDeformationMap3dSGIX_debug(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformationMap3dSGIX, (%s, %f, %f, %d, %d, %f, %f, %d, %d, %f, %f, %d, %d, %p), enum_to_string_GL(target), (double)u1, (double)u2, (int)ustride, (int)uorder, (double)v1, (double)v2, (int)vstride, (int)vorder, (double)w1, (double)w2, (int)wstride, (int)worder, (void*)points)
    glatter_glDeformationMap3dSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glDeformationMap3fSGIX_debug(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeformationMap3fSGIX, (%s, %f, %f, %d, %d, %f, %f, %d, %d, %f, %f, %d, %d, %p), enum_to_string_GL(target), (float)u1, (float)u2, (int)ustride, (int)uorder, (float)v1, (float)v2, (int)vstride, (int)vorder, (float)w1, (float)w2, (int)wstride, (int)worder, (void*)points)
    glatter_glDeformationMap3fSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadIdentityDeformationMapSGIX_debug(GLbitfield mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadIdentityDeformationMapSGIX, (%u), (unsigned int)mask)
    glatter_glLoadIdentityDeformationMapSGIX_ptr(mask);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_polynomial_ffd
#ifdef GL_SGIX_reference_plane
void glatter_glReferencePlaneSGIX_debug(const GLdouble *equation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReferencePlaneSGIX, (%p), (void*)equation)
    glatter_glReferencePlaneSGIX_ptr(equation);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_reference_plane
#ifdef GL_SGIX_sprite
void glatter_glSpriteParameterfSGIX_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterfSGIX, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glSpriteParameterfSGIX_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSpriteParameterfvSGIX_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterfvSGIX, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glSpriteParameterfvSGIX_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glSpriteParameteriSGIX_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameteriSGIX, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glSpriteParameteriSGIX_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSpriteParameterivSGIX_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSpriteParameterivSGIX, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glSpriteParameterivSGIX_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_sprite
#ifdef GL_SGIX_tag_sample_buffer
void glatter_glTagSampleBufferSGIX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTagSampleBufferSGIX, ())
    glatter_glTagSampleBufferSGIX_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_SGIX_tag_sample_buffer
#ifdef GL_SGI_color_table
void glatter_glColorTableParameterfvSGI_debug(GLenum target, GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterfvSGI, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterfvSGI_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glColorTableParameterivSGI_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableParameterivSGI, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glColorTableParameterivSGI_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glColorTableSGI_debug(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorTableSGI, (%s, %s, %d, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glColorTableSGI_ptr(target, internalformat, width, format, type, table);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyColorTableSGI_debug(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyColorTableSGI, (%s, %s, %d, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)x, (int)y, (int)width)
    glatter_glCopyColorTableSGI_ptr(target, internalformat, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameterfvSGI_debug(GLenum target, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterfvSGI, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterfvSGI_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableParameterivSGI_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableParameterivSGI, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetColorTableParameterivSGI_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetColorTableSGI_debug(GLenum target, GLenum format, GLenum type, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetColorTableSGI, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (void*)table)
    glatter_glGetColorTableSGI_ptr(target, format, type, table);
    glatter_check_error_GL(file, line);
}
#endif // GL_SGI_color_table
#ifdef GL_SUNX_constant_data
void glatter_glFinishTextureSUNX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFinishTextureSUNX, ())
    glatter_glFinishTextureSUNX_ptr();
    glatter_check_error_GL(file, line);
}
#endif // GL_SUNX_constant_data
#ifdef GL_SUN_global_alpha
void glatter_glGlobalAlphaFactorbSUN_debug(GLbyte factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorbSUN, (%d), (signed char)factor)
    glatter_glGlobalAlphaFactorbSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactordSUN_debug(GLdouble factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactordSUN, (%f), (double)factor)
    glatter_glGlobalAlphaFactordSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactorfSUN_debug(GLfloat factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorfSUN, (%f), (float)factor)
    glatter_glGlobalAlphaFactorfSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactoriSUN_debug(GLint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactoriSUN, (%d), (int)factor)
    glatter_glGlobalAlphaFactoriSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactorsSUN_debug(GLshort factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorsSUN, (%hi), (short)factor)
    glatter_glGlobalAlphaFactorsSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactorubSUN_debug(GLubyte factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorubSUN, (%u), (unsigned char)factor)
    glatter_glGlobalAlphaFactorubSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactoruiSUN_debug(GLuint factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactoruiSUN, (%u), (unsigned int)factor)
    glatter_glGlobalAlphaFactoruiSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
void glatter_glGlobalAlphaFactorusSUN_debug(GLushort factor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGlobalAlphaFactorusSUN, (%hu), (unsigned short)factor)
    glatter_glGlobalAlphaFactorusSUN_ptr(factor);
    glatter_check_error_GL(file, line);
}
#endif // GL_SUN_global_alpha
#ifdef GL_SUN_mesh_array
void glatter_glDrawMeshArraysSUN_debug(GLenum mode, GLint first, GLsizei count, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawMeshArraysSUN, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)width)
    glatter_glDrawMeshArraysSUN_ptr(mode, first, count, width);
    glatter_check_error_GL(file, line);
}
#endif // GL_SUN_mesh_array
#ifdef GL_SUN_triangle_list
void glatter_glReplacementCodePointerSUN_debug(GLenum type, GLsizei stride, const void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodePointerSUN, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glReplacementCodePointerSUN_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeubSUN_debug(GLubyte code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeubSUN, (%u), (unsigned char)code)
    glatter_glReplacementCodeubSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeubvSUN_debug(const GLubyte *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeubvSUN, (%p), (void*)code)
    glatter_glReplacementCodeubvSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiSUN_debug(GLuint code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiSUN, (%u), (unsigned int)code)
    glatter_glReplacementCodeuiSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuivSUN_debug(const GLuint *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuivSUN, (%p), (void*)code)
    glatter_glReplacementCodeuivSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeusSUN_debug(GLushort code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeusSUN, (%hu), (unsigned short)code)
    glatter_glReplacementCodeusSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeusvSUN_debug(const GLushort *code, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeusvSUN, (%p), (void*)code)
    glatter_glReplacementCodeusvSUN_ptr(code);
    glatter_check_error_GL(file, line);
}
#endif // GL_SUN_triangle_list
#ifdef GL_SUN_vertex
void glatter_glColor3fVertex3fSUN_debug(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3fVertex3fSUN, (%f, %f, %f, %f, %f, %f), (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glColor3fVertex3fSUN_ptr(r, g, b, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glColor3fVertex3fvSUN_debug(const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor3fVertex3fvSUN, (%p, %p), (void*)c, (void*)v)
    glatter_glColor3fVertex3fvSUN_ptr(c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4fNormal3fVertex3fSUN_debug(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4fNormal3fVertex3fSUN, (%f, %f, %f, %f, %f, %f, %f, %f, %f, %f), (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glColor4fNormal3fVertex3fSUN_ptr(r, g, b, a, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4fNormal3fVertex3fvSUN_debug(const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4fNormal3fVertex3fvSUN, (%p, %p, %p), (void*)c, (void*)n, (void*)v)
    glatter_glColor4fNormal3fVertex3fvSUN_ptr(c, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ubVertex2fSUN_debug(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex2fSUN, (%u, %u, %u, %u, %f, %f), (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y)
    glatter_glColor4ubVertex2fSUN_ptr(r, g, b, a, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ubVertex2fvSUN_debug(const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex2fvSUN, (%p, %p), (void*)c, (void*)v)
    glatter_glColor4ubVertex2fvSUN_ptr(c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ubVertex3fSUN_debug(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex3fSUN, (%u, %u, %u, %u, %f, %f, %f), (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glColor4ubVertex3fSUN_ptr(r, g, b, a, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glColor4ubVertex3fvSUN_debug(const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColor4ubVertex3fvSUN, (%p, %p), (void*)c, (void*)v)
    glatter_glColor4ubVertex3fvSUN_ptr(c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3fVertex3fSUN_debug(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3fVertex3fSUN, (%f, %f, %f, %f, %f, %f), (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glNormal3fVertex3fSUN_ptr(nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glNormal3fVertex3fvSUN_debug(const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormal3fVertex3fvSUN, (%p, %p), (void*)n, (void*)v)
    glatter_glNormal3fVertex3fvSUN_ptr(n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor3fVertex3fSUN_debug(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor3fVertex3fSUN, (%u, %f, %f, %f, %f, %f, %f), (unsigned int)rc, (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor3fVertex3fSUN_ptr(rc, r, g, b, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor3fVertex3fvSUN, (%p, %p, %p), (void*)rc, (void*)c, (void*)v)
    glatter_glReplacementCodeuiColor3fVertex3fvSUN_ptr(rc, c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor4fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4fNormal3fVertex3fSUN, (%u, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f), (unsigned int)rc, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr(rc, r, g, b, a, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor4fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4fNormal3fVertex3fvSUN, (%p, %p, %p, %p), (void*)rc, (void*)c, (void*)n, (void*)v)
    glatter_glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr(rc, c, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor4ubVertex3fSUN_debug(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4ubVertex3fSUN, (%u, %u, %u, %u, %u, %f, %f, %f), (unsigned int)rc, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiColor4ubVertex3fSUN_ptr(rc, r, g, b, a, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiColor4ubVertex3fvSUN_debug(const GLuint *rc, const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiColor4ubVertex3fvSUN, (%p, %p, %p), (void*)rc, (void*)c, (void*)v)
    glatter_glReplacementCodeuiColor4ubVertex3fvSUN_ptr(rc, c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiNormal3fVertex3fSUN_debug(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiNormal3fVertex3fSUN, (%u, %f, %f, %f, %f, %f, %f), (unsigned int)rc, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiNormal3fVertex3fSUN_ptr(rc, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiNormal3fVertex3fvSUN, (%p, %p, %p), (void*)rc, (void*)n, (void*)v)
    glatter_glReplacementCodeuiNormal3fVertex3fvSUN_ptr(rc, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, (%u, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f), (unsigned int)rc, (float)s, (float)t, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, (%p, %p, %p, %p, %p), (void*)rc, (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr(rc, tc, c, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, (%u, %f, %f, %f, %f, %f, %f, %f, %f), (unsigned int)rc, (float)s, (float)t, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr(rc, s, t, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, (%p, %p, %p, %p), (void*)rc, (void*)tc, (void*)n, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr(rc, tc, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fVertex3fSUN_debug(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fVertex3fSUN, (%u, %f, %f, %f, %f, %f), (unsigned int)rc, (float)s, (float)t, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiTexCoord2fVertex3fSUN_ptr(rc, s, t, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiTexCoord2fVertex3fvSUN_debug(const GLuint *rc, const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiTexCoord2fVertex3fvSUN, (%p, %p, %p), (void*)rc, (void*)tc, (void*)v)
    glatter_glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr(rc, tc, v);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiVertex3fSUN_debug(GLuint rc, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiVertex3fSUN, (%u, %f, %f, %f), (unsigned int)rc, (float)x, (float)y, (float)z)
    glatter_glReplacementCodeuiVertex3fSUN_ptr(rc, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glReplacementCodeuiVertex3fvSUN_debug(const GLuint *rc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReplacementCodeuiVertex3fvSUN, (%p, %p), (void*)rc, (void*)v)
    glatter_glReplacementCodeuiVertex3fvSUN_ptr(rc, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor3fVertex3fSUN, (%f, %f, %f, %f, %f, %f, %f, %f), (float)s, (float)t, (float)r, (float)g, (float)b, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor3fVertex3fSUN_ptr(s, t, r, g, b, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor3fVertex3fvSUN, (%p, %p, %p), (void*)tc, (void*)c, (void*)v)
    glatter_glTexCoord2fColor3fVertex3fvSUN_ptr(tc, c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor4fNormal3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4fNormal3fVertex3fSUN, (%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f), (float)s, (float)t, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor4fNormal3fVertex3fSUN_ptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor4fNormal3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4fNormal3fVertex3fvSUN, (%p, %p, %p, %p), (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr(tc, c, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor4ubVertex3fSUN_debug(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4ubVertex3fSUN, (%f, %f, %u, %u, %u, %u, %f, %f, %f), (float)s, (float)t, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fColor4ubVertex3fSUN_ptr(s, t, r, g, b, a, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fColor4ubVertex3fvSUN_debug(const GLfloat *tc, const GLubyte *c, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fColor4ubVertex3fvSUN, (%p, %p, %p), (void*)tc, (void*)c, (void*)v)
    glatter_glTexCoord2fColor4ubVertex3fvSUN_ptr(tc, c, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fNormal3fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fNormal3fVertex3fSUN, (%f, %f, %f, %f, %f, %f, %f, %f), (float)s, (float)t, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fNormal3fVertex3fSUN_ptr(s, t, nx, ny, nz, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fNormal3fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fNormal3fVertex3fvSUN, (%p, %p, %p), (void*)tc, (void*)n, (void*)v)
    glatter_glTexCoord2fNormal3fVertex3fvSUN_ptr(tc, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fVertex3fSUN_debug(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fVertex3fSUN, (%f, %f, %f, %f, %f), (float)s, (float)t, (float)x, (float)y, (float)z)
    glatter_glTexCoord2fVertex3fSUN_ptr(s, t, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord2fVertex3fvSUN_debug(const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord2fVertex3fvSUN, (%p, %p), (void*)tc, (void*)v)
    glatter_glTexCoord2fVertex3fvSUN_ptr(tc, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4fColor4fNormal3fVertex4fSUN_debug(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fColor4fNormal3fVertex4fSUN, (%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f), (float)s, (float)t, (float)p, (float)q, (float)r, (float)g, (float)b, (float)a, (float)nx, (float)ny, (float)nz, (float)x, (float)y, (float)z, (float)w)
    glatter_glTexCoord4fColor4fNormal3fVertex4fSUN_ptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4fColor4fNormal3fVertex4fvSUN_debug(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fColor4fNormal3fVertex4fvSUN, (%p, %p, %p, %p), (void*)tc, (void*)c, (void*)n, (void*)v)
    glatter_glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr(tc, c, n, v);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4fVertex4fSUN_debug(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fVertex4fSUN, (%f, %f, %f, %f, %f, %f, %f, %f), (float)s, (float)t, (float)p, (float)q, (float)x, (float)y, (float)z, (float)w)
    glatter_glTexCoord4fVertex4fSUN_ptr(s, t, p, q, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoord4fVertex4fvSUN_debug(const GLfloat *tc, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoord4fVertex4fvSUN, (%p, %p), (void*)tc, (void*)v)
    glatter_glTexCoord4fVertex4fvSUN_ptr(tc, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_SUN_vertex
#ifdef GL_VERSION_1_2
void glatter_glCopyTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %d), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawRangeElements_debug(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawRangeElements, (%s, %u, %u, %d, %s, %p), enum_to_string_GL(mode), (unsigned int)start, (unsigned int)end, (int)count, enum_to_string_GL(type), (void*)indices)
    glatter_glDrawRangeElements_ptr(mode, start, end, count, type, indices);
    glatter_check_error_GL(file, line);
}
void glatter_glTexImage3D_debug(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexImage3D, (%s, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)internalformat, (int)width, (int)height, (int)depth, (int)border, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexImage3D_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_2
#ifdef GL_VERSION_1_3
void glatter_glActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveTexture, (%s), enum_to_string_GL(texture))
    glatter_glActiveTexture_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glClientActiveTexture_debug(GLenum texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClientActiveTexture, (%s), enum_to_string_GL(texture))
    glatter_glClientActiveTexture_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage1D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage1D, (%s, %d, %s, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage1D_ptr(target, level, internalformat, width, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage2D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage2D, (%s, %d, %s, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage2D_ptr(target, level, internalformat, width, height, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexImage3D_debug(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexImage3D, (%s, %d, %s, %d, %d, %d, %d, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (int)border, (int)imageSize, (void*)data)
    glatter_glCompressedTexImage3D_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage1D_debug(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage1D, (%s, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage1D_ptr(target, level, xoffset, width, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage2D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage2D, (%s, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTexSubImage3D_debug(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTexSubImage3D, (%s, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), enum_to_string_GL(target), (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTexImage_debug(GLenum target, GLint level, void *img, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTexImage, (%s, %d, %p), enum_to_string_GL(target), (int)level, (void*)img)
    glatter_glGetCompressedTexImage_ptr(target, level, img);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadTransposeMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixd, (%p), (void*)m)
    glatter_glLoadTransposeMatrixd_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glLoadTransposeMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLoadTransposeMatrixf, (%p), (void*)m)
    glatter_glLoadTransposeMatrixf_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultTransposeMatrixd_debug(const GLdouble *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixd, (%p), (void*)m)
    glatter_glMultTransposeMatrixd_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultTransposeMatrixf_debug(const GLfloat *m, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultTransposeMatrixf, (%p), (void*)m)
    glatter_glMultTransposeMatrixf_ptr(m);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1d_debug(GLenum target, GLdouble s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1d, (%s, %f), enum_to_string_GL(target), (double)s)
    glatter_glMultiTexCoord1d_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1dv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1dv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1f_debug(GLenum target, GLfloat s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1f, (%s, %f), enum_to_string_GL(target), (float)s)
    glatter_glMultiTexCoord1f_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1fv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1fv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1i_debug(GLenum target, GLint s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1i, (%s, %d), enum_to_string_GL(target), (int)s)
    glatter_glMultiTexCoord1i_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1iv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1iv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1s_debug(GLenum target, GLshort s, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1s, (%s, %hi), enum_to_string_GL(target), (short)s)
    glatter_glMultiTexCoord1s_ptr(target, s);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord1sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord1sv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord1sv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2d_debug(GLenum target, GLdouble s, GLdouble t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2d, (%s, %f, %f), enum_to_string_GL(target), (double)s, (double)t)
    glatter_glMultiTexCoord2d_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2dv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2dv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2f_debug(GLenum target, GLfloat s, GLfloat t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2f, (%s, %f, %f), enum_to_string_GL(target), (float)s, (float)t)
    glatter_glMultiTexCoord2f_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2fv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2fv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2i_debug(GLenum target, GLint s, GLint t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2i, (%s, %d, %d), enum_to_string_GL(target), (int)s, (int)t)
    glatter_glMultiTexCoord2i_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2iv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2iv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2s_debug(GLenum target, GLshort s, GLshort t, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2s, (%s, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t)
    glatter_glMultiTexCoord2s_ptr(target, s, t);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord2sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord2sv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord2sv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3d_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3d, (%s, %f, %f, %f), enum_to_string_GL(target), (double)s, (double)t, (double)r)
    glatter_glMultiTexCoord3d_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3dv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3dv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3f_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3f, (%s, %f, %f, %f), enum_to_string_GL(target), (float)s, (float)t, (float)r)
    glatter_glMultiTexCoord3f_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3fv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3fv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3i_debug(GLenum target, GLint s, GLint t, GLint r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3i, (%s, %d, %d, %d), enum_to_string_GL(target), (int)s, (int)t, (int)r)
    glatter_glMultiTexCoord3i_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3iv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3iv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3s_debug(GLenum target, GLshort s, GLshort t, GLshort r, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3s, (%s, %hi, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t, (short)r)
    glatter_glMultiTexCoord3s_ptr(target, s, t, r);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord3sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord3sv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord3sv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4d_debug(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4d, (%s, %f, %f, %f, %f), enum_to_string_GL(target), (double)s, (double)t, (double)r, (double)q)
    glatter_glMultiTexCoord4d_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4dv_debug(GLenum target, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4dv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4dv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4f_debug(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4f, (%s, %f, %f, %f, %f), enum_to_string_GL(target), (float)s, (float)t, (float)r, (float)q)
    glatter_glMultiTexCoord4f_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4fv_debug(GLenum target, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4fv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4fv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4i_debug(GLenum target, GLint s, GLint t, GLint r, GLint q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4i, (%s, %d, %d, %d, %d), enum_to_string_GL(target), (int)s, (int)t, (int)r, (int)q)
    glatter_glMultiTexCoord4i_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4iv_debug(GLenum target, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4iv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4iv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4s_debug(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4s, (%s, %hi, %hi, %hi, %hi), enum_to_string_GL(target), (short)s, (short)t, (short)r, (short)q)
    glatter_glMultiTexCoord4s_ptr(target, s, t, r, q);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoord4sv_debug(GLenum target, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoord4sv, (%s, %p), enum_to_string_GL(target), (void*)v)
    glatter_glMultiTexCoord4sv_ptr(target, v);
    glatter_check_error_GL(file, line);
}
void glatter_glSampleCoverage_debug(GLfloat value, GLboolean invert, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSampleCoverage, (%f, %u), (float)value, (unsigned char)invert)
    glatter_glSampleCoverage_ptr(value, invert);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_3
#ifdef GL_VERSION_1_4
void glatter_glBlendColor_debug(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendColor, (%f, %f, %f, %f), (float)red, (float)green, (float)blue, (float)alpha)
    glatter_glBlendColor_ptr(red, green, blue, alpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquation_debug(GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquation, (%s), enum_to_string_GL(mode))
    glatter_glBlendEquation_ptr(mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparate_debug(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparate, (%s, %s, %s, %s), enum_to_string_GL(sfactorRGB), enum_to_string_GL(dfactorRGB), enum_to_string_GL(sfactorAlpha), enum_to_string_GL(dfactorAlpha))
    glatter_glBlendFuncSeparate_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordPointer_debug(GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordPointer, (%s, %d, %p), enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glFogCoordPointer_ptr(type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordd_debug(GLdouble coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordd, (%f), (double)coord)
    glatter_glFogCoordd_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoorddv_debug(const GLdouble *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoorddv, (%p), (void*)coord)
    glatter_glFogCoorddv_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordf_debug(GLfloat coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordf, (%f), (float)coord)
    glatter_glFogCoordf_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glFogCoordfv_debug(const GLfloat *coord, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFogCoordfv, (%p), (void*)coord)
    glatter_glFogCoordfv_ptr(coord);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawArrays_debug(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArrays, (%s, %p, %p, %d), enum_to_string_GL(mode), (void*)first, (void*)count, (int)drawcount)
    glatter_glMultiDrawArrays_ptr(mode, first, count, drawcount);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElements_debug(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElements, (%s, %p, %s, %p, %d), enum_to_string_GL(mode), (void*)count, enum_to_string_GL(type), (void*)indices, (int)drawcount)
    glatter_glMultiDrawElements_ptr(mode, count, type, indices, drawcount);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterf_debug(GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterf, (%s, %f), enum_to_string_GL(pname), (float)param)
    glatter_glPointParameterf_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameterfv_debug(GLenum pname, const GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameterfv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameterfv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameteri_debug(GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteri, (%s, %d), enum_to_string_GL(pname), (int)param)
    glatter_glPointParameteri_ptr(pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glPointParameteriv_debug(GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPointParameteriv, (%s, %p), enum_to_string_GL(pname), (void*)params)
    glatter_glPointParameteriv_ptr(pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3b_debug(GLbyte red, GLbyte green, GLbyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3b, (%d, %d, %d), (signed char)red, (signed char)green, (signed char)blue)
    glatter_glSecondaryColor3b_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3bv_debug(const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3bv, (%p), (void*)v)
    glatter_glSecondaryColor3bv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3d_debug(GLdouble red, GLdouble green, GLdouble blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3d, (%f, %f, %f), (double)red, (double)green, (double)blue)
    glatter_glSecondaryColor3d_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3dv, (%p), (void*)v)
    glatter_glSecondaryColor3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3f_debug(GLfloat red, GLfloat green, GLfloat blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3f, (%f, %f, %f), (float)red, (float)green, (float)blue)
    glatter_glSecondaryColor3f_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3fv, (%p), (void*)v)
    glatter_glSecondaryColor3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3i_debug(GLint red, GLint green, GLint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3i, (%d, %d, %d), (int)red, (int)green, (int)blue)
    glatter_glSecondaryColor3i_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3iv, (%p), (void*)v)
    glatter_glSecondaryColor3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3s_debug(GLshort red, GLshort green, GLshort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3s, (%hi, %hi, %hi), (short)red, (short)green, (short)blue)
    glatter_glSecondaryColor3s_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3sv, (%p), (void*)v)
    glatter_glSecondaryColor3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ub_debug(GLubyte red, GLubyte green, GLubyte blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ub, (%u, %u, %u), (unsigned char)red, (unsigned char)green, (unsigned char)blue)
    glatter_glSecondaryColor3ub_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ubv_debug(const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ubv, (%p), (void*)v)
    glatter_glSecondaryColor3ubv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3ui_debug(GLuint red, GLuint green, GLuint blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3ui, (%u, %u, %u), (unsigned int)red, (unsigned int)green, (unsigned int)blue)
    glatter_glSecondaryColor3ui_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3uiv_debug(const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3uiv, (%p), (void*)v)
    glatter_glSecondaryColor3uiv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3us_debug(GLushort red, GLushort green, GLushort blue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3us, (%hu, %hu, %hu), (unsigned short)red, (unsigned short)green, (unsigned short)blue)
    glatter_glSecondaryColor3us_ptr(red, green, blue);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColor3usv_debug(const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColor3usv, (%p), (void*)v)
    glatter_glSecondaryColor3usv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorPointer_debug(GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorPointer, (%d, %s, %d, %p), (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glSecondaryColorPointer_ptr(size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2d_debug(GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2d, (%f, %f), (double)x, (double)y)
    glatter_glWindowPos2d_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2dv, (%p), (void*)v)
    glatter_glWindowPos2dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2f_debug(GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2f, (%f, %f), (float)x, (float)y)
    glatter_glWindowPos2f_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2fv, (%p), (void*)v)
    glatter_glWindowPos2fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2i_debug(GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2i, (%d, %d), (int)x, (int)y)
    glatter_glWindowPos2i_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2iv, (%p), (void*)v)
    glatter_glWindowPos2iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2s_debug(GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2s, (%hi, %hi), (short)x, (short)y)
    glatter_glWindowPos2s_ptr(x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos2sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos2sv, (%p), (void*)v)
    glatter_glWindowPos2sv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3d_debug(GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3d, (%f, %f, %f), (double)x, (double)y, (double)z)
    glatter_glWindowPos3d_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3dv_debug(const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3dv, (%p), (void*)v)
    glatter_glWindowPos3dv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3f_debug(GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3f, (%f, %f, %f), (float)x, (float)y, (float)z)
    glatter_glWindowPos3f_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3fv_debug(const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3fv, (%p), (void*)v)
    glatter_glWindowPos3fv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3i_debug(GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3i, (%d, %d, %d), (int)x, (int)y, (int)z)
    glatter_glWindowPos3i_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3iv_debug(const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3iv, (%p), (void*)v)
    glatter_glWindowPos3iv_ptr(v);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3s_debug(GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3s, (%hi, %hi, %hi), (short)x, (short)y, (short)z)
    glatter_glWindowPos3s_ptr(x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glWindowPos3sv_debug(const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glWindowPos3sv, (%p), (void*)v)
    glatter_glWindowPos3sv_ptr(v);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_1_4
#ifdef GL_VERSION_1_5
void glatter_glBeginQuery_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQuery, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBeginQuery_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBuffer_debug(GLenum target, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)buffer)
    glatter_glBindBuffer_ptr(target, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferData_debug(GLenum target, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferData, (%s, %td, %p, %s), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glBufferData_ptr(target, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferSubData, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glBufferSubData_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteBuffers_debug(GLsizei n, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glDeleteBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteQueries_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQuery_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQuery, (%s), enum_to_string_GL(target))
    glatter_glEndQuery_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGenBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glGenBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenQueries_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenQueries, (%d, %p), (int)n, (void*)ids)
    glatter_glGenQueries_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferPointerv_debug(GLenum target, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferPointerv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetBufferPointerv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBufferSubData_debug(GLenum target, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBufferSubData, (%s, %td, %td, %p), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetBufferSubData_ptr(target, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectiv_debug(GLuint id, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectiv, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectiv_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectuiv_debug(GLuint id, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectuiv, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectuiv_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsBuffer, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glIsBuffer_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsQuery_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsQuery, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsQuery_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBuffer_debug(GLenum target, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBuffer, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(access))
    void * rval = glatter_glMapBuffer_ptr(target, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glUnmapBuffer_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapBuffer, (%s), enum_to_string_GL(target))
    GLboolean rval = glatter_glUnmapBuffer_ptr(target);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
#endif // GL_VERSION_1_5
#ifdef GL_VERSION_2_0
void glatter_glAttachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glAttachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glAttachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glBindAttribLocation_debug(GLuint program, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindAttribLocation, (%u, %u, %p), (unsigned int)program, (unsigned int)index, (void*)name)
    glatter_glBindAttribLocation_ptr(program, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparate_debug(GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparate, (%s, %s), enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparate_ptr(modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glCompileShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompileShader, (%u), (unsigned int)shader)
    glatter_glCompileShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateProgram_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgram, ())
    GLuint rval = glatter_glCreateProgram_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLuint glatter_glCreateShader_debug(GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShader, (%s), enum_to_string_GL(type))
    GLuint rval = glatter_glCreateShader_ptr(type);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgram, (%u), (unsigned int)program)
    glatter_glDeleteProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteShader, (%u), (unsigned int)shader)
    glatter_glDeleteShader_ptr(shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDetachShader_debug(GLuint program, GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDetachShader, (%u, %u), (unsigned int)program, (unsigned int)shader)
    glatter_glDetachShader_ptr(program, shader);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glDisableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawBuffers_debug(GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawBuffers, (%d, %p), (int)n, (void*)bufs)
    glatter_glDrawBuffers_ptr(n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexAttribArray_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexAttribArray, (%u), (unsigned int)index)
    glatter_glEnableVertexAttribArray_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAttrib_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAttrib, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveAttrib_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniform_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniform, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetActiveUniform_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetAttachedShaders_debug(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttachedShaders, (%u, %d, %p, %p), (unsigned int)program, (int)maxCount, (void*)count, (void*)shaders)
    glatter_glGetAttachedShaders_ptr(program, maxCount, count, shaders);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetAttribLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetAttribLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetAttribLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetProgramInfoLog_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInfoLog, (%u, %d, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramInfoLog_ptr(program, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramiv_debug(GLuint program, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramiv, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramiv_ptr(program, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderInfoLog_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderInfoLog, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetShaderInfoLog_ptr(shader, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderSource_debug(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)bufSize, (void*)length, (void*)source)
    glatter_glGetShaderSource_ptr(shader, bufSize, length, source);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderiv_debug(GLuint shader, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderiv, (%u, %s, %p), (unsigned int)shader, enum_to_string_GL(pname), (void*)params)
    glatter_glGetShaderiv_ptr(shader, pname, params);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetUniformLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetUniformLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformfv_debug(GLuint program, GLint location, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformfv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformfv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformiv_debug(GLuint program, GLint location, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribPointerv_debug(GLuint index, GLenum pname, void **pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribPointerv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)pointer)
    glatter_glGetVertexAttribPointerv_ptr(index, pname, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribdv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribdv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribfv_debug(GLuint index, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribfv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribfv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgram, (%u), (unsigned int)program)
    GLboolean rval = glatter_glIsProgram_ptr(program);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsShader_debug(GLuint shader, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsShader, (%u), (unsigned int)shader)
    GLboolean rval = glatter_glIsShader_ptr(shader);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glLinkProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glLinkProgram, (%u), (unsigned int)program)
    glatter_glLinkProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderSource_debug(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderSource, (%u, %d, %p, %p), (unsigned int)shader, (int)count, (void*)string, (void*)length)
    glatter_glShaderSource_ptr(shader, count, string, length);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilFuncSeparate_debug(GLenum face, GLenum func, GLint ref, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilFuncSeparate, (%s, %s, %d, %u), enum_to_string_GL(face), enum_to_string_GL(func), (int)ref, (unsigned int)mask)
    glatter_glStencilFuncSeparate_ptr(face, func, ref, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilMaskSeparate_debug(GLenum face, GLuint mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilMaskSeparate, (%s, %u), enum_to_string_GL(face), (unsigned int)mask)
    glatter_glStencilMaskSeparate_ptr(face, mask);
    glatter_check_error_GL(file, line);
}
void glatter_glStencilOpSeparate_debug(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glStencilOpSeparate, (%s, %s, %s, %s), enum_to_string_GL(face), enum_to_string_GL(sfail), enum_to_string_GL(dpfail), enum_to_string_GL(dppass))
    glatter_glStencilOpSeparate_ptr(face, sfail, dpfail, dppass);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1f_debug(GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1f, (%d, %f), (int)location, (float)v0)
    glatter_glUniform1f_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1i_debug(GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1i, (%d, %d), (int)location, (int)v0)
    glatter_glUniform1i_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2f_debug(GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2f, (%d, %f, %f), (int)location, (float)v0, (float)v1)
    glatter_glUniform2f_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2i_debug(GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2i, (%d, %d, %d), (int)location, (int)v0, (int)v1)
    glatter_glUniform2i_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3f, (%d, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glUniform3f_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3i_debug(GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3i, (%d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glUniform3i_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4f_debug(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4f, (%d, %f, %f, %f, %f), (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glUniform4f_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4fv_debug(GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4fv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4fv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4i_debug(GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4i, (%d, %d, %d, %d, %d), (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glUniform4i_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4iv_debug(GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4iv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4iv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgram, (%u), (unsigned int)program)
    glatter_glUseProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgram_debug(GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgram, (%u), (unsigned int)program)
    glatter_glValidateProgram_ptr(program);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1d, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttrib1d_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1f_debug(GLuint index, GLfloat x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1f, (%u, %f), (unsigned int)index, (float)x)
    glatter_glVertexAttrib1f_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1s_debug(GLuint index, GLshort x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1s, (%u, %hi), (unsigned int)index, (short)x)
    glatter_glVertexAttrib1s_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib1sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib1sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib1sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2d, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttrib2d_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2f_debug(GLuint index, GLfloat x, GLfloat y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2f, (%u, %f, %f), (unsigned int)index, (float)x, (float)y)
    glatter_glVertexAttrib2f_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2s_debug(GLuint index, GLshort x, GLshort y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2s, (%u, %hi, %hi), (unsigned int)index, (short)x, (short)y)
    glatter_glVertexAttrib2s_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib2sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib2sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib2sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3d, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttrib3d_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3f, (%u, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z)
    glatter_glVertexAttrib3f_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3s_debug(GLuint index, GLshort x, GLshort y, GLshort z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3s, (%u, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z)
    glatter_glVertexAttrib3s_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib3sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib3sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib3sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nbv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nbv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nbv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Niv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Niv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Niv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nsv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nsv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nsv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nub_debug(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nub, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)x, (unsigned char)y, (unsigned char)z, (unsigned char)w)
    glatter_glVertexAttrib4Nub_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nuiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nuiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nuiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4Nusv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4Nusv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4Nusv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4bv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4bv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4d, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttrib4d_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4f_debug(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4f, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)z, (float)w)
    glatter_glVertexAttrib4f_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4fv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4fv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4fv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4s_debug(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4s, (%u, %hi, %hi, %hi, %hi), (unsigned int)index, (short)x, (short)y, (short)z, (short)w)
    glatter_glVertexAttrib4s_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4ubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4ubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttrib4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttrib4usv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttrib4usv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribPointer_debug(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribPointer, (%u, %d, %s, %u, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (int)stride, (void*)pointer)
    glatter_glVertexAttribPointer_ptr(index, size, type, normalized, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_2_0
#ifdef GL_VERSION_2_1
void glatter_glUniformMatrix2x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3fv_debug(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3fv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3fv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_2_1
#ifdef GL_VERSION_3_0
void glatter_glBeginConditionalRender_debug(GLuint id, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginConditionalRender, (%u, %s), (unsigned int)id, enum_to_string_GL(mode))
    glatter_glBeginConditionalRender_ptr(id, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBeginTransformFeedback_debug(GLenum primitiveMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginTransformFeedback, (%s), enum_to_string_GL(primitiveMode))
    glatter_glBeginTransformFeedback_ptr(primitiveMode);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferBase_debug(GLenum target, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferBase, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer)
    glatter_glBindBufferBase_ptr(target, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBufferRange_debug(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBufferRange, (%s, %u, %u, %td, %td), enum_to_string_GL(target), (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glBindBufferRange_ptr(target, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFragDataLocation_debug(GLuint program, GLuint color, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocation, (%u, %u, %p), (unsigned int)program, (unsigned int)color, (void*)name)
    glatter_glBindFragDataLocation_ptr(program, color, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindFramebuffer_debug(GLenum target, GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFramebuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)framebuffer)
    glatter_glBindFramebuffer_ptr(target, framebuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindRenderbuffer_debug(GLenum target, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindRenderbuffer, (%s, %u), enum_to_string_GL(target), (unsigned int)renderbuffer)
    glatter_glBindRenderbuffer_ptr(target, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexArray, (%u), (unsigned int)array)
    glatter_glBindVertexArray_ptr(array);
    glatter_check_error_GL(file, line);
}
void glatter_glBlitFramebuffer_debug(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitFramebuffer, (%d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitFramebuffer_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckFramebufferStatus_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckFramebufferStatus, (%s), enum_to_string_GL(target))
    GLenum rval = glatter_glCheckFramebufferStatus_ptr(target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClampColor_debug(GLenum target, GLenum clamp, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClampColor, (%s, %s), enum_to_string_GL(target), enum_to_string_GL(clamp))
    glatter_glClampColor_ptr(target, clamp);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfi_debug(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfi, (%s, %d, %f, %d), enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearBufferfi_ptr(buffer, drawbuffer, depth, stencil);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferfv_debug(GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferfv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferfv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferiv_debug(GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferuiv_debug(GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferuiv, (%s, %d, %p), enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearBufferuiv_ptr(buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glColorMaski_debug(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorMaski, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a)
    glatter_glColorMaski_ptr(index, r, g, b, a);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteFramebuffers_debug(GLsizei n, const GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glDeleteFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteRenderbuffers_debug(GLsizei n, const GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glDeleteRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteVertexArrays_debug(GLsizei n, const GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glDeleteVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glDisablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glDisablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnablei_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnablei, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEnablei_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEndConditionalRender_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndConditionalRender, ())
    glatter_glEndConditionalRender_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glEndTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndTransformFeedback, ())
    glatter_glEndTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedBufferRange, (%s, %td, %td), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedBufferRange_ptr(target, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferRenderbuffer_debug(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferRenderbuffer, (%s, %s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glFramebufferRenderbuffer_ptr(target, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture1D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture1D, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture1D_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture2D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture2D, (%s, %s, %s, %u, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level)
    glatter_glFramebufferTexture2D_ptr(target, attachment, textarget, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTexture3D_debug(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTexture3D, (%s, %s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(textarget), (unsigned int)texture, (int)level, (int)zoffset)
    glatter_glFramebufferTexture3D_ptr(target, attachment, textarget, texture, level, zoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferTextureLayer_debug(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferTextureLayer, (%s, %s, %u, %d, %d), enum_to_string_GL(target), enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glFramebufferTextureLayer_ptr(target, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glGenFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glGenFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glGenRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glGenVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateMipmap_debug(GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateMipmap, (%s), enum_to_string_GL(target))
    glatter_glGenerateMipmap_ptr(target);
    glatter_check_error_GL(file, line);
}
void glatter_glGetBooleani_v_debug(GLenum target, GLuint index, GLboolean *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetBooleani_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetBooleani_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataLocation_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataLocation, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataLocation_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFramebufferAttachmentParameteriv_debug(GLenum target, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferAttachmentParameteriv, (%s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferAttachmentParameteriv_ptr(target, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetIntegeri_v_debug(GLenum target, GLuint index, GLint *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetIntegeri_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetIntegeri_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetRenderbufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetRenderbufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetRenderbufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
const GLubyte * glatter_glGetStringi_debug(GLenum name, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetStringi, (%s, %u), enum_to_string_GL(name), (unsigned int)index)
    const GLubyte * rval = glatter_glGetStringi_ptr(name, index);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetTexParameterIiv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTexParameterIuiv_debug(GLenum target, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackVarying_debug(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackVarying, (%u, %u, %d, %p, %p, %p, %p), (unsigned int)program, (unsigned int)index, (int)bufSize, (void*)length, (void*)size, (void*)type, (void*)name)
    glatter_glGetTransformFeedbackVarying_ptr(program, index, bufSize, length, size, type, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformuiv_debug(GLuint program, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformuiv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformuiv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIiv_debug(GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribIuiv_debug(GLuint index, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribIuiv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribIuiv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsEnabledi_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsEnabledi, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    GLboolean rval = glatter_glIsEnabledi_ptr(target, index);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsFramebuffer_debug(GLuint framebuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsFramebuffer, (%u), (unsigned int)framebuffer)
    GLboolean rval = glatter_glIsFramebuffer_ptr(framebuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsRenderbuffer_debug(GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsRenderbuffer, (%u), (unsigned int)renderbuffer)
    GLboolean rval = glatter_glIsRenderbuffer_ptr(renderbuffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLboolean glatter_glIsVertexArray_debug(GLuint array, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsVertexArray, (%u), (unsigned int)array)
    GLboolean rval = glatter_glIsVertexArray_ptr(array);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapBufferRange_debug(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapBufferRange, (%s, %td, %td, %u), enum_to_string_GL(target), (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapBufferRange_ptr(target, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glRenderbufferStorage_debug(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorage, (%s, %s, %d, %d), enum_to_string_GL(target), enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorage_ptr(target, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glRenderbufferStorageMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glRenderbufferStorageMultisample, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glRenderbufferStorageMultisample_ptr(target, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIiv_debug(GLenum target, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTexParameterIuiv_debug(GLenum target, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexParameterIuiv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glTexParameterIuiv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackVaryings_debug(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackVaryings, (%u, %d, %p, %s), (unsigned int)program, (int)count, (void*)varyings, enum_to_string_GL(bufferMode))
    glatter_glTransformFeedbackVaryings_ptr(program, count, varyings, bufferMode);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1ui_debug(GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1ui, (%d, %u), (int)location, (unsigned int)v0)
    glatter_glUniform1ui_ptr(location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2ui_debug(GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2ui, (%d, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glUniform2ui_ptr(location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3ui, (%d, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glUniform3ui_ptr(location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4ui_debug(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4ui, (%d, %u, %u, %u, %u), (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glUniform4ui_ptr(location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4uiv_debug(GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4uiv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4uiv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1i_debug(GLuint index, GLint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1i, (%u, %d), (unsigned int)index, (int)x)
    glatter_glVertexAttribI1i_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1ui_debug(GLuint index, GLuint x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1ui, (%u, %u), (unsigned int)index, (unsigned int)x)
    glatter_glVertexAttribI1ui_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI1uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI1uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI1uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2i_debug(GLuint index, GLint x, GLint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2i, (%u, %d, %d), (unsigned int)index, (int)x, (int)y)
    glatter_glVertexAttribI2i_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2ui_debug(GLuint index, GLuint x, GLuint y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2ui, (%u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y)
    glatter_glVertexAttribI2ui_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI2uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI2uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI2uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3i_debug(GLuint index, GLint x, GLint y, GLint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3i, (%u, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z)
    glatter_glVertexAttribI3i_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3ui, (%u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z)
    glatter_glVertexAttribI3ui_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI3uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI3uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI3uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4bv_debug(GLuint index, const GLbyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4bv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4bv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4i_debug(GLuint index, GLint x, GLint y, GLint z, GLint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4i, (%u, %d, %d, %d, %d), (unsigned int)index, (int)x, (int)y, (int)z, (int)w)
    glatter_glVertexAttribI4i_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4iv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4iv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4iv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4sv_debug(GLuint index, const GLshort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4sv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4sv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ubv_debug(GLuint index, const GLubyte *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ubv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4ubv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4ui_debug(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4ui, (%u, %u, %u, %u, %u), (unsigned int)index, (unsigned int)x, (unsigned int)y, (unsigned int)z, (unsigned int)w)
    glatter_glVertexAttribI4ui_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4uiv_debug(GLuint index, const GLuint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4uiv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4uiv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribI4usv_debug(GLuint index, const GLushort *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribI4usv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribI4usv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIPointer, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribIPointer_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_0
#ifdef GL_VERSION_3_1
void glatter_glCopyBufferSubData_debug(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyBufferSubData, (%s, %s, %td, %td, %td), enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyBufferSubData_ptr(readTarget, writeTarget, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysInstanced_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstanced, (%s, %d, %d, %d), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount)
    glatter_glDrawArraysInstanced_ptr(mode, first, count, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstanced_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstanced, (%s, %d, %s, %p, %d), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount)
    glatter_glDrawElementsInstanced_ptr(mode, count, type, indices, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockName_debug(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockName, (%u, %u, %d, %p, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, (int)bufSize, (void*)length, (void*)uniformBlockName)
    glatter_glGetActiveUniformBlockName_ptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformBlockiv_debug(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformBlockiv, (%u, %u, %s, %p), (unsigned int)program, (unsigned int)uniformBlockIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformBlockiv_ptr(program, uniformBlockIndex, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformName_debug(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformName, (%u, %u, %d, %p, %p), (unsigned int)program, (unsigned int)uniformIndex, (int)bufSize, (void*)length, (void*)uniformName)
    glatter_glGetActiveUniformName_ptr(program, uniformIndex, bufSize, length, uniformName);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveUniformsiv_debug(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveUniformsiv, (%u, %d, %p, %s, %p), (unsigned int)program, (int)uniformCount, (void*)uniformIndices, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveUniformsiv_ptr(program, uniformCount, uniformIndices, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetUniformBlockIndex_debug(GLuint program, const GLchar *uniformBlockName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformBlockIndex, (%u, %p), (unsigned int)program, (void*)uniformBlockName)
    GLuint rval = glatter_glGetUniformBlockIndex_ptr(program, uniformBlockName);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformIndices_debug(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformIndices, (%u, %d, %p, %p), (unsigned int)program, (int)uniformCount, (void*)uniformNames, (void*)uniformIndices)
    glatter_glGetUniformIndices_ptr(program, uniformCount, uniformNames, uniformIndices);
    glatter_check_error_GL(file, line);
}
void glatter_glPrimitiveRestartIndex_debug(GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPrimitiveRestartIndex, (%u), (unsigned int)index)
    glatter_glPrimitiveRestartIndex_ptr(index);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBuffer_debug(GLenum target, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBuffer, (%s, %s, %u), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTexBuffer_ptr(target, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformBlockBinding_debug(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformBlockBinding, (%u, %u, %u), (unsigned int)program, (unsigned int)uniformBlockIndex, (unsigned int)uniformBlockBinding)
    glatter_glUniformBlockBinding_ptr(program, uniformBlockIndex, uniformBlockBinding);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_1
#ifdef GL_VERSION_3_3
void glatter_glBindFragDataLocationIndexed_debug(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindFragDataLocationIndexed, (%u, %u, %u, %p), (unsigned int)program, (unsigned int)colorNumber, (unsigned int)index, (void*)name)
    glatter_glBindFragDataLocationIndexed_ptr(program, colorNumber, index, name);
    glatter_check_error_GL(file, line);
}
void glatter_glBindSampler_debug(GLuint unit, GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSampler, (%u, %u), (unsigned int)unit, (unsigned int)sampler)
    glatter_glBindSampler_ptr(unit, sampler);
    glatter_check_error_GL(file, line);
}
void glatter_glColorP3ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP3ui, (%s, %u), enum_to_string_GL(type), (unsigned int)color)
    glatter_glColorP3ui_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glColorP3uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP3uiv, (%s, %p), enum_to_string_GL(type), (void*)color)
    glatter_glColorP3uiv_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glColorP4ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP4ui, (%s, %u), enum_to_string_GL(type), (unsigned int)color)
    glatter_glColorP4ui_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glColorP4uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glColorP4uiv, (%s, %p), enum_to_string_GL(type), (void*)color)
    glatter_glColorP4uiv_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteSamplers_debug(GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glDeleteSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glGenSamplers_debug(GLsizei count, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenSamplers, (%d, %p), (int)count, (void*)samplers)
    glatter_glGenSamplers_ptr(count, samplers);
    glatter_check_error_GL(file, line);
}
GLint glatter_glGetFragDataIndex_debug(GLuint program, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFragDataIndex, (%u, %p), (unsigned int)program, (void*)name)
    GLint rval = glatter_glGetFragDataIndex_ptr(program, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetQueryObjecti64v_debug(GLuint id, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjecti64v, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjecti64v_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryObjectui64v_debug(GLuint id, GLenum pname, GLuint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryObjectui64v, (%u, %s, %p), (unsigned int)id, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryObjectui64v_ptr(id, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIiv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterIuiv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameterfv_debug(GLuint sampler, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameterfv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetSamplerParameteriv_debug(GLuint sampler, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)params)
    glatter_glGetSamplerParameteriv_ptr(sampler, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsSampler_debug(GLuint sampler, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsSampler, (%u), (unsigned int)sampler)
    GLboolean rval = glatter_glIsSampler_ptr(sampler);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMultiTexCoordP1ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP1ui, (%s, %s, %u), enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP1ui_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP1uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP1uiv, (%s, %s, %p), enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP1uiv_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP2ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP2ui, (%s, %s, %u), enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP2ui_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP2uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP2uiv, (%s, %s, %p), enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP2uiv_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP3ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP3ui, (%s, %s, %u), enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP3ui_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP3uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP3uiv, (%s, %s, %p), enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP3uiv_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP4ui_debug(GLenum texture, GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP4ui, (%s, %s, %u), enum_to_string_GL(texture), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glMultiTexCoordP4ui_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiTexCoordP4uiv_debug(GLenum texture, GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiTexCoordP4uiv, (%s, %s, %p), enum_to_string_GL(texture), enum_to_string_GL(type), (void*)coords)
    glatter_glMultiTexCoordP4uiv_ptr(texture, type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalP3ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalP3ui, (%s, %u), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glNormalP3ui_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glNormalP3uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNormalP3uiv, (%s, %p), enum_to_string_GL(type), (void*)coords)
    glatter_glNormalP3uiv_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glQueryCounter_debug(GLuint id, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glQueryCounter, (%u, %s), (unsigned int)id, enum_to_string_GL(target))
    glatter_glQueryCounter_ptr(id, target);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIiv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterIuiv_debug(GLuint sampler, GLenum pname, const GLuint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterIuiv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterIuiv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterf_debug(GLuint sampler, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterf, (%u, %s, %f), (unsigned int)sampler, enum_to_string_GL(pname), (float)param)
    glatter_glSamplerParameterf_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameterfv_debug(GLuint sampler, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameterfv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameterfv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteri_debug(GLuint sampler, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteri, (%u, %s, %d), (unsigned int)sampler, enum_to_string_GL(pname), (int)param)
    glatter_glSamplerParameteri_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSamplerParameteriv_debug(GLuint sampler, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSamplerParameteriv, (%u, %s, %p), (unsigned int)sampler, enum_to_string_GL(pname), (void*)param)
    glatter_glSamplerParameteriv_ptr(sampler, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorP3ui_debug(GLenum type, GLuint color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorP3ui, (%s, %u), enum_to_string_GL(type), (unsigned int)color)
    glatter_glSecondaryColorP3ui_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glSecondaryColorP3uiv_debug(GLenum type, const GLuint *color, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glSecondaryColorP3uiv, (%s, %p), enum_to_string_GL(type), (void*)color)
    glatter_glSecondaryColorP3uiv_ptr(type, color);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP1ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP1ui, (%s, %u), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP1ui_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP1uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP1uiv, (%s, %p), enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP1uiv_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP2ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP2ui, (%s, %u), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP2ui_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP2uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP2uiv, (%s, %p), enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP2uiv_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP3ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP3ui, (%s, %u), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP3ui_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP3uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP3uiv, (%s, %p), enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP3uiv_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP4ui_debug(GLenum type, GLuint coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP4ui, (%s, %u), enum_to_string_GL(type), (unsigned int)coords)
    glatter_glTexCoordP4ui_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glTexCoordP4uiv_debug(GLenum type, const GLuint *coords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexCoordP4uiv, (%s, %p), enum_to_string_GL(type), (void*)coords)
    glatter_glTexCoordP4uiv_ptr(type, coords);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribDivisor_debug(GLuint index, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribDivisor, (%u, %u), (unsigned int)index, (unsigned int)divisor)
    glatter_glVertexAttribDivisor_ptr(index, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP1ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP1ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP1uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP1uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP1uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP2ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP2ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP2uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP2uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP2uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP3ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP3ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP3uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP3uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP3uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP4ui_debug(GLuint index, GLenum type, GLboolean normalized, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4ui, (%u, %s, %u, %u), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)value)
    glatter_glVertexAttribP4ui_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribP4uiv_debug(GLuint index, GLenum type, GLboolean normalized, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribP4uiv, (%u, %s, %u, %p), (unsigned int)index, enum_to_string_GL(type), (unsigned char)normalized, (void*)value)
    glatter_glVertexAttribP4uiv_ptr(index, type, normalized, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP2ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP2ui, (%s, %u), enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP2ui_ptr(type, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP2uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP2uiv, (%s, %p), enum_to_string_GL(type), (void*)value)
    glatter_glVertexP2uiv_ptr(type, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP3ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP3ui, (%s, %u), enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP3ui_ptr(type, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP3uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP3uiv, (%s, %p), enum_to_string_GL(type), (void*)value)
    glatter_glVertexP3uiv_ptr(type, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP4ui_debug(GLenum type, GLuint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP4ui, (%s, %u), enum_to_string_GL(type), (unsigned int)value)
    glatter_glVertexP4ui_ptr(type, value);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexP4uiv_debug(GLenum type, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexP4uiv, (%s, %p), enum_to_string_GL(type), (void*)value)
    glatter_glVertexP4uiv_ptr(type, value);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_3_3
#ifdef GL_VERSION_4_0
void glatter_glBeginQueryIndexed_debug(GLenum target, GLuint index, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBeginQueryIndexed, (%s, %u, %u), enum_to_string_GL(target), (unsigned int)index, (unsigned int)id)
    glatter_glBeginQueryIndexed_ptr(target, index, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTransformFeedback_debug(GLenum target, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTransformFeedback, (%s, %u), enum_to_string_GL(target), (unsigned int)id)
    glatter_glBindTransformFeedback_ptr(target, id);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationSeparatei_debug(GLuint buf, GLenum modeRGB, GLenum modeAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationSeparatei, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(modeRGB), enum_to_string_GL(modeAlpha))
    glatter_glBlendEquationSeparatei_ptr(buf, modeRGB, modeAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendEquationi_debug(GLuint buf, GLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendEquationi, (%u, %s), (unsigned int)buf, enum_to_string_GL(mode))
    glatter_glBlendEquationi_ptr(buf, mode);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFuncSeparatei_debug(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFuncSeparatei, (%u, %s, %s, %s, %s), (unsigned int)buf, enum_to_string_GL(srcRGB), enum_to_string_GL(dstRGB), enum_to_string_GL(srcAlpha), enum_to_string_GL(dstAlpha))
    glatter_glBlendFuncSeparatei_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    glatter_check_error_GL(file, line);
}
void glatter_glBlendFunci_debug(GLuint buf, GLenum src, GLenum dst, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlendFunci, (%u, %s, %s), (unsigned int)buf, enum_to_string_GL(src), enum_to_string_GL(dst))
    glatter_glBlendFunci_ptr(buf, src, dst);
    glatter_check_error_GL(file, line);
}
void glatter_glDeleteTransformFeedbacks_debug(GLsizei n, const GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glDeleteTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysIndirect_debug(GLenum mode, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysIndirect, (%s, %p), enum_to_string_GL(mode), (void*)indirect)
    glatter_glDrawArraysIndirect_ptr(mode, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsIndirect, (%s, %s, %p), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect)
    glatter_glDrawElementsIndirect_ptr(mode, type, indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedback_debug(GLenum mode, GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedback, (%s, %u), enum_to_string_GL(mode), (unsigned int)id)
    glatter_glDrawTransformFeedback_ptr(mode, id);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackStream_debug(GLenum mode, GLuint id, GLuint stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStream, (%s, %u, %u), enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream)
    glatter_glDrawTransformFeedbackStream_ptr(mode, id, stream);
    glatter_check_error_GL(file, line);
}
void glatter_glEndQueryIndexed_debug(GLenum target, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEndQueryIndexed, (%s, %u), enum_to_string_GL(target), (unsigned int)index)
    glatter_glEndQueryIndexed_ptr(target, index);
    glatter_check_error_GL(file, line);
}
void glatter_glGenTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glGenTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufsize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineName_ptr(program, shadertype, index, bufsize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineUniformName_debug(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, (int)bufsize, (void*)length, (void*)name)
    glatter_glGetActiveSubroutineUniformName_ptr(program, shadertype, index, bufsize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveSubroutineUniformiv_debug(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveSubroutineUniformiv, (%u, %s, %u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (unsigned int)index, enum_to_string_GL(pname), (void*)values)
    glatter_glGetActiveSubroutineUniformiv_ptr(program, shadertype, index, pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramStageiv_debug(GLuint program, GLenum shadertype, GLenum pname, GLint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramStageiv, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), enum_to_string_GL(pname), (void*)values)
    glatter_glGetProgramStageiv_ptr(program, shadertype, pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryIndexediv_debug(GLenum target, GLuint index, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryIndexediv, (%s, %u, %s, %p), enum_to_string_GL(target), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetQueryIndexediv_ptr(target, index, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetSubroutineIndex_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLuint rval = glatter_glGetSubroutineIndex_ptr(program, shadertype, name);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetSubroutineUniformLocation_debug(GLuint program, GLenum shadertype, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetSubroutineUniformLocation, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(shadertype), (void*)name)
    GLint rval = glatter_glGetSubroutineUniformLocation_ptr(program, shadertype, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetUniformSubroutineuiv_debug(GLenum shadertype, GLint location, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformSubroutineuiv, (%s, %d, %p), enum_to_string_GL(shadertype), (int)location, (void*)params)
    glatter_glGetUniformSubroutineuiv_ptr(shadertype, location, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetUniformdv_debug(GLuint program, GLint location, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetUniformdv, (%u, %d, %p), (unsigned int)program, (int)location, (void*)params)
    glatter_glGetUniformdv_ptr(program, location, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsTransformFeedback_debug(GLuint id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsTransformFeedback, (%u), (unsigned int)id)
    GLboolean rval = glatter_glIsTransformFeedback_ptr(id);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMinSampleShading_debug(GLfloat value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMinSampleShading, (%f), (float)value)
    glatter_glMinSampleShading_ptr(value);
    glatter_check_error_GL(file, line);
}
void glatter_glPatchParameterfv_debug(GLenum pname, const GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameterfv, (%s, %p), enum_to_string_GL(pname), (void*)values)
    glatter_glPatchParameterfv_ptr(pname, values);
    glatter_check_error_GL(file, line);
}
void glatter_glPatchParameteri_debug(GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPatchParameteri, (%s, %d), enum_to_string_GL(pname), (int)value)
    glatter_glPatchParameteri_ptr(pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glPauseTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPauseTransformFeedback, ())
    glatter_glPauseTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glResumeTransformFeedback_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glResumeTransformFeedback, ())
    glatter_glResumeTransformFeedback_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1d_debug(GLint location, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1d, (%d, %f), (int)location, (double)x)
    glatter_glUniform1d_ptr(location, x);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform1dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform1dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform1dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2d_debug(GLint location, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2d, (%d, %f, %f), (int)location, (double)x, (double)y)
    glatter_glUniform2d_ptr(location, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform2dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform2dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform2dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3d, (%d, %f, %f, %f), (int)location, (double)x, (double)y, (double)z)
    glatter_glUniform3d_ptr(location, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform3dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform3dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform3dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4d_debug(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4d, (%d, %f, %f, %f, %f), (int)location, (double)x, (double)y, (double)z, (double)w)
    glatter_glUniform4d_ptr(location, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glUniform4dv_debug(GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniform4dv, (%d, %d, %p), (int)location, (int)count, (void*)value)
    glatter_glUniform4dv_ptr(location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix2x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix2x4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix2x4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix3x4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix3x4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix3x4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x2dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x2dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x2dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformMatrix4x3dv_debug(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformMatrix4x3dv, (%d, %d, %u, %p), (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glUniformMatrix4x3dv_ptr(location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glUniformSubroutinesuiv_debug(GLenum shadertype, GLsizei count, const GLuint *indices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUniformSubroutinesuiv, (%s, %d, %p), enum_to_string_GL(shadertype), (int)count, (void*)indices)
    glatter_glUniformSubroutinesuiv_ptr(shadertype, count, indices);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_0
#ifdef GL_VERSION_4_1
void glatter_glActiveShaderProgram_debug(GLuint pipeline, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glActiveShaderProgram, (%u, %u), (unsigned int)pipeline, (unsigned int)program)
    glatter_glActiveShaderProgram_ptr(pipeline, program);
    glatter_check_error_GL(file, line);
}
void glatter_glBindProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glBindProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glClearDepthf_debug(GLfloat d, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearDepthf, (%f), (float)d)
    glatter_glClearDepthf_ptr(d);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glCreateShaderProgramv_debug(GLenum type, GLsizei count, const GLchar *const*strings, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateShaderProgramv, (%s, %d, %p), enum_to_string_GL(type), (int)count, (void*)strings)
    GLuint rval = glatter_glCreateShaderProgramv_ptr(type, count, strings);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glDeleteProgramPipelines_debug(GLsizei n, const GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDeleteProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glDeleteProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeArrayv_debug(GLuint first, GLsizei count, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glDepthRangeArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangeIndexed_debug(GLuint index, GLdouble n, GLdouble f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangeIndexed, (%u, %f, %f), (unsigned int)index, (double)n, (double)f)
    glatter_glDepthRangeIndexed_ptr(index, n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glDepthRangef_debug(GLfloat n, GLfloat f, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDepthRangef, (%f, %f), (float)n, (float)f)
    glatter_glDepthRangef_ptr(n, f);
    glatter_check_error_GL(file, line);
}
void glatter_glGenProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glGenProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glGetDoublei_v_debug(GLenum target, GLuint index, GLdouble *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDoublei_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetDoublei_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetFloati_v_debug(GLenum target, GLuint index, GLfloat *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFloati_v, (%s, %u, %p), enum_to_string_GL(target), (unsigned int)index, (void*)data)
    glatter_glGetFloati_v_ptr(target, index, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramBinary_debug(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramBinary, (%u, %d, %p, %p, %p), (unsigned int)program, (int)bufSize, (void*)length, (void*)binaryFormat, (void*)binary)
    glatter_glGetProgramBinary_ptr(program, bufSize, length, binaryFormat, binary);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineInfoLog_debug(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineInfoLog, (%u, %d, %p, %p), (unsigned int)pipeline, (int)bufSize, (void*)length, (void*)infoLog)
    glatter_glGetProgramPipelineInfoLog_ptr(pipeline, bufSize, length, infoLog);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramPipelineiv_debug(GLuint pipeline, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramPipelineiv, (%u, %s, %p), (unsigned int)pipeline, enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramPipelineiv_ptr(pipeline, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetShaderPrecisionFormat_debug(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetShaderPrecisionFormat, (%s, %s, %p, %p), enum_to_string_GL(shadertype), enum_to_string_GL(precisiontype), (void*)range, (void*)precision)
    glatter_glGetShaderPrecisionFormat_ptr(shadertype, precisiontype, range, precision);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexAttribLdv_debug(GLuint index, GLenum pname, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexAttribLdv, (%u, %s, %p), (unsigned int)index, enum_to_string_GL(pname), (void*)params)
    glatter_glGetVertexAttribLdv_ptr(index, pname, params);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glIsProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glIsProgramPipeline, (%u), (unsigned int)pipeline)
    GLboolean rval = glatter_glIsProgramPipeline_ptr(pipeline);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glProgramBinary_debug(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramBinary, (%u, %s, %p, %d), (unsigned int)program, enum_to_string_GL(binaryFormat), (void*)binary, (int)length)
    glatter_glProgramBinary_ptr(program, binaryFormat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramParameteri_debug(GLuint program, GLenum pname, GLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramParameteri, (%u, %s, %d), (unsigned int)program, enum_to_string_GL(pname), (int)value)
    glatter_glProgramParameteri_ptr(program, pname, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1d_debug(GLuint program, GLint location, GLdouble v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1d, (%u, %d, %f), (unsigned int)program, (int)location, (double)v0)
    glatter_glProgramUniform1d_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1f_debug(GLuint program, GLint location, GLfloat v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1f, (%u, %d, %f), (unsigned int)program, (int)location, (float)v0)
    glatter_glProgramUniform1f_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1i_debug(GLuint program, GLint location, GLint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1i, (%u, %d, %d), (unsigned int)program, (int)location, (int)v0)
    glatter_glProgramUniform1i_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1ui_debug(GLuint program, GLint location, GLuint v0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1ui, (%u, %d, %u), (unsigned int)program, (int)location, (unsigned int)v0)
    glatter_glProgramUniform1ui_ptr(program, location, v0);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform1uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform1uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform1uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2d, (%u, %d, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1)
    glatter_glProgramUniform2d_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2f, (%u, %d, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1)
    glatter_glProgramUniform2f_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2i_debug(GLuint program, GLint location, GLint v0, GLint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2i, (%u, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1)
    glatter_glProgramUniform2i_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2ui, (%u, %d, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1)
    glatter_glProgramUniform2ui_ptr(program, location, v0, v1);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform2uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform2uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform2uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3d, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2)
    glatter_glProgramUniform3d_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3f, (%u, %d, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2)
    glatter_glProgramUniform3f_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3i, (%u, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2)
    glatter_glProgramUniform3i_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3ui, (%u, %d, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2)
    glatter_glProgramUniform3ui_ptr(program, location, v0, v1, v2);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform3uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform3uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform3uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4d_debug(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4d, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (double)v0, (double)v1, (double)v2, (double)v3)
    glatter_glProgramUniform4d_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4dv_debug(GLuint program, GLint location, GLsizei count, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4dv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4dv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4f_debug(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4f, (%u, %d, %f, %f, %f, %f), (unsigned int)program, (int)location, (float)v0, (float)v1, (float)v2, (float)v3)
    glatter_glProgramUniform4f_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4fv_debug(GLuint program, GLint location, GLsizei count, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4fv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4fv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4i_debug(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4i, (%u, %d, %d, %d, %d, %d), (unsigned int)program, (int)location, (int)v0, (int)v1, (int)v2, (int)v3)
    glatter_glProgramUniform4i_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4iv_debug(GLuint program, GLint location, GLsizei count, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4iv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4iv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4ui_debug(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4ui, (%u, %d, %u, %u, %u, %u), (unsigned int)program, (int)location, (unsigned int)v0, (unsigned int)v1, (unsigned int)v2, (unsigned int)v3)
    glatter_glProgramUniform4ui_ptr(program, location, v0, v1, v2, v3);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniform4uiv_debug(GLuint program, GLint location, GLsizei count, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniform4uiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)count, (void*)value)
    glatter_glProgramUniform4uiv_ptr(program, location, count, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix2x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix2x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix2x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix3x4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix3x4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix3x4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x2fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x2fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x2fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3dv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3dv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3dv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glProgramUniformMatrix4x3fv_debug(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glProgramUniformMatrix4x3fv, (%u, %d, %d, %u, %p), (unsigned int)program, (int)location, (int)count, (unsigned char)transpose, (void*)value)
    glatter_glProgramUniformMatrix4x3fv_ptr(program, location, count, transpose, value);
    glatter_check_error_GL(file, line);
}
void glatter_glReleaseShaderCompiler_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReleaseShaderCompiler, ())
    glatter_glReleaseShaderCompiler_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glScissorArrayv_debug(GLuint first, GLsizei count, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glScissorArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexed_debug(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexed, (%u, %d, %d, %d, %d), (unsigned int)index, (int)left, (int)bottom, (int)width, (int)height)
    glatter_glScissorIndexed_ptr(index, left, bottom, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glScissorIndexedv_debug(GLuint index, const GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glScissorIndexedv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glScissorIndexedv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderBinary_debug(GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderBinary, (%d, %p, %s, %p, %d), (int)count, (void*)shaders, enum_to_string_GL(binaryformat), (void*)binary, (int)length)
    glatter_glShaderBinary_ptr(count, shaders, binaryformat, binary, length);
    glatter_check_error_GL(file, line);
}
void glatter_glUseProgramStages_debug(GLuint pipeline, GLbitfield stages, GLuint program, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUseProgramStages, (%u, %u, %u), (unsigned int)pipeline, (unsigned int)stages, (unsigned int)program)
    glatter_glUseProgramStages_ptr(pipeline, stages, program);
    glatter_check_error_GL(file, line);
}
void glatter_glValidateProgramPipeline_debug(GLuint pipeline, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glValidateProgramPipeline, (%u), (unsigned int)pipeline)
    glatter_glValidateProgramPipeline_ptr(pipeline);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1d_debug(GLuint index, GLdouble x, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1d, (%u, %f), (unsigned int)index, (double)x)
    glatter_glVertexAttribL1d_ptr(index, x);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL1dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL1dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL1dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2d_debug(GLuint index, GLdouble x, GLdouble y, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2d, (%u, %f, %f), (unsigned int)index, (double)x, (double)y)
    glatter_glVertexAttribL2d_ptr(index, x, y);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL2dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL2dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL2dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3d, (%u, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z)
    glatter_glVertexAttribL3d_ptr(index, x, y, z);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL3dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL3dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL3dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4d_debug(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4d, (%u, %f, %f, %f, %f), (unsigned int)index, (double)x, (double)y, (double)z, (double)w)
    glatter_glVertexAttribL4d_ptr(index, x, y, z, w);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribL4dv_debug(GLuint index, const GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribL4dv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glVertexAttribL4dv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLPointer_debug(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLPointer, (%u, %d, %s, %d, %p), (unsigned int)index, (int)size, enum_to_string_GL(type), (int)stride, (void*)pointer)
    glatter_glVertexAttribLPointer_ptr(index, size, type, stride, pointer);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportArrayv_debug(GLuint first, GLsizei count, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportArrayv, (%u, %d, %p), (unsigned int)first, (int)count, (void*)v)
    glatter_glViewportArrayv_ptr(first, count, v);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedf_debug(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedf, (%u, %f, %f, %f, %f), (unsigned int)index, (float)x, (float)y, (float)w, (float)h)
    glatter_glViewportIndexedf_ptr(index, x, y, w, h);
    glatter_check_error_GL(file, line);
}
void glatter_glViewportIndexedfv_debug(GLuint index, const GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glViewportIndexedfv, (%u, %p), (unsigned int)index, (void*)v)
    glatter_glViewportIndexedfv_ptr(index, v);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_1
#ifdef GL_VERSION_4_2
void glatter_glBindImageTexture_debug(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTexture, (%u, %u, %d, %u, %d, %s, %s), (unsigned int)unit, (unsigned int)texture, (int)level, (unsigned char)layered, (int)layer, enum_to_string_GL(access), enum_to_string_GL(format))
    glatter_glBindImageTexture_ptr(unit, texture, level, layered, layer, access, format);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawArraysInstancedBaseInstance_debug(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawArraysInstancedBaseInstance, (%s, %d, %d, %d, %u), enum_to_string_GL(mode), (int)first, (int)count, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawArraysInstancedBaseInstance_ptr(mode, first, count, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseInstance, (%s, %d, %s, %p, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseInstance_ptr(mode, count, type, indices, instancecount, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawElementsInstancedBaseVertexBaseInstance_debug(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawElementsInstancedBaseVertexBaseInstance, (%s, %d, %s, %p, %d, %d, %u), enum_to_string_GL(mode), (int)count, enum_to_string_GL(type), (void*)indices, (int)instancecount, (int)basevertex, (unsigned int)baseinstance)
    glatter_glDrawElementsInstancedBaseVertexBaseInstance_ptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackInstanced_debug(GLenum mode, GLuint id, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackInstanced, (%s, %u, %d), enum_to_string_GL(mode), (unsigned int)id, (int)instancecount)
    glatter_glDrawTransformFeedbackInstanced_ptr(mode, id, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glDrawTransformFeedbackStreamInstanced_debug(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDrawTransformFeedbackStreamInstanced, (%s, %u, %u, %d), enum_to_string_GL(mode), (unsigned int)id, (unsigned int)stream, (int)instancecount)
    glatter_glDrawTransformFeedbackStreamInstanced_ptr(mode, id, stream, instancecount);
    glatter_check_error_GL(file, line);
}
void glatter_glGetActiveAtomicCounterBufferiv_debug(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetActiveAtomicCounterBufferiv, (%u, %u, %s, %p), (unsigned int)program, (unsigned int)bufferIndex, enum_to_string_GL(pname), (void*)params)
    glatter_glGetActiveAtomicCounterBufferiv_ptr(program, bufferIndex, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInternalformativ_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformativ, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformativ_ptr(target, internalformat, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glMemoryBarrier_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrier, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrier_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage1D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage1D, (%s, %d, %s, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTexStorage1D_ptr(target, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2D, (%s, %d, %s, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTexStorage2D_ptr(target, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3D_debug(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3D, (%s, %d, %s, %d, %d, %d), enum_to_string_GL(target), (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTexStorage3D_ptr(target, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_2
#ifdef GL_VERSION_4_3
void glatter_glBindVertexBuffer_debug(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffer, (%u, %u, %td, %d), (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glBindVertexBuffer_ptr(bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferData_debug(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferData, (%s, %s, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferData_ptr(target, internalformat, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearBufferSubData_debug(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearBufferSubData, (%s, %s, %td, %td, %s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), (ptrdiff_t)offset, (ptrdiff_t)size, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearBufferSubData_ptr(target, internalformat, offset, size, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyImageSubData_debug(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyImageSubData, (%u, %s, %d, %d, %d, %d, %u, %s, %d, %d, %d, %d, %d, %d, %d), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)srcWidth, (int)srcHeight, (int)srcDepth)
    glatter_glCopyImageSubData_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageCallback_debug(GLDEBUGPROC callback, const void *userParam, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageCallback, (%s, %p), GET_PRS(callback), (void*)userParam)
    glatter_glDebugMessageCallback_ptr(callback, userParam);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageControl_debug(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageControl, (%s, %s, %s, %d, %p, %u), enum_to_string_GL(source), enum_to_string_GL(type), enum_to_string_GL(severity), (int)count, (void*)ids, (unsigned char)enabled)
    glatter_glDebugMessageControl_ptr(source, type, severity, count, ids, enabled);
    glatter_check_error_GL(file, line);
}
void glatter_glDebugMessageInsert_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDebugMessageInsert, (%s, %s, %u, %s, %d, %p), enum_to_string_GL(source), enum_to_string_GL(type), (unsigned int)id, enum_to_string_GL(severity), (int)length, (void*)buf)
    glatter_glDebugMessageInsert_ptr(source, type, id, severity, length, buf);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchCompute_debug(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchCompute, (%u, %u, %u), (unsigned int)num_groups_x, (unsigned int)num_groups_y, (unsigned int)num_groups_z)
    glatter_glDispatchCompute_ptr(num_groups_x, num_groups_y, num_groups_z);
    glatter_check_error_GL(file, line);
}
void glatter_glDispatchComputeIndirect_debug(GLintptr indirect, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDispatchComputeIndirect, (%td), (ptrdiff_t)indirect)
    glatter_glDispatchComputeIndirect_ptr(indirect);
    glatter_check_error_GL(file, line);
}
void glatter_glFramebufferParameteri_debug(GLenum target, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFramebufferParameteri, (%s, %s, %d), enum_to_string_GL(target), enum_to_string_GL(pname), (int)param)
    glatter_glFramebufferParameteri_ptr(target, pname, param);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetDebugMessageLog_debug(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetDebugMessageLog, (%u, %d, %p, %p, %p, %p, %p, %p), (unsigned int)count, (int)bufSize, (void*)sources, (void*)types, (void*)ids, (void*)severities, (void*)lengths, (void*)messageLog)
    GLuint rval = glatter_glGetDebugMessageLog_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetFramebufferParameteriv_debug(GLenum target, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetFramebufferParameteriv, (%s, %s, %p), enum_to_string_GL(target), enum_to_string_GL(pname), (void*)params)
    glatter_glGetFramebufferParameteriv_ptr(target, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetInternalformati64v_debug(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetInternalformati64v, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(internalformat), enum_to_string_GL(pname), (int)bufSize, (void*)params)
    glatter_glGetInternalformati64v_ptr(target, internalformat, pname, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectLabel_debug(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectLabel, (%s, %u, %d, %p, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectLabel_ptr(identifier, name, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetObjectPtrLabel_debug(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetObjectPtrLabel, (%p, %d, %p, %p), (void*)ptr, (int)bufSize, (void*)length, (void*)label)
    glatter_glGetObjectPtrLabel_ptr(ptr, bufSize, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramInterfaceiv_debug(GLuint program, GLenum programInterface, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramInterfaceiv, (%u, %s, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), enum_to_string_GL(pname), (void*)params)
    glatter_glGetProgramInterfaceiv_ptr(program, programInterface, pname, params);
    glatter_check_error_GL(file, line);
}
GLuint glatter_glGetProgramResourceIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLuint rval = glatter_glGetProgramResourceIndex_ptr(program, programInterface, name);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocation_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocation, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocation_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
GLint glatter_glGetProgramResourceLocationIndex_debug(GLuint program, GLenum programInterface, const GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceLocationIndex, (%u, %s, %p), (unsigned int)program, enum_to_string_GL(programInterface), (void*)name)
    GLint rval = glatter_glGetProgramResourceLocationIndex_ptr(program, programInterface, name);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetProgramResourceName_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceName, (%u, %s, %u, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)bufSize, (void*)length, (void*)name)
    glatter_glGetProgramResourceName_ptr(program, programInterface, index, bufSize, length, name);
    glatter_check_error_GL(file, line);
}
void glatter_glGetProgramResourceiv_debug(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetProgramResourceiv, (%u, %s, %u, %d, %p, %d, %p, %p), (unsigned int)program, enum_to_string_GL(programInterface), (unsigned int)index, (int)propCount, (void*)props, (int)bufSize, (void*)length, (void*)params)
    glatter_glGetProgramResourceiv_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateBufferData_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferData, (%u), (unsigned int)buffer)
    glatter_glInvalidateBufferData_ptr(buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateBufferSubData, (%u, %td, %td), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glInvalidateBufferSubData_ptr(buffer, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateFramebuffer, (%s, %d, %p), enum_to_string_GL(target), (int)numAttachments, (void*)attachments)
    glatter_glInvalidateFramebuffer_ptr(target, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateSubFramebuffer_debug(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateSubFramebuffer, (%s, %d, %p, %d, %d, %d, %d), enum_to_string_GL(target), (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateSubFramebuffer_ptr(target, numAttachments, attachments, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateTexImage_debug(GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexImage, (%u, %d), (unsigned int)texture, (int)level)
    glatter_glInvalidateTexImage_ptr(texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateTexSubImage, (%u, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth)
    glatter_glInvalidateTexSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawArraysIndirect_debug(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawArraysIndirect, (%s, %p, %d, %d), enum_to_string_GL(mode), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawArraysIndirect_ptr(mode, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glMultiDrawElementsIndirect_debug(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMultiDrawElementsIndirect, (%s, %s, %p, %d, %d), enum_to_string_GL(mode), enum_to_string_GL(type), (void*)indirect, (int)drawcount, (int)stride)
    glatter_glMultiDrawElementsIndirect_ptr(mode, type, indirect, drawcount, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectLabel_debug(GLenum identifier, GLuint name, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectLabel, (%s, %u, %d, %p), enum_to_string_GL(identifier), (unsigned int)name, (int)length, (void*)label)
    glatter_glObjectLabel_ptr(identifier, name, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glObjectPtrLabel_debug(const void *ptr, GLsizei length, const GLchar *label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glObjectPtrLabel, (%p, %d, %p), (void*)ptr, (int)length, (void*)label)
    glatter_glObjectPtrLabel_ptr(ptr, length, label);
    glatter_check_error_GL(file, line);
}
void glatter_glPopDebugGroup_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPopDebugGroup, ())
    glatter_glPopDebugGroup_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glPushDebugGroup_debug(GLenum source, GLuint id, GLsizei length, const GLchar *message, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glPushDebugGroup, (%s, %u, %d, %p), enum_to_string_GL(source), (unsigned int)id, (int)length, (void*)message)
    glatter_glPushDebugGroup_ptr(source, id, length, message);
    glatter_check_error_GL(file, line);
}
void glatter_glShaderStorageBlockBinding_debug(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glShaderStorageBlockBinding, (%u, %u, %u), (unsigned int)program, (unsigned int)storageBlockIndex, (unsigned int)storageBlockBinding)
    glatter_glShaderStorageBlockBinding_ptr(program, storageBlockIndex, storageBlockBinding);
    glatter_check_error_GL(file, line);
}
void glatter_glTexBufferRange_debug(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexBufferRange, (%s, %s, %u, %td, %td), enum_to_string_GL(target), enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTexBufferRange_ptr(target, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage2DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage2DMultisample, (%s, %d, %s, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTexStorage3DMultisample_debug(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTexStorage3DMultisample, (%s, %d, %s, %d, %d, %d, %u), enum_to_string_GL(target), (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTexStorage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureView_debug(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureView, (%u, %s, %u, %s, %u, %u, %u, %u), (unsigned int)texture, enum_to_string_GL(target), (unsigned int)origtexture, enum_to_string_GL(internalformat), (unsigned int)minlevel, (unsigned int)numlevels, (unsigned int)minlayer, (unsigned int)numlayers)
    glatter_glTextureView_ptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribBinding_debug(GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribBinding, (%u, %u), (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexAttribBinding_ptr(attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribFormat_debug(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribFormat, (%u, %d, %s, %u, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexAttribFormat_ptr(attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribIFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribIFormat, (%u, %d, %s, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribIFormat_ptr(attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexAttribLFormat_debug(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexAttribLFormat, (%u, %d, %s, %u), (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexAttribLFormat_ptr(attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexBindingDivisor_debug(GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexBindingDivisor, (%u, %u), (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexBindingDivisor_ptr(bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_3
#ifdef GL_VERSION_4_4
void glatter_glBindBuffersBase_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersBase, (%s, %u, %d, %p), enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers)
    glatter_glBindBuffersBase_ptr(target, first, count, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glBindBuffersRange_debug(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindBuffersRange, (%s, %u, %d, %p, %p, %p), enum_to_string_GL(target), (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)sizes)
    glatter_glBindBuffersRange_ptr(target, first, count, buffers, offsets, sizes);
    glatter_check_error_GL(file, line);
}
void glatter_glBindImageTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindImageTextures, (%u, %d, %p), (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindImageTextures_ptr(first, count, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glBindSamplers_debug(GLuint first, GLsizei count, const GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindSamplers, (%u, %d, %p), (unsigned int)first, (int)count, (void*)samplers)
    glatter_glBindSamplers_ptr(first, count, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glBindTextures_debug(GLuint first, GLsizei count, const GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextures, (%u, %d, %p), (unsigned int)first, (int)count, (void*)textures)
    glatter_glBindTextures_ptr(first, count, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glBindVertexBuffers_debug(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindVertexBuffers, (%u, %d, %p, %p, %p), (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glBindVertexBuffers_ptr(first, count, buffers, offsets, strides);
    glatter_check_error_GL(file, line);
}
void glatter_glBufferStorage_debug(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBufferStorage, (%s, %td, %p, %u), enum_to_string_GL(target), (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glBufferStorage_ptr(target, size, data, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glClearTexImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexImage, (%u, %d, %s, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexImage_ptr(texture, level, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearTexSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearTexSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearTexSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_4
#ifdef GL_VERSION_4_5
void glatter_glBindTextureUnit_debug(GLuint unit, GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBindTextureUnit, (%u, %u), (unsigned int)unit, (unsigned int)texture)
    glatter_glBindTextureUnit_ptr(unit, texture);
    glatter_check_error_GL(file, line);
}
void glatter_glBlitNamedFramebuffer_debug(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glBlitNamedFramebuffer, (%u, %u, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s), (unsigned int)readFramebuffer, (unsigned int)drawFramebuffer, (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glBlitNamedFramebuffer_ptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glCheckNamedFramebufferStatus_debug(GLuint framebuffer, GLenum target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCheckNamedFramebufferStatus, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(target))
    GLenum rval = glatter_glCheckNamedFramebufferStatus_ptr(framebuffer, target);
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glClearNamedBufferData_debug(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferData, (%u, %s, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferData_ptr(buffer, internalformat, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedBufferSubData_debug(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedBufferSubData, (%u, %s, %td, %td, %s, %s, %p), (unsigned int)buffer, enum_to_string_GL(internalformat), (ptrdiff_t)offset, (ptrdiff_t)size, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    glatter_glClearNamedBufferSubData_ptr(buffer, internalformat, offset, size, format, type, data);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferfi_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfi, (%u, %s, %d, %f, %d), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (float)depth, (int)stencil)
    glatter_glClearNamedFramebufferfi_ptr(framebuffer, buffer, drawbuffer, depth, stencil);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferfv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferfv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferfv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferiv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferiv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClearNamedFramebufferuiv_debug(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClearNamedFramebufferuiv, (%u, %s, %d, %p), (unsigned int)framebuffer, enum_to_string_GL(buffer), (int)drawbuffer, (void*)value)
    glatter_glClearNamedFramebufferuiv_ptr(framebuffer, buffer, drawbuffer, value);
    glatter_check_error_GL(file, line);
}
void glatter_glClipControl_debug(GLenum origin, GLenum depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glClipControl, (%s, %s), enum_to_string_GL(origin), enum_to_string_GL(depth))
    glatter_glClipControl_ptr(origin, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage1D, (%u, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage1D_ptr(texture, level, xoffset, width, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage2D_ptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCompressedTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCompressedTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), (int)imageSize, (void*)data)
    glatter_glCompressedTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyNamedBufferSubData_debug(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyNamedBufferSubData, (%u, %u, %td, %td, %td), (unsigned int)readBuffer, (unsigned int)writeBuffer, (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glCopyNamedBufferSubData_ptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage1D, (%u, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)x, (int)y, (int)width)
    glatter_glCopyTextureSubImage1D_ptr(texture, level, xoffset, x, y, width);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage2D_ptr(texture, level, xoffset, yoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCopyTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCopyTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %d), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)x, (int)y, (int)width, (int)height)
    glatter_glCopyTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateBuffers_debug(GLsizei n, GLuint *buffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateBuffers, (%d, %p), (int)n, (void*)buffers)
    glatter_glCreateBuffers_ptr(n, buffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateFramebuffers_debug(GLsizei n, GLuint *framebuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateFramebuffers, (%d, %p), (int)n, (void*)framebuffers)
    glatter_glCreateFramebuffers_ptr(n, framebuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateProgramPipelines_debug(GLsizei n, GLuint *pipelines, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateProgramPipelines, (%d, %p), (int)n, (void*)pipelines)
    glatter_glCreateProgramPipelines_ptr(n, pipelines);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateQueries_debug(GLenum target, GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateQueries, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)ids)
    glatter_glCreateQueries_ptr(target, n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateRenderbuffers_debug(GLsizei n, GLuint *renderbuffers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateRenderbuffers, (%d, %p), (int)n, (void*)renderbuffers)
    glatter_glCreateRenderbuffers_ptr(n, renderbuffers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateSamplers_debug(GLsizei n, GLuint *samplers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateSamplers, (%d, %p), (int)n, (void*)samplers)
    glatter_glCreateSamplers_ptr(n, samplers);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateTextures_debug(GLenum target, GLsizei n, GLuint *textures, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTextures, (%s, %d, %p), enum_to_string_GL(target), (int)n, (void*)textures)
    glatter_glCreateTextures_ptr(target, n, textures);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateTransformFeedbacks_debug(GLsizei n, GLuint *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateTransformFeedbacks, (%d, %p), (int)n, (void*)ids)
    glatter_glCreateTransformFeedbacks_ptr(n, ids);
    glatter_check_error_GL(file, line);
}
void glatter_glCreateVertexArrays_debug(GLsizei n, GLuint *arrays, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glCreateVertexArrays, (%d, %p), (int)n, (void*)arrays)
    glatter_glCreateVertexArrays_ptr(n, arrays);
    glatter_check_error_GL(file, line);
}
void glatter_glDisableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glDisableVertexArrayAttrib, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glDisableVertexArrayAttrib_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glEnableVertexArrayAttrib_debug(GLuint vaobj, GLuint index, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glEnableVertexArrayAttrib, (%u, %u), (unsigned int)vaobj, (unsigned int)index)
    glatter_glEnableVertexArrayAttrib_ptr(vaobj, index);
    glatter_check_error_GL(file, line);
}
void glatter_glFlushMappedNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glFlushMappedNamedBufferRange, (%u, %td, %td), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length)
    glatter_glFlushMappedNamedBufferRange_ptr(buffer, offset, length);
    glatter_check_error_GL(file, line);
}
void glatter_glGenerateTextureMipmap_debug(GLuint texture, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGenerateTextureMipmap, (%u), (unsigned int)texture)
    glatter_glGenerateTextureMipmap_ptr(texture);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTextureImage_debug(GLuint texture, GLint level, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureImage, (%u, %d, %d, %p), (unsigned int)texture, (int)level, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureImage_ptr(texture, level, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetCompressedTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetCompressedTextureSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, (int)bufSize, (void*)pixels)
    glatter_glGetCompressedTextureSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
GLenum glatter_glGetGraphicsResetStatus_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetGraphicsResetStatus, ())
    GLenum rval = glatter_glGetGraphicsResetStatus_ptr();
    printf("GLATTER: returned %s", enum_to_string_GL(rval));
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glGetNamedBufferParameteri64v_debug(GLuint buffer, GLenum pname, GLint64 *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteri64v, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteri64v_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferParameteriv_debug(GLuint buffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferParameteriv, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferParameteriv_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferPointerv_debug(GLuint buffer, GLenum pname, void **params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferPointerv, (%u, %s, %p), (unsigned int)buffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedBufferPointerv_ptr(buffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedBufferSubData, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glGetNamedBufferSubData_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferAttachmentParameteriv_debug(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferAttachmentParameteriv, (%u, %s, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedFramebufferAttachmentParameteriv_ptr(framebuffer, attachment, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedFramebufferParameteriv_debug(GLuint framebuffer, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedFramebufferParameteriv, (%u, %s, %p), (unsigned int)framebuffer, enum_to_string_GL(pname), (void*)param)
    glatter_glGetNamedFramebufferParameteriv_ptr(framebuffer, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetNamedRenderbufferParameteriv_debug(GLuint renderbuffer, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetNamedRenderbufferParameteriv, (%u, %s, %p), (unsigned int)renderbuffer, enum_to_string_GL(pname), (void*)params)
    glatter_glGetNamedRenderbufferParameteriv_ptr(renderbuffer, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjecti64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjecti64v, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjecti64v_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectiv, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectiv_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectui64v_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectui64v, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectui64v_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetQueryBufferObjectuiv_debug(GLuint id, GLuint buffer, GLenum pname, GLintptr offset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetQueryBufferObjectuiv, (%u, %u, %s, %td), (unsigned int)id, (unsigned int)buffer, enum_to_string_GL(pname), (ptrdiff_t)offset)
    glatter_glGetQueryBufferObjectuiv_ptr(id, buffer, pname, offset);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureImage_debug(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureImage, (%u, %d, %s, %s, %d, %p), (unsigned int)texture, (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureImage_ptr(texture, level, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameterfv_debug(GLuint texture, GLint level, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameterfv, (%u, %d, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameterfv_ptr(texture, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureLevelParameteriv_debug(GLuint texture, GLint level, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureLevelParameteriv, (%u, %d, %s, %p), (unsigned int)texture, (int)level, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureLevelParameteriv_ptr(texture, level, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIiv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterIuiv_debug(GLuint texture, GLenum pname, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterIuiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterIuiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameterfv_debug(GLuint texture, GLenum pname, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameterfv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameterfv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureParameteriv_debug(GLuint texture, GLenum pname, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureParameteriv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glGetTextureParameteriv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTextureSubImage_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTextureSubImage, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %d, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetTextureSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbacki64_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki64_v, (%u, %s, %u, %p), (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki64_v_ptr(xfb, pname, index, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbacki_v_debug(GLuint xfb, GLenum pname, GLuint index, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbacki_v, (%u, %s, %u, %p), (unsigned int)xfb, enum_to_string_GL(pname), (unsigned int)index, (void*)param)
    glatter_glGetTransformFeedbacki_v_ptr(xfb, pname, index, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetTransformFeedbackiv_debug(GLuint xfb, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetTransformFeedbackiv, (%u, %s, %p), (unsigned int)xfb, enum_to_string_GL(pname), (void*)param)
    glatter_glGetTransformFeedbackiv_ptr(xfb, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIndexed64iv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexed64iv, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexed64iv_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayIndexediv_debug(GLuint vaobj, GLuint index, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayIndexediv, (%u, %u, %s, %p), (unsigned int)vaobj, (unsigned int)index, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayIndexediv_ptr(vaobj, index, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetVertexArrayiv_debug(GLuint vaobj, GLenum pname, GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetVertexArrayiv, (%u, %s, %p), (unsigned int)vaobj, enum_to_string_GL(pname), (void*)param)
    glatter_glGetVertexArrayiv_ptr(vaobj, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnColorTable_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnColorTable, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)table)
    glatter_glGetnColorTable_ptr(target, format, type, bufSize, table);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnCompressedTexImage_debug(GLenum target, GLint lod, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnCompressedTexImage, (%s, %d, %d, %p), enum_to_string_GL(target), (int)lod, (int)bufSize, (void*)pixels)
    glatter_glGetnCompressedTexImage_ptr(target, lod, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnConvolutionFilter_debug(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnConvolutionFilter, (%s, %s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)image)
    glatter_glGetnConvolutionFilter_ptr(target, format, type, bufSize, image);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnHistogram_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnHistogram, (%s, %u, %s, %s, %d, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnHistogram_ptr(target, reset, format, type, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapdv_debug(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapdv, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapdv_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapfv_debug(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapfv, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapfv_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMapiv_debug(GLenum target, GLenum query, GLsizei bufSize, GLint *v, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMapiv, (%s, %s, %d, %p), enum_to_string_GL(target), enum_to_string_GL(query), (int)bufSize, (void*)v)
    glatter_glGetnMapiv_ptr(target, query, bufSize, v);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnMinmax_debug(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnMinmax, (%s, %u, %s, %s, %d, %p), enum_to_string_GL(target), (unsigned char)reset, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)values)
    glatter_glGetnMinmax_ptr(target, reset, format, type, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapfv_debug(GLenum map, GLsizei bufSize, GLfloat *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapfv, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapfv_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapuiv_debug(GLenum map, GLsizei bufSize, GLuint *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapuiv, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapuiv_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPixelMapusv_debug(GLenum map, GLsizei bufSize, GLushort *values, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPixelMapusv, (%s, %d, %p), enum_to_string_GL(map), (int)bufSize, (void*)values)
    glatter_glGetnPixelMapusv_ptr(map, bufSize, values);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnPolygonStipple_debug(GLsizei bufSize, GLubyte *pattern, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnPolygonStipple, (%d, %p), (int)bufSize, (void*)pattern)
    glatter_glGetnPolygonStipple_ptr(bufSize, pattern);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnSeparableFilter_debug(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnSeparableFilter, (%s, %s, %s, %d, %p, %d, %p, %p), enum_to_string_GL(target), enum_to_string_GL(format), enum_to_string_GL(type), (int)rowBufSize, (void*)row, (int)columnBufSize, (void*)column, (void*)span)
    glatter_glGetnSeparableFilter_ptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnTexImage_debug(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnTexImage, (%s, %d, %s, %s, %d, %p), enum_to_string_GL(target), (int)level, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)pixels)
    glatter_glGetnTexImage_ptr(target, level, format, type, bufSize, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformdv_debug(GLuint program, GLint location, GLsizei bufSize, GLdouble *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformdv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformdv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformfv_debug(GLuint program, GLint location, GLsizei bufSize, GLfloat *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformfv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformfv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformiv_debug(GLuint program, GLint location, GLsizei bufSize, GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glGetnUniformuiv_debug(GLuint program, GLint location, GLsizei bufSize, GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glGetnUniformuiv, (%u, %d, %d, %p), (unsigned int)program, (int)location, (int)bufSize, (void*)params)
    glatter_glGetnUniformuiv_ptr(program, location, bufSize, params);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateNamedFramebufferData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferData, (%u, %d, %p), (unsigned int)framebuffer, (int)numAttachments, (void*)attachments)
    glatter_glInvalidateNamedFramebufferData_ptr(framebuffer, numAttachments, attachments);
    glatter_check_error_GL(file, line);
}
void glatter_glInvalidateNamedFramebufferSubData_debug(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glInvalidateNamedFramebufferSubData, (%u, %d, %p, %d, %d, %d, %d), (unsigned int)framebuffer, (int)numAttachments, (void*)attachments, (int)x, (int)y, (int)width, (int)height)
    glatter_glInvalidateNamedFramebufferSubData_ptr(framebuffer, numAttachments, attachments, x, y, width, height);
    glatter_check_error_GL(file, line);
}
void * glatter_glMapNamedBuffer_debug(GLuint buffer, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBuffer, (%u, %s), (unsigned int)buffer, enum_to_string_GL(access))
    void * rval = glatter_glMapNamedBuffer_ptr(buffer, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void * glatter_glMapNamedBufferRange_debug(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMapNamedBufferRange, (%u, %td, %td, %u), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)length, (unsigned int)access)
    void * rval = glatter_glMapNamedBufferRange_ptr(buffer, offset, length, access);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glMemoryBarrierByRegion_debug(GLbitfield barriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glMemoryBarrierByRegion, (%u), (unsigned int)barriers)
    glatter_glMemoryBarrierByRegion_ptr(barriers);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferData_debug(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferData, (%u, %td, %p, %s), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, enum_to_string_GL(usage))
    glatter_glNamedBufferData_ptr(buffer, size, data, usage);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferStorage_debug(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferStorage, (%u, %td, %p, %u), (unsigned int)buffer, (ptrdiff_t)size, (void*)data, (unsigned int)flags)
    glatter_glNamedBufferStorage_ptr(buffer, size, data, flags);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedBufferSubData_debug(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedBufferSubData, (%u, %td, %td, %p), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size, (void*)data)
    glatter_glNamedBufferSubData_ptr(buffer, offset, size, data);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferDrawBuffer_debug(GLuint framebuffer, GLenum buf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffer, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(buf))
    glatter_glNamedFramebufferDrawBuffer_ptr(framebuffer, buf);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferDrawBuffers_debug(GLuint framebuffer, GLsizei n, const GLenum *bufs, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferDrawBuffers, (%u, %d, %p), (unsigned int)framebuffer, (int)n, (void*)bufs)
    glatter_glNamedFramebufferDrawBuffers_ptr(framebuffer, n, bufs);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferParameteri_debug(GLuint framebuffer, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferParameteri, (%u, %s, %d), (unsigned int)framebuffer, enum_to_string_GL(pname), (int)param)
    glatter_glNamedFramebufferParameteri_ptr(framebuffer, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferReadBuffer_debug(GLuint framebuffer, GLenum src, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferReadBuffer, (%u, %s), (unsigned int)framebuffer, enum_to_string_GL(src))
    glatter_glNamedFramebufferReadBuffer_ptr(framebuffer, src);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferRenderbuffer_debug(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferRenderbuffer, (%u, %s, %s, %u), (unsigned int)framebuffer, enum_to_string_GL(attachment), enum_to_string_GL(renderbuffertarget), (unsigned int)renderbuffer)
    glatter_glNamedFramebufferRenderbuffer_ptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTexture_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTexture, (%u, %s, %u, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level)
    glatter_glNamedFramebufferTexture_ptr(framebuffer, attachment, texture, level);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedFramebufferTextureLayer_debug(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedFramebufferTextureLayer, (%u, %s, %u, %d, %d), (unsigned int)framebuffer, enum_to_string_GL(attachment), (unsigned int)texture, (int)level, (int)layer)
    glatter_glNamedFramebufferTextureLayer_ptr(framebuffer, attachment, texture, level, layer);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorage_debug(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorage, (%u, %s, %d, %d), (unsigned int)renderbuffer, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorage_ptr(renderbuffer, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glNamedRenderbufferStorageMultisample_debug(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glNamedRenderbufferStorageMultisample, (%u, %d, %s, %d, %d), (unsigned int)renderbuffer, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glNamedRenderbufferStorageMultisample_ptr(renderbuffer, samples, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glReadnPixels_debug(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glReadnPixels, (%d, %d, %d, %d, %s, %s, %d, %p), (int)x, (int)y, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (int)bufSize, (void*)data)
    glatter_glReadnPixels_ptr(x, y, width, height, format, type, bufSize, data);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBarrier_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBarrier, ())
    glatter_glTextureBarrier_ptr();
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBuffer_debug(GLuint texture, GLenum internalformat, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBuffer, (%u, %s, %u), (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer)
    glatter_glTextureBuffer_ptr(texture, internalformat, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureBufferRange_debug(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureBufferRange, (%u, %s, %u, %td, %td), (unsigned int)texture, enum_to_string_GL(internalformat), (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTextureBufferRange_ptr(texture, internalformat, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIiv_debug(GLuint texture, GLenum pname, const GLint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterIuiv_debug(GLuint texture, GLenum pname, const GLuint *params, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterIuiv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)params)
    glatter_glTextureParameterIuiv_ptr(texture, pname, params);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterf_debug(GLuint texture, GLenum pname, GLfloat param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterf, (%u, %s, %f), (unsigned int)texture, enum_to_string_GL(pname), (float)param)
    glatter_glTextureParameterf_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameterfv_debug(GLuint texture, GLenum pname, const GLfloat *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameterfv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameterfv_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameteri_debug(GLuint texture, GLenum pname, GLint param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteri, (%u, %s, %d), (unsigned int)texture, enum_to_string_GL(pname), (int)param)
    glatter_glTextureParameteri_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureParameteriv_debug(GLuint texture, GLenum pname, const GLint *param, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureParameteriv, (%u, %s, %p), (unsigned int)texture, enum_to_string_GL(pname), (void*)param)
    glatter_glTextureParameteriv_ptr(texture, pname, param);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage1D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage1D, (%u, %d, %s, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width)
    glatter_glTextureStorage1D_ptr(texture, levels, internalformat, width);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2D, (%u, %d, %s, %d, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height)
    glatter_glTextureStorage2D_ptr(texture, levels, internalformat, width, height);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage2DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage2DMultisample, (%u, %d, %s, %d, %d, %u), (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage2DMultisample_ptr(texture, samples, internalformat, width, height, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3D_debug(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3D, (%u, %d, %s, %d, %d, %d), (unsigned int)texture, (int)levels, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth)
    glatter_glTextureStorage3D_ptr(texture, levels, internalformat, width, height, depth);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureStorage3DMultisample_debug(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureStorage3DMultisample, (%u, %d, %s, %d, %d, %d, %u), (unsigned int)texture, (int)samples, enum_to_string_GL(internalformat), (int)width, (int)height, (int)depth, (unsigned char)fixedsamplelocations)
    glatter_glTextureStorage3DMultisample_ptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage1D_debug(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage1D, (%u, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage1D_ptr(texture, level, xoffset, width, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage2D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage2D, (%u, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage2D_ptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTextureSubImage3D_debug(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTextureSubImage3D, (%u, %d, %d, %d, %d, %d, %d, %d, %s, %s, %p), (unsigned int)texture, (int)level, (int)xoffset, (int)yoffset, (int)zoffset, (int)width, (int)height, (int)depth, enum_to_string_GL(format), enum_to_string_GL(type), (void*)pixels)
    glatter_glTextureSubImage3D_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackBufferBase_debug(GLuint xfb, GLuint index, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferBase, (%u, %u, %u), (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer)
    glatter_glTransformFeedbackBufferBase_ptr(xfb, index, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glTransformFeedbackBufferRange_debug(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glTransformFeedbackBufferRange, (%u, %u, %u, %td, %td), (unsigned int)xfb, (unsigned int)index, (unsigned int)buffer, (ptrdiff_t)offset, (ptrdiff_t)size)
    glatter_glTransformFeedbackBufferRange_ptr(xfb, index, buffer, offset, size);
    glatter_check_error_GL(file, line);
}
GLboolean glatter_glUnmapNamedBuffer_debug(GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glUnmapNamedBuffer, (%u), (unsigned int)buffer)
    GLboolean rval = glatter_glUnmapNamedBuffer_ptr(buffer);
    printf("GLATTER: returned %u", (unsigned char)rval);
    glatter_check_error_GL(file, line);
    return rval;
}
void glatter_glVertexArrayAttribBinding_debug(GLuint vaobj, GLuint attribindex, GLuint bindingindex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribBinding, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (unsigned int)bindingindex)
    glatter_glVertexArrayAttribBinding_ptr(vaobj, attribindex, bindingindex);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribFormat, (%u, %u, %d, %s, %u, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned char)normalized, (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribFormat_ptr(vaobj, attribindex, size, type, normalized, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribIFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribIFormat, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribIFormat_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayAttribLFormat_debug(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayAttribLFormat, (%u, %u, %d, %s, %u), (unsigned int)vaobj, (unsigned int)attribindex, (int)size, enum_to_string_GL(type), (unsigned int)relativeoffset)
    glatter_glVertexArrayAttribLFormat_ptr(vaobj, attribindex, size, type, relativeoffset);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayBindingDivisor_debug(GLuint vaobj, GLuint bindingindex, GLuint divisor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayBindingDivisor, (%u, %u, %u), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)divisor)
    glatter_glVertexArrayBindingDivisor_ptr(vaobj, bindingindex, divisor);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayElementBuffer_debug(GLuint vaobj, GLuint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayElementBuffer, (%u, %u), (unsigned int)vaobj, (unsigned int)buffer)
    glatter_glVertexArrayElementBuffer_ptr(vaobj, buffer);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexBuffer_debug(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffer, (%u, %u, %u, %td, %d), (unsigned int)vaobj, (unsigned int)bindingindex, (unsigned int)buffer, (ptrdiff_t)offset, (int)stride)
    glatter_glVertexArrayVertexBuffer_ptr(vaobj, bindingindex, buffer, offset, stride);
    glatter_check_error_GL(file, line);
}
void glatter_glVertexArrayVertexBuffers_debug(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glVertexArrayVertexBuffers, (%u, %u, %d, %p, %p, %p), (unsigned int)vaobj, (unsigned int)first, (int)count, (void*)buffers, (void*)offsets, (void*)strides)
    glatter_glVertexArrayVertexBuffers_ptr(vaobj, first, count, buffers, offsets, strides);
    glatter_check_error_GL(file, line);
}
#endif // GL_VERSION_4_5
#endif // __glext_h_
#endif // GLATTER_GL

#endif // NDEBUG



#ifdef GLATTER_GLU

#ifdef __glu_h__
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluBeginCurve, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluBeginPolygon, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluBeginSurface, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluBeginTrim, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(return, GLU, , int, APIENTRY, gluBuild1DMipmaps, (target, components, width, format, type, data), (GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(return, GLU, , int, APIENTRY, gluBuild2DMipmaps, (target, components, width, height, format, type, data), (GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluCylinder, (qobj, baseRadius, topRadius, height, slices, stacks), (GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluDeleteNurbsRenderer, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluDeleteQuadric, (state), (GLUquadric *state))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluDeleteTess, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluDisk, (qobj, innerRadius, outerRadius, slices, loops), (GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluEndCurve, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluEndPolygon, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluEndSurface, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluEndTrim, (nobj), (GLUnurbs *nobj))
GLATTER_FBLOCK(return, GLU, , const GLubyte*, APIENTRY, gluErrorString, (errCode), (GLenum errCode))
GLATTER_FBLOCK(return, GLU, , const wchar_t*, APIENTRY, gluErrorUnicodeStringEXT, (errCode), (GLenum errCode))
GLATTER_FBLOCK(return, GLU, , const GLubyte*, APIENTRY, gluGetString, (name), (GLenum name))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluGetTessProperty, (tess, which, value), (GLUtesselator *tess, GLenum which, GLdouble *value))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluLookAt, (eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz), (GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz))
GLATTER_FBLOCK(return, GLU, , GLUnurbs*, APIENTRY, gluNewNurbsRenderer, (), ())
GLATTER_FBLOCK(return, GLU, , GLUquadric*, APIENTRY, gluNewQuadric, (), ())
GLATTER_FBLOCK(return, GLU, , GLUtesselator*, APIENTRY, gluNewTess, (), ())
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluNextContour, (tess, type), (GLUtesselator *tess, GLenum type))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluNurbsCurve, (nobj, nknots, knot, stride, ctlarray, order, type), (GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluOrtho2D, (left, right, bottom, top), (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluPartialDisk, (qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle), (GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluPerspective, (fovy, aspect, zNear, zFar), (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluPickMatrix, (x, y, width, height, viewport), (GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4]))
GLATTER_FBLOCK(return, GLU, , int, APIENTRY, gluProject, (objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz), (GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluPwlCurve, (nobj, count, array, stride, type), (GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluQuadricCallback, (qobj, which, fn), (GLUquadric *qobj, GLenum which, void (CALLBACK* fn)()))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluQuadricDrawStyle, (quadObject, drawStyle), (GLUquadric *quadObject, GLenum drawStyle))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluQuadricNormals, (quadObject, normals), (GLUquadric *quadObject, GLenum normals))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluQuadricOrientation, (quadObject, orientation), (GLUquadric *quadObject, GLenum orientation))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluQuadricTexture, (quadObject, textureCoords), (GLUquadric *quadObject, GLboolean textureCoords))
GLATTER_FBLOCK(return, GLU, , int, APIENTRY, gluScaleImage, (format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout), (GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluSphere, (qobj, radius, slices, stacks), (GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessBeginContour, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessBeginPolygon, (tess, polygon_data), (GLUtesselator *tess, void *polygon_data))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessCallback, (tess, which, fn), (GLUtesselator *tess, GLenum which, void (CALLBACK *fn)()))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessEndContour, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessEndPolygon, (tess), (GLUtesselator *tess))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessNormal, (tess, x, y, z), (GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessProperty, (tess, which, value), (GLUtesselator *tess, GLenum which, GLdouble value))
GLATTER_FBLOCK(, GLU, , void, APIENTRY, gluTessVertex, (tess, coords, data), (GLUtesselator *tess, GLdouble coords[3], void *data))
GLATTER_FBLOCK(return, GLU, , int, APIENTRY, gluUnProject, (winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz), (GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz))
#endif // __glu_h__
#endif // GLATTER_GLU

#ifndef NDEBUG

#ifdef GLATTER_GLU

#ifdef __glu_h__
void glatter_gluBeginCurve_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBeginCurve, (%p), (void*)nobj)
    glatter_gluBeginCurve_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
void glatter_gluBeginPolygon_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBeginPolygon, (%p), (void*)tess)
    glatter_gluBeginPolygon_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluBeginSurface_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBeginSurface, (%p), (void*)nobj)
    glatter_gluBeginSurface_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
void glatter_gluBeginTrim_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBeginTrim, (%p), (void*)nobj)
    glatter_gluBeginTrim_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
int glatter_gluBuild1DMipmaps_debug(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBuild1DMipmaps, (%s, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)components, (int)width, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    int rval = glatter_gluBuild1DMipmaps_ptr(target, components, width, format, type, data);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
int glatter_gluBuild2DMipmaps_debug(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluBuild2DMipmaps, (%s, %d, %d, %d, %s, %s, %p), enum_to_string_GL(target), (int)components, (int)width, (int)height, enum_to_string_GL(format), enum_to_string_GL(type), (void*)data)
    int rval = glatter_gluBuild2DMipmaps_ptr(target, components, width, height, format, type, data);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
void glatter_gluCylinder_debug(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluCylinder, (%p, %f, %f, %f, %d, %d), (void*)qobj, (double)baseRadius, (double)topRadius, (double)height, (int)slices, (int)stacks)
    glatter_gluCylinder_ptr(qobj, baseRadius, topRadius, height, slices, stacks);
    glatter_check_error_GLU(file, line);
}
void glatter_gluDeleteNurbsRenderer_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluDeleteNurbsRenderer, (%p), (void*)nobj)
    glatter_gluDeleteNurbsRenderer_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
void glatter_gluDeleteQuadric_debug(GLUquadric *state, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluDeleteQuadric, (%p), (void*)state)
    glatter_gluDeleteQuadric_ptr(state);
    glatter_check_error_GLU(file, line);
}
void glatter_gluDeleteTess_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluDeleteTess, (%p), (void*)tess)
    glatter_gluDeleteTess_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluDisk_debug(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluDisk, (%p, %f, %f, %d, %d), (void*)qobj, (double)innerRadius, (double)outerRadius, (int)slices, (int)loops)
    glatter_gluDisk_ptr(qobj, innerRadius, outerRadius, slices, loops);
    glatter_check_error_GLU(file, line);
}
void glatter_gluEndCurve_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluEndCurve, (%p), (void*)nobj)
    glatter_gluEndCurve_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
void glatter_gluEndPolygon_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluEndPolygon, (%p), (void*)tess)
    glatter_gluEndPolygon_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluEndSurface_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluEndSurface, (%p), (void*)nobj)
    glatter_gluEndSurface_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
void glatter_gluEndTrim_debug(GLUnurbs *nobj, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluEndTrim, (%p), (void*)nobj)
    glatter_gluEndTrim_ptr(nobj);
    glatter_check_error_GLU(file, line);
}
const GLubyte* glatter_gluErrorString_debug(GLenum errCode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluErrorString, (%s), enum_to_string_GL(errCode))
    const GLubyte* rval = glatter_gluErrorString_ptr(errCode);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
const wchar_t* glatter_gluErrorUnicodeStringEXT_debug(GLenum errCode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluErrorUnicodeStringEXT, (%s), enum_to_string_GL(errCode))
    const wchar_t* rval = glatter_gluErrorUnicodeStringEXT_ptr(errCode);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
const GLubyte* glatter_gluGetString_debug(GLenum name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluGetString, (%s), enum_to_string_GL(name))
    const GLubyte* rval = glatter_gluGetString_ptr(name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
void glatter_gluGetTessProperty_debug(GLUtesselator *tess, GLenum which, GLdouble *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluGetTessProperty, (%p, %s, %p), (void*)tess, enum_to_string_GL(which), (void*)value)
    glatter_gluGetTessProperty_ptr(tess, which, value);
    glatter_check_error_GLU(file, line);
}
void glatter_gluLookAt_debug(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluLookAt, (%f, %f, %f, %f, %f, %f, %f, %f, %f), (double)eyex, (double)eyey, (double)eyez, (double)centerx, (double)centery, (double)centerz, (double)upx, (double)upy, (double)upz)
    glatter_gluLookAt_ptr(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
    glatter_check_error_GLU(file, line);
}
GLUnurbs* glatter_gluNewNurbsRenderer_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluNewNurbsRenderer, ())
    GLUnurbs* rval = glatter_gluNewNurbsRenderer_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
GLUquadric* glatter_gluNewQuadric_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluNewQuadric, ())
    GLUquadric* rval = glatter_gluNewQuadric_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
GLUtesselator* glatter_gluNewTess_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluNewTess, ())
    GLUtesselator* rval = glatter_gluNewTess_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
void glatter_gluNextContour_debug(GLUtesselator *tess, GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluNextContour, (%p, %s), (void*)tess, enum_to_string_GL(type))
    glatter_gluNextContour_ptr(tess, type);
    glatter_check_error_GLU(file, line);
}
void glatter_gluNurbsCurve_debug(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluNurbsCurve, (%p, %d, %p, %d, %p, %d, %s), (void*)nobj, (int)nknots, (void*)knot, (int)stride, (void*)ctlarray, (int)order, enum_to_string_GL(type))
    glatter_gluNurbsCurve_ptr(nobj, nknots, knot, stride, ctlarray, order, type);
    glatter_check_error_GLU(file, line);
}
void glatter_gluOrtho2D_debug(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluOrtho2D, (%f, %f, %f, %f), (double)left, (double)right, (double)bottom, (double)top)
    glatter_gluOrtho2D_ptr(left, right, bottom, top);
    glatter_check_error_GLU(file, line);
}
void glatter_gluPartialDisk_debug(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluPartialDisk, (%p, %f, %f, %d, %d, %f, %f), (void*)qobj, (double)innerRadius, (double)outerRadius, (int)slices, (int)loops, (double)startAngle, (double)sweepAngle)
    glatter_gluPartialDisk_ptr(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle);
    glatter_check_error_GLU(file, line);
}
void glatter_gluPerspective_debug(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluPerspective, (%f, %f, %f, %f), (double)fovy, (double)aspect, (double)zNear, (double)zFar)
    glatter_gluPerspective_ptr(fovy, aspect, zNear, zFar);
    glatter_check_error_GLU(file, line);
}
void glatter_gluPickMatrix_debug(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4], const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluPickMatrix, (%f, %f, %f, %f, %s), (double)x, (double)y, (double)width, (double)height, GET_PRS(viewport))
    glatter_gluPickMatrix_ptr(x, y, width, height, viewport);
    glatter_check_error_GLU(file, line);
}
int glatter_gluProject_debug(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluProject, (%f, %f, %f, %s, %s, %s, %p, %p, %p), (double)objx, (double)objy, (double)objz, GET_PRS(modelMatrix), GET_PRS(projMatrix), GET_PRS(viewport), (void*)winx, (void*)winy, (void*)winz)
    int rval = glatter_gluProject_ptr(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
void glatter_gluPwlCurve_debug(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluPwlCurve, (%p, %d, %p, %d, %s), (void*)nobj, (int)count, (void*)array, (int)stride, enum_to_string_GL(type))
    glatter_gluPwlCurve_ptr(nobj, count, array, stride, type);
    glatter_check_error_GLU(file, line);
}
void glatter_gluQuadricCallback_debug(GLUquadric *qobj, GLenum which, void (CALLBACK* fn)(), const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluQuadricCallback, (%p, %s, %p), (void*)qobj, enum_to_string_GL(which), (void*)fn)
    glatter_gluQuadricCallback_ptr(qobj, which, fn);
    glatter_check_error_GLU(file, line);
}
void glatter_gluQuadricDrawStyle_debug(GLUquadric *quadObject, GLenum drawStyle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluQuadricDrawStyle, (%p, %s), (void*)quadObject, enum_to_string_GL(drawStyle))
    glatter_gluQuadricDrawStyle_ptr(quadObject, drawStyle);
    glatter_check_error_GLU(file, line);
}
void glatter_gluQuadricNormals_debug(GLUquadric *quadObject, GLenum normals, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluQuadricNormals, (%p, %s), (void*)quadObject, enum_to_string_GL(normals))
    glatter_gluQuadricNormals_ptr(quadObject, normals);
    glatter_check_error_GLU(file, line);
}
void glatter_gluQuadricOrientation_debug(GLUquadric *quadObject, GLenum orientation, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluQuadricOrientation, (%p, %s), (void*)quadObject, enum_to_string_GL(orientation))
    glatter_gluQuadricOrientation_ptr(quadObject, orientation);
    glatter_check_error_GLU(file, line);
}
void glatter_gluQuadricTexture_debug(GLUquadric *quadObject, GLboolean textureCoords, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluQuadricTexture, (%p, %u), (void*)quadObject, (unsigned char)textureCoords)
    glatter_gluQuadricTexture_ptr(quadObject, textureCoords);
    glatter_check_error_GLU(file, line);
}
int glatter_gluScaleImage_debug(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluScaleImage, (%s, %d, %d, %s, %p, %d, %d, %s, %p), enum_to_string_GL(format), (int)widthin, (int)heightin, enum_to_string_GL(typein), (void*)datain, (int)widthout, (int)heightout, enum_to_string_GL(typeout), (void*)dataout)
    int rval = glatter_gluScaleImage_ptr(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
void glatter_gluSphere_debug(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluSphere, (%p, %f, %d, %d), (void*)qobj, (double)radius, (int)slices, (int)stacks)
    glatter_gluSphere_ptr(qobj, radius, slices, stacks);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessBeginContour_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessBeginContour, (%p), (void*)tess)
    glatter_gluTessBeginContour_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessBeginPolygon_debug(GLUtesselator *tess, void *polygon_data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessBeginPolygon, (%p, %p), (void*)tess, (void*)polygon_data)
    glatter_gluTessBeginPolygon_ptr(tess, polygon_data);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessCallback_debug(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)(), const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessCallback, (%p, %s, %p), (void*)tess, enum_to_string_GL(which), (void*)fn)
    glatter_gluTessCallback_ptr(tess, which, fn);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessEndContour_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessEndContour, (%p), (void*)tess)
    glatter_gluTessEndContour_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessEndPolygon_debug(GLUtesselator *tess, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessEndPolygon, (%p), (void*)tess)
    glatter_gluTessEndPolygon_ptr(tess);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessNormal_debug(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessNormal, (%p, %f, %f, %f), (void*)tess, (double)x, (double)y, (double)z)
    glatter_gluTessNormal_ptr(tess, x, y, z);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessProperty_debug(GLUtesselator *tess, GLenum which, GLdouble value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessProperty, (%p, %s, %f), (void*)tess, enum_to_string_GL(which), (double)value)
    glatter_gluTessProperty_ptr(tess, which, value);
    glatter_check_error_GLU(file, line);
}
void glatter_gluTessVertex_debug(GLUtesselator *tess, GLdouble coords[3], void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluTessVertex, (%p, %s, %p), (void*)tess, GET_PRS(coords), (void*)data)
    glatter_gluTessVertex_ptr(tess, coords, data);
    glatter_check_error_GLU(file, line);
}
int glatter_gluUnProject_debug(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, gluUnProject, (%f, %f, %f, %s, %s, %s, %p, %p, %p), (double)winx, (double)winy, (double)winz, GET_PRS(modelMatrix), GET_PRS(projMatrix), GET_PRS(viewport), (void*)objx, (void*)objy, (void*)objz)
    int rval = glatter_gluUnProject_ptr(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLU(file, line);
    return rval;
}
#endif // __glu_h__
#endif // GLATTER_GLU

#endif // NDEBUG



#ifdef GLATTER_WGL

#ifdef __wglext_h_
#ifdef WGL_3DL_stereo_control
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSetStereoEmitterState3DL, (hDC, uState), (HDC hDC, UINT uState))
#endif // WGL_3DL_stereo_control
#ifdef WGL_AMD_gpu_association
GLATTER_FBLOCK(return, WGL, VOID , WINAPI, , wglBlitContextFramebufferAMD, (dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, WGL, HGLRC , WINAPI, , wglCreateAssociatedContextAMD, (id), (UINT id))
GLATTER_FBLOCK(return, WGL, HGLRC , WINAPI, , wglCreateAssociatedContextAttribsAMD, (id, hShareContext, attribList), (UINT id, HGLRC hShareContext, const int *attribList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDeleteAssociatedContextAMD, (hglrc), (HGLRC hglrc))
GLATTER_FBLOCK(return, WGL, UINT , WINAPI, , wglGetContextGPUIDAMD, (hglrc), (HGLRC hglrc))
GLATTER_FBLOCK(return, WGL, HGLRC , WINAPI, , wglGetCurrentAssociatedContextAMD, (), ())
GLATTER_FBLOCK(return, WGL, UINT , WINAPI, , wglGetGPUIDsAMD, (maxCount, ids), (UINT maxCount, UINT *ids))
GLATTER_FBLOCK(return, WGL, INT , WINAPI, , wglGetGPUInfoAMD, (id, property, dataType, size, data), (UINT id, int property, GLenum dataType, UINT size, void *data))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglMakeAssociatedContextCurrentAMD, (hglrc), (HGLRC hglrc))
#endif // WGL_AMD_gpu_association
#ifdef WGL_ARB_buffer_region
GLATTER_FBLOCK(return, WGL, HANDLE , WINAPI, , wglCreateBufferRegionARB, (hDC, iLayerPlane, uType), (HDC hDC, int iLayerPlane, UINT uType))
GLATTER_FBLOCK(return, WGL, VOID , WINAPI, , wglDeleteBufferRegionARB, (hRegion), (HANDLE hRegion))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglRestoreBufferRegionARB, (hRegion, x, y, width, height, xSrc, ySrc), (HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSaveBufferRegionARB, (hRegion, x, y, width, height), (HANDLE hRegion, int x, int y, int width, int height))
#endif // WGL_ARB_buffer_region
#ifdef WGL_ARB_create_context
GLATTER_FBLOCK(return, WGL, HGLRC , WINAPI, , wglCreateContextAttribsARB, (hDC, hShareContext, attribList), (HDC hDC, HGLRC hShareContext, const int *attribList))
#endif // WGL_ARB_create_context
#ifdef WGL_ARB_extensions_string
GLATTER_FBLOCK(return, WGL, , const char *WINAPI, , wglGetExtensionsStringARB, (hdc), (HDC hdc))
#endif // WGL_ARB_extensions_string
#ifdef WGL_ARB_make_current_read
GLATTER_FBLOCK(return, WGL, HDC , WINAPI, , wglGetCurrentReadDCARB, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglMakeContextCurrentARB, (hDrawDC, hReadDC, hglrc), (HDC hDrawDC, HDC hReadDC, HGLRC hglrc))
#endif // WGL_ARB_make_current_read
#ifdef WGL_ARB_pbuffer
GLATTER_FBLOCK(return, WGL, HPBUFFERARB , WINAPI, , wglCreatePbufferARB, (hDC, iPixelFormat, iWidth, iHeight, piAttribList), (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDestroyPbufferARB, (hPbuffer), (HPBUFFERARB hPbuffer))
GLATTER_FBLOCK(return, WGL, HDC , WINAPI, , wglGetPbufferDCARB, (hPbuffer), (HPBUFFERARB hPbuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryPbufferARB, (hPbuffer, iAttribute, piValue), (HPBUFFERARB hPbuffer, int iAttribute, int *piValue))
GLATTER_FBLOCK(return, WGL, , int WINAPI, , wglReleasePbufferDCARB, (hPbuffer, hDC), (HPBUFFERARB hPbuffer, HDC hDC))
#endif // WGL_ARB_pbuffer
#ifdef WGL_ARB_pixel_format
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglChoosePixelFormatARB, (hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats), (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetPixelFormatAttribfvARB, (hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues), (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetPixelFormatAttribivARB, (hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues), (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues))
#endif // WGL_ARB_pixel_format
#ifdef WGL_ARB_render_texture
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBindTexImageARB, (hPbuffer, iBuffer), (HPBUFFERARB hPbuffer, int iBuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglReleaseTexImageARB, (hPbuffer, iBuffer), (HPBUFFERARB hPbuffer, int iBuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSetPbufferAttribARB, (hPbuffer, piAttribList), (HPBUFFERARB hPbuffer, const int *piAttribList))
#endif // WGL_ARB_render_texture
#ifdef WGL_EXT_display_color_table
GLATTER_FBLOCK(return, WGL, , GLboolean WINAPI, , wglBindDisplayColorTableEXT, (id), (GLushort id))
GLATTER_FBLOCK(return, WGL, , GLboolean WINAPI, , wglCreateDisplayColorTableEXT, (id), (GLushort id))
GLATTER_FBLOCK(return, WGL, VOID , WINAPI, , wglDestroyDisplayColorTableEXT, (id), (GLushort id))
GLATTER_FBLOCK(return, WGL, , GLboolean WINAPI, , wglLoadDisplayColorTableEXT, (table, length), (const GLushort *table, GLuint length))
#endif // WGL_EXT_display_color_table
#ifdef WGL_EXT_extensions_string
GLATTER_FBLOCK(return, WGL, , const char *WINAPI, , wglGetExtensionsStringEXT, (), ())
#endif // WGL_EXT_extensions_string
#ifdef WGL_EXT_make_current_read
GLATTER_FBLOCK(return, WGL, HDC , WINAPI, , wglGetCurrentReadDCEXT, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglMakeContextCurrentEXT, (hDrawDC, hReadDC, hglrc), (HDC hDrawDC, HDC hReadDC, HGLRC hglrc))
#endif // WGL_EXT_make_current_read
#ifdef WGL_EXT_pbuffer
GLATTER_FBLOCK(return, WGL, HPBUFFEREXT , WINAPI, , wglCreatePbufferEXT, (hDC, iPixelFormat, iWidth, iHeight, piAttribList), (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDestroyPbufferEXT, (hPbuffer), (HPBUFFEREXT hPbuffer))
GLATTER_FBLOCK(return, WGL, HDC , WINAPI, , wglGetPbufferDCEXT, (hPbuffer), (HPBUFFEREXT hPbuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryPbufferEXT, (hPbuffer, iAttribute, piValue), (HPBUFFEREXT hPbuffer, int iAttribute, int *piValue))
GLATTER_FBLOCK(return, WGL, , int WINAPI, , wglReleasePbufferDCEXT, (hPbuffer, hDC), (HPBUFFEREXT hPbuffer, HDC hDC))
#endif // WGL_EXT_pbuffer
#ifdef WGL_EXT_pixel_format
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglChoosePixelFormatEXT, (hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats), (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetPixelFormatAttribfvEXT, (hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues), (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetPixelFormatAttribivEXT, (hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues), (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues))
#endif // WGL_EXT_pixel_format
#ifdef WGL_EXT_swap_control
GLATTER_FBLOCK(return, WGL, , int WINAPI, , wglGetSwapIntervalEXT, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSwapIntervalEXT, (interval), (int interval))
#endif // WGL_EXT_swap_control
#ifdef WGL_I3D_digital_video_control
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetDigitalVideoParametersI3D, (hDC, iAttribute, piValue), (HDC hDC, int iAttribute, int *piValue))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSetDigitalVideoParametersI3D, (hDC, iAttribute, piValue), (HDC hDC, int iAttribute, const int *piValue))
#endif // WGL_I3D_digital_video_control
#ifdef WGL_I3D_gamma
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGammaTableI3D, (hDC, iEntries, puRed, puGreen, puBlue), (HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGammaTableParametersI3D, (hDC, iAttribute, piValue), (HDC hDC, int iAttribute, int *piValue))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSetGammaTableI3D, (hDC, iEntries, puRed, puGreen, puBlue), (HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSetGammaTableParametersI3D, (hDC, iAttribute, piValue), (HDC hDC, int iAttribute, const int *piValue))
#endif // WGL_I3D_gamma
#ifdef WGL_I3D_genlock
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDisableGenlockI3D, (hDC), (HDC hDC))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEnableGenlockI3D, (hDC), (HDC hDC))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGenlockSampleRateI3D, (hDC, uRate), (HDC hDC, UINT uRate))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGenlockSourceDelayI3D, (hDC, uDelay), (HDC hDC, UINT uDelay))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGenlockSourceEdgeI3D, (hDC, uEdge), (HDC hDC, UINT uEdge))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGenlockSourceI3D, (hDC, uSource), (HDC hDC, UINT uSource))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGenlockSampleRateI3D, (hDC, uRate), (HDC hDC, UINT *uRate))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGenlockSourceDelayI3D, (hDC, uDelay), (HDC hDC, UINT *uDelay))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGenlockSourceEdgeI3D, (hDC, uEdge), (HDC hDC, UINT *uEdge))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetGenlockSourceI3D, (hDC, uSource), (HDC hDC, UINT *uSource))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglIsEnabledGenlockI3D, (hDC, pFlag), (HDC hDC, BOOL *pFlag))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryGenlockMaxSourceDelayI3D, (hDC, uMaxLineDelay, uMaxPixelDelay), (HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay))
#endif // WGL_I3D_genlock
#ifdef WGL_I3D_image_buffer
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglAssociateImageBufferEventsI3D, (hDC, pEvent, pAddress, pSize, count), (HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count))
GLATTER_FBLOCK(return, WGL, LPVOID , WINAPI, , wglCreateImageBufferI3D, (hDC, dwSize, uFlags), (HDC hDC, DWORD dwSize, UINT uFlags))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDestroyImageBufferI3D, (hDC, pAddress), (HDC hDC, LPVOID pAddress))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglReleaseImageBufferEventsI3D, (hDC, pAddress, count), (HDC hDC, const LPVOID *pAddress, UINT count))
#endif // WGL_I3D_image_buffer
#ifdef WGL_I3D_swap_frame_lock
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDisableFrameLockI3D, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEnableFrameLockI3D, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglIsEnabledFrameLockI3D, (pFlag), (BOOL *pFlag))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryFrameLockMasterI3D, (pFlag), (BOOL *pFlag))
#endif // WGL_I3D_swap_frame_lock
#ifdef WGL_I3D_swap_frame_usage
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBeginFrameTrackingI3D, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEndFrameTrackingI3D, (), ())
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetFrameUsageI3D, (pUsage), (float *pUsage))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryFrameTrackingI3D, (pFrameCount, pMissedFrames, pLastMissedUsage), (DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage))
#endif // WGL_I3D_swap_frame_usage
#ifdef WGL_NV_DX_interop
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXCloseDeviceNV, (hDevice), (HANDLE hDevice))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXLockObjectsNV, (hDevice, count, hObjects), (HANDLE hDevice, GLint count, HANDLE *hObjects))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXObjectAccessNV, (hObject, access), (HANDLE hObject, GLenum access))
GLATTER_FBLOCK(return, WGL, HANDLE , WINAPI, , wglDXOpenDeviceNV, (dxDevice), (void *dxDevice))
GLATTER_FBLOCK(return, WGL, HANDLE , WINAPI, , wglDXRegisterObjectNV, (hDevice, dxObject, name, type, access), (HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXSetResourceShareHandleNV, (dxObject, shareHandle), (void *dxObject, HANDLE shareHandle))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXUnlockObjectsNV, (hDevice, count, hObjects), (HANDLE hDevice, GLint count, HANDLE *hObjects))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDXUnregisterObjectNV, (hDevice, hObject), (HANDLE hDevice, HANDLE hObject))
#endif // WGL_NV_DX_interop
#ifdef WGL_NV_copy_image
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglCopyImageSubDataNV, (hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
#endif // WGL_NV_copy_image
#ifdef WGL_NV_delay_before_swap
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDelayBeforeSwapNV, (hDC, seconds), (HDC hDC, GLfloat seconds))
#endif // WGL_NV_delay_before_swap
#ifdef WGL_NV_gpu_affinity
GLATTER_FBLOCK(return, WGL, HDC , WINAPI, , wglCreateAffinityDCNV, (phGpuList), (const HGPUNV *phGpuList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglDeleteDCNV, (hdc), (HDC hdc))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEnumGpuDevicesNV, (hGpu, iDeviceIndex, lpGpuDevice), (HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEnumGpusFromAffinityDCNV, (hAffinityDC, iGpuIndex, hGpu), (HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglEnumGpusNV, (iGpuIndex, phGpu), (UINT iGpuIndex, HGPUNV *phGpu))
#endif // WGL_NV_gpu_affinity
#ifdef WGL_NV_present_video
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBindVideoDeviceNV, (hDC, uVideoSlot, hVideoDevice, piAttribList), (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList))
GLATTER_FBLOCK(return, WGL, , int WINAPI, , wglEnumerateVideoDevicesNV, (hDC, phDeviceList), (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryCurrentContextNV, (iAttribute, piValue), (int iAttribute, int *piValue))
#endif // WGL_NV_present_video
#ifdef WGL_NV_swap_group
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBindSwapBarrierNV, (group, barrier), (GLuint group, GLuint barrier))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglJoinSwapGroupNV, (hDC, group), (HDC hDC, GLuint group))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryFrameCountNV, (hDC, count), (HDC hDC, GLuint *count))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryMaxSwapGroupsNV, (hDC, maxGroups, maxBarriers), (HDC hDC, GLuint *maxGroups, GLuint *maxBarriers))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQuerySwapGroupNV, (hDC, group, barrier), (HDC hDC, GLuint *group, GLuint *barrier))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglResetFrameCountNV, (hDC), (HDC hDC))
#endif // WGL_NV_swap_group
#ifdef WGL_NV_vertex_array_range
GLATTER_FBLOCK(return, WGL, , void *WINAPI, , wglAllocateMemoryNV, (size, readfreq, writefreq, priority), (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority))
GLATTER_FBLOCK(return, WGL, , void WINAPI, , wglFreeMemoryNV, (pointer), (void *pointer))
#endif // WGL_NV_vertex_array_range
#ifdef WGL_NV_video_capture
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBindVideoCaptureDeviceNV, (uVideoSlot, hDevice), (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice))
GLATTER_FBLOCK(return, WGL, UINT , WINAPI, , wglEnumerateVideoCaptureDevicesNV, (hDc, phDeviceList), (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglLockVideoCaptureDeviceNV, (hDc, hDevice), (HDC hDc, HVIDEOINPUTDEVICENV hDevice))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglQueryVideoCaptureDeviceNV, (hDc, hDevice, iAttribute, piValue), (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglReleaseVideoCaptureDeviceNV, (hDc, hDevice), (HDC hDc, HVIDEOINPUTDEVICENV hDevice))
#endif // WGL_NV_video_capture
#ifdef WGL_NV_video_output
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglBindVideoImageNV, (hVideoDevice, hPbuffer, iVideoBuffer), (HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetVideoDeviceNV, (hDC, numDevices, hVideoDevice), (HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetVideoInfoNV, (hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo), (HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglReleaseVideoDeviceNV, (hVideoDevice), (HPVIDEODEV hVideoDevice))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglReleaseVideoImageNV, (hPbuffer, iVideoBuffer), (HPBUFFERARB hPbuffer, int iVideoBuffer))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglSendPbufferToVideoNV, (hPbuffer, iBufferType, pulCounterPbuffer, bBlock), (HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock))
#endif // WGL_NV_video_output
#ifdef WGL_OML_sync_control
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetMscRateOML, (hdc, numerator, denominator), (HDC hdc, INT32 *numerator, INT32 *denominator))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglGetSyncValuesOML, (hdc, ust, msc, sbc), (HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc))
GLATTER_FBLOCK(return, WGL, INT64 , WINAPI, , wglSwapBuffersMscOML, (hdc, target_msc, divisor, remainder), (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder))
GLATTER_FBLOCK(return, WGL, INT64 , WINAPI, , wglSwapLayerBuffersMscOML, (hdc, fuPlanes, target_msc, divisor, remainder), (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglWaitForMscOML, (hdc, target_msc, divisor, remainder, ust, msc, sbc), (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc))
GLATTER_FBLOCK(return, WGL, BOOL , WINAPI, , wglWaitForSbcOML, (hdc, target_sbc, ust, msc, sbc), (HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc))
#endif // WGL_OML_sync_control
#endif // __wglext_h_
#endif // GLATTER_WGL

#ifndef NDEBUG

#ifdef GLATTER_WGL

#ifdef __wglext_h_
#ifdef WGL_3DL_stereo_control
WINAPI glatter_wglSetStereoEmitterState3DL_debug(HDC hDC, UINT uState, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSetStereoEmitterState3DL, (%s, %s), GET_PRS(hDC), GET_PRS(uState))
    WINAPI rval = glatter_wglSetStereoEmitterState3DL_ptr(hDC, uState);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_3DL_stereo_control
#ifdef WGL_AMD_gpu_association
WINAPI glatter_wglBlitContextFramebufferAMD_debug(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBlitContextFramebufferAMD, (%s, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s), GET_PRS(dstCtx), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    WINAPI rval = glatter_wglBlitContextFramebufferAMD_ptr(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglCreateAssociatedContextAMD_debug(UINT id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateAssociatedContextAMD, (%s), GET_PRS(id))
    WINAPI rval = glatter_wglCreateAssociatedContextAMD_ptr(id);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglCreateAssociatedContextAttribsAMD_debug(UINT id, HGLRC hShareContext, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateAssociatedContextAttribsAMD, (%s, %s, %p), GET_PRS(id), GET_PRS(hShareContext), (void*)attribList)
    WINAPI rval = glatter_wglCreateAssociatedContextAttribsAMD_ptr(id, hShareContext, attribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDeleteAssociatedContextAMD_debug(HGLRC hglrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDeleteAssociatedContextAMD, (%s), GET_PRS(hglrc))
    WINAPI rval = glatter_wglDeleteAssociatedContextAMD_ptr(hglrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetContextGPUIDAMD_debug(HGLRC hglrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetContextGPUIDAMD, (%s), GET_PRS(hglrc))
    WINAPI rval = glatter_wglGetContextGPUIDAMD_ptr(hglrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetCurrentAssociatedContextAMD_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetCurrentAssociatedContextAMD, ())
    WINAPI rval = glatter_wglGetCurrentAssociatedContextAMD_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGPUIDsAMD_debug(UINT maxCount, UINT *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGPUIDsAMD, (%s, %p), GET_PRS(maxCount), (void*)ids)
    WINAPI rval = glatter_wglGetGPUIDsAMD_ptr(maxCount, ids);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGPUInfoAMD_debug(UINT id, int property, GLenum dataType, UINT size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGPUInfoAMD, (%s, %d, %s, %s, %p), GET_PRS(id), (int)property, enum_to_string_GL(dataType), GET_PRS(size), (void*)data)
    WINAPI rval = glatter_wglGetGPUInfoAMD_ptr(id, property, dataType, size, data);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglMakeAssociatedContextCurrentAMD_debug(HGLRC hglrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglMakeAssociatedContextCurrentAMD, (%s), GET_PRS(hglrc))
    WINAPI rval = glatter_wglMakeAssociatedContextCurrentAMD_ptr(hglrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_AMD_gpu_association
#ifdef WGL_ARB_buffer_region
WINAPI glatter_wglCreateBufferRegionARB_debug(HDC hDC, int iLayerPlane, UINT uType, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateBufferRegionARB, (%s, %d, %s), GET_PRS(hDC), (int)iLayerPlane, GET_PRS(uType))
    WINAPI rval = glatter_wglCreateBufferRegionARB_ptr(hDC, iLayerPlane, uType);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDeleteBufferRegionARB_debug(HANDLE hRegion, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDeleteBufferRegionARB, (%s), GET_PRS(hRegion))
    WINAPI rval = glatter_wglDeleteBufferRegionARB_ptr(hRegion);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglRestoreBufferRegionARB_debug(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglRestoreBufferRegionARB, (%s, %d, %d, %d, %d, %d, %d), GET_PRS(hRegion), (int)x, (int)y, (int)width, (int)height, (int)xSrc, (int)ySrc)
    WINAPI rval = glatter_wglRestoreBufferRegionARB_ptr(hRegion, x, y, width, height, xSrc, ySrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSaveBufferRegionARB_debug(HANDLE hRegion, int x, int y, int width, int height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSaveBufferRegionARB, (%s, %d, %d, %d, %d), GET_PRS(hRegion), (int)x, (int)y, (int)width, (int)height)
    WINAPI rval = glatter_wglSaveBufferRegionARB_ptr(hRegion, x, y, width, height);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_buffer_region
#ifdef WGL_ARB_create_context
WINAPI glatter_wglCreateContextAttribsARB_debug(HDC hDC, HGLRC hShareContext, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateContextAttribsARB, (%s, %s, %p), GET_PRS(hDC), GET_PRS(hShareContext), (void*)attribList)
    WINAPI rval = glatter_wglCreateContextAttribsARB_ptr(hDC, hShareContext, attribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_create_context
#ifdef WGL_ARB_extensions_string
const char *WINAPI glatter_wglGetExtensionsStringARB_debug(HDC hdc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetExtensionsStringARB, (%s), GET_PRS(hdc))
    const char *WINAPI rval = glatter_wglGetExtensionsStringARB_ptr(hdc);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_extensions_string
#ifdef WGL_ARB_make_current_read
WINAPI glatter_wglGetCurrentReadDCARB_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetCurrentReadDCARB, ())
    WINAPI rval = glatter_wglGetCurrentReadDCARB_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglMakeContextCurrentARB_debug(HDC hDrawDC, HDC hReadDC, HGLRC hglrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglMakeContextCurrentARB, (%s, %s, %s), GET_PRS(hDrawDC), GET_PRS(hReadDC), GET_PRS(hglrc))
    WINAPI rval = glatter_wglMakeContextCurrentARB_ptr(hDrawDC, hReadDC, hglrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_make_current_read
#ifdef WGL_ARB_pbuffer
WINAPI glatter_wglCreatePbufferARB_debug(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreatePbufferARB, (%s, %d, %d, %d, %p), GET_PRS(hDC), (int)iPixelFormat, (int)iWidth, (int)iHeight, (void*)piAttribList)
    WINAPI rval = glatter_wglCreatePbufferARB_ptr(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDestroyPbufferARB_debug(HPBUFFERARB hPbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDestroyPbufferARB, (%s), GET_PRS(hPbuffer))
    WINAPI rval = glatter_wglDestroyPbufferARB_ptr(hPbuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPbufferDCARB_debug(HPBUFFERARB hPbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPbufferDCARB, (%s), GET_PRS(hPbuffer))
    WINAPI rval = glatter_wglGetPbufferDCARB_ptr(hPbuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryPbufferARB_debug(HPBUFFERARB hPbuffer, int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryPbufferARB, (%s, %d, %p), GET_PRS(hPbuffer), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglQueryPbufferARB_ptr(hPbuffer, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
int WINAPI glatter_wglReleasePbufferDCARB_debug(HPBUFFERARB hPbuffer, HDC hDC, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleasePbufferDCARB, (%s, %s), GET_PRS(hPbuffer), GET_PRS(hDC))
    int WINAPI rval = glatter_wglReleasePbufferDCARB_ptr(hPbuffer, hDC);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_pbuffer
#ifdef WGL_ARB_pixel_format
WINAPI glatter_wglChoosePixelFormatARB_debug(HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglChoosePixelFormatARB, (%s, %p, %p, %s, %p, %p), GET_PRS(hdc), (void*)piAttribIList, (void*)pfAttribFList, GET_PRS(nMaxFormats), (void*)piFormats, (void*)nNumFormats)
    WINAPI rval = glatter_wglChoosePixelFormatARB_ptr(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPixelFormatAttribfvARB_debug(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPixelFormatAttribfvARB, (%s, %d, %d, %s, %p, %p), GET_PRS(hdc), (int)iPixelFormat, (int)iLayerPlane, GET_PRS(nAttributes), (void*)piAttributes, (void*)pfValues)
    WINAPI rval = glatter_wglGetPixelFormatAttribfvARB_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPixelFormatAttribivARB_debug(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPixelFormatAttribivARB, (%s, %d, %d, %s, %p, %p), GET_PRS(hdc), (int)iPixelFormat, (int)iLayerPlane, GET_PRS(nAttributes), (void*)piAttributes, (void*)piValues)
    WINAPI rval = glatter_wglGetPixelFormatAttribivARB_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_pixel_format
#ifdef WGL_ARB_render_texture
WINAPI glatter_wglBindTexImageARB_debug(HPBUFFERARB hPbuffer, int iBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindTexImageARB, (%s, %d), GET_PRS(hPbuffer), (int)iBuffer)
    WINAPI rval = glatter_wglBindTexImageARB_ptr(hPbuffer, iBuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglReleaseTexImageARB_debug(HPBUFFERARB hPbuffer, int iBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleaseTexImageARB, (%s, %d), GET_PRS(hPbuffer), (int)iBuffer)
    WINAPI rval = glatter_wglReleaseTexImageARB_ptr(hPbuffer, iBuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSetPbufferAttribARB_debug(HPBUFFERARB hPbuffer, const int *piAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSetPbufferAttribARB, (%s, %p), GET_PRS(hPbuffer), (void*)piAttribList)
    WINAPI rval = glatter_wglSetPbufferAttribARB_ptr(hPbuffer, piAttribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_ARB_render_texture
#ifdef WGL_EXT_display_color_table
GLboolean WINAPI glatter_wglBindDisplayColorTableEXT_debug(GLushort id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindDisplayColorTableEXT, (%hu), (unsigned short)id)
    GLboolean WINAPI rval = glatter_wglBindDisplayColorTableEXT_ptr(id);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
GLboolean WINAPI glatter_wglCreateDisplayColorTableEXT_debug(GLushort id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateDisplayColorTableEXT, (%hu), (unsigned short)id)
    GLboolean WINAPI rval = glatter_wglCreateDisplayColorTableEXT_ptr(id);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDestroyDisplayColorTableEXT_debug(GLushort id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDestroyDisplayColorTableEXT, (%hu), (unsigned short)id)
    WINAPI rval = glatter_wglDestroyDisplayColorTableEXT_ptr(id);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
GLboolean WINAPI glatter_wglLoadDisplayColorTableEXT_debug(const GLushort *table, GLuint length, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglLoadDisplayColorTableEXT, (%p, %u), (void*)table, (unsigned int)length)
    GLboolean WINAPI rval = glatter_wglLoadDisplayColorTableEXT_ptr(table, length);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_display_color_table
#ifdef WGL_EXT_extensions_string
const char *WINAPI glatter_wglGetExtensionsStringEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetExtensionsStringEXT, ())
    const char *WINAPI rval = glatter_wglGetExtensionsStringEXT_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_extensions_string
#ifdef WGL_EXT_make_current_read
WINAPI glatter_wglGetCurrentReadDCEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetCurrentReadDCEXT, ())
    WINAPI rval = glatter_wglGetCurrentReadDCEXT_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglMakeContextCurrentEXT_debug(HDC hDrawDC, HDC hReadDC, HGLRC hglrc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglMakeContextCurrentEXT, (%s, %s, %s), GET_PRS(hDrawDC), GET_PRS(hReadDC), GET_PRS(hglrc))
    WINAPI rval = glatter_wglMakeContextCurrentEXT_ptr(hDrawDC, hReadDC, hglrc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_make_current_read
#ifdef WGL_EXT_pbuffer
WINAPI glatter_wglCreatePbufferEXT_debug(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreatePbufferEXT, (%s, %d, %d, %d, %p), GET_PRS(hDC), (int)iPixelFormat, (int)iWidth, (int)iHeight, (void*)piAttribList)
    WINAPI rval = glatter_wglCreatePbufferEXT_ptr(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDestroyPbufferEXT_debug(HPBUFFEREXT hPbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDestroyPbufferEXT, (%s), GET_PRS(hPbuffer))
    WINAPI rval = glatter_wglDestroyPbufferEXT_ptr(hPbuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPbufferDCEXT_debug(HPBUFFEREXT hPbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPbufferDCEXT, (%s), GET_PRS(hPbuffer))
    WINAPI rval = glatter_wglGetPbufferDCEXT_ptr(hPbuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryPbufferEXT_debug(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryPbufferEXT, (%s, %d, %p), GET_PRS(hPbuffer), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglQueryPbufferEXT_ptr(hPbuffer, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
int WINAPI glatter_wglReleasePbufferDCEXT_debug(HPBUFFEREXT hPbuffer, HDC hDC, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleasePbufferDCEXT, (%s, %s), GET_PRS(hPbuffer), GET_PRS(hDC))
    int WINAPI rval = glatter_wglReleasePbufferDCEXT_ptr(hPbuffer, hDC);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_pbuffer
#ifdef WGL_EXT_pixel_format
WINAPI glatter_wglChoosePixelFormatEXT_debug(HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglChoosePixelFormatEXT, (%s, %p, %p, %s, %p, %p), GET_PRS(hdc), (void*)piAttribIList, (void*)pfAttribFList, GET_PRS(nMaxFormats), (void*)piFormats, (void*)nNumFormats)
    WINAPI rval = glatter_wglChoosePixelFormatEXT_ptr(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPixelFormatAttribfvEXT_debug(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPixelFormatAttribfvEXT, (%s, %d, %d, %s, %p, %p), GET_PRS(hdc), (int)iPixelFormat, (int)iLayerPlane, GET_PRS(nAttributes), (void*)piAttributes, (void*)pfValues)
    WINAPI rval = glatter_wglGetPixelFormatAttribfvEXT_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetPixelFormatAttribivEXT_debug(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetPixelFormatAttribivEXT, (%s, %d, %d, %s, %p, %p), GET_PRS(hdc), (int)iPixelFormat, (int)iLayerPlane, GET_PRS(nAttributes), (void*)piAttributes, (void*)piValues)
    WINAPI rval = glatter_wglGetPixelFormatAttribivEXT_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_pixel_format
#ifdef WGL_EXT_swap_control
int WINAPI glatter_wglGetSwapIntervalEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetSwapIntervalEXT, ())
    int WINAPI rval = glatter_wglGetSwapIntervalEXT_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSwapIntervalEXT_debug(int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSwapIntervalEXT, (%d), (int)interval)
    WINAPI rval = glatter_wglSwapIntervalEXT_ptr(interval);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_EXT_swap_control
#ifdef WGL_I3D_digital_video_control
WINAPI glatter_wglGetDigitalVideoParametersI3D_debug(HDC hDC, int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetDigitalVideoParametersI3D, (%s, %d, %p), GET_PRS(hDC), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglGetDigitalVideoParametersI3D_ptr(hDC, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSetDigitalVideoParametersI3D_debug(HDC hDC, int iAttribute, const int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSetDigitalVideoParametersI3D, (%s, %d, %p), GET_PRS(hDC), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglSetDigitalVideoParametersI3D_ptr(hDC, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_digital_video_control
#ifdef WGL_I3D_gamma
WINAPI glatter_wglGetGammaTableI3D_debug(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGammaTableI3D, (%s, %d, %p, %p, %p), GET_PRS(hDC), (int)iEntries, (void*)puRed, (void*)puGreen, (void*)puBlue)
    WINAPI rval = glatter_wglGetGammaTableI3D_ptr(hDC, iEntries, puRed, puGreen, puBlue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGammaTableParametersI3D_debug(HDC hDC, int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGammaTableParametersI3D, (%s, %d, %p), GET_PRS(hDC), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglGetGammaTableParametersI3D_ptr(hDC, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSetGammaTableI3D_debug(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSetGammaTableI3D, (%s, %d, %p, %p, %p), GET_PRS(hDC), (int)iEntries, (void*)puRed, (void*)puGreen, (void*)puBlue)
    WINAPI rval = glatter_wglSetGammaTableI3D_ptr(hDC, iEntries, puRed, puGreen, puBlue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSetGammaTableParametersI3D_debug(HDC hDC, int iAttribute, const int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSetGammaTableParametersI3D, (%s, %d, %p), GET_PRS(hDC), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglSetGammaTableParametersI3D_ptr(hDC, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_gamma
#ifdef WGL_I3D_genlock
WINAPI glatter_wglDisableGenlockI3D_debug(HDC hDC, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDisableGenlockI3D, (%s), GET_PRS(hDC))
    WINAPI rval = glatter_wglDisableGenlockI3D_ptr(hDC);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnableGenlockI3D_debug(HDC hDC, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnableGenlockI3D, (%s), GET_PRS(hDC))
    WINAPI rval = glatter_wglEnableGenlockI3D_ptr(hDC);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGenlockSampleRateI3D_debug(HDC hDC, UINT uRate, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGenlockSampleRateI3D, (%s, %s), GET_PRS(hDC), GET_PRS(uRate))
    WINAPI rval = glatter_wglGenlockSampleRateI3D_ptr(hDC, uRate);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGenlockSourceDelayI3D_debug(HDC hDC, UINT uDelay, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGenlockSourceDelayI3D, (%s, %s), GET_PRS(hDC), GET_PRS(uDelay))
    WINAPI rval = glatter_wglGenlockSourceDelayI3D_ptr(hDC, uDelay);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGenlockSourceEdgeI3D_debug(HDC hDC, UINT uEdge, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGenlockSourceEdgeI3D, (%s, %s), GET_PRS(hDC), GET_PRS(uEdge))
    WINAPI rval = glatter_wglGenlockSourceEdgeI3D_ptr(hDC, uEdge);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGenlockSourceI3D_debug(HDC hDC, UINT uSource, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGenlockSourceI3D, (%s, %s), GET_PRS(hDC), GET_PRS(uSource))
    WINAPI rval = glatter_wglGenlockSourceI3D_ptr(hDC, uSource);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGenlockSampleRateI3D_debug(HDC hDC, UINT *uRate, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGenlockSampleRateI3D, (%s, %p), GET_PRS(hDC), (void*)uRate)
    WINAPI rval = glatter_wglGetGenlockSampleRateI3D_ptr(hDC, uRate);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGenlockSourceDelayI3D_debug(HDC hDC, UINT *uDelay, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGenlockSourceDelayI3D, (%s, %p), GET_PRS(hDC), (void*)uDelay)
    WINAPI rval = glatter_wglGetGenlockSourceDelayI3D_ptr(hDC, uDelay);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGenlockSourceEdgeI3D_debug(HDC hDC, UINT *uEdge, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGenlockSourceEdgeI3D, (%s, %p), GET_PRS(hDC), (void*)uEdge)
    WINAPI rval = glatter_wglGetGenlockSourceEdgeI3D_ptr(hDC, uEdge);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetGenlockSourceI3D_debug(HDC hDC, UINT *uSource, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetGenlockSourceI3D, (%s, %p), GET_PRS(hDC), (void*)uSource)
    WINAPI rval = glatter_wglGetGenlockSourceI3D_ptr(hDC, uSource);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglIsEnabledGenlockI3D_debug(HDC hDC, BOOL *pFlag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglIsEnabledGenlockI3D, (%s, %p), GET_PRS(hDC), (void*)pFlag)
    WINAPI rval = glatter_wglIsEnabledGenlockI3D_ptr(hDC, pFlag);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryGenlockMaxSourceDelayI3D_debug(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryGenlockMaxSourceDelayI3D, (%s, %p, %p), GET_PRS(hDC), (void*)uMaxLineDelay, (void*)uMaxPixelDelay)
    WINAPI rval = glatter_wglQueryGenlockMaxSourceDelayI3D_ptr(hDC, uMaxLineDelay, uMaxPixelDelay);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_genlock
#ifdef WGL_I3D_image_buffer
WINAPI glatter_wglAssociateImageBufferEventsI3D_debug(HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglAssociateImageBufferEventsI3D, (%s, %p, %p, %p, %s), GET_PRS(hDC), (void*)pEvent, (void*)pAddress, (void*)pSize, GET_PRS(count))
    WINAPI rval = glatter_wglAssociateImageBufferEventsI3D_ptr(hDC, pEvent, pAddress, pSize, count);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglCreateImageBufferI3D_debug(HDC hDC, DWORD dwSize, UINT uFlags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateImageBufferI3D, (%s, %s, %s), GET_PRS(hDC), GET_PRS(dwSize), GET_PRS(uFlags))
    WINAPI rval = glatter_wglCreateImageBufferI3D_ptr(hDC, dwSize, uFlags);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDestroyImageBufferI3D_debug(HDC hDC, LPVOID pAddress, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDestroyImageBufferI3D, (%s, %s), GET_PRS(hDC), GET_PRS(pAddress))
    WINAPI rval = glatter_wglDestroyImageBufferI3D_ptr(hDC, pAddress);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglReleaseImageBufferEventsI3D_debug(HDC hDC, const LPVOID *pAddress, UINT count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleaseImageBufferEventsI3D, (%s, %p, %s), GET_PRS(hDC), (void*)pAddress, GET_PRS(count))
    WINAPI rval = glatter_wglReleaseImageBufferEventsI3D_ptr(hDC, pAddress, count);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_image_buffer
#ifdef WGL_I3D_swap_frame_lock
WINAPI glatter_wglDisableFrameLockI3D_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDisableFrameLockI3D, ())
    WINAPI rval = glatter_wglDisableFrameLockI3D_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnableFrameLockI3D_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnableFrameLockI3D, ())
    WINAPI rval = glatter_wglEnableFrameLockI3D_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglIsEnabledFrameLockI3D_debug(BOOL *pFlag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglIsEnabledFrameLockI3D, (%p), (void*)pFlag)
    WINAPI rval = glatter_wglIsEnabledFrameLockI3D_ptr(pFlag);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryFrameLockMasterI3D_debug(BOOL *pFlag, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryFrameLockMasterI3D, (%p), (void*)pFlag)
    WINAPI rval = glatter_wglQueryFrameLockMasterI3D_ptr(pFlag);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_swap_frame_lock
#ifdef WGL_I3D_swap_frame_usage
WINAPI glatter_wglBeginFrameTrackingI3D_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBeginFrameTrackingI3D, ())
    WINAPI rval = glatter_wglBeginFrameTrackingI3D_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEndFrameTrackingI3D_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEndFrameTrackingI3D, ())
    WINAPI rval = glatter_wglEndFrameTrackingI3D_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetFrameUsageI3D_debug(float *pUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetFrameUsageI3D, (%p), (void*)pUsage)
    WINAPI rval = glatter_wglGetFrameUsageI3D_ptr(pUsage);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryFrameTrackingI3D_debug(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryFrameTrackingI3D, (%p, %p, %p), (void*)pFrameCount, (void*)pMissedFrames, (void*)pLastMissedUsage)
    WINAPI rval = glatter_wglQueryFrameTrackingI3D_ptr(pFrameCount, pMissedFrames, pLastMissedUsage);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_I3D_swap_frame_usage
#ifdef WGL_NV_DX_interop
WINAPI glatter_wglDXCloseDeviceNV_debug(HANDLE hDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXCloseDeviceNV, (%s), GET_PRS(hDevice))
    WINAPI rval = glatter_wglDXCloseDeviceNV_ptr(hDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXLockObjectsNV_debug(HANDLE hDevice, GLint count, HANDLE *hObjects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXLockObjectsNV, (%s, %d, %p), GET_PRS(hDevice), (int)count, (void*)hObjects)
    WINAPI rval = glatter_wglDXLockObjectsNV_ptr(hDevice, count, hObjects);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXObjectAccessNV_debug(HANDLE hObject, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXObjectAccessNV, (%s, %s), GET_PRS(hObject), enum_to_string_GL(access))
    WINAPI rval = glatter_wglDXObjectAccessNV_ptr(hObject, access);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXOpenDeviceNV_debug(void *dxDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXOpenDeviceNV, (%p), (void*)dxDevice)
    WINAPI rval = glatter_wglDXOpenDeviceNV_ptr(dxDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXRegisterObjectNV_debug(HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXRegisterObjectNV, (%s, %p, %u, %s, %s), GET_PRS(hDevice), (void*)dxObject, (unsigned int)name, enum_to_string_GL(type), enum_to_string_GL(access))
    WINAPI rval = glatter_wglDXRegisterObjectNV_ptr(hDevice, dxObject, name, type, access);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXSetResourceShareHandleNV_debug(void *dxObject, HANDLE shareHandle, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXSetResourceShareHandleNV, (%p, %s), (void*)dxObject, GET_PRS(shareHandle))
    WINAPI rval = glatter_wglDXSetResourceShareHandleNV_ptr(dxObject, shareHandle);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXUnlockObjectsNV_debug(HANDLE hDevice, GLint count, HANDLE *hObjects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXUnlockObjectsNV, (%s, %d, %p), GET_PRS(hDevice), (int)count, (void*)hObjects)
    WINAPI rval = glatter_wglDXUnlockObjectsNV_ptr(hDevice, count, hObjects);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDXUnregisterObjectNV_debug(HANDLE hDevice, HANDLE hObject, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDXUnregisterObjectNV, (%s, %s), GET_PRS(hDevice), GET_PRS(hObject))
    WINAPI rval = glatter_wglDXUnregisterObjectNV_ptr(hDevice, hObject);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_DX_interop
#ifdef WGL_NV_copy_image
WINAPI glatter_wglCopyImageSubDataNV_debug(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCopyImageSubDataNV, (%s, %u, %s, %d, %d, %d, %d, %s, %u, %s, %d, %d, %d, %d, %d, %d, %d), GET_PRS(hSrcRC), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, GET_PRS(hDstRC), (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    WINAPI rval = glatter_wglCopyImageSubDataNV_ptr(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_copy_image
#ifdef WGL_NV_delay_before_swap
WINAPI glatter_wglDelayBeforeSwapNV_debug(HDC hDC, GLfloat seconds, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDelayBeforeSwapNV, (%s, %f), GET_PRS(hDC), (float)seconds)
    WINAPI rval = glatter_wglDelayBeforeSwapNV_ptr(hDC, seconds);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_delay_before_swap
#ifdef WGL_NV_gpu_affinity
WINAPI glatter_wglCreateAffinityDCNV_debug(const HGPUNV *phGpuList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglCreateAffinityDCNV, (%p), (void*)phGpuList)
    WINAPI rval = glatter_wglCreateAffinityDCNV_ptr(phGpuList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglDeleteDCNV_debug(HDC hdc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglDeleteDCNV, (%s), GET_PRS(hdc))
    WINAPI rval = glatter_wglDeleteDCNV_ptr(hdc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnumGpuDevicesNV_debug(HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnumGpuDevicesNV, (%s, %s, %s), GET_PRS(hGpu), GET_PRS(iDeviceIndex), GET_PRS(lpGpuDevice))
    WINAPI rval = glatter_wglEnumGpuDevicesNV_ptr(hGpu, iDeviceIndex, lpGpuDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnumGpusFromAffinityDCNV_debug(HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnumGpusFromAffinityDCNV, (%s, %s, %p), GET_PRS(hAffinityDC), GET_PRS(iGpuIndex), (void*)hGpu)
    WINAPI rval = glatter_wglEnumGpusFromAffinityDCNV_ptr(hAffinityDC, iGpuIndex, hGpu);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnumGpusNV_debug(UINT iGpuIndex, HGPUNV *phGpu, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnumGpusNV, (%s, %p), GET_PRS(iGpuIndex), (void*)phGpu)
    WINAPI rval = glatter_wglEnumGpusNV_ptr(iGpuIndex, phGpu);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_gpu_affinity
#ifdef WGL_NV_present_video
WINAPI glatter_wglBindVideoDeviceNV_debug(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindVideoDeviceNV, (%s, %u, %s, %p), GET_PRS(hDC), (unsigned int)uVideoSlot, GET_PRS(hVideoDevice), (void*)piAttribList)
    WINAPI rval = glatter_wglBindVideoDeviceNV_ptr(hDC, uVideoSlot, hVideoDevice, piAttribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
int WINAPI glatter_wglEnumerateVideoDevicesNV_debug(HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnumerateVideoDevicesNV, (%s, %p), GET_PRS(hDC), (void*)phDeviceList)
    int WINAPI rval = glatter_wglEnumerateVideoDevicesNV_ptr(hDC, phDeviceList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryCurrentContextNV_debug(int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryCurrentContextNV, (%d, %p), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglQueryCurrentContextNV_ptr(iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_present_video
#ifdef WGL_NV_swap_group
WINAPI glatter_wglBindSwapBarrierNV_debug(GLuint group, GLuint barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindSwapBarrierNV, (%u, %u), (unsigned int)group, (unsigned int)barrier)
    WINAPI rval = glatter_wglBindSwapBarrierNV_ptr(group, barrier);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglJoinSwapGroupNV_debug(HDC hDC, GLuint group, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglJoinSwapGroupNV, (%s, %u), GET_PRS(hDC), (unsigned int)group)
    WINAPI rval = glatter_wglJoinSwapGroupNV_ptr(hDC, group);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryFrameCountNV_debug(HDC hDC, GLuint *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryFrameCountNV, (%s, %p), GET_PRS(hDC), (void*)count)
    WINAPI rval = glatter_wglQueryFrameCountNV_ptr(hDC, count);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryMaxSwapGroupsNV_debug(HDC hDC, GLuint *maxGroups, GLuint *maxBarriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryMaxSwapGroupsNV, (%s, %p, %p), GET_PRS(hDC), (void*)maxGroups, (void*)maxBarriers)
    WINAPI rval = glatter_wglQueryMaxSwapGroupsNV_ptr(hDC, maxGroups, maxBarriers);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQuerySwapGroupNV_debug(HDC hDC, GLuint *group, GLuint *barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQuerySwapGroupNV, (%s, %p, %p), GET_PRS(hDC), (void*)group, (void*)barrier)
    WINAPI rval = glatter_wglQuerySwapGroupNV_ptr(hDC, group, barrier);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglResetFrameCountNV_debug(HDC hDC, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglResetFrameCountNV, (%s), GET_PRS(hDC))
    WINAPI rval = glatter_wglResetFrameCountNV_ptr(hDC);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_swap_group
#ifdef WGL_NV_vertex_array_range
void *WINAPI glatter_wglAllocateMemoryNV_debug(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglAllocateMemoryNV, (%d, %f, %f, %f), (int)size, (float)readfreq, (float)writefreq, (float)priority)
    void *WINAPI rval = glatter_wglAllocateMemoryNV_ptr(size, readfreq, writefreq, priority);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_WGL(file, line);
    return rval;
}
void WINAPI glatter_wglFreeMemoryNV_debug(void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglFreeMemoryNV, (%p), (void*)pointer)
    void WINAPI rval = glatter_wglFreeMemoryNV_ptr(pointer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_vertex_array_range
#ifdef WGL_NV_video_capture
WINAPI glatter_wglBindVideoCaptureDeviceNV_debug(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindVideoCaptureDeviceNV, (%s, %s), GET_PRS(uVideoSlot), GET_PRS(hDevice))
    WINAPI rval = glatter_wglBindVideoCaptureDeviceNV_ptr(uVideoSlot, hDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglEnumerateVideoCaptureDevicesNV_debug(HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglEnumerateVideoCaptureDevicesNV, (%s, %p), GET_PRS(hDc), (void*)phDeviceList)
    WINAPI rval = glatter_wglEnumerateVideoCaptureDevicesNV_ptr(hDc, phDeviceList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglLockVideoCaptureDeviceNV_debug(HDC hDc, HVIDEOINPUTDEVICENV hDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglLockVideoCaptureDeviceNV, (%s, %s), GET_PRS(hDc), GET_PRS(hDevice))
    WINAPI rval = glatter_wglLockVideoCaptureDeviceNV_ptr(hDc, hDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglQueryVideoCaptureDeviceNV_debug(HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglQueryVideoCaptureDeviceNV, (%s, %s, %d, %p), GET_PRS(hDc), GET_PRS(hDevice), (int)iAttribute, (void*)piValue)
    WINAPI rval = glatter_wglQueryVideoCaptureDeviceNV_ptr(hDc, hDevice, iAttribute, piValue);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglReleaseVideoCaptureDeviceNV_debug(HDC hDc, HVIDEOINPUTDEVICENV hDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleaseVideoCaptureDeviceNV, (%s, %s), GET_PRS(hDc), GET_PRS(hDevice))
    WINAPI rval = glatter_wglReleaseVideoCaptureDeviceNV_ptr(hDc, hDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_video_capture
#ifdef WGL_NV_video_output
WINAPI glatter_wglBindVideoImageNV_debug(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglBindVideoImageNV, (%s, %s, %d), GET_PRS(hVideoDevice), GET_PRS(hPbuffer), (int)iVideoBuffer)
    WINAPI rval = glatter_wglBindVideoImageNV_ptr(hVideoDevice, hPbuffer, iVideoBuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetVideoDeviceNV_debug(HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetVideoDeviceNV, (%s, %d, %p), GET_PRS(hDC), (int)numDevices, (void*)hVideoDevice)
    WINAPI rval = glatter_wglGetVideoDeviceNV_ptr(hDC, numDevices, hVideoDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetVideoInfoNV_debug(HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetVideoInfoNV, (%s, %p, %p), GET_PRS(hpVideoDevice), (void*)pulCounterOutputPbuffer, (void*)pulCounterOutputVideo)
    WINAPI rval = glatter_wglGetVideoInfoNV_ptr(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglReleaseVideoDeviceNV_debug(HPVIDEODEV hVideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleaseVideoDeviceNV, (%s), GET_PRS(hVideoDevice))
    WINAPI rval = glatter_wglReleaseVideoDeviceNV_ptr(hVideoDevice);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglReleaseVideoImageNV_debug(HPBUFFERARB hPbuffer, int iVideoBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglReleaseVideoImageNV, (%s, %d), GET_PRS(hPbuffer), (int)iVideoBuffer)
    WINAPI rval = glatter_wglReleaseVideoImageNV_ptr(hPbuffer, iVideoBuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSendPbufferToVideoNV_debug(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSendPbufferToVideoNV, (%s, %d, %p, %s), GET_PRS(hPbuffer), (int)iBufferType, (void*)pulCounterPbuffer, GET_PRS(bBlock))
    WINAPI rval = glatter_wglSendPbufferToVideoNV_ptr(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_NV_video_output
#ifdef WGL_OML_sync_control
WINAPI glatter_wglGetMscRateOML_debug(HDC hdc, INT32 *numerator, INT32 *denominator, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetMscRateOML, (%s, %p, %p), GET_PRS(hdc), (void*)numerator, (void*)denominator)
    WINAPI rval = glatter_wglGetMscRateOML_ptr(hdc, numerator, denominator);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglGetSyncValuesOML_debug(HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglGetSyncValuesOML, (%s, %p, %p, %p), GET_PRS(hdc), (void*)ust, (void*)msc, (void*)sbc)
    WINAPI rval = glatter_wglGetSyncValuesOML_ptr(hdc, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSwapBuffersMscOML_debug(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSwapBuffersMscOML, (%s, %s, %s, %s), GET_PRS(hdc), GET_PRS(target_msc), GET_PRS(divisor), GET_PRS(remainder))
    WINAPI rval = glatter_wglSwapBuffersMscOML_ptr(hdc, target_msc, divisor, remainder);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglSwapLayerBuffersMscOML_debug(HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglSwapLayerBuffersMscOML, (%s, %d, %s, %s, %s), GET_PRS(hdc), (int)fuPlanes, GET_PRS(target_msc), GET_PRS(divisor), GET_PRS(remainder))
    WINAPI rval = glatter_wglSwapLayerBuffersMscOML_ptr(hdc, fuPlanes, target_msc, divisor, remainder);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglWaitForMscOML_debug(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglWaitForMscOML, (%s, %s, %s, %s, %p, %p, %p), GET_PRS(hdc), GET_PRS(target_msc), GET_PRS(divisor), GET_PRS(remainder), (void*)ust, (void*)msc, (void*)sbc)
    WINAPI rval = glatter_wglWaitForMscOML_ptr(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
WINAPI glatter_wglWaitForSbcOML_debug(HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, wglWaitForSbcOML, (%s, %s, %p, %p, %p), GET_PRS(hdc), GET_PRS(target_sbc), (void*)ust, (void*)msc, (void*)sbc)
    WINAPI rval = glatter_wglWaitForSbcOML_ptr(hdc, target_sbc, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_WGL(file, line);
    return rval;
}
#endif // WGL_OML_sync_control
#endif // __wglext_h_
#endif // GLATTER_WGL

#endif // NDEBUG



#ifdef GLATTER_GLX

#ifdef __glxext_h_
GLATTER_FBLOCK(return, GLX, , Bool, , glXGetMscRateOML, (dpy, drawable, numerator, denominator), (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator))
GLATTER_FBLOCK(return, GLX, , Bool, , glXGetSyncValuesOML, (dpy, drawable, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc))
GLATTER_FBLOCK(return, GLX, , int64_t, , glXSwapBuffersMscOML, (dpy, drawable, target_msc, divisor, remainder), (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder))
GLATTER_FBLOCK(return, GLX, , Bool, , glXWaitForMscOML, (dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc))
GLATTER_FBLOCK(return, GLX, , Bool, , glXWaitForSbcOML, (dpy, drawable, target_sbc, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc))
#ifdef GLX_AMD_gpu_association
GLATTER_FBLOCK(, GLX, , void, , glXBlitContextFramebufferAMD, (dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateAssociatedContextAMD, (id, share_list), (unsigned int id, GLXContext share_list))
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateAssociatedContextAttribsAMD, (id, share_context, attribList), (unsigned int id, GLXContext share_context, const int *attribList))
GLATTER_FBLOCK(return, GLX, , Bool, , glXDeleteAssociatedContextAMD, (ctx), (GLXContext ctx))
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetContextGPUIDAMD, (ctx), (GLXContext ctx))
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXGetCurrentAssociatedContextAMD, (), ())
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetGPUIDsAMD, (maxCount, ids), (unsigned int maxCount, unsigned int *ids))
GLATTER_FBLOCK(return, GLX, , int, , glXGetGPUInfoAMD, (id, property, dataType, size, data), (unsigned int id, int property, GLenum dataType, unsigned int size, void *data))
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeAssociatedContextCurrentAMD, (ctx), (GLXContext ctx))
#endif // GLX_AMD_gpu_association
#ifdef GLX_ARB_create_context
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateContextAttribsARB, (dpy, config, share_context, direct, attrib_list), (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list))
#endif // GLX_ARB_create_context
#ifdef GLX_ARB_get_proc_address
GLATTER_FBLOCK(return, GLX, , __GLXextFuncPtr, , glXGetProcAddressARB, (procName), (const GLubyte *procName))
#endif // GLX_ARB_get_proc_address
#ifdef GLX_EXT_import_context
GLATTER_FBLOCK(, GLX, , void, , glXFreeContextEXT, (dpy, context), (Display *dpy, GLXContext context))
GLATTER_FBLOCK(return, GLX, , GLXContextID, , glXGetContextIDEXT, (context), (const GLXContext context))
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXImportContextEXT, (dpy, contextID), (Display *dpy, GLXContextID contextID))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryContextInfoEXT, (dpy, context, attribute, value), (Display *dpy, GLXContext context, int attribute, int *value))
#endif // GLX_EXT_import_context
#ifdef GLX_EXT_swap_control
GLATTER_FBLOCK(, GLX, , void, , glXSwapIntervalEXT, (dpy, drawable, interval), (Display *dpy, GLXDrawable drawable, int interval))
#endif // GLX_EXT_swap_control
#ifdef GLX_EXT_texture_from_pixmap
GLATTER_FBLOCK(, GLX, , void, , glXBindTexImageEXT, (dpy, drawable, buffer, attrib_list), (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list))
GLATTER_FBLOCK(, GLX, , void, , glXReleaseTexImageEXT, (dpy, drawable, buffer), (Display *dpy, GLXDrawable drawable, int buffer))
#endif // GLX_EXT_texture_from_pixmap
#ifdef GLX_MESA_agp_offset
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetAGPOffsetMESA, (pointer), (const void *pointer))
#endif // GLX_MESA_agp_offset
#ifdef GLX_MESA_copy_sub_buffer
GLATTER_FBLOCK(, GLX, , void, , glXCopySubBufferMESA, (dpy, drawable, x, y, width, height), (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height))
#endif // GLX_MESA_copy_sub_buffer
#ifdef GLX_MESA_pixmap_colormap
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreateGLXPixmapMESA, (dpy, visual, pixmap, cmap), (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap))
#endif // GLX_MESA_pixmap_colormap
#ifdef GLX_MESA_query_renderer
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryCurrentRendererIntegerMESA, (attribute, value), (int attribute, unsigned int *value))
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryRendererIntegerMESA, (dpy, screen, renderer, attribute, value), (Display *dpy, int screen, int renderer, int attribute, unsigned int *value))
#endif // GLX_MESA_query_renderer
#ifdef GLX_MESA_release_buffers
GLATTER_FBLOCK(return, GLX, , Bool, , glXReleaseBuffersMESA, (dpy, drawable), (Display *dpy, GLXDrawable drawable))
#endif // GLX_MESA_release_buffers
#ifdef GLX_MESA_set_3dfx_mode
GLATTER_FBLOCK(return, GLX, , Bool, , glXSet3DfxModeMESA, (mode), (int mode))
#endif // GLX_MESA_set_3dfx_mode
#ifdef GLX_NV_copy_buffer
GLATTER_FBLOCK(, GLX, , void, , glXCopyBufferSubDataNV, (dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size), (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_FBLOCK(, GLX, , void, , glXNamedCopyBufferSubDataNV, (dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size), (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
#endif // GLX_NV_copy_buffer
#ifdef GLX_NV_copy_image
GLATTER_FBLOCK(, GLX, , void, , glXCopyImageSubDataNV, (dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
#endif // GLX_NV_copy_image
#ifdef GLX_NV_delay_before_swap
GLATTER_FBLOCK(return, GLX, , Bool, , glXDelayBeforeSwapNV, (dpy, drawable, seconds), (Display *dpy, GLXDrawable drawable, GLfloat seconds))
#endif // GLX_NV_delay_before_swap
#ifdef GLX_NV_present_video
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoDeviceNV, (dpy, video_slot, video_device, attrib_list), (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list))
#endif // GLX_NV_present_video
#ifdef GLX_NV_swap_group
GLATTER_FBLOCK(return, GLX, , Bool, , glXBindSwapBarrierNV, (dpy, group, barrier), (Display *dpy, GLuint group, GLuint barrier))
GLATTER_FBLOCK(return, GLX, , Bool, , glXJoinSwapGroupNV, (dpy, drawable, group), (Display *dpy, GLXDrawable drawable, GLuint group))
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryFrameCountNV, (dpy, screen, count), (Display *dpy, int screen, GLuint *count))
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryMaxSwapGroupsNV, (dpy, screen, maxGroups, maxBarriers), (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers))
GLATTER_FBLOCK(return, GLX, , Bool, , glXQuerySwapGroupNV, (dpy, drawable, group, barrier), (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier))
GLATTER_FBLOCK(return, GLX, , Bool, , glXResetFrameCountNV, (dpy, screen), (Display *dpy, int screen))
#endif // GLX_NV_swap_group
#ifdef GLX_NV_video_capture
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoCaptureDeviceNV, (dpy, video_capture_slot, device), (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device))
GLATTER_FBLOCK(, GLX, , void, , glXLockVideoCaptureDeviceNV, (dpy, device), (Display *dpy, GLXVideoCaptureDeviceNV device))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryVideoCaptureDeviceNV, (dpy, device, attribute, value), (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value))
GLATTER_FBLOCK(, GLX, , void, , glXReleaseVideoCaptureDeviceNV, (dpy, device), (Display *dpy, GLXVideoCaptureDeviceNV device))
#endif // GLX_NV_video_capture
#ifdef GLX_NV_video_out
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoImageNV, (dpy, VideoDevice, pbuf, iVideoBuffer), (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer))
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoDeviceNV, (dpy, screen, numVideoDevices, pVideoDevice), (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice))
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoInfoNV, (dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo), (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo))
GLATTER_FBLOCK(return, GLX, , int, , glXReleaseVideoDeviceNV, (dpy, screen, VideoDevice), (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice))
GLATTER_FBLOCK(return, GLX, , int, , glXReleaseVideoImageNV, (dpy, pbuf), (Display *dpy, GLXPbuffer pbuf))
GLATTER_FBLOCK(return, GLX, , int, , glXSendPbufferToVideoNV, (dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock), (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock))
#endif // GLX_NV_video_out
#ifdef GLX_SGIX_dmbuffer
GLATTER_FBLOCK(return, GLX, , Bool, , glXAssociateDMPbufferSGIX, (dpy, pbuffer, params, dmbuffer), (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer))
#endif // GLX_SGIX_dmbuffer
#ifdef GLX_SGIX_fbconfig
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateContextWithConfigSGIX, (dpy, config, render_type, share_list, direct), (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct))
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreateGLXPixmapWithConfigSGIX, (dpy, config, pixmap), (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap))
GLATTER_FBLOCK(return, GLX, , int, , glXGetFBConfigAttribSGIX, (dpy, config, attribute, value), (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value))
GLATTER_FBLOCK(return, GLX, , GLXFBConfigSGIX, , glXGetFBConfigFromVisualSGIX, (dpy, vis), (Display *dpy, XVisualInfo *vis))
#endif // GLX_SGIX_fbconfig
#ifdef GLX_SGIX_hyperpipe
GLATTER_FBLOCK(return, GLX, , int, , glXBindHyperpipeSGIX, (dpy, hpId), (Display *dpy, int hpId))
GLATTER_FBLOCK(return, GLX, , int, , glXDestroyHyperpipeConfigSGIX, (dpy, hpId), (Display *dpy, int hpId))
GLATTER_FBLOCK(return, GLX, , int, , glXHyperpipeAttribSGIX, (dpy, timeSlice, attrib, size, attribList), (Display *dpy, int timeSlice, int attrib, int size, void *attribList))
GLATTER_FBLOCK(return, GLX, , int, , glXHyperpipeConfigSGIX, (dpy, networkId, npipes, cfg, hpId), (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryHyperpipeAttribSGIX, (dpy, timeSlice, attrib, size, returnAttribList), (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryHyperpipeBestAttribSGIX, (dpy, timeSlice, attrib, size, attribList, returnAttribList), (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList))
#endif // GLX_SGIX_hyperpipe
#ifdef GLX_SGIX_pbuffer
GLATTER_FBLOCK(return, GLX, , GLXPbufferSGIX, , glXCreateGLXPbufferSGIX, (dpy, config, width, height, attrib_list), (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list))
GLATTER_FBLOCK(, GLX, , void, , glXDestroyGLXPbufferSGIX, (dpy, pbuf), (Display *dpy, GLXPbufferSGIX pbuf))
GLATTER_FBLOCK(, GLX, , void, , glXGetSelectedEventSGIX, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long *mask))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryGLXPbufferSGIX, (dpy, pbuf, attribute, value), (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value))
GLATTER_FBLOCK(, GLX, , void, , glXSelectEventSGIX, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long mask))
#endif // GLX_SGIX_pbuffer
#ifdef GLX_SGIX_swap_barrier
GLATTER_FBLOCK(, GLX, , void, , glXBindSwapBarrierSGIX, (dpy, drawable, barrier), (Display *dpy, GLXDrawable drawable, int barrier))
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryMaxSwapBarriersSGIX, (dpy, screen, max), (Display *dpy, int screen, int *max))
#endif // GLX_SGIX_swap_barrier
#ifdef GLX_SGIX_swap_group
GLATTER_FBLOCK(, GLX, , void, , glXJoinSwapGroupSGIX, (dpy, drawable, member), (Display *dpy, GLXDrawable drawable, GLXDrawable member))
#endif // GLX_SGIX_swap_group
#ifdef GLX_SGIX_video_resize
GLATTER_FBLOCK(return, GLX, , int, , glXBindChannelToWindowSGIX, (display, screen, channel, window), (Display *display, int screen, int channel, Window window))
GLATTER_FBLOCK(return, GLX, , int, , glXChannelRectSGIX, (display, screen, channel, x, y, w, h), (Display *display, int screen, int channel, int x, int y, int w, int h))
GLATTER_FBLOCK(return, GLX, , int, , glXChannelRectSyncSGIX, (display, screen, channel, synctype), (Display *display, int screen, int channel, GLenum synctype))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryChannelDeltasSGIX, (display, screen, channel, x, y, w, h), (Display *display, int screen, int channel, int *x, int *y, int *w, int *h))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryChannelRectSGIX, (display, screen, channel, dx, dy, dw, dh), (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh))
#endif // GLX_SGIX_video_resize
#ifdef GLX_SGIX_video_source
GLATTER_FBLOCK(return, GLX, , GLXVideoSourceSGIX, , glXCreateGLXVideoSourceSGIX, (display, screen, server, path, nodeClass, drainNode), (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode))
GLATTER_FBLOCK(, GLX, , void, , glXDestroyGLXVideoSourceSGIX, (dpy, glxvideosource), (Display *dpy, GLXVideoSourceSGIX glxvideosource))
#endif // GLX_SGIX_video_source
#ifdef GLX_SGI_cushion
GLATTER_FBLOCK(, GLX, , void, , glXCushionSGI, (dpy, window, cushion), (Display *dpy, Window window, float cushion))
#endif // GLX_SGI_cushion
#ifdef GLX_SGI_make_current_read
GLATTER_FBLOCK(return, GLX, , GLXDrawable, , glXGetCurrentReadDrawableSGI, (), ())
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeCurrentReadSGI, (dpy, draw, read, ctx), (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx))
#endif // GLX_SGI_make_current_read
#ifdef GLX_SGI_swap_control
GLATTER_FBLOCK(return, GLX, , int, , glXSwapIntervalSGI, (interval), (int interval))
#endif // GLX_SGI_swap_control
#ifdef GLX_SGI_video_sync
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoSyncSGI, (count), (unsigned int *count))
GLATTER_FBLOCK(return, GLX, , int, , glXWaitVideoSyncSGI, (divisor, remainder, count), (int divisor, int remainder, unsigned int *count))
#endif // GLX_SGI_video_sync
#ifdef GLX_SUN_get_transparent_index
GLATTER_FBLOCK(return, GLX, , Status, , glXGetTransparentIndexSUN, (dpy, overlay, underlay, pTransparentIndex), (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex))
#endif // GLX_SUN_get_transparent_index
#ifdef GLX_VERSION_1_3
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateNewContext, (dpy, config, render_type, share_list, direct), (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct))
GLATTER_FBLOCK(return, GLX, , GLXPbuffer, , glXCreatePbuffer, (dpy, config, attrib_list), (Display *dpy, GLXFBConfig config, const int *attrib_list))
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreatePixmap, (dpy, config, pixmap, attrib_list), (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list))
GLATTER_FBLOCK(return, GLX, , GLXWindow, , glXCreateWindow, (dpy, config, win, attrib_list), (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list))
GLATTER_FBLOCK(, GLX, , void, , glXDestroyPbuffer, (dpy, pbuf), (Display *dpy, GLXPbuffer pbuf))
GLATTER_FBLOCK(, GLX, , void, , glXDestroyPixmap, (dpy, pixmap), (Display *dpy, GLXPixmap pixmap))
GLATTER_FBLOCK(, GLX, , void, , glXDestroyWindow, (dpy, win), (Display *dpy, GLXWindow win))
GLATTER_FBLOCK(return, GLX, , GLXDrawable, , glXGetCurrentReadDrawable, (), ())
GLATTER_FBLOCK(return, GLX, , int, , glXGetFBConfigAttrib, (dpy, config, attribute, value), (Display *dpy, GLXFBConfig config, int attribute, int *value))
GLATTER_FBLOCK(, GLX, , void, , glXGetSelectedEvent, (dpy, draw, event_mask), (Display *dpy, GLXDrawable draw, unsigned long *event_mask))
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeContextCurrent, (dpy, draw, read, ctx), (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx))
GLATTER_FBLOCK(return, GLX, , int, , glXQueryContext, (dpy, ctx, attribute, value), (Display *dpy, GLXContext ctx, int attribute, int *value))
GLATTER_FBLOCK(, GLX, , void, , glXQueryDrawable, (dpy, draw, attribute, value), (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value))
GLATTER_FBLOCK(, GLX, , void, , glXSelectEvent, (dpy, draw, event_mask), (Display *dpy, GLXDrawable draw, unsigned long event_mask))
#endif // GLX_VERSION_1_3
#ifdef GLX_VERSION_1_4
GLATTER_FBLOCK(return, GLX, , __GLXextFuncPtr, , glXGetProcAddress, (procName), (const GLubyte *procName))
#endif // GLX_VERSION_1_4
#endif // __glxext_h_
#endif // GLATTER_GLX

#ifndef NDEBUG

#ifdef GLATTER_GLX

#ifdef __glxext_h_
Bool glatter_glXGetMscRateOML_debug(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetMscRateOML, (%p, %s, %p, %p), (void*)dpy, GET_PRS(drawable), (void*)numerator, (void*)denominator)
    Bool rval = glatter_glXGetMscRateOML_ptr(dpy, drawable, numerator, denominator);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXGetSyncValuesOML_debug(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSyncValuesOML, (%p, %s, %p, %p, %p), (void*)dpy, GET_PRS(drawable), (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXGetSyncValuesOML_ptr(dpy, drawable, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
int64_t glatter_glXSwapBuffersMscOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapBuffersMscOML, (%p, %s, %s, %s, %s), (void*)dpy, GET_PRS(drawable), GET_PRS(target_msc), GET_PRS(divisor), GET_PRS(remainder))
    int64_t rval = glatter_glXSwapBuffersMscOML_ptr(dpy, drawable, target_msc, divisor, remainder);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXWaitForMscOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitForMscOML, (%p, %s, %s, %s, %s, %p, %p, %p), (void*)dpy, GET_PRS(drawable), GET_PRS(target_msc), GET_PRS(divisor), GET_PRS(remainder), (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXWaitForMscOML_ptr(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXWaitForSbcOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitForSbcOML, (%p, %s, %s, %p, %p, %p), (void*)dpy, GET_PRS(drawable), GET_PRS(target_sbc), (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXWaitForSbcOML_ptr(dpy, drawable, target_sbc, ust, msc, sbc);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#ifdef GLX_AMD_gpu_association
void glatter_glXBlitContextFramebufferAMD_debug(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBlitContextFramebufferAMD, (%s, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s), GET_PRS(dstCtx), (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glXBlitContextFramebufferAMD_ptr(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    glatter_check_error_GLX(file, line);
}
GLXContext glatter_glXCreateAssociatedContextAMD_debug(unsigned int id, GLXContext share_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateAssociatedContextAMD, (%u, %s), (unsigned int)id, GET_PRS(share_list))
    GLXContext rval = glatter_glXCreateAssociatedContextAMD_ptr(id, share_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXContext glatter_glXCreateAssociatedContextAttribsAMD_debug(unsigned int id, GLXContext share_context, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateAssociatedContextAttribsAMD, (%u, %s, %p), (unsigned int)id, GET_PRS(share_context), (void*)attribList)
    GLXContext rval = glatter_glXCreateAssociatedContextAttribsAMD_ptr(id, share_context, attribList);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXDeleteAssociatedContextAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDeleteAssociatedContextAMD, (%s), GET_PRS(ctx))
    Bool rval = glatter_glXDeleteAssociatedContextAMD_ptr(ctx);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
unsigned int glatter_glXGetContextGPUIDAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetContextGPUIDAMD, (%s), GET_PRS(ctx))
    unsigned int rval = glatter_glXGetContextGPUIDAMD_ptr(ctx);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXContext glatter_glXGetCurrentAssociatedContextAMD_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentAssociatedContextAMD, ())
    GLXContext rval = glatter_glXGetCurrentAssociatedContextAMD_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
unsigned int glatter_glXGetGPUIDsAMD_debug(unsigned int maxCount, unsigned int *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetGPUIDsAMD, (%u, %p), (unsigned int)maxCount, (void*)ids)
    unsigned int rval = glatter_glXGetGPUIDsAMD_ptr(maxCount, ids);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXGetGPUInfoAMD_debug(unsigned int id, int property, GLenum dataType, unsigned int size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetGPUInfoAMD, (%u, %d, %s, %u, %p), (unsigned int)id, (int)property, enum_to_string_GL(dataType), (unsigned int)size, (void*)data)
    int rval = glatter_glXGetGPUInfoAMD_ptr(id, property, dataType, size, data);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXMakeAssociatedContextCurrentAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeAssociatedContextCurrentAMD, (%s), GET_PRS(ctx))
    Bool rval = glatter_glXMakeAssociatedContextCurrentAMD_ptr(ctx);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_AMD_gpu_association
#ifdef GLX_ARB_create_context
GLXContext glatter_glXCreateContextAttribsARB_debug(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateContextAttribsARB, (%p, %p, %s, %s, %p), (void*)dpy, (void*)config, GET_PRS(share_context), GET_PRS(direct), (void*)attrib_list)
    GLXContext rval = glatter_glXCreateContextAttribsARB_ptr(dpy, config, share_context, direct, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_ARB_create_context
#ifdef GLX_ARB_get_proc_address
__GLXextFuncPtr glatter_glXGetProcAddressARB_debug(const GLubyte *procName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetProcAddressARB, (%p), (void*)procName)
    __GLXextFuncPtr rval = glatter_glXGetProcAddressARB_ptr(procName);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_ARB_get_proc_address
#ifdef GLX_EXT_import_context
void glatter_glXFreeContextEXT_debug(Display *dpy, GLXContext context, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXFreeContextEXT, (%p, %s), (void*)dpy, GET_PRS(context))
    glatter_glXFreeContextEXT_ptr(dpy, context);
    glatter_check_error_GLX(file, line);
}
GLXContextID glatter_glXGetContextIDEXT_debug(const GLXContext context, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetContextIDEXT, (%s), GET_PRS(context))
    GLXContextID rval = glatter_glXGetContextIDEXT_ptr(context);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXContext glatter_glXImportContextEXT_debug(Display *dpy, GLXContextID contextID, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXImportContextEXT, (%p, %s), (void*)dpy, GET_PRS(contextID))
    GLXContext rval = glatter_glXImportContextEXT_ptr(dpy, contextID);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryContextInfoEXT_debug(Display *dpy, GLXContext context, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryContextInfoEXT, (%p, %s, %d, %p), (void*)dpy, GET_PRS(context), (int)attribute, (void*)value)
    int rval = glatter_glXQueryContextInfoEXT_ptr(dpy, context, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_EXT_import_context
#ifdef GLX_EXT_swap_control
void glatter_glXSwapIntervalEXT_debug(Display *dpy, GLXDrawable drawable, int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalEXT, (%p, %s, %d), (void*)dpy, GET_PRS(drawable), (int)interval)
    glatter_glXSwapIntervalEXT_ptr(dpy, drawable, interval);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_EXT_swap_control
#ifdef GLX_EXT_texture_from_pixmap
void glatter_glXBindTexImageEXT_debug(Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindTexImageEXT, (%p, %s, %d, %p), (void*)dpy, GET_PRS(drawable), (int)buffer, (void*)attrib_list)
    glatter_glXBindTexImageEXT_ptr(dpy, drawable, buffer, attrib_list);
    glatter_check_error_GLX(file, line);
}
void glatter_glXReleaseTexImageEXT_debug(Display *dpy, GLXDrawable drawable, int buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseTexImageEXT, (%p, %s, %d), (void*)dpy, GET_PRS(drawable), (int)buffer)
    glatter_glXReleaseTexImageEXT_ptr(dpy, drawable, buffer);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_EXT_texture_from_pixmap
#ifdef GLX_MESA_agp_offset
unsigned int glatter_glXGetAGPOffsetMESA_debug(const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetAGPOffsetMESA, (%p), (void*)pointer)
    unsigned int rval = glatter_glXGetAGPOffsetMESA_ptr(pointer);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_MESA_agp_offset
#ifdef GLX_MESA_copy_sub_buffer
void glatter_glXCopySubBufferMESA_debug(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopySubBufferMESA, (%p, %s, %d, %d, %d, %d), (void*)dpy, GET_PRS(drawable), (int)x, (int)y, (int)width, (int)height)
    glatter_glXCopySubBufferMESA_ptr(dpy, drawable, x, y, width, height);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_MESA_copy_sub_buffer
#ifdef GLX_MESA_pixmap_colormap
GLXPixmap glatter_glXCreateGLXPixmapMESA_debug(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPixmapMESA, (%p, %p, %s, %s), (void*)dpy, (void*)visual, GET_PRS(pixmap), GET_PRS(cmap))
    GLXPixmap rval = glatter_glXCreateGLXPixmapMESA_ptr(dpy, visual, pixmap, cmap);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_MESA_pixmap_colormap
#ifdef GLX_MESA_query_renderer
Bool glatter_glXQueryCurrentRendererIntegerMESA_debug(int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryCurrentRendererIntegerMESA, (%d, %p), (int)attribute, (void*)value)
    Bool rval = glatter_glXQueryCurrentRendererIntegerMESA_ptr(attribute, value);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXQueryRendererIntegerMESA_debug(Display *dpy, int screen, int renderer, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryRendererIntegerMESA, (%p, %d, %d, %d, %p), (void*)dpy, (int)screen, (int)renderer, (int)attribute, (void*)value)
    Bool rval = glatter_glXQueryRendererIntegerMESA_ptr(dpy, screen, renderer, attribute, value);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_MESA_query_renderer
#ifdef GLX_MESA_release_buffers
Bool glatter_glXReleaseBuffersMESA_debug(Display *dpy, GLXDrawable drawable, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseBuffersMESA, (%p, %s), (void*)dpy, GET_PRS(drawable))
    Bool rval = glatter_glXReleaseBuffersMESA_ptr(dpy, drawable);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_MESA_release_buffers
#ifdef GLX_MESA_set_3dfx_mode
Bool glatter_glXSet3DfxModeMESA_debug(int mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSet3DfxModeMESA, (%d), (int)mode)
    Bool rval = glatter_glXSet3DfxModeMESA_ptr(mode);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_MESA_set_3dfx_mode
#ifdef GLX_NV_copy_buffer
void glatter_glXCopyBufferSubDataNV_debug(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopyBufferSubDataNV, (%p, %s, %s, %s, %s, %td, %td, %td), (void*)dpy, GET_PRS(readCtx), GET_PRS(writeCtx), enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glXCopyBufferSubDataNV_ptr(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    glatter_check_error_GLX(file, line);
}
void glatter_glXNamedCopyBufferSubDataNV_debug(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXNamedCopyBufferSubDataNV, (%p, %s, %s, %u, %u, %td, %td, %td), (void*)dpy, GET_PRS(readCtx), GET_PRS(writeCtx), (unsigned int)readBuffer, (unsigned int)writeBuffer, (ptrdiff_t)readOffset, (ptrdiff_t)writeOffset, (ptrdiff_t)size)
    glatter_glXNamedCopyBufferSubDataNV_ptr(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_NV_copy_buffer
#ifdef GLX_NV_copy_image
void glatter_glXCopyImageSubDataNV_debug(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopyImageSubDataNV, (%p, %s, %u, %s, %d, %d, %d, %d, %s, %u, %s, %d, %d, %d, %d, %d, %d, %d), (void*)dpy, GET_PRS(srcCtx), (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, GET_PRS(dstCtx), (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    glatter_glXCopyImageSubDataNV_ptr(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_NV_copy_image
#ifdef GLX_NV_delay_before_swap
Bool glatter_glXDelayBeforeSwapNV_debug(Display *dpy, GLXDrawable drawable, GLfloat seconds, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDelayBeforeSwapNV, (%p, %s, %f), (void*)dpy, GET_PRS(drawable), (float)seconds)
    Bool rval = glatter_glXDelayBeforeSwapNV_ptr(dpy, drawable, seconds);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_NV_delay_before_swap
#ifdef GLX_NV_present_video
int glatter_glXBindVideoDeviceNV_debug(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoDeviceNV, (%p, %u, %u, %p), (void*)dpy, (unsigned int)video_slot, (unsigned int)video_device, (void*)attrib_list)
    int rval = glatter_glXBindVideoDeviceNV_ptr(dpy, video_slot, video_device, attrib_list);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_NV_present_video
#ifdef GLX_NV_swap_group
Bool glatter_glXBindSwapBarrierNV_debug(Display *dpy, GLuint group, GLuint barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindSwapBarrierNV, (%p, %u, %u), (void*)dpy, (unsigned int)group, (unsigned int)barrier)
    Bool rval = glatter_glXBindSwapBarrierNV_ptr(dpy, group, barrier);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXJoinSwapGroupNV_debug(Display *dpy, GLXDrawable drawable, GLuint group, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXJoinSwapGroupNV, (%p, %s, %u), (void*)dpy, GET_PRS(drawable), (unsigned int)group)
    Bool rval = glatter_glXJoinSwapGroupNV_ptr(dpy, drawable, group);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXQueryFrameCountNV_debug(Display *dpy, int screen, GLuint *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryFrameCountNV, (%p, %d, %p), (void*)dpy, (int)screen, (void*)count)
    Bool rval = glatter_glXQueryFrameCountNV_ptr(dpy, screen, count);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXQueryMaxSwapGroupsNV_debug(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryMaxSwapGroupsNV, (%p, %d, %p, %p), (void*)dpy, (int)screen, (void*)maxGroups, (void*)maxBarriers)
    Bool rval = glatter_glXQueryMaxSwapGroupsNV_ptr(dpy, screen, maxGroups, maxBarriers);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXQuerySwapGroupNV_debug(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQuerySwapGroupNV, (%p, %s, %p, %p), (void*)dpy, GET_PRS(drawable), (void*)group, (void*)barrier)
    Bool rval = glatter_glXQuerySwapGroupNV_ptr(dpy, drawable, group, barrier);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXResetFrameCountNV_debug(Display *dpy, int screen, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXResetFrameCountNV, (%p, %d), (void*)dpy, (int)screen)
    Bool rval = glatter_glXResetFrameCountNV_ptr(dpy, screen);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_NV_swap_group
#ifdef GLX_NV_video_capture
int glatter_glXBindVideoCaptureDeviceNV_debug(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoCaptureDeviceNV, (%p, %u, %s), (void*)dpy, (unsigned int)video_capture_slot, GET_PRS(device))
    int rval = glatter_glXBindVideoCaptureDeviceNV_ptr(dpy, video_capture_slot, device);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXLockVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXLockVideoCaptureDeviceNV, (%p, %s), (void*)dpy, GET_PRS(device))
    glatter_glXLockVideoCaptureDeviceNV_ptr(dpy, device);
    glatter_check_error_GLX(file, line);
}
int glatter_glXQueryVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryVideoCaptureDeviceNV, (%p, %s, %d, %p), (void*)dpy, GET_PRS(device), (int)attribute, (void*)value)
    int rval = glatter_glXQueryVideoCaptureDeviceNV_ptr(dpy, device, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXReleaseVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoCaptureDeviceNV, (%p, %s), (void*)dpy, GET_PRS(device))
    glatter_glXReleaseVideoCaptureDeviceNV_ptr(dpy, device);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_NV_video_capture
#ifdef GLX_NV_video_out
int glatter_glXBindVideoImageNV_debug(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoImageNV, (%p, %u, %s, %d), (void*)dpy, (unsigned int)VideoDevice, GET_PRS(pbuf), (int)iVideoBuffer)
    int rval = glatter_glXBindVideoImageNV_ptr(dpy, VideoDevice, pbuf, iVideoBuffer);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXGetVideoDeviceNV_debug(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoDeviceNV, (%p, %d, %d, %p), (void*)dpy, (int)screen, (int)numVideoDevices, (void*)pVideoDevice)
    int rval = glatter_glXGetVideoDeviceNV_ptr(dpy, screen, numVideoDevices, pVideoDevice);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXGetVideoInfoNV_debug(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoInfoNV, (%p, %d, %u, %p, %p), (void*)dpy, (int)screen, (unsigned int)VideoDevice, (void*)pulCounterOutputPbuffer, (void*)pulCounterOutputVideo)
    int rval = glatter_glXGetVideoInfoNV_ptr(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXReleaseVideoDeviceNV_debug(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoDeviceNV, (%p, %d, %u), (void*)dpy, (int)screen, (unsigned int)VideoDevice)
    int rval = glatter_glXReleaseVideoDeviceNV_ptr(dpy, screen, VideoDevice);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXReleaseVideoImageNV_debug(Display *dpy, GLXPbuffer pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoImageNV, (%p, %s), (void*)dpy, GET_PRS(pbuf))
    int rval = glatter_glXReleaseVideoImageNV_ptr(dpy, pbuf);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXSendPbufferToVideoNV_debug(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSendPbufferToVideoNV, (%p, %s, %d, %p, %u), (void*)dpy, GET_PRS(pbuf), (int)iBufferType, (void*)pulCounterPbuffer, (unsigned char)bBlock)
    int rval = glatter_glXSendPbufferToVideoNV_ptr(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_NV_video_out
#ifdef GLX_SGIX_dmbuffer
Bool glatter_glXAssociateDMPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXAssociateDMPbufferSGIX, (%p, %s, %p, %s), (void*)dpy, GET_PRS(pbuffer), (void*)params, GET_PRS(dmbuffer))
    Bool rval = glatter_glXAssociateDMPbufferSGIX_ptr(dpy, pbuffer, params, dmbuffer);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGIX_dmbuffer
#ifdef GLX_SGIX_fbconfig
GLXContext glatter_glXCreateContextWithConfigSGIX_debug(Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateContextWithConfigSGIX, (%p, %p, %d, %s, %s), (void*)dpy, (void*)config, (int)render_type, GET_PRS(share_list), GET_PRS(direct))
    GLXContext rval = glatter_glXCreateContextWithConfigSGIX_ptr(dpy, config, render_type, share_list, direct);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXPixmap glatter_glXCreateGLXPixmapWithConfigSGIX_debug(Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPixmapWithConfigSGIX, (%p, %p, %s), (void*)dpy, (void*)config, GET_PRS(pixmap))
    GLXPixmap rval = glatter_glXCreateGLXPixmapWithConfigSGIX_ptr(dpy, config, pixmap);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXGetFBConfigAttribSGIX_debug(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigAttribSGIX, (%p, %p, %d, %p), (void*)dpy, (void*)config, (int)attribute, (void*)value)
    int rval = glatter_glXGetFBConfigAttribSGIX_ptr(dpy, config, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXFBConfigSGIX glatter_glXGetFBConfigFromVisualSGIX_debug(Display *dpy, XVisualInfo *vis, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigFromVisualSGIX, (%p, %p), (void*)dpy, (void*)vis)
    GLXFBConfigSGIX rval = glatter_glXGetFBConfigFromVisualSGIX_ptr(dpy, vis);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGIX_fbconfig
#ifdef GLX_SGIX_hyperpipe
int glatter_glXBindHyperpipeSGIX_debug(Display *dpy, int hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindHyperpipeSGIX, (%p, %d), (void*)dpy, (int)hpId)
    int rval = glatter_glXBindHyperpipeSGIX_ptr(dpy, hpId);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXDestroyHyperpipeConfigSGIX_debug(Display *dpy, int hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyHyperpipeConfigSGIX, (%p, %d), (void*)dpy, (int)hpId)
    int rval = glatter_glXDestroyHyperpipeConfigSGIX_ptr(dpy, hpId);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXHyperpipeAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXHyperpipeAttribSGIX, (%p, %d, %d, %d, %p), (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)attribList)
    int rval = glatter_glXHyperpipeAttribSGIX_ptr(dpy, timeSlice, attrib, size, attribList);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXHyperpipeConfigSGIX_debug(Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXHyperpipeConfigSGIX, (%p, %d, %d, %p, %p), (void*)dpy, (int)networkId, (int)npipes, (void*)cfg, (void*)hpId)
    int rval = glatter_glXHyperpipeConfigSGIX_ptr(dpy, networkId, npipes, cfg, hpId);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryHyperpipeAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeAttribSGIX, (%p, %d, %d, %d, %p), (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)returnAttribList)
    int rval = glatter_glXQueryHyperpipeAttribSGIX_ptr(dpy, timeSlice, attrib, size, returnAttribList);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryHyperpipeBestAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeBestAttribSGIX, (%p, %d, %d, %d, %p, %p), (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)attribList, (void*)returnAttribList)
    int rval = glatter_glXQueryHyperpipeBestAttribSGIX_ptr(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGIX_hyperpipe
#ifdef GLX_SGIX_pbuffer
GLXPbufferSGIX glatter_glXCreateGLXPbufferSGIX_debug(Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPbufferSGIX, (%p, %p, %u, %u, %p), (void*)dpy, (void*)config, (unsigned int)width, (unsigned int)height, (void*)attrib_list)
    GLXPbufferSGIX rval = glatter_glXCreateGLXPbufferSGIX_ptr(dpy, config, width, height, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXDestroyGLXPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyGLXPbufferSGIX, (%p, %s), (void*)dpy, GET_PRS(pbuf))
    glatter_glXDestroyGLXPbufferSGIX_ptr(dpy, pbuf);
    glatter_check_error_GLX(file, line);
}
void glatter_glXGetSelectedEventSGIX_debug(Display *dpy, GLXDrawable drawable, unsigned long *mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSelectedEventSGIX, (%p, %s, %p), (void*)dpy, GET_PRS(drawable), (void*)mask)
    glatter_glXGetSelectedEventSGIX_ptr(dpy, drawable, mask);
    glatter_check_error_GLX(file, line);
}
int glatter_glXQueryGLXPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryGLXPbufferSGIX, (%p, %s, %d, %p), (void*)dpy, GET_PRS(pbuf), (int)attribute, (void*)value)
    int rval = glatter_glXQueryGLXPbufferSGIX_ptr(dpy, pbuf, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXSelectEventSGIX_debug(Display *dpy, GLXDrawable drawable, unsigned long mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSelectEventSGIX, (%p, %s, %lu), (void*)dpy, GET_PRS(drawable), (unsigned long)mask)
    glatter_glXSelectEventSGIX_ptr(dpy, drawable, mask);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_SGIX_pbuffer
#ifdef GLX_SGIX_swap_barrier
void glatter_glXBindSwapBarrierSGIX_debug(Display *dpy, GLXDrawable drawable, int barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindSwapBarrierSGIX, (%p, %s, %d), (void*)dpy, GET_PRS(drawable), (int)barrier)
    glatter_glXBindSwapBarrierSGIX_ptr(dpy, drawable, barrier);
    glatter_check_error_GLX(file, line);
}
Bool glatter_glXQueryMaxSwapBarriersSGIX_debug(Display *dpy, int screen, int *max, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryMaxSwapBarriersSGIX, (%p, %d, %p), (void*)dpy, (int)screen, (void*)max)
    Bool rval = glatter_glXQueryMaxSwapBarriersSGIX_ptr(dpy, screen, max);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGIX_swap_barrier
#ifdef GLX_SGIX_swap_group
void glatter_glXJoinSwapGroupSGIX_debug(Display *dpy, GLXDrawable drawable, GLXDrawable member, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXJoinSwapGroupSGIX, (%p, %s, %s), (void*)dpy, GET_PRS(drawable), GET_PRS(member))
    glatter_glXJoinSwapGroupSGIX_ptr(dpy, drawable, member);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_SGIX_swap_group
#ifdef GLX_SGIX_video_resize
int glatter_glXBindChannelToWindowSGIX_debug(Display *display, int screen, int channel, Window window, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindChannelToWindowSGIX, (%p, %d, %d, %s), (void*)display, (int)screen, (int)channel, GET_PRS(window))
    int rval = glatter_glXBindChannelToWindowSGIX_ptr(display, screen, channel, window);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXChannelRectSGIX_debug(Display *display, int screen, int channel, int x, int y, int w, int h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChannelRectSGIX, (%p, %d, %d, %d, %d, %d, %d), (void*)display, (int)screen, (int)channel, (int)x, (int)y, (int)w, (int)h)
    int rval = glatter_glXChannelRectSGIX_ptr(display, screen, channel, x, y, w, h);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXChannelRectSyncSGIX_debug(Display *display, int screen, int channel, GLenum synctype, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChannelRectSyncSGIX, (%p, %d, %d, %s), (void*)display, (int)screen, (int)channel, enum_to_string_GL(synctype))
    int rval = glatter_glXChannelRectSyncSGIX_ptr(display, screen, channel, synctype);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryChannelDeltasSGIX_debug(Display *display, int screen, int channel, int *x, int *y, int *w, int *h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryChannelDeltasSGIX, (%p, %d, %d, %p, %p, %p, %p), (void*)display, (int)screen, (int)channel, (void*)x, (void*)y, (void*)w, (void*)h)
    int rval = glatter_glXQueryChannelDeltasSGIX_ptr(display, screen, channel, x, y, w, h);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryChannelRectSGIX_debug(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryChannelRectSGIX, (%p, %d, %d, %p, %p, %p, %p), (void*)display, (int)screen, (int)channel, (void*)dx, (void*)dy, (void*)dw, (void*)dh)
    int rval = glatter_glXQueryChannelRectSGIX_ptr(display, screen, channel, dx, dy, dw, dh);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGIX_video_resize
#ifdef GLX_SGIX_video_source
GLXVideoSourceSGIX glatter_glXCreateGLXVideoSourceSGIX_debug(Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXVideoSourceSGIX, (%p, %d, %s, %s, %d, %s), (void*)display, (int)screen, GET_PRS(server), GET_PRS(path), (int)nodeClass, GET_PRS(drainNode))
    GLXVideoSourceSGIX rval = glatter_glXCreateGLXVideoSourceSGIX_ptr(display, screen, server, path, nodeClass, drainNode);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXDestroyGLXVideoSourceSGIX_debug(Display *dpy, GLXVideoSourceSGIX glxvideosource, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyGLXVideoSourceSGIX, (%p, %s), (void*)dpy, GET_PRS(glxvideosource))
    glatter_glXDestroyGLXVideoSourceSGIX_ptr(dpy, glxvideosource);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_SGIX_video_source
#ifdef GLX_SGI_cushion
void glatter_glXCushionSGI_debug(Display *dpy, Window window, float cushion, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCushionSGI, (%p, %s, %f), (void*)dpy, GET_PRS(window), (float)cushion)
    glatter_glXCushionSGI_ptr(dpy, window, cushion);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_SGI_cushion
#ifdef GLX_SGI_make_current_read
GLXDrawable glatter_glXGetCurrentReadDrawableSGI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentReadDrawableSGI, ())
    GLXDrawable rval = glatter_glXGetCurrentReadDrawableSGI_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
Bool glatter_glXMakeCurrentReadSGI_debug(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeCurrentReadSGI, (%p, %s, %s, %s), (void*)dpy, GET_PRS(draw), GET_PRS(read), GET_PRS(ctx))
    Bool rval = glatter_glXMakeCurrentReadSGI_ptr(dpy, draw, read, ctx);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGI_make_current_read
#ifdef GLX_SGI_swap_control
int glatter_glXSwapIntervalSGI_debug(int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalSGI, (%d), (int)interval)
    int rval = glatter_glXSwapIntervalSGI_ptr(interval);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGI_swap_control
#ifdef GLX_SGI_video_sync
int glatter_glXGetVideoSyncSGI_debug(unsigned int *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoSyncSGI, (%p), (void*)count)
    int rval = glatter_glXGetVideoSyncSGI_ptr(count);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXWaitVideoSyncSGI_debug(int divisor, int remainder, unsigned int *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitVideoSyncSGI, (%d, %d, %p), (int)divisor, (int)remainder, (void*)count)
    int rval = glatter_glXWaitVideoSyncSGI_ptr(divisor, remainder, count);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SGI_video_sync
#ifdef GLX_SUN_get_transparent_index
Status glatter_glXGetTransparentIndexSUN_debug(Display *dpy, Window overlay, Window underlay, long *pTransparentIndex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetTransparentIndexSUN, (%p, %s, %s, %p), (void*)dpy, GET_PRS(overlay), GET_PRS(underlay), (void*)pTransparentIndex)
    Status rval = glatter_glXGetTransparentIndexSUN_ptr(dpy, overlay, underlay, pTransparentIndex);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_SUN_get_transparent_index
#ifdef GLX_VERSION_1_3
GLXContext glatter_glXCreateNewContext_debug(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateNewContext, (%p, %p, %d, %s, %s), (void*)dpy, (void*)config, (int)render_type, GET_PRS(share_list), GET_PRS(direct))
    GLXContext rval = glatter_glXCreateNewContext_ptr(dpy, config, render_type, share_list, direct);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXPbuffer glatter_glXCreatePbuffer_debug(Display *dpy, GLXFBConfig config, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePbuffer, (%p, %p, %p), (void*)dpy, (void*)config, (void*)attrib_list)
    GLXPbuffer rval = glatter_glXCreatePbuffer_ptr(dpy, config, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXPixmap glatter_glXCreatePixmap_debug(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePixmap, (%p, %p, %s, %p), (void*)dpy, (void*)config, GET_PRS(pixmap), (void*)attrib_list)
    GLXPixmap rval = glatter_glXCreatePixmap_ptr(dpy, config, pixmap, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
GLXWindow glatter_glXCreateWindow_debug(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateWindow, (%p, %p, %s, %p), (void*)dpy, (void*)config, GET_PRS(win), (void*)attrib_list)
    GLXWindow rval = glatter_glXCreateWindow_ptr(dpy, config, win, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXDestroyPbuffer_debug(Display *dpy, GLXPbuffer pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPbuffer, (%p, %s), (void*)dpy, GET_PRS(pbuf))
    glatter_glXDestroyPbuffer_ptr(dpy, pbuf);
    glatter_check_error_GLX(file, line);
}
void glatter_glXDestroyPixmap_debug(Display *dpy, GLXPixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPixmap, (%p, %s), (void*)dpy, GET_PRS(pixmap))
    glatter_glXDestroyPixmap_ptr(dpy, pixmap);
    glatter_check_error_GLX(file, line);
}
void glatter_glXDestroyWindow_debug(Display *dpy, GLXWindow win, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyWindow, (%p, %s), (void*)dpy, GET_PRS(win))
    glatter_glXDestroyWindow_ptr(dpy, win);
    glatter_check_error_GLX(file, line);
}
GLXDrawable glatter_glXGetCurrentReadDrawable_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentReadDrawable, ())
    GLXDrawable rval = glatter_glXGetCurrentReadDrawable_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXGetFBConfigAttrib_debug(Display *dpy, GLXFBConfig config, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigAttrib, (%p, %p, %d, %p), (void*)dpy, (void*)config, (int)attribute, (void*)value)
    int rval = glatter_glXGetFBConfigAttrib_ptr(dpy, config, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXGetSelectedEvent_debug(Display *dpy, GLXDrawable draw, unsigned long *event_mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSelectedEvent, (%p, %s, %p), (void*)dpy, GET_PRS(draw), (void*)event_mask)
    glatter_glXGetSelectedEvent_ptr(dpy, draw, event_mask);
    glatter_check_error_GLX(file, line);
}
Bool glatter_glXMakeContextCurrent_debug(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeContextCurrent, (%p, %s, %s, %s), (void*)dpy, GET_PRS(draw), GET_PRS(read), GET_PRS(ctx))
    Bool rval = glatter_glXMakeContextCurrent_ptr(dpy, draw, read, ctx);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
int glatter_glXQueryContext_debug(Display *dpy, GLXContext ctx, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryContext, (%p, %s, %d, %p), (void*)dpy, GET_PRS(ctx), (int)attribute, (void*)value)
    int rval = glatter_glXQueryContext_ptr(dpy, ctx, attribute, value);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_GLX(file, line);
    return rval;
}
void glatter_glXQueryDrawable_debug(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryDrawable, (%p, %s, %d, %p), (void*)dpy, GET_PRS(draw), (int)attribute, (void*)value)
    glatter_glXQueryDrawable_ptr(dpy, draw, attribute, value);
    glatter_check_error_GLX(file, line);
}
void glatter_glXSelectEvent_debug(Display *dpy, GLXDrawable draw, unsigned long event_mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSelectEvent, (%p, %s, %lu), (void*)dpy, GET_PRS(draw), (unsigned long)event_mask)
    glatter_glXSelectEvent_ptr(dpy, draw, event_mask);
    glatter_check_error_GLX(file, line);
}
#endif // GLX_VERSION_1_3
#ifdef GLX_VERSION_1_4
__GLXextFuncPtr glatter_glXGetProcAddress_debug(const GLubyte *procName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetProcAddress, (%p), (void*)procName)
    __GLXextFuncPtr rval = glatter_glXGetProcAddress_ptr(procName);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_GLX(file, line);
    return rval;
}
#endif // GLX_VERSION_1_4
#endif // __glxext_h_
#endif // GLATTER_GLX

#endif // NDEBUG



#ifdef GLATTER_EGL

#ifdef __egl_h_
#ifdef EGL_VERSION_1_0
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglChooseConfig, (dpy, attrib_list, configs, config_size, num_config), (EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCopyBuffers, (dpy, surface, target), (EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLContext, EGLAPIENTRY, eglCreateContext, (dpy, config, share_context, attrib_list), (EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePbufferSurface, (dpy, config, attrib_list), (EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePixmapSurface, (dpy, config, pixmap, attrib_list), (EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreateWindowSurface, (dpy, config, win, attrib_list), (EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroyContext, (dpy, ctx), (EGLDisplay dpy, EGLContext ctx))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroySurface, (dpy, surface), (EGLDisplay dpy, EGLSurface surface))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetConfigAttrib, (dpy, config, attribute, value), (EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetConfigs, (dpy, configs, config_size, num_config), (EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLDisplay, EGLAPIENTRY, eglGetCurrentDisplay, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglGetCurrentSurface, (readdraw), (EGLint readdraw))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLDisplay, EGLAPIENTRY, eglGetDisplay, (display_id), (EGLNativeDisplayType display_id))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglGetError, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , __eglMustCastToProperFunctionPointerType, EGLAPIENTRY, eglGetProcAddress, (procname), (const char *procname))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglInitialize, (dpy, major, minor), (EGLDisplay dpy, EGLint *major, EGLint *minor))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglMakeCurrent, (dpy, draw, read, ctx), (EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryContext, (dpy, ctx, attribute, value), (EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , const char *, EGLAPIENTRY, eglQueryString, (dpy, name), (EGLDisplay dpy, EGLint name))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQuerySurface, (dpy, surface, attribute, value), (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapBuffers, (dpy, surface), (EGLDisplay dpy, EGLSurface surface))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglTerminate, (dpy), (EGLDisplay dpy))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglWaitGL, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglWaitNative, (engine), (EGLint engine))
#endif // EGL_VERSION_1_0
#ifdef EGL_VERSION_1_1
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglBindTexImage, (dpy, surface, buffer), (EGLDisplay dpy, EGLSurface surface, EGLint buffer))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglReleaseTexImage, (dpy, surface, buffer), (EGLDisplay dpy, EGLSurface surface, EGLint buffer))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSurfaceAttrib, (dpy, surface, attribute, value), (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapInterval, (dpy, interval), (EGLDisplay dpy, EGLint interval))
#endif // EGL_VERSION_1_1
#ifdef EGL_VERSION_1_2
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglBindAPI, (api), (EGLenum api))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePbufferFromClientBuffer, (dpy, buftype, buffer, config, attrib_list), (EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLenum, EGLAPIENTRY, eglQueryAPI, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglReleaseThread, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglWaitClient, (), ())
#endif // EGL_VERSION_1_2
#ifdef EGL_VERSION_1_4
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLContext, EGLAPIENTRY, eglGetCurrentContext, (), ())
#endif // EGL_VERSION_1_4
#ifdef EGL_VERSION_1_5
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglClientWaitSync, (dpy, sync, flags, timeout), (EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLImage, EGLAPIENTRY, eglCreateImage, (dpy, ctx, target, buffer, attrib_list), (EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePlatformPixmapSurface, (dpy, config, native_pixmap, attrib_list), (EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePlatformWindowSurface, (dpy, config, native_window, attrib_list), (EGLDisplay dpy, EGLConfig config, void *native_window, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSync, EGLAPIENTRY, eglCreateSync, (dpy, type, attrib_list), (EGLDisplay dpy, EGLenum type, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroyImage, (dpy, image), (EGLDisplay dpy, EGLImage image))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroySync, (dpy, sync), (EGLDisplay dpy, EGLSync sync))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLDisplay, EGLAPIENTRY, eglGetPlatformDisplay, (platform, native_display, attrib_list), (EGLenum platform, void *native_display, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetSyncAttrib, (dpy, sync, attribute, value), (EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglWaitSync, (dpy, sync, flags), (EGLDisplay dpy, EGLSync sync, EGLint flags))
#endif // EGL_VERSION_1_5
#endif // __egl_h_

#ifdef __eglext_h_
#ifdef EGL_ANDROID_blob_cache
GLATTER_FBLOCK(, EGL, EGLAPI , void, EGLAPIENTRY, eglSetBlobCacheFuncsANDROID, (dpy, set, get), (EGLDisplay dpy, EGLSetBlobFuncANDROID set, EGLGetBlobFuncANDROID get))
#endif // EGL_ANDROID_blob_cache
#ifdef EGL_ANDROID_create_native_client_buffer
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLClientBuffer, EGLAPIENTRY, eglCreateNativeClientBufferANDROID, (attrib_list), (const EGLint *attrib_list))
#endif // EGL_ANDROID_create_native_client_buffer
#ifdef EGL_ANDROID_native_fence_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglDupNativeFenceFDANDROID, (dpy, sync), (EGLDisplay dpy, EGLSyncKHR sync))
#endif // EGL_ANDROID_native_fence_sync
#ifdef EGL_ANDROID_presentation_time
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglPresentationTimeANDROID, (dpy, surface, time), (EGLDisplay dpy, EGLSurface surface, EGLnsecsANDROID time))
#endif // EGL_ANDROID_presentation_time
#ifdef EGL_ANGLE_query_surface_pointer
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQuerySurfacePointerANGLE, (dpy, surface, attribute, value), (EGLDisplay dpy, EGLSurface surface, EGLint attribute, void **value))
#endif // EGL_ANGLE_query_surface_pointer
#ifdef EGL_EXT_compositor
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorBindTexWindowEXT, (external_win_id), (EGLint external_win_id))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSetContextAttributesEXT, (external_ref_id, context_attributes, num_entries), (EGLint external_ref_id, const EGLint *context_attributes, EGLint num_entries))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSetContextListEXT, (external_ref_ids, num_entries), (const EGLint *external_ref_ids, EGLint num_entries))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSetSizeEXT, (external_win_id, width, height), (EGLint external_win_id, EGLint width, EGLint height))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSetWindowAttributesEXT, (external_win_id, window_attributes, num_entries), (EGLint external_win_id, const EGLint *window_attributes, EGLint num_entries))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSetWindowListEXT, (external_ref_id, external_win_ids, num_entries), (EGLint external_ref_id, const EGLint *external_win_ids, EGLint num_entries))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglCompositorSwapPolicyEXT, (external_win_id, policy), (EGLint external_win_id, EGLint policy))
#endif // EGL_EXT_compositor
#ifdef EGL_EXT_device_base
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDeviceAttribEXT, (device, attribute, value), (EGLDeviceEXT device, EGLint attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , const char *, EGLAPIENTRY, eglQueryDeviceStringEXT, (device, name), (EGLDeviceEXT device, EGLint name))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDevicesEXT, (max_devices, devices, num_devices), (EGLint max_devices, EGLDeviceEXT *devices, EGLint *num_devices))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDisplayAttribEXT, (dpy, attribute, value), (EGLDisplay dpy, EGLint attribute, EGLAttrib *value))
#endif // EGL_EXT_device_base
#ifdef EGL_EXT_image_dma_buf_import_modifiers
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDmaBufFormatsEXT, (dpy, max_formats, formats, num_formats), (EGLDisplay dpy, EGLint max_formats, EGLint *formats, EGLint *num_formats))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDmaBufModifiersEXT, (dpy, format, max_modifiers, modifiers, external_only, num_modifiers), (EGLDisplay dpy, EGLint format, EGLint max_modifiers, EGLuint64KHR *modifiers, EGLBoolean *external_only, EGLint *num_modifiers))
#endif // EGL_EXT_image_dma_buf_import_modifiers
#ifdef EGL_EXT_output_base
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetOutputLayersEXT, (dpy, attrib_list, layers, max_layers, num_layers), (EGLDisplay dpy, const EGLAttrib *attrib_list, EGLOutputLayerEXT *layers, EGLint max_layers, EGLint *num_layers))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetOutputPortsEXT, (dpy, attrib_list, ports, max_ports, num_ports), (EGLDisplay dpy, const EGLAttrib *attrib_list, EGLOutputPortEXT *ports, EGLint max_ports, EGLint *num_ports))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglOutputLayerAttribEXT, (dpy, layer, attribute, value), (EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglOutputPortAttribEXT, (dpy, port, attribute, value), (EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryOutputLayerAttribEXT, (dpy, layer, attribute, value), (EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , const char *, EGLAPIENTRY, eglQueryOutputLayerStringEXT, (dpy, layer, name), (EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint name))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryOutputPortAttribEXT, (dpy, port, attribute, value), (EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , const char *, EGLAPIENTRY, eglQueryOutputPortStringEXT, (dpy, port, name), (EGLDisplay dpy, EGLOutputPortEXT port, EGLint name))
#endif // EGL_EXT_output_base
#ifdef EGL_EXT_platform_base
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePlatformPixmapSurfaceEXT, (dpy, config, native_pixmap, attrib_list), (EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePlatformWindowSurfaceEXT, (dpy, config, native_window, attrib_list), (EGLDisplay dpy, EGLConfig config, void *native_window, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLDisplay, EGLAPIENTRY, eglGetPlatformDisplayEXT, (platform, native_display, attrib_list), (EGLenum platform, void *native_display, const EGLint *attrib_list))
#endif // EGL_EXT_platform_base
#ifdef EGL_EXT_stream_consumer_egloutput
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerOutputEXT, (dpy, stream, layer), (EGLDisplay dpy, EGLStreamKHR stream, EGLOutputLayerEXT layer))
#endif // EGL_EXT_stream_consumer_egloutput
#ifdef EGL_EXT_swap_buffers_with_damage
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapBuffersWithDamageEXT, (dpy, surface, rects, n_rects), (EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects))
#endif // EGL_EXT_swap_buffers_with_damage
#ifdef EGL_HI_clientpixmap
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreatePixmapSurfaceHI, (dpy, config, pixmap), (EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI *pixmap))
#endif // EGL_HI_clientpixmap
#ifdef EGL_KHR_cl_event2
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSyncKHR, EGLAPIENTRY, eglCreateSync64KHR, (dpy, type, attrib_list), (EGLDisplay dpy, EGLenum type, const EGLAttribKHR *attrib_list))
#endif // EGL_KHR_cl_event2
#ifdef EGL_KHR_debug
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglDebugMessageControlKHR, (callback, attrib_list), (EGLDEBUGPROCKHR callback, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglLabelObjectKHR, (display, objectType, object, label), (EGLDisplay display, EGLenum objectType, EGLObjectKHR object, EGLLabelKHR label))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDebugKHR, (attribute, value), (EGLint attribute, EGLAttrib *value))
#endif // EGL_KHR_debug
#ifdef EGL_KHR_fence_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglClientWaitSyncKHR, (dpy, sync, flags, timeout), (EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSyncKHR, EGLAPIENTRY, eglCreateSyncKHR, (dpy, type, attrib_list), (EGLDisplay dpy, EGLenum type, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroySyncKHR, (dpy, sync), (EGLDisplay dpy, EGLSyncKHR sync))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetSyncAttribKHR, (dpy, sync, attribute, value), (EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *value))
#endif // EGL_KHR_fence_sync
#ifdef EGL_KHR_image
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLImageKHR, EGLAPIENTRY, eglCreateImageKHR, (dpy, ctx, target, buffer, attrib_list), (EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroyImageKHR, (dpy, image), (EGLDisplay dpy, EGLImageKHR image))
#endif // EGL_KHR_image
#ifdef EGL_KHR_lock_surface
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglLockSurfaceKHR, (dpy, surface, attrib_list), (EGLDisplay dpy, EGLSurface surface, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglUnlockSurfaceKHR, (dpy, surface), (EGLDisplay dpy, EGLSurface surface))
#endif // EGL_KHR_lock_surface
#ifdef EGL_KHR_lock_surface3
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQuerySurface64KHR, (dpy, surface, attribute, value), (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLAttribKHR *value))
#endif // EGL_KHR_lock_surface3
#ifdef EGL_KHR_partial_update
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSetDamageRegionKHR, (dpy, surface, rects, n_rects), (EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects))
#endif // EGL_KHR_partial_update
#ifdef EGL_KHR_reusable_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSignalSyncKHR, (dpy, sync, mode), (EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode))
#endif // EGL_KHR_reusable_sync
#ifdef EGL_KHR_stream
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLStreamKHR, EGLAPIENTRY, eglCreateStreamKHR, (dpy, attrib_list), (EGLDisplay dpy, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroyStreamKHR, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryStreamKHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryStreamu64KHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamAttribKHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value))
#endif // EGL_KHR_stream
#ifdef EGL_KHR_stream_attrib
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLStreamKHR, EGLAPIENTRY, eglCreateStreamAttribKHR, (dpy, attrib_list), (EGLDisplay dpy, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryStreamAttribKHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSetStreamAttribKHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerAcquireAttribKHR, (dpy, stream, attrib_list), (EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerReleaseAttribKHR, (dpy, stream, attrib_list), (EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib *attrib_list))
#endif // EGL_KHR_stream_attrib
#ifdef EGL_KHR_stream_consumer_gltexture
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerAcquireKHR, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerGLTextureExternalKHR, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerReleaseKHR, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
#endif // EGL_KHR_stream_consumer_gltexture
#ifdef EGL_KHR_stream_cross_process_fd
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLStreamKHR, EGLAPIENTRY, eglCreateStreamFromFileDescriptorKHR, (dpy, file_descriptor), (EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLNativeFileDescriptorKHR, EGLAPIENTRY, eglGetStreamFileDescriptorKHR, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
#endif // EGL_KHR_stream_cross_process_fd
#ifdef EGL_KHR_stream_fifo
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryStreamTimeKHR, (dpy, stream, attribute, value), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR *value))
#endif // EGL_KHR_stream_fifo
#ifdef EGL_KHR_stream_producer_eglsurface
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSurface, EGLAPIENTRY, eglCreateStreamProducerSurfaceKHR, (dpy, config, stream, attrib_list), (EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *attrib_list))
#endif // EGL_KHR_stream_producer_eglsurface
#ifdef EGL_KHR_swap_buffers_with_damage
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapBuffersWithDamageKHR, (dpy, surface, rects, n_rects), (EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects))
#endif // EGL_KHR_swap_buffers_with_damage
#ifdef EGL_KHR_wait_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglWaitSyncKHR, (dpy, sync, flags), (EGLDisplay dpy, EGLSyncKHR sync, EGLint flags))
#endif // EGL_KHR_wait_sync
#ifdef EGL_MESA_drm_image
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLImageKHR, EGLAPIENTRY, eglCreateDRMImageMESA, (dpy, attrib_list), (EGLDisplay dpy, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglExportDRMImageMESA, (dpy, image, name, handle, stride), (EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride))
#endif // EGL_MESA_drm_image
#ifdef EGL_MESA_image_dma_buf_export
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglExportDMABUFImageMESA, (dpy, image, fds, strides, offsets), (EGLDisplay dpy, EGLImageKHR image, int *fds, EGLint *strides, EGLint *offsets))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglExportDMABUFImageQueryMESA, (dpy, image, fourcc, num_planes, modifiers), (EGLDisplay dpy, EGLImageKHR image, int *fourcc, int *num_planes, EGLuint64KHR *modifiers))
#endif // EGL_MESA_image_dma_buf_export
#ifdef EGL_NOK_swap_region
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapBuffersRegionNOK, (dpy, surface, numRects, rects), (EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *rects))
#endif // EGL_NOK_swap_region
#ifdef EGL_NOK_swap_region2
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSwapBuffersRegion2NOK, (dpy, surface, numRects, rects), (EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *rects))
#endif // EGL_NOK_swap_region2
#ifdef EGL_NV_native_query
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryNativeDisplayNV, (dpy, display_id), (EGLDisplay dpy, EGLNativeDisplayType *display_id))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryNativePixmapNV, (dpy, surf, pixmap), (EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *pixmap))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryNativeWindowNV, (dpy, surf, window), (EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *window))
#endif // EGL_NV_native_query
#ifdef EGL_NV_post_sub_buffer
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglPostSubBufferNV, (dpy, surface, x, y, width, height), (EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height))
#endif // EGL_NV_post_sub_buffer
#ifdef EGL_NV_stream_consumer_gltexture_yuv
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglStreamConsumerGLTextureExternalAttribsNV, (dpy, stream, attrib_list), (EGLDisplay dpy, EGLStreamKHR stream, EGLAttrib *attrib_list))
#endif // EGL_NV_stream_consumer_gltexture_yuv
#ifdef EGL_NV_stream_metadata
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryDisplayAttribNV, (dpy, attribute, value), (EGLDisplay dpy, EGLint attribute, EGLAttrib *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglQueryStreamMetadataNV, (dpy, stream, name, n, offset, size, data), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum name, EGLint n, EGLint offset, EGLint size, void *data))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSetStreamMetadataNV, (dpy, stream, n, offset, size, data), (EGLDisplay dpy, EGLStreamKHR stream, EGLint n, EGLint offset, EGLint size, const void *data))
#endif // EGL_NV_stream_metadata
#ifdef EGL_NV_stream_reset
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglResetStreamNV, (dpy, stream), (EGLDisplay dpy, EGLStreamKHR stream))
#endif // EGL_NV_stream_reset
#ifdef EGL_NV_stream_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSyncKHR, EGLAPIENTRY, eglCreateStreamSyncNV, (dpy, stream, type, attrib_list), (EGLDisplay dpy, EGLStreamKHR stream, EGLenum type, const EGLint *attrib_list))
#endif // EGL_NV_stream_sync
#ifdef EGL_NV_sync
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLint, EGLAPIENTRY, eglClientWaitSyncNV, (sync, flags, timeout), (EGLSyncNV sync, EGLint flags, EGLTimeNV timeout))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLSyncNV, EGLAPIENTRY, eglCreateFenceSyncNV, (dpy, condition, attrib_list), (EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglDestroySyncNV, (sync), (EGLSyncNV sync))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglFenceNV, (sync), (EGLSyncNV sync))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglGetSyncAttribNV, (sync, attribute, value), (EGLSyncNV sync, EGLint attribute, EGLint *value))
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLBoolean, EGLAPIENTRY, eglSignalSyncNV, (sync, mode), (EGLSyncNV sync, EGLenum mode))
#endif // EGL_NV_sync
#ifdef EGL_NV_system_time
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLuint64NV, EGLAPIENTRY, eglGetSystemTimeFrequencyNV, (), ())
GLATTER_FBLOCK(return, EGL, EGLAPI , EGLuint64NV, EGLAPIENTRY, eglGetSystemTimeNV, (), ())
#endif // EGL_NV_system_time
#endif // __eglext_h_
#endif // GLATTER_EGL

#ifndef NDEBUG

#ifdef GLATTER_EGL

#ifdef __egl_h_
#ifdef EGL_VERSION_1_0
EGLBoolean glatter_eglChooseConfig_debug(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglChooseConfig, (%p, %p, %p, %s, %p), (void*)dpy, (void*)attrib_list, (void*)configs, GET_PRS(config_size), (void*)num_config)
    EGLBoolean rval = glatter_eglChooseConfig_ptr(dpy, attrib_list, configs, config_size, num_config);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCopyBuffers_debug(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCopyBuffers, (%p, %p, %s), (void*)dpy, (void*)surface, GET_PRS(target))
    EGLBoolean rval = glatter_eglCopyBuffers_ptr(dpy, surface, target);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLContext glatter_eglCreateContext_debug(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateContext, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)share_context, (void*)attrib_list)
    EGLContext rval = glatter_eglCreateContext_ptr(dpy, config, share_context, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePbufferSurface_debug(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePbufferSurface, (%p, %p, %p), (void*)dpy, (void*)config, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePbufferSurface_ptr(dpy, config, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePixmapSurface_debug(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePixmapSurface, (%p, %p, %s, %p), (void*)dpy, (void*)config, GET_PRS(pixmap), (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePixmapSurface_ptr(dpy, config, pixmap, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreateWindowSurface_debug(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateWindowSurface, (%p, %p, %s, %p), (void*)dpy, (void*)config, GET_PRS(win), (void*)attrib_list)
    EGLSurface rval = glatter_eglCreateWindowSurface_ptr(dpy, config, win, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroyContext_debug(EGLDisplay dpy, EGLContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroyContext, (%p, %p), (void*)dpy, (void*)ctx)
    EGLBoolean rval = glatter_eglDestroyContext_ptr(dpy, ctx);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroySurface_debug(EGLDisplay dpy, EGLSurface surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroySurface, (%p, %p), (void*)dpy, (void*)surface)
    EGLBoolean rval = glatter_eglDestroySurface_ptr(dpy, surface);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetConfigAttrib_debug(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetConfigAttrib, (%p, %p, %s, %p), (void*)dpy, (void*)config, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglGetConfigAttrib_ptr(dpy, config, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetConfigs_debug(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetConfigs, (%p, %p, %s, %p), (void*)dpy, (void*)configs, GET_PRS(config_size), (void*)num_config)
    EGLBoolean rval = glatter_eglGetConfigs_ptr(dpy, configs, config_size, num_config);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLDisplay glatter_eglGetCurrentDisplay_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetCurrentDisplay, ())
    EGLDisplay rval = glatter_eglGetCurrentDisplay_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglGetCurrentSurface_debug(EGLint readdraw, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetCurrentSurface, (%s), GET_PRS(readdraw))
    EGLSurface rval = glatter_eglGetCurrentSurface_ptr(readdraw);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLDisplay glatter_eglGetDisplay_debug(EGLNativeDisplayType display_id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetDisplay, (%p), (void*)display_id)
    EGLDisplay rval = glatter_eglGetDisplay_ptr(display_id);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLint glatter_eglGetError_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetError, ())
    EGLint rval = glatter_eglGetError_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
__eglMustCastToProperFunctionPointerType glatter_eglGetProcAddress_debug(const char *procname, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetProcAddress, (%p), (void*)procname)
    __eglMustCastToProperFunctionPointerType rval = glatter_eglGetProcAddress_ptr(procname);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglInitialize_debug(EGLDisplay dpy, EGLint *major, EGLint *minor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglInitialize, (%p, %p, %p), (void*)dpy, (void*)major, (void*)minor)
    EGLBoolean rval = glatter_eglInitialize_ptr(dpy, major, minor);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglMakeCurrent_debug(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglMakeCurrent, (%p, %p, %p, %p), (void*)dpy, (void*)draw, (void*)read, (void*)ctx)
    EGLBoolean rval = glatter_eglMakeCurrent_ptr(dpy, draw, read, ctx);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryContext_debug(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryContext, (%p, %p, %s, %p), (void*)dpy, (void*)ctx, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryContext_ptr(dpy, ctx, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
const char * glatter_eglQueryString_debug(EGLDisplay dpy, EGLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryString, (%p, %s), (void*)dpy, GET_PRS(name))
    const char * rval = glatter_eglQueryString_ptr(dpy, name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQuerySurface_debug(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQuerySurface, (%p, %p, %s, %p), (void*)dpy, (void*)surface, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQuerySurface_ptr(dpy, surface, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSwapBuffers_debug(EGLDisplay dpy, EGLSurface surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapBuffers, (%p, %p), (void*)dpy, (void*)surface)
    EGLBoolean rval = glatter_eglSwapBuffers_ptr(dpy, surface);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglTerminate_debug(EGLDisplay dpy, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglTerminate, (%p), (void*)dpy)
    EGLBoolean rval = glatter_eglTerminate_ptr(dpy);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglWaitGL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglWaitGL, ())
    EGLBoolean rval = glatter_eglWaitGL_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglWaitNative_debug(EGLint engine, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglWaitNative, (%s), GET_PRS(engine))
    EGLBoolean rval = glatter_eglWaitNative_ptr(engine);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_VERSION_1_0
#ifdef EGL_VERSION_1_1
EGLBoolean glatter_eglBindTexImage_debug(EGLDisplay dpy, EGLSurface surface, EGLint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglBindTexImage, (%p, %p, %s), (void*)dpy, (void*)surface, GET_PRS(buffer))
    EGLBoolean rval = glatter_eglBindTexImage_ptr(dpy, surface, buffer);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglReleaseTexImage_debug(EGLDisplay dpy, EGLSurface surface, EGLint buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglReleaseTexImage, (%p, %p, %s), (void*)dpy, (void*)surface, GET_PRS(buffer))
    EGLBoolean rval = glatter_eglReleaseTexImage_ptr(dpy, surface, buffer);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSurfaceAttrib_debug(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSurfaceAttrib, (%p, %p, %s, %s), (void*)dpy, (void*)surface, GET_PRS(attribute), GET_PRS(value))
    EGLBoolean rval = glatter_eglSurfaceAttrib_ptr(dpy, surface, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSwapInterval_debug(EGLDisplay dpy, EGLint interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapInterval, (%p, %s), (void*)dpy, GET_PRS(interval))
    EGLBoolean rval = glatter_eglSwapInterval_ptr(dpy, interval);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_VERSION_1_1
#ifdef EGL_VERSION_1_2
EGLBoolean glatter_eglBindAPI_debug(EGLenum api, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglBindAPI, (%s), enum_to_string_EGL(api))
    EGLBoolean rval = glatter_eglBindAPI_ptr(api);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePbufferFromClientBuffer_debug(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePbufferFromClientBuffer, (%p, %s, %p, %p, %p), (void*)dpy, enum_to_string_EGL(buftype), (void*)buffer, (void*)config, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePbufferFromClientBuffer_ptr(dpy, buftype, buffer, config, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLenum glatter_eglQueryAPI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryAPI, ())
    EGLenum rval = glatter_eglQueryAPI_ptr();
    printf("GLATTER: returned %s", enum_to_string_EGL(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglReleaseThread_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglReleaseThread, ())
    EGLBoolean rval = glatter_eglReleaseThread_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglWaitClient_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglWaitClient, ())
    EGLBoolean rval = glatter_eglWaitClient_ptr();
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_VERSION_1_2
#ifdef EGL_VERSION_1_4
EGLContext glatter_eglGetCurrentContext_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetCurrentContext, ())
    EGLContext rval = glatter_eglGetCurrentContext_ptr();
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_VERSION_1_4
#ifdef EGL_VERSION_1_5
EGLint glatter_eglClientWaitSync_debug(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglClientWaitSync, (%p, %p, %s, %s), (void*)dpy, (void*)sync, GET_PRS(flags), GET_PRS(timeout))
    EGLint rval = glatter_eglClientWaitSync_ptr(dpy, sync, flags, timeout);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLImage glatter_eglCreateImage_debug(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateImage, (%p, %p, %s, %p, %p), (void*)dpy, (void*)ctx, enum_to_string_EGL(target), (void*)buffer, (void*)attrib_list)
    EGLImage rval = glatter_eglCreateImage_ptr(dpy, ctx, target, buffer, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePlatformPixmapSurface_debug(EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePlatformPixmapSurface, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)native_pixmap, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePlatformPixmapSurface_ptr(dpy, config, native_pixmap, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePlatformWindowSurface_debug(EGLDisplay dpy, EGLConfig config, void *native_window, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePlatformWindowSurface, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)native_window, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePlatformWindowSurface_ptr(dpy, config, native_window, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSync glatter_eglCreateSync_debug(EGLDisplay dpy, EGLenum type, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateSync, (%p, %s, %p), (void*)dpy, enum_to_string_EGL(type), (void*)attrib_list)
    EGLSync rval = glatter_eglCreateSync_ptr(dpy, type, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroyImage_debug(EGLDisplay dpy, EGLImage image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroyImage, (%p, %p), (void*)dpy, (void*)image)
    EGLBoolean rval = glatter_eglDestroyImage_ptr(dpy, image);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroySync_debug(EGLDisplay dpy, EGLSync sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroySync, (%p, %p), (void*)dpy, (void*)sync)
    EGLBoolean rval = glatter_eglDestroySync_ptr(dpy, sync);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLDisplay glatter_eglGetPlatformDisplay_debug(EGLenum platform, void *native_display, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetPlatformDisplay, (%s, %p, %p), enum_to_string_EGL(platform), (void*)native_display, (void*)attrib_list)
    EGLDisplay rval = glatter_eglGetPlatformDisplay_ptr(platform, native_display, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetSyncAttrib_debug(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetSyncAttrib, (%p, %p, %s, %p), (void*)dpy, (void*)sync, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglGetSyncAttrib_ptr(dpy, sync, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglWaitSync_debug(EGLDisplay dpy, EGLSync sync, EGLint flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglWaitSync, (%p, %p, %s), (void*)dpy, (void*)sync, GET_PRS(flags))
    EGLBoolean rval = glatter_eglWaitSync_ptr(dpy, sync, flags);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_VERSION_1_5
#endif // __egl_h_

#ifdef __eglext_h_
#ifdef EGL_ANDROID_blob_cache
void glatter_eglSetBlobCacheFuncsANDROID_debug(EGLDisplay dpy, EGLSetBlobFuncANDROID set, EGLGetBlobFuncANDROID get, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSetBlobCacheFuncsANDROID, (%p, %s, %s), (void*)dpy, GET_PRS(set), GET_PRS(get))
    glatter_eglSetBlobCacheFuncsANDROID_ptr(dpy, set, get);
    glatter_check_error_EGL(file, line);
}
#endif // EGL_ANDROID_blob_cache
#ifdef EGL_ANDROID_create_native_client_buffer
EGLClientBuffer glatter_eglCreateNativeClientBufferANDROID_debug(const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateNativeClientBufferANDROID, (%p), (void*)attrib_list)
    EGLClientBuffer rval = glatter_eglCreateNativeClientBufferANDROID_ptr(attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_ANDROID_create_native_client_buffer
#ifdef EGL_ANDROID_native_fence_sync
EGLint glatter_eglDupNativeFenceFDANDROID_debug(EGLDisplay dpy, EGLSyncKHR sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDupNativeFenceFDANDROID, (%p, %p), (void*)dpy, (void*)sync)
    EGLint rval = glatter_eglDupNativeFenceFDANDROID_ptr(dpy, sync);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_ANDROID_native_fence_sync
#ifdef EGL_ANDROID_presentation_time
EGLBoolean glatter_eglPresentationTimeANDROID_debug(EGLDisplay dpy, EGLSurface surface, EGLnsecsANDROID time, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglPresentationTimeANDROID, (%p, %p, %s), (void*)dpy, (void*)surface, GET_PRS(time))
    EGLBoolean rval = glatter_eglPresentationTimeANDROID_ptr(dpy, surface, time);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_ANDROID_presentation_time
#ifdef EGL_ANGLE_query_surface_pointer
EGLBoolean glatter_eglQuerySurfacePointerANGLE_debug(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void **value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQuerySurfacePointerANGLE, (%p, %p, %s, %p), (void*)dpy, (void*)surface, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQuerySurfacePointerANGLE_ptr(dpy, surface, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_ANGLE_query_surface_pointer
#ifdef EGL_EXT_compositor
EGLBoolean glatter_eglCompositorBindTexWindowEXT_debug(EGLint external_win_id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorBindTexWindowEXT, (%s), GET_PRS(external_win_id))
    EGLBoolean rval = glatter_eglCompositorBindTexWindowEXT_ptr(external_win_id);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSetContextAttributesEXT_debug(EGLint external_ref_id, const EGLint *context_attributes, EGLint num_entries, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSetContextAttributesEXT, (%s, %p, %s), GET_PRS(external_ref_id), (void*)context_attributes, GET_PRS(num_entries))
    EGLBoolean rval = glatter_eglCompositorSetContextAttributesEXT_ptr(external_ref_id, context_attributes, num_entries);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSetContextListEXT_debug(const EGLint *external_ref_ids, EGLint num_entries, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSetContextListEXT, (%p, %s), (void*)external_ref_ids, GET_PRS(num_entries))
    EGLBoolean rval = glatter_eglCompositorSetContextListEXT_ptr(external_ref_ids, num_entries);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSetSizeEXT_debug(EGLint external_win_id, EGLint width, EGLint height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSetSizeEXT, (%s, %s, %s), GET_PRS(external_win_id), GET_PRS(width), GET_PRS(height))
    EGLBoolean rval = glatter_eglCompositorSetSizeEXT_ptr(external_win_id, width, height);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSetWindowAttributesEXT_debug(EGLint external_win_id, const EGLint *window_attributes, EGLint num_entries, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSetWindowAttributesEXT, (%s, %p, %s), GET_PRS(external_win_id), (void*)window_attributes, GET_PRS(num_entries))
    EGLBoolean rval = glatter_eglCompositorSetWindowAttributesEXT_ptr(external_win_id, window_attributes, num_entries);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSetWindowListEXT_debug(EGLint external_ref_id, const EGLint *external_win_ids, EGLint num_entries, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSetWindowListEXT, (%s, %p, %s), GET_PRS(external_ref_id), (void*)external_win_ids, GET_PRS(num_entries))
    EGLBoolean rval = glatter_eglCompositorSetWindowListEXT_ptr(external_ref_id, external_win_ids, num_entries);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglCompositorSwapPolicyEXT_debug(EGLint external_win_id, EGLint policy, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCompositorSwapPolicyEXT, (%s, %s), GET_PRS(external_win_id), GET_PRS(policy))
    EGLBoolean rval = glatter_eglCompositorSwapPolicyEXT_ptr(external_win_id, policy);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_compositor
#ifdef EGL_EXT_device_base
EGLBoolean glatter_eglQueryDeviceAttribEXT_debug(EGLDeviceEXT device, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDeviceAttribEXT, (%p, %s, %p), (void*)device, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryDeviceAttribEXT_ptr(device, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
const char * glatter_eglQueryDeviceStringEXT_debug(EGLDeviceEXT device, EGLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDeviceStringEXT, (%p, %s), (void*)device, GET_PRS(name))
    const char * rval = glatter_eglQueryDeviceStringEXT_ptr(device, name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryDevicesEXT_debug(EGLint max_devices, EGLDeviceEXT *devices, EGLint *num_devices, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDevicesEXT, (%s, %p, %p), GET_PRS(max_devices), (void*)devices, (void*)num_devices)
    EGLBoolean rval = glatter_eglQueryDevicesEXT_ptr(max_devices, devices, num_devices);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryDisplayAttribEXT_debug(EGLDisplay dpy, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDisplayAttribEXT, (%p, %s, %p), (void*)dpy, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryDisplayAttribEXT_ptr(dpy, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_device_base
#ifdef EGL_EXT_image_dma_buf_import_modifiers
EGLBoolean glatter_eglQueryDmaBufFormatsEXT_debug(EGLDisplay dpy, EGLint max_formats, EGLint *formats, EGLint *num_formats, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDmaBufFormatsEXT, (%p, %s, %p, %p), (void*)dpy, GET_PRS(max_formats), (void*)formats, (void*)num_formats)
    EGLBoolean rval = glatter_eglQueryDmaBufFormatsEXT_ptr(dpy, max_formats, formats, num_formats);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryDmaBufModifiersEXT_debug(EGLDisplay dpy, EGLint format, EGLint max_modifiers, EGLuint64KHR *modifiers, EGLBoolean *external_only, EGLint *num_modifiers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDmaBufModifiersEXT, (%p, %s, %s, %p, %p, %p), (void*)dpy, GET_PRS(format), GET_PRS(max_modifiers), (void*)modifiers, (void*)external_only, (void*)num_modifiers)
    EGLBoolean rval = glatter_eglQueryDmaBufModifiersEXT_ptr(dpy, format, max_modifiers, modifiers, external_only, num_modifiers);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_image_dma_buf_import_modifiers
#ifdef EGL_EXT_output_base
EGLBoolean glatter_eglGetOutputLayersEXT_debug(EGLDisplay dpy, const EGLAttrib *attrib_list, EGLOutputLayerEXT *layers, EGLint max_layers, EGLint *num_layers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetOutputLayersEXT, (%p, %p, %p, %s, %p), (void*)dpy, (void*)attrib_list, (void*)layers, GET_PRS(max_layers), (void*)num_layers)
    EGLBoolean rval = glatter_eglGetOutputLayersEXT_ptr(dpy, attrib_list, layers, max_layers, num_layers);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetOutputPortsEXT_debug(EGLDisplay dpy, const EGLAttrib *attrib_list, EGLOutputPortEXT *ports, EGLint max_ports, EGLint *num_ports, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetOutputPortsEXT, (%p, %p, %p, %s, %p), (void*)dpy, (void*)attrib_list, (void*)ports, GET_PRS(max_ports), (void*)num_ports)
    EGLBoolean rval = glatter_eglGetOutputPortsEXT_ptr(dpy, attrib_list, ports, max_ports, num_ports);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglOutputLayerAttribEXT_debug(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglOutputLayerAttribEXT, (%p, %p, %s, %"PRIxPTR"), (void*)dpy, (void*)layer, GET_PRS(attribute), (intptr_t)value)
    EGLBoolean rval = glatter_eglOutputLayerAttribEXT_ptr(dpy, layer, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglOutputPortAttribEXT_debug(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglOutputPortAttribEXT, (%p, %p, %s, %"PRIxPTR"), (void*)dpy, (void*)port, GET_PRS(attribute), (intptr_t)value)
    EGLBoolean rval = glatter_eglOutputPortAttribEXT_ptr(dpy, port, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryOutputLayerAttribEXT_debug(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryOutputLayerAttribEXT, (%p, %p, %s, %p), (void*)dpy, (void*)layer, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryOutputLayerAttribEXT_ptr(dpy, layer, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
const char * glatter_eglQueryOutputLayerStringEXT_debug(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryOutputLayerStringEXT, (%p, %p, %s), (void*)dpy, (void*)layer, GET_PRS(name))
    const char * rval = glatter_eglQueryOutputLayerStringEXT_ptr(dpy, layer, name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryOutputPortAttribEXT_debug(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryOutputPortAttribEXT, (%p, %p, %s, %p), (void*)dpy, (void*)port, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryOutputPortAttribEXT_ptr(dpy, port, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
const char * glatter_eglQueryOutputPortStringEXT_debug(EGLDisplay dpy, EGLOutputPortEXT port, EGLint name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryOutputPortStringEXT, (%p, %p, %s), (void*)dpy, (void*)port, GET_PRS(name))
    const char * rval = glatter_eglQueryOutputPortStringEXT_ptr(dpy, port, name);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_output_base
#ifdef EGL_EXT_platform_base
EGLSurface glatter_eglCreatePlatformPixmapSurfaceEXT_debug(EGLDisplay dpy, EGLConfig config, void *native_pixmap, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePlatformPixmapSurfaceEXT, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)native_pixmap, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePlatformPixmapSurfaceEXT_ptr(dpy, config, native_pixmap, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSurface glatter_eglCreatePlatformWindowSurfaceEXT_debug(EGLDisplay dpy, EGLConfig config, void *native_window, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePlatformWindowSurfaceEXT, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)native_window, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreatePlatformWindowSurfaceEXT_ptr(dpy, config, native_window, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLDisplay glatter_eglGetPlatformDisplayEXT_debug(EGLenum platform, void *native_display, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetPlatformDisplayEXT, (%s, %p, %p), enum_to_string_EGL(platform), (void*)native_display, (void*)attrib_list)
    EGLDisplay rval = glatter_eglGetPlatformDisplayEXT_ptr(platform, native_display, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_platform_base
#ifdef EGL_EXT_stream_consumer_egloutput
EGLBoolean glatter_eglStreamConsumerOutputEXT_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLOutputLayerEXT layer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerOutputEXT, (%p, %p, %p), (void*)dpy, (void*)stream, (void*)layer)
    EGLBoolean rval = glatter_eglStreamConsumerOutputEXT_ptr(dpy, stream, layer);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_stream_consumer_egloutput
#ifdef EGL_EXT_swap_buffers_with_damage
EGLBoolean glatter_eglSwapBuffersWithDamageEXT_debug(EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapBuffersWithDamageEXT, (%p, %p, %p, %s), (void*)dpy, (void*)surface, (void*)rects, GET_PRS(n_rects))
    EGLBoolean rval = glatter_eglSwapBuffersWithDamageEXT_ptr(dpy, surface, rects, n_rects);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_EXT_swap_buffers_with_damage
#ifdef EGL_HI_clientpixmap
EGLSurface glatter_eglCreatePixmapSurfaceHI_debug(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI *pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreatePixmapSurfaceHI, (%p, %p, %p), (void*)dpy, (void*)config, (void*)pixmap)
    EGLSurface rval = glatter_eglCreatePixmapSurfaceHI_ptr(dpy, config, pixmap);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_HI_clientpixmap
#ifdef EGL_KHR_cl_event2
EGLSyncKHR glatter_eglCreateSync64KHR_debug(EGLDisplay dpy, EGLenum type, const EGLAttribKHR *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateSync64KHR, (%p, %s, %p), (void*)dpy, enum_to_string_EGL(type), (void*)attrib_list)
    EGLSyncKHR rval = glatter_eglCreateSync64KHR_ptr(dpy, type, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_cl_event2
#ifdef EGL_KHR_debug
EGLint glatter_eglDebugMessageControlKHR_debug(EGLDEBUGPROCKHR callback, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDebugMessageControlKHR, (%s, %p), GET_PRS(callback), (void*)attrib_list)
    EGLint rval = glatter_eglDebugMessageControlKHR_ptr(callback, attrib_list);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLint glatter_eglLabelObjectKHR_debug(EGLDisplay display, EGLenum objectType, EGLObjectKHR object, EGLLabelKHR label, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglLabelObjectKHR, (%p, %s, %p, %p), (void*)display, enum_to_string_EGL(objectType), (void*)object, (void*)label)
    EGLint rval = glatter_eglLabelObjectKHR_ptr(display, objectType, object, label);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryDebugKHR_debug(EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDebugKHR, (%s, %p), GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryDebugKHR_ptr(attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_debug
#ifdef EGL_KHR_fence_sync
EGLint glatter_eglClientWaitSyncKHR_debug(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglClientWaitSyncKHR, (%p, %p, %s, %s), (void*)dpy, (void*)sync, GET_PRS(flags), GET_PRS(timeout))
    EGLint rval = glatter_eglClientWaitSyncKHR_ptr(dpy, sync, flags, timeout);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSyncKHR glatter_eglCreateSyncKHR_debug(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateSyncKHR, (%p, %s, %p), (void*)dpy, enum_to_string_EGL(type), (void*)attrib_list)
    EGLSyncKHR rval = glatter_eglCreateSyncKHR_ptr(dpy, type, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroySyncKHR_debug(EGLDisplay dpy, EGLSyncKHR sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroySyncKHR, (%p, %p), (void*)dpy, (void*)sync)
    EGLBoolean rval = glatter_eglDestroySyncKHR_ptr(dpy, sync);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetSyncAttribKHR_debug(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetSyncAttribKHR, (%p, %p, %s, %p), (void*)dpy, (void*)sync, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglGetSyncAttribKHR_ptr(dpy, sync, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_fence_sync
#ifdef EGL_KHR_image
EGLImageKHR glatter_eglCreateImageKHR_debug(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateImageKHR, (%p, %p, %s, %p, %p), (void*)dpy, (void*)ctx, enum_to_string_EGL(target), (void*)buffer, (void*)attrib_list)
    EGLImageKHR rval = glatter_eglCreateImageKHR_ptr(dpy, ctx, target, buffer, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroyImageKHR_debug(EGLDisplay dpy, EGLImageKHR image, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroyImageKHR, (%p, %p), (void*)dpy, (void*)image)
    EGLBoolean rval = glatter_eglDestroyImageKHR_ptr(dpy, image);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_image
#ifdef EGL_KHR_lock_surface
EGLBoolean glatter_eglLockSurfaceKHR_debug(EGLDisplay dpy, EGLSurface surface, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglLockSurfaceKHR, (%p, %p, %p), (void*)dpy, (void*)surface, (void*)attrib_list)
    EGLBoolean rval = glatter_eglLockSurfaceKHR_ptr(dpy, surface, attrib_list);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglUnlockSurfaceKHR_debug(EGLDisplay dpy, EGLSurface surface, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglUnlockSurfaceKHR, (%p, %p), (void*)dpy, (void*)surface)
    EGLBoolean rval = glatter_eglUnlockSurfaceKHR_ptr(dpy, surface);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_lock_surface
#ifdef EGL_KHR_lock_surface3
EGLBoolean glatter_eglQuerySurface64KHR_debug(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLAttribKHR *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQuerySurface64KHR, (%p, %p, %s, %p), (void*)dpy, (void*)surface, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQuerySurface64KHR_ptr(dpy, surface, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_lock_surface3
#ifdef EGL_KHR_partial_update
EGLBoolean glatter_eglSetDamageRegionKHR_debug(EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSetDamageRegionKHR, (%p, %p, %p, %s), (void*)dpy, (void*)surface, (void*)rects, GET_PRS(n_rects))
    EGLBoolean rval = glatter_eglSetDamageRegionKHR_ptr(dpy, surface, rects, n_rects);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_partial_update
#ifdef EGL_KHR_reusable_sync
EGLBoolean glatter_eglSignalSyncKHR_debug(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSignalSyncKHR, (%p, %p, %s), (void*)dpy, (void*)sync, enum_to_string_EGL(mode))
    EGLBoolean rval = glatter_eglSignalSyncKHR_ptr(dpy, sync, mode);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_reusable_sync
#ifdef EGL_KHR_stream
EGLStreamKHR glatter_eglCreateStreamKHR_debug(EGLDisplay dpy, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateStreamKHR, (%p, %p), (void*)dpy, (void*)attrib_list)
    EGLStreamKHR rval = glatter_eglCreateStreamKHR_ptr(dpy, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroyStreamKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroyStreamKHR, (%p, %p), (void*)dpy, (void*)stream)
    EGLBoolean rval = glatter_eglDestroyStreamKHR_ptr(dpy, stream);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryStreamKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryStreamKHR, (%p, %p, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryStreamKHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryStreamu64KHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryStreamu64KHR, (%p, %p, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryStreamu64KHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglStreamAttribKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamAttribKHR, (%p, %p, %s, %s), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), GET_PRS(value))
    EGLBoolean rval = glatter_eglStreamAttribKHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream
#ifdef EGL_KHR_stream_attrib
EGLStreamKHR glatter_eglCreateStreamAttribKHR_debug(EGLDisplay dpy, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateStreamAttribKHR, (%p, %p), (void*)dpy, (void*)attrib_list)
    EGLStreamKHR rval = glatter_eglCreateStreamAttribKHR_ptr(dpy, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryStreamAttribKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryStreamAttribKHR, (%p, %p, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryStreamAttribKHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSetStreamAttribKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSetStreamAttribKHR, (%p, %p, %s, %"PRIxPTR"), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), (intptr_t)value)
    EGLBoolean rval = glatter_eglSetStreamAttribKHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglStreamConsumerAcquireAttribKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerAcquireAttribKHR, (%p, %p, %p), (void*)dpy, (void*)stream, (void*)attrib_list)
    EGLBoolean rval = glatter_eglStreamConsumerAcquireAttribKHR_ptr(dpy, stream, attrib_list);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglStreamConsumerReleaseAttribKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerReleaseAttribKHR, (%p, %p, %p), (void*)dpy, (void*)stream, (void*)attrib_list)
    EGLBoolean rval = glatter_eglStreamConsumerReleaseAttribKHR_ptr(dpy, stream, attrib_list);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream_attrib
#ifdef EGL_KHR_stream_consumer_gltexture
EGLBoolean glatter_eglStreamConsumerAcquireKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerAcquireKHR, (%p, %p), (void*)dpy, (void*)stream)
    EGLBoolean rval = glatter_eglStreamConsumerAcquireKHR_ptr(dpy, stream);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglStreamConsumerGLTextureExternalKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerGLTextureExternalKHR, (%p, %p), (void*)dpy, (void*)stream)
    EGLBoolean rval = glatter_eglStreamConsumerGLTextureExternalKHR_ptr(dpy, stream);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglStreamConsumerReleaseKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerReleaseKHR, (%p, %p), (void*)dpy, (void*)stream)
    EGLBoolean rval = glatter_eglStreamConsumerReleaseKHR_ptr(dpy, stream);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream_consumer_gltexture
#ifdef EGL_KHR_stream_cross_process_fd
EGLStreamKHR glatter_eglCreateStreamFromFileDescriptorKHR_debug(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateStreamFromFileDescriptorKHR, (%p, %d), (void*)dpy, (int)file_descriptor)
    EGLStreamKHR rval = glatter_eglCreateStreamFromFileDescriptorKHR_ptr(dpy, file_descriptor);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLNativeFileDescriptorKHR glatter_eglGetStreamFileDescriptorKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetStreamFileDescriptorKHR, (%p, %p), (void*)dpy, (void*)stream)
    EGLNativeFileDescriptorKHR rval = glatter_eglGetStreamFileDescriptorKHR_ptr(dpy, stream);
    printf("GLATTER: returned %d", (int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream_cross_process_fd
#ifdef EGL_KHR_stream_fifo
EGLBoolean glatter_eglQueryStreamTimeKHR_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryStreamTimeKHR, (%p, %p, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryStreamTimeKHR_ptr(dpy, stream, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream_fifo
#ifdef EGL_KHR_stream_producer_eglsurface
EGLSurface glatter_eglCreateStreamProducerSurfaceKHR_debug(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateStreamProducerSurfaceKHR, (%p, %p, %p, %p), (void*)dpy, (void*)config, (void*)stream, (void*)attrib_list)
    EGLSurface rval = glatter_eglCreateStreamProducerSurfaceKHR_ptr(dpy, config, stream, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_stream_producer_eglsurface
#ifdef EGL_KHR_swap_buffers_with_damage
EGLBoolean glatter_eglSwapBuffersWithDamageKHR_debug(EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapBuffersWithDamageKHR, (%p, %p, %p, %s), (void*)dpy, (void*)surface, (void*)rects, GET_PRS(n_rects))
    EGLBoolean rval = glatter_eglSwapBuffersWithDamageKHR_ptr(dpy, surface, rects, n_rects);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_swap_buffers_with_damage
#ifdef EGL_KHR_wait_sync
EGLint glatter_eglWaitSyncKHR_debug(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglWaitSyncKHR, (%p, %p, %s), (void*)dpy, (void*)sync, GET_PRS(flags))
    EGLint rval = glatter_eglWaitSyncKHR_ptr(dpy, sync, flags);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_KHR_wait_sync
#ifdef EGL_MESA_drm_image
EGLImageKHR glatter_eglCreateDRMImageMESA_debug(EGLDisplay dpy, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateDRMImageMESA, (%p, %p), (void*)dpy, (void*)attrib_list)
    EGLImageKHR rval = glatter_eglCreateDRMImageMESA_ptr(dpy, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglExportDRMImageMESA_debug(EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglExportDRMImageMESA, (%p, %p, %p, %p, %p), (void*)dpy, (void*)image, (void*)name, (void*)handle, (void*)stride)
    EGLBoolean rval = glatter_eglExportDRMImageMESA_ptr(dpy, image, name, handle, stride);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_MESA_drm_image
#ifdef EGL_MESA_image_dma_buf_export
EGLBoolean glatter_eglExportDMABUFImageMESA_debug(EGLDisplay dpy, EGLImageKHR image, int *fds, EGLint *strides, EGLint *offsets, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglExportDMABUFImageMESA, (%p, %p, %p, %p, %p), (void*)dpy, (void*)image, (void*)fds, (void*)strides, (void*)offsets)
    EGLBoolean rval = glatter_eglExportDMABUFImageMESA_ptr(dpy, image, fds, strides, offsets);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglExportDMABUFImageQueryMESA_debug(EGLDisplay dpy, EGLImageKHR image, int *fourcc, int *num_planes, EGLuint64KHR *modifiers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglExportDMABUFImageQueryMESA, (%p, %p, %p, %p, %p), (void*)dpy, (void*)image, (void*)fourcc, (void*)num_planes, (void*)modifiers)
    EGLBoolean rval = glatter_eglExportDMABUFImageQueryMESA_ptr(dpy, image, fourcc, num_planes, modifiers);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_MESA_image_dma_buf_export
#ifdef EGL_NOK_swap_region
EGLBoolean glatter_eglSwapBuffersRegionNOK_debug(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *rects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapBuffersRegionNOK, (%p, %p, %s, %p), (void*)dpy, (void*)surface, GET_PRS(numRects), (void*)rects)
    EGLBoolean rval = glatter_eglSwapBuffersRegionNOK_ptr(dpy, surface, numRects, rects);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NOK_swap_region
#ifdef EGL_NOK_swap_region2
EGLBoolean glatter_eglSwapBuffersRegion2NOK_debug(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *rects, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSwapBuffersRegion2NOK, (%p, %p, %s, %p), (void*)dpy, (void*)surface, GET_PRS(numRects), (void*)rects)
    EGLBoolean rval = glatter_eglSwapBuffersRegion2NOK_ptr(dpy, surface, numRects, rects);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NOK_swap_region2
#ifdef EGL_NV_native_query
EGLBoolean glatter_eglQueryNativeDisplayNV_debug(EGLDisplay dpy, EGLNativeDisplayType *display_id, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryNativeDisplayNV, (%p, %p), (void*)dpy, (void*)display_id)
    EGLBoolean rval = glatter_eglQueryNativeDisplayNV_ptr(dpy, display_id);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryNativePixmapNV_debug(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryNativePixmapNV, (%p, %p, %p), (void*)dpy, (void*)surf, (void*)pixmap)
    EGLBoolean rval = glatter_eglQueryNativePixmapNV_ptr(dpy, surf, pixmap);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryNativeWindowNV_debug(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *window, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryNativeWindowNV, (%p, %p, %p), (void*)dpy, (void*)surf, (void*)window)
    EGLBoolean rval = glatter_eglQueryNativeWindowNV_ptr(dpy, surf, window);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_native_query
#ifdef EGL_NV_post_sub_buffer
EGLBoolean glatter_eglPostSubBufferNV_debug(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglPostSubBufferNV, (%p, %p, %s, %s, %s, %s), (void*)dpy, (void*)surface, GET_PRS(x), GET_PRS(y), GET_PRS(width), GET_PRS(height))
    EGLBoolean rval = glatter_eglPostSubBufferNV_ptr(dpy, surface, x, y, width, height);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_post_sub_buffer
#ifdef EGL_NV_stream_consumer_gltexture_yuv
EGLBoolean glatter_eglStreamConsumerGLTextureExternalAttribsNV_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLAttrib *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglStreamConsumerGLTextureExternalAttribsNV, (%p, %p, %p), (void*)dpy, (void*)stream, (void*)attrib_list)
    EGLBoolean rval = glatter_eglStreamConsumerGLTextureExternalAttribsNV_ptr(dpy, stream, attrib_list);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_stream_consumer_gltexture_yuv
#ifdef EGL_NV_stream_metadata
EGLBoolean glatter_eglQueryDisplayAttribNV_debug(EGLDisplay dpy, EGLint attribute, EGLAttrib *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryDisplayAttribNV, (%p, %s, %p), (void*)dpy, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglQueryDisplayAttribNV_ptr(dpy, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglQueryStreamMetadataNV_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum name, EGLint n, EGLint offset, EGLint size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglQueryStreamMetadataNV, (%p, %p, %s, %s, %s, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(name), GET_PRS(n), GET_PRS(offset), GET_PRS(size), (void*)data)
    EGLBoolean rval = glatter_eglQueryStreamMetadataNV_ptr(dpy, stream, name, n, offset, size, data);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSetStreamMetadataNV_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLint n, EGLint offset, EGLint size, const void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSetStreamMetadataNV, (%p, %p, %s, %s, %s, %p), (void*)dpy, (void*)stream, GET_PRS(n), GET_PRS(offset), GET_PRS(size), (void*)data)
    EGLBoolean rval = glatter_eglSetStreamMetadataNV_ptr(dpy, stream, n, offset, size, data);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_stream_metadata
#ifdef EGL_NV_stream_reset
EGLBoolean glatter_eglResetStreamNV_debug(EGLDisplay dpy, EGLStreamKHR stream, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglResetStreamNV, (%p, %p), (void*)dpy, (void*)stream)
    EGLBoolean rval = glatter_eglResetStreamNV_ptr(dpy, stream);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_stream_reset
#ifdef EGL_NV_stream_sync
EGLSyncKHR glatter_eglCreateStreamSyncNV_debug(EGLDisplay dpy, EGLStreamKHR stream, EGLenum type, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateStreamSyncNV, (%p, %p, %s, %p), (void*)dpy, (void*)stream, enum_to_string_EGL(type), (void*)attrib_list)
    EGLSyncKHR rval = glatter_eglCreateStreamSyncNV_ptr(dpy, stream, type, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_stream_sync
#ifdef EGL_NV_sync
EGLint glatter_eglClientWaitSyncNV_debug(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglClientWaitSyncNV, (%p, %s, %s), (void*)sync, GET_PRS(flags), GET_PRS(timeout))
    EGLint rval = glatter_eglClientWaitSyncNV_ptr(sync, flags, timeout);
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLSyncNV glatter_eglCreateFenceSyncNV_debug(EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglCreateFenceSyncNV, (%p, %s, %p), (void*)dpy, enum_to_string_EGL(condition), (void*)attrib_list)
    EGLSyncNV rval = glatter_eglCreateFenceSyncNV_ptr(dpy, condition, attrib_list);
    printf("GLATTER: returned %p", (void*)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglDestroySyncNV_debug(EGLSyncNV sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglDestroySyncNV, (%p), (void*)sync)
    EGLBoolean rval = glatter_eglDestroySyncNV_ptr(sync);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglFenceNV_debug(EGLSyncNV sync, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglFenceNV, (%p), (void*)sync)
    EGLBoolean rval = glatter_eglFenceNV_ptr(sync);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglGetSyncAttribNV_debug(EGLSyncNV sync, EGLint attribute, EGLint *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetSyncAttribNV, (%p, %s, %p), (void*)sync, GET_PRS(attribute), (void*)value)
    EGLBoolean rval = glatter_eglGetSyncAttribNV_ptr(sync, attribute, value);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLBoolean glatter_eglSignalSyncNV_debug(EGLSyncNV sync, EGLenum mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglSignalSyncNV, (%p, %s), (void*)sync, enum_to_string_EGL(mode))
    EGLBoolean rval = glatter_eglSignalSyncNV_ptr(sync, mode);
    printf("GLATTER: returned %u", (unsigned int)rval);
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_sync
#ifdef EGL_NV_system_time
EGLuint64NV glatter_eglGetSystemTimeFrequencyNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetSystemTimeFrequencyNV, ())
    EGLuint64NV rval = glatter_eglGetSystemTimeFrequencyNV_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
EGLuint64NV glatter_eglGetSystemTimeNV_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, eglGetSystemTimeNV, ())
    EGLuint64NV rval = glatter_eglGetSystemTimeNV_ptr();
    printf("GLATTER: returned %s", GET_PRS(rval));
    glatter_check_error_EGL(file, line);
    return rval;
}
#endif // EGL_NV_system_time
#endif // __eglext_h_
#endif // GLATTER_EGL

#endif // NDEBUG

